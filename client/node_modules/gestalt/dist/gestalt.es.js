import { findDOMNode, createPortal } from 'react-dom';
import classnames from 'classnames';
import { createElement, PureComponent, forwardRef, Component, Fragment, Children } from 'react';
import PropTypes from 'prop-types';

var styles = { "box": "_h _xu _4q", "xsDisplayNone": "_i", "xsDisplayFlex": "_j", "xsDisplayBlock": "_k", "xsDisplayInlineBlock": "_l", "xsDisplayVisuallyHidden": "_m", "smDisplayNone": "_n", "smDisplayFlex": "_o", "smDisplayBlock": "_p", "smDisplayInlineBlock": "_q", "smDisplayVisuallyHidden": "_r", "mdDisplayNone": "_s", "mdDisplayFlex": "_t", "mdDisplayBlock": "_u", "mdDisplayInlineBlock": "_v", "mdDisplayVisuallyHidden": "_w", "lgDisplayNone": "_x", "lgDisplayFlex": "_y", "lgDisplayBlock": "_z", "lgDisplayInlineBlock": "_10", "lgDisplayVisuallyHidden": "_11", "xsDirectionRow": "_12", "xsDirectionColumn": "_13", "smDirectionRow": "_14", "smDirectionColumn": "_15", "mdDirectionRow": "_16", "mdDirectionColumn": "_17", "lgDirectionRow": "_18", "lgDirectionColumn": "_19", "xsCol0": "_1a", "xsCol1": "_1b _xx", "xsCol2": "_1c _xy", "xsCol3": "_1d _xz", "xsCol4": "_1e _y0", "xsCol5": "_1f _y1", "xsCol6": "_1g _y2", "xsCol7": "_1h _y3", "xsCol8": "_1i _y4", "xsCol9": "_1j _y5", "xsCol10": "_1k _y6", "xsCol11": "_1l _y7", "xsCol12": "_1m _y8", "smCol0": "_1n", "smCol1": "_1o _y9", "smCol2": "_1p _ya", "smCol3": "_1q _yb", "smCol4": "_1r _yc", "smCol5": "_1s _yd", "smCol6": "_1t _ye", "smCol7": "_1u _yf", "smCol8": "_1v _yg", "smCol9": "_1w _yh", "smCol10": "_1x _yi", "smCol11": "_1y _yj", "smCol12": "_1z _yk", "mdCol0": "_20", "mdCol1": "_21 _yl", "mdCol2": "_22 _ym", "mdCol3": "_23 _yn", "mdCol4": "_24 _yo", "mdCol5": "_25 _yp", "mdCol6": "_26 _yq", "mdCol7": "_27 _yr", "mdCol8": "_28 _ys", "mdCol9": "_29 _yt", "mdCol10": "_2a _yu", "mdCol11": "_2b _yv", "mdCol12": "_2c _yw", "lgCol0": "_2d", "lgCol1": "_2e _yx", "lgCol2": "_2f _yy", "lgCol3": "_2g _yz", "lgCol4": "_2h _z0", "lgCol5": "_2i _z1", "lgCol6": "_2j _z2", "lgCol7": "_2k _z3", "lgCol8": "_2l _z4", "lgCol9": "_2m _z5", "lgCol10": "_2n _z6", "lgCol11": "_2o _z7", "lgCol12": "_2p _z8" };

var borders = { "border": "_2q", "borderTop": "_2r", "borderRight": "_2s", "borderBottom": "_2t", "borderLeft": "_2u", "square": "_2v", "circle": "_2w", "pill": "_2x", "rounded": "_2y", "roundedTop": "_2z", "roundedRight": "_30", "roundedBottom": "_31", "roundedLeft": "_32", "noBorder": "_33" };

var colors = { "red": "_34", "redBg": "_35", "white": "_36", "whiteBg": "_37", "lightGray": "_38", "lightGrayBg": "_39", "gray": "_3a", "grayBg": "_3b", "darkGray": "_3c", "darkGrayBg": "_3d", "green": "_3e", "greenBg": "_3f", "pine": "_3g", "pineBg": "_3h", "olive": "_3i", "oliveBg": "_3j", "blue": "_3k", "blueBg": "_3l", "navy": "_3m", "navyBg": "_3n", "midnight": "_3o", "midnightBg": "_3p", "purple": "_3q", "purpleBg": "_3r", "orchid": "_3s", "orchidBg": "_3t", "eggplant": "_3u", "eggplantBg": "_3v", "maroon": "_3w", "maroonBg": "_3x", "watermelon": "_3y", "watermelonBg": "_3z", "orange": "_40", "orangeBg": "_41", "transparentBg": "_42", "lightWashBg": "_43", "darkWashBg": "_44" };

var layout = { "block": "_45", "inline": "_46", "inlineBlock": "_47", "table": "_48", "overflowHidden": "_49", "overflowScroll": "_4a", "overflowScrollX": "_4b", "overflowScrollY": "_4c", "overflowAuto": "_4d", "fit": "_4e", "relative": "_4f", "fixed": "_4g", "absolute": "_4h", "sticky": "_4i", "top0": "_4j", "right0": "_4k", "bottom0": "_4l", "left0": "_4m", "small": "_4n", "medium": "_4o", "large": "_4p", "borderBox": "_4q", "contentBox": "_4r", "-webkit-box-flex": "_4s", "-webkit-flex": "_4s", "-ms-flex": "_4s", "flex": "_4s", "smFlex": "_4t", "mdFlex": "_4u", "lgFlex": "_4v", "flexColumn": "_4w", "flexWrap": "_4x", "itemsStart": "_4y", "itemsEnd": "_4z", "itemsCenter": "_50", "itemsBaseline": "_51", "itemsStretch": "_52", "selfStart": "_53", "selfEnd": "_54", "selfCenter": "_55", "selfBaseline": "_56", "selfStretch": "_57", "justifyStart": "_58", "justifyEnd": "_59", "justifyCenter": "_5a", "justifyBetween": "_5b", "justifyAround": "_5c", "contentStart": "_5d", "contentEnd": "_5e", "contentCenter": "_5f", "contentBetween": "_5g", "contentAround": "_5h", "contentStretch": "_5i", "flexGrow": "_5j", "flexNone": "_5k", "orderFirst": "_5l", "orderLast": "_5m" };

var whitespace = { "marginStart1": "_5n", "marginEnd1": "_5o", "marginStartN1": "_5p", "marginEndN1": "_5q", "marginTop1": "_5r", "marginRight1": "_5s", "marginBottom1": "_5t", "marginLeft1": "_5u", "marginTopN1": "_5v", "marginRightN1": "_5w", "marginBottomN1": "_5x", "marginLeftN1": "_5y", "paddingY1": "_5z", "paddingX1": "_60", "marginStart2": "_61", "marginEnd2": "_62", "marginStartN2": "_63", "marginEndN2": "_64", "marginTop2": "_65", "marginRight2": "_66", "marginBottom2": "_67", "marginLeft2": "_68", "marginTopN2": "_69", "marginRightN2": "_6a", "marginBottomN2": "_6b", "marginLeftN2": "_6c", "paddingY2": "_6d", "paddingX2": "_6e", "marginStart3": "_6f", "marginEnd3": "_6g", "marginStartN3": "_6h", "marginEndN3": "_6i", "marginTop3": "_6j", "marginRight3": "_6k", "marginBottom3": "_6l", "marginLeft3": "_6m", "marginTopN3": "_6n", "marginRightN3": "_6o", "marginBottomN3": "_6p", "marginLeftN3": "_6q", "paddingY3": "_6r", "paddingX3": "_6s", "marginStart4": "_6t", "marginEnd4": "_6u", "marginStartN4": "_6v", "marginEndN4": "_6w", "marginTop4": "_6x", "marginRight4": "_6y", "marginBottom4": "_6z", "marginLeft4": "_70", "marginTopN4": "_71", "marginRightN4": "_72", "marginBottomN4": "_73", "marginLeftN4": "_74", "paddingY4": "_75", "paddingX4": "_76", "marginStart5": "_77", "marginEnd5": "_78", "marginStartN5": "_79", "marginEndN5": "_7a", "marginTop5": "_7b", "marginRight5": "_7c", "marginBottom5": "_7d", "marginLeft5": "_7e", "marginTopN5": "_7f", "marginRightN5": "_7g", "marginBottomN5": "_7h", "marginLeftN5": "_7i", "paddingY5": "_7j", "paddingX5": "_7k", "marginStart6": "_7l", "marginEnd6": "_7m", "marginStartN6": "_7n", "marginEndN6": "_7o", "marginTop6": "_7p", "marginRight6": "_7q", "marginBottom6": "_7r", "marginLeft6": "_7s", "marginTopN6": "_7t", "marginRightN6": "_7u", "marginBottomN6": "_7v", "marginLeftN6": "_7w", "paddingY6": "_7x", "paddingX6": "_7y", "marginStart7": "_7z", "marginEnd7": "_80", "marginStartN7": "_81", "marginEndN7": "_82", "marginTop7": "_83", "marginRight7": "_84", "marginBottom7": "_85", "marginLeft7": "_86", "marginTopN7": "_87", "marginRightN7": "_88", "marginBottomN7": "_89", "marginLeftN7": "_8a", "paddingY7": "_8b", "paddingX7": "_8c", "marginStart8": "_8d", "marginEnd8": "_8e", "marginStartN8": "_8f", "marginEndN8": "_8g", "marginTop8": "_8h", "marginRight8": "_8i", "marginBottom8": "_8j", "marginLeft8": "_8k", "marginTopN8": "_8l", "marginRightN8": "_8m", "marginBottomN8": "_8n", "marginLeftN8": "_8o", "paddingY8": "_8p", "paddingX8": "_8q", "marginStart9": "_8r", "marginEnd9": "_8s", "marginStartN9": "_8t", "marginEndN9": "_8u", "marginTop9": "_8v", "marginRight9": "_8w", "marginBottom9": "_8x", "marginLeft9": "_8y", "marginTopN9": "_8z", "marginRightN9": "_90", "marginBottomN9": "_91", "marginLeftN9": "_92", "paddingY9": "_93", "paddingX9": "_94", "marginStart10": "_95", "marginEnd10": "_96", "marginStartN10": "_97", "marginEndN10": "_98", "marginTop10": "_99", "marginRight10": "_9a", "marginBottom10": "_9b", "marginLeft10": "_9c", "marginTopN10": "_9d", "marginRightN10": "_9e", "marginBottomN10": "_9f", "marginLeftN10": "_9g", "paddingY10": "_9h", "paddingX10": "_9i", "marginStart11": "_9j", "marginEnd11": "_9k", "marginStartN11": "_9l", "marginEndN11": "_9m", "marginTop11": "_9n", "marginRight11": "_9o", "marginBottom11": "_9p", "marginLeft11": "_9q", "marginTopN11": "_9r", "marginRightN11": "_9s", "marginBottomN11": "_9t", "marginLeftN11": "_9u", "paddingY11": "_9v", "paddingX11": "_9w", "marginStart12": "_9x", "marginEnd12": "_9y", "marginStartN12": "_9z", "marginEndN12": "_a0", "marginTop12": "_a1", "marginRight12": "_a2", "marginBottom12": "_a3", "marginLeft12": "_a4", "marginTopN12": "_a5", "marginRightN12": "_a6", "marginBottomN12": "_a7", "marginLeftN12": "_a8", "paddingY12": "_a9", "paddingX12": "_aa", "smMarginStart1": "_ab", "smMarginEnd1": "_ac", "smMarginStartN1": "_ad", "smMarginEndN1": "_ae", "smMarginTop1": "_af", "smMarginRight1": "_ag", "smMarginBottom1": "_ah", "smMarginLeft1": "_ai", "smMarginTopN1": "_aj", "smMarginRightN1": "_ak", "smMarginBottomN1": "_al", "smMarginLeftN1": "_am", "smPaddingY1": "_an", "smPaddingX1": "_ao", "smMarginStart2": "_ap", "smMarginEnd2": "_aq", "smMarginStartN2": "_ar", "smMarginEndN2": "_as", "smMarginTop2": "_at", "smMarginRight2": "_au", "smMarginBottom2": "_av", "smMarginLeft2": "_aw", "smMarginTopN2": "_ax", "smMarginRightN2": "_ay", "smMarginBottomN2": "_az", "smMarginLeftN2": "_b0", "smPaddingY2": "_b1", "smPaddingX2": "_b2", "smMarginStart3": "_b3", "smMarginEnd3": "_b4", "smMarginStartN3": "_b5", "smMarginEndN3": "_b6", "smMarginTop3": "_b7", "smMarginRight3": "_b8", "smMarginBottom3": "_b9", "smMarginLeft3": "_ba", "smMarginTopN3": "_bb", "smMarginRightN3": "_bc", "smMarginBottomN3": "_bd", "smMarginLeftN3": "_be", "smPaddingY3": "_bf", "smPaddingX3": "_bg", "smMarginStart4": "_bh", "smMarginEnd4": "_bi", "smMarginStartN4": "_bj", "smMarginEndN4": "_bk", "smMarginTop4": "_bl", "smMarginRight4": "_bm", "smMarginBottom4": "_bn", "smMarginLeft4": "_bo", "smMarginTopN4": "_bp", "smMarginRightN4": "_bq", "smMarginBottomN4": "_br", "smMarginLeftN4": "_bs", "smPaddingY4": "_bt", "smPaddingX4": "_bu", "smMarginStart5": "_bv", "smMarginEnd5": "_bw", "smMarginStartN5": "_bx", "smMarginEndN5": "_by", "smMarginTop5": "_bz", "smMarginRight5": "_c0", "smMarginBottom5": "_c1", "smMarginLeft5": "_c2", "smMarginTopN5": "_c3", "smMarginRightN5": "_c4", "smMarginBottomN5": "_c5", "smMarginLeftN5": "_c6", "smPaddingY5": "_c7", "smPaddingX5": "_c8", "smMarginStart6": "_c9", "smMarginEnd6": "_ca", "smMarginStartN6": "_cb", "smMarginEndN6": "_cc", "smMarginTop6": "_cd", "smMarginRight6": "_ce", "smMarginBottom6": "_cf", "smMarginLeft6": "_cg", "smMarginTopN6": "_ch", "smMarginRightN6": "_ci", "smMarginBottomN6": "_cj", "smMarginLeftN6": "_ck", "smPaddingY6": "_cl", "smPaddingX6": "_cm", "smMarginStart7": "_cn", "smMarginEnd7": "_co", "smMarginStartN7": "_cp", "smMarginEndN7": "_cq", "smMarginTop7": "_cr", "smMarginRight7": "_cs", "smMarginBottom7": "_ct", "smMarginLeft7": "_cu", "smMarginTopN7": "_cv", "smMarginRightN7": "_cw", "smMarginBottomN7": "_cx", "smMarginLeftN7": "_cy", "smPaddingY7": "_cz", "smPaddingX7": "_d0", "smMarginStart8": "_d1", "smMarginEnd8": "_d2", "smMarginStartN8": "_d3", "smMarginEndN8": "_d4", "smMarginTop8": "_d5", "smMarginRight8": "_d6", "smMarginBottom8": "_d7", "smMarginLeft8": "_d8", "smMarginTopN8": "_d9", "smMarginRightN8": "_da", "smMarginBottomN8": "_db", "smMarginLeftN8": "_dc", "smPaddingY8": "_dd", "smPaddingX8": "_de", "smMarginStart9": "_df", "smMarginEnd9": "_dg", "smMarginStartN9": "_dh", "smMarginEndN9": "_di", "smMarginTop9": "_dj", "smMarginRight9": "_dk", "smMarginBottom9": "_dl", "smMarginLeft9": "_dm", "smMarginTopN9": "_dn", "smMarginRightN9": "_do", "smMarginBottomN9": "_dp", "smMarginLeftN9": "_dq", "smPaddingY9": "_dr", "smPaddingX9": "_ds", "smMarginStart10": "_dt", "smMarginEnd10": "_du", "smMarginStartN10": "_dv", "smMarginEndN10": "_dw", "smMarginTop10": "_dx", "smMarginRight10": "_dy", "smMarginBottom10": "_dz", "smMarginLeft10": "_e0", "smMarginTopN10": "_e1", "smMarginRightN10": "_e2", "smMarginBottomN10": "_e3", "smMarginLeftN10": "_e4", "smPaddingY10": "_e5", "smPaddingX10": "_e6", "smMarginStart11": "_e7", "smMarginEnd11": "_e8", "smMarginStartN11": "_e9", "smMarginEndN11": "_ea", "smMarginTop11": "_eb", "smMarginRight11": "_ec", "smMarginBottom11": "_ed", "smMarginLeft11": "_ee", "smMarginTopN11": "_ef", "smMarginRightN11": "_eg", "smMarginBottomN11": "_eh", "smMarginLeftN11": "_ei", "smPaddingY11": "_ej", "smPaddingX11": "_ek", "smMarginStart12": "_el", "smMarginEnd12": "_em", "smMarginStartN12": "_en", "smMarginEndN12": "_eo", "smMarginTop12": "_ep", "smMarginRight12": "_eq", "smMarginBottom12": "_er", "smMarginLeft12": "_es", "smMarginTopN12": "_et", "smMarginRightN12": "_eu", "smMarginBottomN12": "_ev", "smMarginLeftN12": "_ew", "smPaddingY12": "_ex", "smPaddingX12": "_ey", "mdMarginStart1": "_ez", "mdMarginEnd1": "_f0", "mdMarginStartN1": "_f1", "mdMarginEndN1": "_f2", "mdMarginTop1": "_f3", "mdMarginRight1": "_f4", "mdMarginBottom1": "_f5", "mdMarginLeft1": "_f6", "mdMarginTopN1": "_f7", "mdMarginRightN1": "_f8", "mdMarginBottomN1": "_f9", "mdMarginLeftN1": "_fa", "mdPaddingY1": "_fb", "mdPaddingX1": "_fc", "mdMarginStart2": "_fd", "mdMarginEnd2": "_fe", "mdMarginStartN2": "_ff", "mdMarginEndN2": "_fg", "mdMarginTop2": "_fh", "mdMarginRight2": "_fi", "mdMarginBottom2": "_fj", "mdMarginLeft2": "_fk", "mdMarginTopN2": "_fl", "mdMarginRightN2": "_fm", "mdMarginBottomN2": "_fn", "mdMarginLeftN2": "_fo", "mdPaddingY2": "_fp", "mdPaddingX2": "_fq", "mdMarginStart3": "_fr", "mdMarginEnd3": "_fs", "mdMarginStartN3": "_ft", "mdMarginEndN3": "_fu", "mdMarginTop3": "_fv", "mdMarginRight3": "_fw", "mdMarginBottom3": "_fx", "mdMarginLeft3": "_fy", "mdMarginTopN3": "_fz", "mdMarginRightN3": "_g0", "mdMarginBottomN3": "_g1", "mdMarginLeftN3": "_g2", "mdPaddingY3": "_g3", "mdPaddingX3": "_g4", "mdMarginStart4": "_g5", "mdMarginEnd4": "_g6", "mdMarginStartN4": "_g7", "mdMarginEndN4": "_g8", "mdMarginTop4": "_g9", "mdMarginRight4": "_ga", "mdMarginBottom4": "_gb", "mdMarginLeft4": "_gc", "mdMarginTopN4": "_gd", "mdMarginRightN4": "_ge", "mdMarginBottomN4": "_gf", "mdMarginLeftN4": "_gg", "mdPaddingY4": "_gh", "mdPaddingX4": "_gi", "mdMarginStart5": "_gj", "mdMarginEnd5": "_gk", "mdMarginStartN5": "_gl", "mdMarginEndN5": "_gm", "mdMarginTop5": "_gn", "mdMarginRight5": "_go", "mdMarginBottom5": "_gp", "mdMarginLeft5": "_gq", "mdMarginTopN5": "_gr", "mdMarginRightN5": "_gs", "mdMarginBottomN5": "_gt", "mdMarginLeftN5": "_gu", "mdPaddingY5": "_gv", "mdPaddingX5": "_gw", "mdMarginStart6": "_gx", "mdMarginEnd6": "_gy", "mdMarginStartN6": "_gz", "mdMarginEndN6": "_h0", "mdMarginTop6": "_h1", "mdMarginRight6": "_h2", "mdMarginBottom6": "_h3", "mdMarginLeft6": "_h4", "mdMarginTopN6": "_h5", "mdMarginRightN6": "_h6", "mdMarginBottomN6": "_h7", "mdMarginLeftN6": "_h8", "mdPaddingY6": "_h9", "mdPaddingX6": "_ha", "mdMarginStart7": "_hb", "mdMarginEnd7": "_hc", "mdMarginStartN7": "_hd", "mdMarginEndN7": "_he", "mdMarginTop7": "_hf", "mdMarginRight7": "_hg", "mdMarginBottom7": "_hh", "mdMarginLeft7": "_hi", "mdMarginTopN7": "_hj", "mdMarginRightN7": "_hk", "mdMarginBottomN7": "_hl", "mdMarginLeftN7": "_hm", "mdPaddingY7": "_hn", "mdPaddingX7": "_ho", "mdMarginStart8": "_hp", "mdMarginEnd8": "_hq", "mdMarginStartN8": "_hr", "mdMarginEndN8": "_hs", "mdMarginTop8": "_ht", "mdMarginRight8": "_hu", "mdMarginBottom8": "_hv", "mdMarginLeft8": "_hw", "mdMarginTopN8": "_hx", "mdMarginRightN8": "_hy", "mdMarginBottomN8": "_hz", "mdMarginLeftN8": "_i0", "mdPaddingY8": "_i1", "mdPaddingX8": "_i2", "mdMarginStart9": "_i3", "mdMarginEnd9": "_i4", "mdMarginStartN9": "_i5", "mdMarginEndN9": "_i6", "mdMarginTop9": "_i7", "mdMarginRight9": "_i8", "mdMarginBottom9": "_i9", "mdMarginLeft9": "_ia", "mdMarginTopN9": "_ib", "mdMarginRightN9": "_ic", "mdMarginBottomN9": "_id", "mdMarginLeftN9": "_ie", "mdPaddingY9": "_if", "mdPaddingX9": "_ig", "mdMarginStart10": "_ih", "mdMarginEnd10": "_ii", "mdMarginStartN10": "_ij", "mdMarginEndN10": "_ik", "mdMarginTop10": "_il", "mdMarginRight10": "_im", "mdMarginBottom10": "_in", "mdMarginLeft10": "_io", "mdMarginTopN10": "_ip", "mdMarginRightN10": "_iq", "mdMarginBottomN10": "_ir", "mdMarginLeftN10": "_is", "mdPaddingY10": "_it", "mdPaddingX10": "_iu", "mdMarginStart11": "_iv", "mdMarginEnd11": "_iw", "mdMarginStartN11": "_ix", "mdMarginEndN11": "_iy", "mdMarginTop11": "_iz", "mdMarginRight11": "_j0", "mdMarginBottom11": "_j1", "mdMarginLeft11": "_j2", "mdMarginTopN11": "_j3", "mdMarginRightN11": "_j4", "mdMarginBottomN11": "_j5", "mdMarginLeftN11": "_j6", "mdPaddingY11": "_j7", "mdPaddingX11": "_j8", "mdMarginStart12": "_j9", "mdMarginEnd12": "_ja", "mdMarginStartN12": "_jb", "mdMarginEndN12": "_jc", "mdMarginTop12": "_jd", "mdMarginRight12": "_je", "mdMarginBottom12": "_jf", "mdMarginLeft12": "_jg", "mdMarginTopN12": "_jh", "mdMarginRightN12": "_ji", "mdMarginBottomN12": "_jj", "mdMarginLeftN12": "_jk", "mdPaddingY12": "_jl", "mdPaddingX12": "_jm", "lgMarginStart1": "_jn", "lgMarginEnd1": "_jo", "lgMarginStartN1": "_jp", "lgMarginEndN1": "_jq", "lgMarginTop1": "_jr", "lgMarginRight1": "_js", "lgMarginBottom1": "_jt", "lgMarginLeft1": "_ju", "lgMarginTopN1": "_jv", "lgMarginRightN1": "_jw", "lgMarginBottomN1": "_jx", "lgMarginLeftN1": "_jy", "lgPaddingY1": "_jz", "lgPaddingX1": "_k0", "lgMarginStart2": "_k1", "lgMarginEnd2": "_k2", "lgMarginStartN2": "_k3", "lgMarginEndN2": "_k4", "lgMarginTop2": "_k5", "lgMarginRight2": "_k6", "lgMarginBottom2": "_k7", "lgMarginLeft2": "_k8", "lgMarginTopN2": "_k9", "lgMarginRightN2": "_ka", "lgMarginBottomN2": "_kb", "lgMarginLeftN2": "_kc", "lgPaddingY2": "_kd", "lgPaddingX2": "_ke", "lgMarginStart3": "_kf", "lgMarginEnd3": "_kg", "lgMarginStartN3": "_kh", "lgMarginEndN3": "_ki", "lgMarginTop3": "_kj", "lgMarginRight3": "_kk", "lgMarginBottom3": "_kl", "lgMarginLeft3": "_km", "lgMarginTopN3": "_kn", "lgMarginRightN3": "_ko", "lgMarginBottomN3": "_kp", "lgMarginLeftN3": "_kq", "lgPaddingY3": "_kr", "lgPaddingX3": "_ks", "lgMarginStart4": "_kt", "lgMarginEnd4": "_ku", "lgMarginStartN4": "_kv", "lgMarginEndN4": "_kw", "lgMarginTop4": "_kx", "lgMarginRight4": "_ky", "lgMarginBottom4": "_kz", "lgMarginLeft4": "_l0", "lgMarginTopN4": "_l1", "lgMarginRightN4": "_l2", "lgMarginBottomN4": "_l3", "lgMarginLeftN4": "_l4", "lgPaddingY4": "_l5", "lgPaddingX4": "_l6", "lgMarginStart5": "_l7", "lgMarginEnd5": "_l8", "lgMarginStartN5": "_l9", "lgMarginEndN5": "_la", "lgMarginTop5": "_lb", "lgMarginRight5": "_lc", "lgMarginBottom5": "_ld", "lgMarginLeft5": "_le", "lgMarginTopN5": "_lf", "lgMarginRightN5": "_lg", "lgMarginBottomN5": "_lh", "lgMarginLeftN5": "_li", "lgPaddingY5": "_lj", "lgPaddingX5": "_lk", "lgMarginStart6": "_ll", "lgMarginEnd6": "_lm", "lgMarginStartN6": "_ln", "lgMarginEndN6": "_lo", "lgMarginTop6": "_lp", "lgMarginRight6": "_lq", "lgMarginBottom6": "_lr", "lgMarginLeft6": "_ls", "lgMarginTopN6": "_lt", "lgMarginRightN6": "_lu", "lgMarginBottomN6": "_lv", "lgMarginLeftN6": "_lw", "lgPaddingY6": "_lx", "lgPaddingX6": "_ly", "lgMarginStart7": "_lz", "lgMarginEnd7": "_m0", "lgMarginStartN7": "_m1", "lgMarginEndN7": "_m2", "lgMarginTop7": "_m3", "lgMarginRight7": "_m4", "lgMarginBottom7": "_m5", "lgMarginLeft7": "_m6", "lgMarginTopN7": "_m7", "lgMarginRightN7": "_m8", "lgMarginBottomN7": "_m9", "lgMarginLeftN7": "_ma", "lgPaddingY7": "_mb", "lgPaddingX7": "_mc", "lgMarginStart8": "_md", "lgMarginEnd8": "_me", "lgMarginStartN8": "_mf", "lgMarginEndN8": "_mg", "lgMarginTop8": "_mh", "lgMarginRight8": "_mi", "lgMarginBottom8": "_mj", "lgMarginLeft8": "_mk", "lgMarginTopN8": "_ml", "lgMarginRightN8": "_mm", "lgMarginBottomN8": "_mn", "lgMarginLeftN8": "_mo", "lgPaddingY8": "_mp", "lgPaddingX8": "_mq", "lgMarginStart9": "_mr", "lgMarginEnd9": "_ms", "lgMarginStartN9": "_mt", "lgMarginEndN9": "_mu", "lgMarginTop9": "_mv", "lgMarginRight9": "_mw", "lgMarginBottom9": "_mx", "lgMarginLeft9": "_my", "lgMarginTopN9": "_mz", "lgMarginRightN9": "_n0", "lgMarginBottomN9": "_n1", "lgMarginLeftN9": "_n2", "lgPaddingY9": "_n3", "lgPaddingX9": "_n4", "lgMarginStart10": "_n5", "lgMarginEnd10": "_n6", "lgMarginStartN10": "_n7", "lgMarginEndN10": "_n8", "lgMarginTop10": "_n9", "lgMarginRight10": "_na", "lgMarginBottom10": "_nb", "lgMarginLeft10": "_nc", "lgMarginTopN10": "_nd", "lgMarginRightN10": "_ne", "lgMarginBottomN10": "_nf", "lgMarginLeftN10": "_ng", "lgPaddingY10": "_nh", "lgPaddingX10": "_ni", "lgMarginStart11": "_nj", "lgMarginEnd11": "_nk", "lgMarginStartN11": "_nl", "lgMarginEndN11": "_nm", "lgMarginTop11": "_nn", "lgMarginRight11": "_no", "lgMarginBottom11": "_np", "lgMarginLeft11": "_nq", "lgMarginTopN11": "_nr", "lgMarginRightN11": "_ns", "lgMarginBottomN11": "_nt", "lgMarginLeftN11": "_nu", "lgPaddingY11": "_nv", "lgPaddingX11": "_nw", "lgMarginStart12": "_nx", "lgMarginEnd12": "_ny", "lgMarginStartN12": "_nz", "lgMarginEndN12": "_o0", "lgMarginTop12": "_o1", "lgMarginRight12": "_o2", "lgMarginBottom12": "_o3", "lgMarginLeft12": "_o4", "lgMarginTopN12": "_o5", "lgMarginRightN12": "_o6", "lgMarginBottomN12": "_o7", "lgMarginLeftN12": "_o8", "lgPaddingY12": "_o9", "lgPaddingX12": "_oa" };

var whitespaceLegacy = { "mlAuto": "_ob", "mrAuto": "_oc", "m0": "_od", "mt0": "_oe", "mr0": "_of", "mb0": "_og", "ml0": "_oh", "p0": "_oi", "px0": "_oj", "py0": "_ok", "m1": "_ol", "mt1": "_om", "mr1": "_on", "mb1": "_oo", "ml1": "_op", "mn1": "_oq", "mtn1": "_or", "mbn1": "_os", "mln1": "_ot", "mrn1": "_ou", "mxn1": "_ov", "myn1": "_ow", "p1": "_ox", "px1": "_oy", "py1": "_oz", "m2": "_p0", "mt2": "_p1", "mr2": "_p2", "mb2": "_p3", "ml2": "_p4", "mn2": "_p5", "mtn2": "_p6", "mbn2": "_p7", "mln2": "_p8", "mrn2": "_p9", "mxn2": "_pa", "myn2": "_pb", "p2": "_pc", "px2": "_pd", "py2": "_pe", "m3": "_pf", "mt3": "_pg", "mr3": "_ph", "mb3": "_pi", "ml3": "_pj", "mn3": "_pk", "mtn3": "_pl", "mbn3": "_pm", "mln3": "_pn", "mrn3": "_po", "mxn3": "_pp", "myn3": "_pq", "p3": "_pr", "px3": "_ps", "py3": "_pt", "m4": "_pu", "mt4": "_pv", "mr4": "_pw", "mb4": "_px", "ml4": "_py", "mn4": "_pz", "mtn4": "_q0", "mbn4": "_q1", "mln4": "_q2", "mrn4": "_q3", "mxn4": "_q4", "myn4": "_q5", "p4": "_q6", "px4": "_q7", "py4": "_q8", "m5": "_q9", "mt5": "_qa", "mr5": "_qb", "mb5": "_qc", "ml5": "_qd", "mn5": "_qe", "mtn5": "_qf", "mbn5": "_qg", "mln5": "_qh", "mrn5": "_qi", "mxn5": "_qj", "myn5": "_qk", "p5": "_ql", "px5": "_qm", "py5": "_qn", "m6": "_qo", "mt6": "_qp", "mr6": "_qq", "mb6": "_qr", "ml6": "_qs", "mn6": "_qt", "mtn6": "_qu", "mbn6": "_qv", "mln6": "_qw", "mrn6": "_qx", "mxn6": "_qy", "myn6": "_qz", "p6": "_r0", "px6": "_r1", "py6": "_r2" };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

var objectWithoutProperties = function (obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

/*

Style is a monoid that capture the "to-be-applied" styles (inline and classes)
for a Box. It's basically set that is closed under an associative binary
operation and has an identity element such that for all HA HA HA. Yes, it's a
monoid, which sounds scary but it's not really and actually super useful. All
that means is that basically you can do two things with it:

    1. concat(concat(a, b), c) === concat(a, concat(b, c));
    2. concat(identity(), a) === concat(a, identity()) === a;

What that means is that it's really easy to compose styles together and the
order in which you do so doesn't really matter.

*/

var identity = function identity() {
  return {
    className: new Set(),
    inlineStyle: {}
  };
};

// TODO: This type should be opaque, however the Babel parser doesn't support
//       the opaque syntax yet.


var fromClassName = function fromClassName() {
  for (var _len = arguments.length, classNames = Array(_len), _key = 0; _key < _len; _key++) {
    classNames[_key] = arguments[_key];
  }

  return {
    className: new Set(classNames),
    inlineStyle: {}
  };
};

var fromInlineStyle = function fromInlineStyle(inlineStyle) {
  return {
    className: new Set(),
    inlineStyle: inlineStyle
  };
};

var concat = function concat(styles) {
  return styles.reduce(function (_ref, _ref2) {
    var classNameA = _ref.className,
        inlineStyleA = _ref.inlineStyle;
    var classNameB = _ref2.className,
        inlineStyleB = _ref2.inlineStyle;
    return {
      className: new Set([].concat(toConsumableArray(classNameA), toConsumableArray(classNameB))),
      inlineStyle: _extends({}, inlineStyleA, inlineStyleB)
    };
  }, identity());
};

var mapClassName = function mapClassName(fn) {
  return function (_ref3) {
    var className = _ref3.className,
        inlineStyle = _ref3.inlineStyle;
    return {
      className: new Set(Array.from(className).map(fn)),
      inlineStyle: inlineStyle
    };
  };
};

var toProps = function toProps(_ref4) {
  var className = _ref4.className,
      inlineStyle = _ref4.inlineStyle;

  var props = {};

  if (className.size > 0) {
    // Sorting here ensures that classNames are always stable, reducing diff
    // churn. Box usually has a small number of properties so it's not a perf
    // concern.
    props.className = Array.from(className).sort().join(' ');
  }

  if (Object.keys(inlineStyle).length > 0) {
    props.style = inlineStyle;
  }

  return props;
};

/*

Transforms

These are a collection of a few functors that take values and returns Style's. OMG, I used the word functor - it's really just a fancy word for function.

*/

// Adds a classname when a property is present.
//
//     <Box top />
//
var toggle = function toggle() {
  for (var _len = arguments.length, classNames = Array(_len), _key = 0; _key < _len; _key++) {
    classNames[_key] = arguments[_key];
  }

  return function (val) {
    return val ? fromClassName.apply(undefined, classNames) : identity();
  };
};

// Maps string values to classes
//
//     <Box alignItems="center" />
//
var mapping = function mapping(map) {
  return function (val) {
    return Object.prototype.hasOwnProperty.call(map, val) ? fromClassName(map[val]) : identity();
  };
};

// Maps a range of integers to a range of classnames
//
//     <Box padding={1} />
//
var range = function range(scale) {
  return function (n) {
    return fromClassName('' + scale + (n < 0 ? 'N' + Math.abs(n) : n));
  };
};

// Like `range`, maps a range of integers to a range of classnames, excluding
// zero values.
//
//     <Box padding={0} />
var rangeWithoutZero = function rangeWithoutZero(scale) {
  return function (n) {
    return n === 0 ? identity() : range(scale)(n);
  };
};

// Binds a string classname to the value in an object. Useful when interacting
// with ranges that need to come dynamically from a style object. This is
// similar to the NPM package 'classnames/bind'.
var bind = function bind(fn, scope) {
  return function (val) {
    return mapClassName(function (name) {
      return scope[name];
    })(fn(val));
  };
};

// This takes a series of the previously defined functors, runs them all
// against a value and returns the set of their classnames.
var union = function union() {
  for (var _len2 = arguments.length, fns = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    fns[_key2] = arguments[_key2];
  }

  return function (val) {
    return concat(fns.map(function (fn) {
      return fn(val);
    }));
  };
};

/*

# ProTypes

Box's type definition is exhaustive. With the exception of `dangerouslySetInlineStyle`, values shouldn't be ambigious. That means that we have to type out things like boints, but that's also where Box's magic lies. Also, by putting in extra effort around type definitions here, we can skip extra runtime typechecks in the transformers for performance.

*/

// --

/*

# Transformers

This is where the meat and the bones of Box's transforms are. You can read more about the DSL in `./transforms.js`, but basically they are a small declarative way of specifying how a property (i.e. `marginTop={4}`) gets turned into a CSS class (`marginTop4`).

There's a little preamble here, but it culminates in a big object mapping the actual property names to the transformer values.

*/

var marginStart = bind(rangeWithoutZero('marginStart'), whitespace);
var marginEnd = bind(rangeWithoutZero('marginEnd'), whitespace);
var marginTop = bind(rangeWithoutZero('marginTop'), whitespace);
var marginRight = bind(rangeWithoutZero('marginRight'), whitespace);
var marginBottom = bind(rangeWithoutZero('marginBottom'), whitespace);
var marginLeft = bind(rangeWithoutZero('marginLeft'), whitespace);
var margin = union(marginTop, marginBottom, marginLeft, marginRight);

var smMarginTop = bind(rangeWithoutZero('smMarginTop'), whitespace);
var smMarginRight = bind(rangeWithoutZero('smMarginRight'), whitespace);
var smMarginBottom = bind(rangeWithoutZero('smMarginBottom'), whitespace);
var smMarginLeft = bind(rangeWithoutZero('smMarginLeft'), whitespace);
var smMargin = union(smMarginTop, smMarginBottom, smMarginLeft, smMarginRight);

var mdMarginTop = bind(rangeWithoutZero('mdMarginTop'), whitespace);
var mdMarginRight = bind(rangeWithoutZero('mdMarginRight'), whitespace);
var mdMarginBottom = bind(rangeWithoutZero('mdMarginBottom'), whitespace);
var mdMarginLeft = bind(rangeWithoutZero('mdMarginLeft'), whitespace);
var mdMargin = union(mdMarginTop, mdMarginBottom, mdMarginLeft, mdMarginRight);

var lgMarginTop = bind(rangeWithoutZero('lgMarginTop'), whitespace);
var lgMarginRight = bind(rangeWithoutZero('lgMarginRight'), whitespace);
var lgMarginBottom = bind(rangeWithoutZero('lgMarginBottom'), whitespace);
var lgMarginLeft = bind(rangeWithoutZero('lgMarginLeft'), whitespace);
var lgMargin = union(lgMarginTop, lgMarginBottom, lgMarginLeft, lgMarginRight);

var paddingX = bind(rangeWithoutZero('paddingX'), whitespace);
var paddingY = bind(rangeWithoutZero('paddingY'), whitespace);
var padding = union(paddingX, paddingY);

var smPaddingX = bind(rangeWithoutZero('smPaddingX'), whitespace);
var smPaddingY = bind(rangeWithoutZero('smPaddingY'), whitespace);
var smPadding = union(smPaddingX, smPaddingY);

var mdPaddingX = bind(rangeWithoutZero('mdPaddingX'), whitespace);
var mdPaddingY = bind(rangeWithoutZero('mdPaddingY'), whitespace);
var mdPadding = union(mdPaddingX, mdPaddingY);

var lgPaddingX = bind(rangeWithoutZero('lgPaddingX'), whitespace);
var lgPaddingY = bind(rangeWithoutZero('lgPaddingY'), whitespace);
var lgPadding = union(lgPaddingX, lgPaddingY);

/*

These functions are legacy. I'd like to get rid of most of this file's dependency on importing `./style.js` directly once these are removed.

*/

var prefix = function prefix(pre) {
  return mapClassName(function (name) {
    return '' + pre + name;
  });
};
var display = function display(value) {
  switch (value) {
    case 'flex':
      return fromClassName('DisplayFlex', 'DirectionRow');
    case 'flexColumn':
      return fromClassName('DisplayFlex', 'DirectionColumn');
    case 'inlineBlock':
      return fromClassName('DisplayInlineBlock');
    case 'visuallyHidden':
      return fromClassName('DisplayVisuallyHidden');
    case false:
      return fromClassName('DisplayNone');
    default:
      /* block */
      return fromClassName('DisplayBlock');
  }
};
var column = range('Col');

var formatIntBoint = function formatIntBoint(x) {
  return x < 0 ? 'n' + Math.abs(x) : x.toString();
};

/*

It's preferable to put new properties into that object directly just so it's easier to read.

*/

var propToFn = {
  xs: function xs(value) {
    if (!value) {
      return identity();
    }
    return mapClassName(function (c) {
      return styles[c];
    })(prefix('xs')(concat([value.column ? column(value.column) : identity(), typeof value.display !== 'undefined' ? display(value.display) : identity()])));
  },
  sm: function sm(value) {
    if (!value) {
      return identity();
    }
    return mapClassName(function (c) {
      return styles[c];
    })(prefix('sm')(concat([value.column ? column(value.column) : identity(), typeof value.display !== 'undefined' ? display(value.display) : identity()])));
  },
  md: function md(value) {
    if (!value) {
      return identity();
    }
    return mapClassName(function (c) {
      return styles[c];
    })(prefix('md')(concat([value.column ? column(value.column) : identity(), typeof value.display !== 'undefined' ? display(value.display) : identity()])));
  },
  lg: function lg(value) {
    if (!value) {
      return identity();
    }
    return mapClassName(function (c) {
      return styles[c];
    })(prefix('lg')(concat([value.column ? column(value.column) : identity(), typeof value.display !== 'undefined' ? display(value.display) : identity()])));
  },

  display: mapping({
    none: styles.xsDisplayNone,
    flex: styles.xsDisplayFlex,
    block: styles.xsDisplayBlock,
    inlineBlock: styles.xsDisplayInlineBlock,
    visuallyHidden: styles.xsDisplayVisuallyHidden
  }),
  column: bind(range('xsCol'), styles),
  direction: mapping({
    row: styles.xsDirectionRow,
    column: styles.xsDirectionColumn
  }),

  smDisplay: mapping({
    none: styles.smDisplayNone,
    flex: styles.smDisplayFlex,
    block: styles.smDisplayBlock,
    inlineBlock: styles.smDisplayInlineBlock,
    visuallyHidden: styles.smDisplayVisuallyHidden
  }),
  smColumn: bind(range('smCol'), styles),
  smDirection: mapping({
    row: styles.smDirectionRow,
    column: styles.smDirectionColumn
  }),

  mdDisplay: mapping({
    none: styles.mdDisplayNone,
    flex: styles.mdDisplayFlex,
    block: styles.mdDisplayBlock,
    inlineBlock: styles.mdDisplayInlineBlock,
    visuallyHidden: styles.mdDisplayVisuallyHidden
  }),
  mdColumn: bind(range('mdCol'), styles),
  mdDirection: mapping({
    row: styles.mdDirectionRow,
    column: styles.mdDirectionColumn
  }),

  lgDisplay: mapping({
    none: styles.lgDisplayNone,
    flex: styles.lgDisplayFlex,
    block: styles.lgDisplayBlock,
    inlineBlock: styles.lgDisplayInlineBlock,
    visuallyHidden: styles.lgDisplayVisuallyHidden
  }),
  lgColumn: bind(range('lgCol'), styles),
  lgDirection: mapping({
    row: styles.lgDirectionRow,
    column: styles.lgDirectionColumn
  }),

  alignContent: mapping({
    start: layout.contentStart,
    end: layout.contentEnd,
    center: layout.contentCenter,
    between: layout.contentBetween,
    around: layout.contentAround
    // default: stretch
  }),
  alignItems: mapping({
    start: layout.itemsStart,
    end: layout.itemsEnd,
    center: layout.itemsCenter,
    baseline: layout.itemsBaseline
    // default: stretch
  }),
  alignSelf: mapping({
    start: layout.selfStart,
    end: layout.selfEnd,
    center: layout.selfCenter,
    baseline: layout.selfBaseline,
    stretch: layout.selfStretch
    // default: auto
  }),
  bottom: toggle(layout.bottom0),
  color: mapping({
    blue: colors.blueBg,
    darkGray: colors.darkGrayBg,
    pine: colors.pineBg,
    gray: colors.grayBg,
    red: colors.redBg,
    olive: colors.oliveBg,
    lightGray: colors.lightGrayBg,
    white: colors.whiteBg,
    orange: colors.orangeBg,
    green: colors.greenBg,
    navy: colors.navyBg,
    midnight: colors.midnightBg,
    purple: colors.purpleBg,
    orchid: colors.orchidBg,
    eggplant: colors.eggplantBg,
    maroon: colors.maroonBg,
    watermelon: colors.watermelonBg,
    lightWash: colors.lightWashBg,
    darkWash: colors.darkWashBg
    // default: transparent
  }),
  fit: toggle(layout.fit),
  flex: mapping({
    grow: layout.flexGrow,
    none: layout.flexNone
    // default: shrink
  }),
  height: function (_height) {
    function height(_x) {
      return _height.apply(this, arguments);
    }

    height.toString = function () {
      return _height.toString();
    };

    return height;
  }(function (height) {
    return fromInlineStyle({ height: height });
  }),
  justifyContent: mapping({
    end: layout.justifyEnd,
    center: layout.justifyCenter,
    between: layout.justifyBetween,
    around: layout.justifyAround
    // default: start
  }),
  left: toggle(layout.left0),
  deprecatedMargin: function deprecatedMargin(value) {
    var mt = identity();
    var mb = identity();
    var ml = identity();
    var mr = identity();
    switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {
      case 'number':
        return fromClassName(whitespaceLegacy['m' + formatIntBoint(value)]);
      case 'object':
        if (value.top) {
          mt = fromClassName(whitespaceLegacy['mt' + formatIntBoint(value.top)]);
        }

        if (value.bottom) {
          mb = fromClassName(whitespaceLegacy['mb' + formatIntBoint(value.bottom)]);
        }

        if (value.left) {
          ml = fromClassName(value.left === 'auto' ? whitespaceLegacy.mlAuto : whitespaceLegacy['ml' + formatIntBoint(value.left)]);
        }

        if (value.right) {
          mr = fromClassName(value.right === 'auto' ? whitespaceLegacy.mrAuto : whitespaceLegacy['mr' + formatIntBoint(value.right)]);
        }
        return concat([mt, mb, ml, mr]);
      default:
        return identity();
    }
  },
  marginStart: marginStart,
  marginEnd: marginEnd,
  margin: margin,
  marginTop: marginTop,
  marginRight: marginRight,
  marginBottom: marginBottom,
  marginLeft: marginLeft,
  smMargin: smMargin,
  smMarginTop: smMarginTop,
  smMarginRight: smMarginRight,
  smMarginBottom: smMarginBottom,
  smMarginLeft: smMarginLeft,
  mdMargin: mdMargin,
  mdMarginTop: mdMarginTop,
  mdMarginRight: mdMarginRight,
  mdMarginBottom: mdMarginBottom,
  mdMarginLeft: mdMarginLeft,
  lgMargin: lgMargin,
  lgMarginTop: lgMarginTop,
  lgMarginRight: lgMarginRight,
  lgMarginBottom: lgMarginBottom,
  lgMarginLeft: lgMarginLeft,
  maxHeight: function (_maxHeight) {
    function maxHeight(_x2) {
      return _maxHeight.apply(this, arguments);
    }

    maxHeight.toString = function () {
      return _maxHeight.toString();
    };

    return maxHeight;
  }(function (maxHeight) {
    return fromInlineStyle({ maxHeight: maxHeight });
  }),
  maxWidth: function (_maxWidth) {
    function maxWidth(_x3) {
      return _maxWidth.apply(this, arguments);
    }

    maxWidth.toString = function () {
      return _maxWidth.toString();
    };

    return maxWidth;
  }(function (maxWidth) {
    return fromInlineStyle({ maxWidth: maxWidth });
  }),
  minHeight: function (_minHeight) {
    function minHeight(_x4) {
      return _minHeight.apply(this, arguments);
    }

    minHeight.toString = function () {
      return _minHeight.toString();
    };

    return minHeight;
  }(function (minHeight) {
    return fromInlineStyle({ minHeight: minHeight });
  }),
  minWidth: function (_minWidth) {
    function minWidth(_x5) {
      return _minWidth.apply(this, arguments);
    }

    minWidth.toString = function () {
      return _minWidth.toString();
    };

    return minWidth;
  }(function (minWidth) {
    return fromInlineStyle({ minWidth: minWidth });
  }),
  overflow: mapping({
    hidden: layout.overflowHidden,
    scroll: layout.overflowScroll,
    auto: layout.overflowAuto,
    scrollX: layout.overflowScrollX,
    scrollY: layout.overflowScrollY
    // default: visible
  }),
  deprecatedPadding: function deprecatedPadding(value) {
    switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {
      case 'number':
        return fromClassName(whitespaceLegacy['p' + value]);
      case 'object':
        return concat([value.x ? fromClassName(whitespaceLegacy['px' + value.x]) : identity(), value.y ? fromClassName(whitespaceLegacy['py' + value.y]) : identity()]);
      default:
        return identity();
    }
  },
  padding: padding,
  paddingX: paddingX,
  paddingY: paddingY,
  smPadding: smPadding,
  smPaddingX: smPaddingX,
  smPaddingY: smPaddingY,
  mdPadding: mdPadding,
  mdPaddingX: mdPaddingX,
  mdPaddingY: mdPaddingY,
  lgPadding: lgPadding,
  lgPaddingX: lgPaddingX,
  lgPaddingY: lgPaddingY,
  position: mapping({
    absolute: layout.absolute,
    relative: layout.relative,
    fixed: layout.fixed
    // default: static
  }),
  right: toggle(layout.right0),
  shape: mapping({
    circle: borders.circle,
    pill: borders.pill,
    rounded: borders.rounded,
    roundedBottom: borders.roundedBottom,
    roundedLeft: borders.roundedLeft,
    roundedRight: borders.roundedRight,
    roundedTop: borders.roundedTop
    // default: square
  }),
  top: toggle(layout.top0),
  width: function (_width) {
    function width(_x6) {
      return _width.apply(this, arguments);
    }

    width.toString = function () {
      return _width.toString();
    };

    return width;
  }(function (width) {
    return fromInlineStyle({ width: width });
  }),
  wrap: toggle(layout.flexWrap),
  dangerouslySetInlineStyle: function dangerouslySetInlineStyle(value) {
    return (
      /* eslint-disable-next-line no-underscore-dangle */
      value && value.__style ? fromInlineStyle(value.__style) : identity()
    );
  }
};

/*

# The Component

*/

var contains = function contains(key, arr) {
  return arr.indexOf(key) >= 0;
};
var omit = function omit(keys, obj) {
  return Object.keys(obj).reduce(function (acc, k) {
    if (contains(k, keys)) {
      return acc;
    }
    return _extends({}, acc, defineProperty({}, k, obj[k]));
  }, {});
};

// $FlowIssue https://github.com/facebook/flow/issues/6103
var Box = forwardRef(function (_ref, ref) {
  var children = _ref.children,
      props = objectWithoutProperties(_ref, ['children']);

  // Flow can't reason about the constant nature of Object.keys so we can't use
  // a functional (reduce) style here.

  // Box is a "pass-through" component, meaning that if you pass properties to
  // it that it doesn't know about (`aria-label` for instance) it passes
  // directly back to the underlying `<div/>`. That's generally useful, but
  // we'd also like to strip out a few naughty properties that break style
  // encapsulation (className, style) or accessibility (onClick).
  var blacklist = ['onClick', 'className', 'style'];

  // All Box's are box-sized by default, so we start off building up the styles
  // to be applied with a Box base class.
  var s = fromClassName(styles.box);

  // This loops through each property and if it exists in the previously
  // defined transform map, concatentes the resulting styles to the base
  // styles. If there's a match, we also don't pass through that property. This
  // means Box's runtime is only dependent on the number of properties passed
  // to it (which is typically small) instead of the total number of possible
  // properties (~30 or so). While it may ~feel~ like Box is innefficient, its
  // biggest performance impact is on startup time because there's so much code
  // here.

  // eslint-disable-next-line no-restricted-syntax
  for (var prop in props) {
    if (Object.prototype.hasOwnProperty.call(propToFn, prop)) {
      var fn = propToFn[prop];
      var value = props[prop];
      blacklist = blacklist.concat(prop);
      s = concat([s, fn(value)]);
    }
  }

  // And... magic!
  return createElement(
    'div',
    _extends({}, omit(blacklist, props), toProps(s), { ref: ref }),
    children
  );
});

//  NOTE: This is needed in order to override the ForwardRef display name that is
//  used in dev tools and in snapshot testing.
Box.displayName = 'Box';

/*

# PropTypes

And we're done here :)

*/

var ColumnPropType = PropTypes.oneOf([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]);

var MarginPropType = PropTypes.oneOf([-12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]);

var PaddingPropType = PropTypes.oneOf([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]);

Box.propTypes = {
  children: PropTypes.node,
  dangerouslySetInlineStyle: PropTypes.exact({
    __style: PropTypes.object
  }),

  xs: PropTypes.exact({
    display: PropTypes.oneOfType([PropTypes.bool, PropTypes.oneOf(['flex', 'flexColumn', 'inlineBlock'])]),
    column: PropTypes.number
  }),
  sm: PropTypes.exact({
    display: PropTypes.oneOfType([PropTypes.bool, PropTypes.oneOf(['flex', 'flexColumn', 'inlineBlock'])]),
    column: PropTypes.number
  }),
  md: PropTypes.exact({
    display: PropTypes.oneOfType([PropTypes.bool, PropTypes.oneOf(['flex', 'flexColumn', 'inlineBlock'])]),
    column: PropTypes.number
  }),
  lg: PropTypes.exact({
    display: PropTypes.oneOfType([PropTypes.bool, PropTypes.oneOf(['flex', 'flexColumn', 'inlineBlock'])]),
    column: PropTypes.number
  }),
  deprecatedMargin: PropTypes.oneOfType([PropTypes.number, PropTypes.shape({
    top: PropTypes.number,
    bottom: PropTypes.number,
    left: PropTypes.oneOfType([PropTypes.number, PropTypes.oneOf(['auto'])]),
    right: PropTypes.oneOfType([PropTypes.number, PropTypes.oneOf(['auto'])])
  })]),
  deprecatedPadding: PropTypes.oneOfType([PropTypes.number, PropTypes.shape({
    x: PropTypes.number,
    y: PropTypes.number
  })]),

  display: PropTypes.oneOf(['none', 'flex', 'block', 'inlineBlock', 'visuallyHidden']),
  direction: PropTypes.oneOf(['row', 'column']),
  column: ColumnPropType,

  smDisplay: PropTypes.oneOf(['none', 'flex', 'block', 'inlineBlock', 'visuallyHidden']),
  smDirection: PropTypes.oneOf(['row', 'column']),
  smColumn: ColumnPropType,

  mdDisplay: PropTypes.oneOf(['none', 'flex', 'block', 'inlineBlock', 'visuallyHidden']),
  mdDirection: PropTypes.oneOf(['row', 'column']),
  mdColumn: ColumnPropType,

  lgDisplay: PropTypes.oneOf(['none', 'flex', 'block', 'inlineBlock', 'visuallyHidden']),
  lgDirection: PropTypes.oneOf(['row', 'column']),
  lgColumn: ColumnPropType,

  alignContent: PropTypes.oneOf(['start', 'end', 'center', 'between', 'around', 'stretch']),
  alignItems: PropTypes.oneOf(['start', 'end', 'center', 'baseline', 'stretch']),
  alignSelf: PropTypes.oneOf(['auto', 'start', 'end', 'center', 'baseline', 'stretch']),
  bottom: PropTypes.bool,
  color: PropTypes.oneOf(['blue', 'darkGray', 'darkWash', 'eggplant', 'gray', 'green', 'lightGray', 'lightWash', 'maroon', 'midnight', 'navy', 'olive', 'orange', 'orchid', 'pine', 'purple', 'red', 'transparent', 'watermelon', 'white']),
  fit: PropTypes.bool,
  flex: PropTypes.oneOf(['grow', 'shrink', 'none']),
  grow: PropTypes.bool,
  height: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  justifyContent: PropTypes.oneOf(['start', 'end', 'center', 'between', 'around']),
  left: PropTypes.bool,

  marginStart: MarginPropType,
  marginEnd: MarginPropType,

  margin: MarginPropType,
  marginTop: MarginPropType,
  marginRight: MarginPropType,
  marginBottom: MarginPropType,
  marginLeft: MarginPropType,

  smMargin: MarginPropType,
  smMarginTop: MarginPropType,
  smMarginRight: MarginPropType,
  smMarginBottom: MarginPropType,
  smMarginLeft: MarginPropType,

  mdMargin: MarginPropType,
  mdMarginTop: MarginPropType,
  mdMarginRight: MarginPropType,
  mdMarginBottom: MarginPropType,
  mdMarginLeft: MarginPropType,

  lgMargin: MarginPropType,
  lgMarginTop: MarginPropType,
  lgMarginRight: MarginPropType,
  lgMarginBottom: MarginPropType,
  lgMarginLeft: MarginPropType,

  maxHeight: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  maxWidth: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  minHeight: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  minWidth: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

  overflow: PropTypes.oneOf(['visible', 'hidden', 'scroll', 'scrollX', 'scrollY', 'auto']),

  padding: PaddingPropType,
  paddingX: PaddingPropType,
  paddingY: PaddingPropType,

  smPadding: PaddingPropType,
  smPaddingX: PaddingPropType,
  smPaddingY: PaddingPropType,

  mdPadding: PaddingPropType,
  mdPaddingX: PaddingPropType,
  mdPaddingY: PaddingPropType,

  lgPadding: PaddingPropType,
  lgPaddingX: PaddingPropType,
  lgPaddingY: PaddingPropType,

  position: PropTypes.oneOf(['static', 'absolute', 'relative', 'fixed']),
  right: PropTypes.bool,
  shape: PropTypes.oneOf(['square', 'rounded', 'pill', 'circle', 'roundedTop', 'roundedBottom', 'roundedLeft', 'roundedRight']),
  top: PropTypes.bool,
  width: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  wrap: PropTypes.bool
};

var styles$1 = { "icon": "_u0", "iconBlock": "_u1 _45" };

var add = 'M22 10h-8V2a2 2 0 0 0-4 0v8H2a2 2 0 0 0 0 4h8v8a2 2 0 0 0 4 0v-8h8a2 2 0 0 0 0-4';

var addCircle = 'M17.75 13.25h-4.5v4.5a1.25 1.25 0 0 1-2.5 0v-4.5h-4.5a1.25 1.25 0 0 1 0-2.5h4.5v-4.5a1.25 1.25 0 0 1 2.5 0v4.5h4.5a1.25 1.25 0 0 1 0 2.5M12 0C5.37 0 0 5.37 0 12s5.37 12 12 12 12-5.37 12-12S18.63 0 12 0';

var addPin = 'M21.5 8.69c1.49.87 2.5 2.46 2.5 4.31h-4v7.96L19 23l-1-2.04V13h-4c0-1.85 1.01-3.44 2.5-4.31V2.93c-.86-.22-1.5-1-1.5-1.93h8c0 .93-.64 1.71-1.5 1.93v5.76zm-11.25.81a1.25 1.25 0 0 1 0 2.5H7v3.25a1.25 1.25 0 0 1-2.5 0V12H1.25a1.25 1.25 0 0 1 0-2.5H4.5V6.25a1.25 1.25 0 0 1 2.5 0V9.5h3.25z';

var alignBottomCenter = 'M20.5 19.75c0 .413-.337.75-.75.75H15.5V14h-7v6.5H4.25a.752.752 0 0 1-.75-.75V4.25a.75.75 0 0 1 .75-.75h15.5a.75.75 0 0 1 .75.75v15.5zM19.75 1H4.25A3.254 3.254 0 0 0 1 4.25v15.5A3.254 3.254 0 0 0 4.25 23h15.5A3.254 3.254 0 0 0 23 19.75V4.25A3.254 3.254 0 0 0 19.75 1z';

var alignBottomLeft = 'M20.5 19.75c0 .413-.337.75-.75.75H10V14H3.5V4.25a.75.75 0 0 1 .75-.75h15.5a.75.75 0 0 1 .75.75v15.5zM19.75 1H4.25A3.254 3.254 0 0 0 1 4.25v15.5A3.254 3.254 0 0 0 4.25 23h15.5A3.254 3.254 0 0 0 23 19.75V4.25A3.254 3.254 0 0 0 19.75 1z';

var alignBottomRight = 'M3.5 19.75V4.25a.75.75 0 0 1 .75-.75h15.5a.75.75 0 0 1 .75.75V14H14v6.5H4.25a.752.752 0 0 1-.75-.75M19.75 1H4.25A3.254 3.254 0 0 0 1 4.25v15.5A3.254 3.254 0 0 0 4.25 23h15.5A3.254 3.254 0 0 0 23 19.75V4.25A3.254 3.254 0 0 0 19.75 1';

var alignBottom = 'M4.25 3.5h15.5a.75.75 0 0 1 .75.75V14h-17V4.25a.75.75 0 0 1 .75-.75M19.75 1H4.25A3.254 3.254 0 0 0 1 4.25v15.5A3.254 3.254 0 0 0 4.25 23h15.5A3.254 3.254 0 0 0 23 19.75V4.25A3.254 3.254 0 0 0 19.75 1';

var alignMiddle = 'M19.75 20.5H4.25a.75.75 0 0 1-.75-.75V15.5h17v4.25a.75.75 0 0 1-.75.75m-15.5-17h15.5a.75.75 0 0 1 .75.75V8.5h-17V4.25a.75.75 0 0 1 .75-.75M19.75 1H4.25A3.254 3.254 0 0 0 1 4.25v15.5A3.254 3.254 0 0 0 4.25 23h15.5A3.254 3.254 0 0 0 23 19.75V4.25A3.254 3.254 0 0 0 19.75 1';

var alignTopCenter = 'M20.5 19.75a.75.75 0 0 1-.75.75H4.25a.75.75 0 0 1-.75-.75V4.25a.75.75 0 0 1 .75-.75H8.5V10h7V3.5h4.25a.75.75 0 0 1 .75.75v15.5zM19.75 1H4.25A3.254 3.254 0 0 0 1 4.25v15.5A3.254 3.254 0 0 0 4.25 23h15.5A3.254 3.254 0 0 0 23 19.75V4.25A3.254 3.254 0 0 0 19.75 1z';

var alignTopLeft = 'M20.5 19.75a.75.75 0 0 1-.75.75H4.25a.75.75 0 0 1-.75-.75V10H10V3.5h9.75a.75.75 0 0 1 .75.75v15.5zM19.75 1H4.25A3.254 3.254 0 0 0 1 4.25v15.5A3.254 3.254 0 0 0 4.25 23h15.5A3.254 3.254 0 0 0 23 19.75V4.25A3.254 3.254 0 0 0 19.75 1z';

var alignTopRight = 'M19.75 20.5H4.25a.75.75 0 0 1-.75-.75V4.25a.75.75 0 0 1 .75-.75H14V10h6.5v9.75a.75.75 0 0 1-.75.75m0-19.5H4.25A3.254 3.254 0 0 0 1 4.25v15.5A3.254 3.254 0 0 0 4.25 23h15.5A3.254 3.254 0 0 0 23 19.75V4.25A3.254 3.254 0 0 0 19.75 1';

var alignTop = 'M19.75 20.5H4.25a.752.752 0 0 1-.75-.75V10h17v9.75c0 .413-.337.75-.75.75m0-19.5H4.25A3.254 3.254 0 0 0 1 4.25v15.5A3.254 3.254 0 0 0 4.25 23h15.5A3.254 3.254 0 0 0 23 19.75V4.25A3.254 3.254 0 0 0 19.75 1';

var angledPin = 'M13.988,19.153 C15.485,17.656 15.985,15.446 15.481,13.537 L19.740,9.074 L22.662,8.807 L22.645,8.789 C22.739,8.804 22.837,8.780 22.909,8.708 C23.030,8.587 23.031,8.391 22.910,8.271 L15.730,1.090 C15.609,0.970 15.413,0.970 15.292,1.091 C15.220,1.163 15.197,1.262 15.211,1.356 L15.194,1.338 L14.927,4.261 L10.463,8.520 C8.554,8.015 6.344,8.516 4.847,10.012 L8.656,13.821 L3.324,19.153 C2.562,19.915 0.711,22.108 1.039,22.962 C1.892,23.290 4.086,21.438 4.847,20.676 C5.609,19.915 10.179,15.344 10.179,15.344 L13.988,19.153 Z';

var apps = 'M20 17a3 3 0 1 0 0 6 3 3 0 0 0 0-6m0-8a3 3 0 1 0 0 6 3 3 0 0 0 0-6m0-8a3 3 0 1 0 0 6 3 3 0 0 0 0-6m-8 16a3 3 0 1 0 0 6 3 3 0 0 0 0-6m0-8a3 3 0 1 0 0 6 3 3 0 0 0 0-6m0-8a3 3 0 1 0 0 6 3 3 0 0 0 0-6M4 17a3 3 0 1 0 0 6 3 3 0 0 0 0-6m0-8a3 3 0 1 0 0 6 3 3 0 0 0 0-6m3-5a3 3 0 1 1-6 0 3 3 0 0 1 6 0';

var arrowBack = 'M17.28 24c-.57 0-1.14-.22-1.58-.66L4.5 12 15.7.66a2.21 2.21 0 0 1 3.15 0c.87.88.87 2.3 0 3.18L10.79 12l8.06 8.16c.87.88.87 2.3 0 3.18-.44.44-1 .66-1.57.66';

var arrowCircleForward = 'M12.94 16.07c-.49.48-1.28.48-1.77 0a1.25 1.25 0 0 1 0-1.77l1.06-1.07H8.25a1.25 1.25 0 0 1 0-2.5h3.95L11.17 9.7a1.25 1.25 0 0 1 0-1.77c.49-.48 1.28-.48 1.77 0L17 12l-4.06 4.07zM12 0C5.37 0 0 5.37 0 12s5.37 12 12 12 12-5.37 12-12S18.63 0 12 0z';

var arrowCircleDown = 'M0 12c0 6.63 5.37 12 12 12s12-5.37 12-12S18.63 0 12 0 0 5.37 0 12zm10.77-3.75a1.25 1.25 0 0 1 2.5 0v3.95l1.03-1.03a1.25 1.25 0 0 1 1.77 0c.48.49.48 1.28 0 1.77L12 17l-4.07-4.06c-.48-.49-.48-1.28 0-1.77a1.25 1.25 0 0 1 1.77 0l1.07 1.06V8.25z';

var arrowDown = 'M12 19.5L.66 8.29c-.88-.86-.88-2.27 0-3.14.88-.87 2.3-.87 3.18 0L12 13.21l8.16-8.06c.88-.87 2.3-.87 3.18 0 .88.87.88 2.28 0 3.14L12 19.5z';

var arrowForward = 'M6.72 24c.57 0 1.14-.22 1.57-.66L19.5 12 8.29.66c-.86-.88-2.27-.88-3.14 0-.87.88-.87 2.3 0 3.18L13.21 12l-8.06 8.16c-.87.88-.87 2.3 0 3.18.43.44 1 .66 1.57.66';

var arrowUp = 'M21.75 19.5c-.58 0-1.15-.22-1.59-.65L12 10.79l-8.16 8.06c-.88.87-2.3.87-3.18 0a2.21 2.21 0 0 1 0-3.15L12 4.5l11.34 11.2c.88.87.88 2.28 0 3.15-.44.43-1.01.65-1.59.65';

var arrowUpRight = 'M4.9283,1 C3.6273,1 2.5713,2.054 2.5713,3.357 C2.5713,4.66 3.6273,5.714 4.9283,5.714 L14.9523,5.714 L1.6893,18.976 C0.7703,19.896 0.7703,21.389 1.6893,22.31 C2.1503,22.771 2.7533,23 3.3573,23 C3.9603,23 4.5633,22.771 5.0243,22.31 L18.2853,9.047 L18.2853,19.071 C18.2853,20.374 19.3413,21.429 20.6433,21.429 C21.9443,21.429 23.0003,20.374 23.0003,19.071 L23.0003,1 L4.9283,1 Z';

var bell = 'M12 24c-1.66 0-3-1.34-3-3h6c0 1.66-1.34 3-3 3zm7-10.83c1.58 1.52 2.67 3.55 3 5.83H2c.33-2.28 1.42-4.31 3-5.83V7c0-3.87 3.13-7 7-7s7 3.13 7 7v6.17z';

var camera = 'M6.36 4.99L8.56 2h6.88l2.2 2.99h3.09c1.8 0 3.27 1.49 3.27 3.33v10.35c0 1.84-1.47 3.33-3.27 3.33H3.27C1.47 22 0 20.51 0 18.67V8.32c0-1.84 1.47-3.33 3.27-3.33h3.09zM12 7.22a5.74 5.74 0 1 0 0 11.48 5.74 5.74 0 0 0 0-11.48m0 2.73c1.66 0 3.01 1.35 3.01 3.01 0 1.66-1.35 3.01-3.01 3.01-1.66 0-3.01-1.35-3.01-3.01 0-1.66 1.35-3.01 3.01-3.01';

var cameraRoll = 'M8 10c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2M6.25 3.5h11.5c1.52 0 2.75 1.23 2.75 2.75v8.25L17 11l-6 6-3.5-3.5-4 4V6.25c0-1.52 1.23-2.75 2.75-2.75M17.75 1H6.25A5.25 5.25 0 0 0 1 6.25v11.5C1 20.64 3.35 23 6.25 23h11.5c2.89 0 5.25-2.36 5.25-5.25V6.25C23 3.35 20.64 1 17.75 1';

var cancel = 'M15.18 12l7.16-7.16c.88-.88.88-2.3 0-3.18-.88-.88-2.3-.88-3.18 0L12 8.82 4.84 1.66c-.88-.88-2.3-.88-3.18 0-.88.88-.88 2.3 0 3.18L8.82 12l-7.16 7.16c-.88.88-.88 2.3 0 3.18.44.44 1.01.66 1.59.66.58 0 1.15-.22 1.59-.66L12 15.18l7.16 7.16c.44.44 1.01.66 1.59.66.58 0 1.15-.22 1.59-.66.88-.88.88-2.3 0-3.18L15.18 12z';

var canonicalPin = 'M19 20c0 .551-.448 1-1 1h-7.471c-.551 0-1-.449-1-1v-2H14a2 2 0 0 0 2-2V8h2c.552 0 1 .449 1 1v11zM5.705 9.996a1.126 1.126 0 0 1 1.59-1.591L8.7 9.809l3.004-3.004a1.125 1.125 0 1 1 1.592 1.591L8.7 12.991 5.705 9.996zM18 6h-2V3a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2h2.529v2c0 1.654 1.346 3 3 3H18c1.654 0 3-1.346 3-3V9c0-1.654-1.346-3-3-3z';

var check = 'M9.17 21.75L.73 12.79c-.97-1.04-.97-2.71 0-3.75a2.403 2.403 0 0 1 3.53 0l4.91 5.22L19.74 3.03c.98-1.04 2.55-1.04 3.53 0 .97 1.03.97 2.71 0 3.74L9.17 21.75z';

var checkCircle = 'M18.88 9.88l-8.66 8.67-5.12-5.13a1.25 1.25 0 0 1 0-1.77c.48-.49 1.28-.49 1.76 0l3.36 3.36 6.9-6.89c.49-.49 1.28-.49 1.76 0 .49.49.49 1.28 0 1.76M12 0C5.37 0 0 5.37 0 12s5.37 12 12 12 12-5.37 12-12S18.63 0 12 0';

var circleOutline = 'M12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.6 0 12 0zm0 22.2C6.45 22.2 1.8 17.7 1.8 12 1.8 6.3 6.3 1.8 12 1.8c5.7 0 10.2 4.5 10.2 10.2 0 5.7-4.65 10.2-10.2 10.2z';

var clear = 'M15.18 16.95L12 13.77l-3.18 3.18c-.49.49-1.28.49-1.77 0a1.25 1.25 0 0 1 0-1.77L10.23 12 7.05 8.82a1.25 1.25 0 0 1 0-1.77 1.25 1.25 0 0 1 1.77 0L12 10.23l3.18-3.18a1.25 1.25 0 0 1 1.77 0c.49.49.49 1.28 0 1.77L13.77 12l3.18 3.18c.49.49.49 1.28 0 1.77s-1.28.49-1.77 0M24 12c0-6.63-5.37-12-12-12S0 5.37 0 12s5.37 12 12 12 12-5.37 12-12';

var clock = 'M17.83 17.83c-.37.36-.85.55-1.33.55-.48 0-.96-.19-1.33-.55l-5.04-5.05V6c0-1.04.83-1.87 1.87-1.87s1.88.83 1.88 1.87v5.22l3.95 3.95c.73.74.73 1.92 0 2.66M12 0C5.37 0 0 5.37 0 12s5.37 12 12 12 12-5.37 12-12S18.63 0 12 0';

var cog = 'M6.25 2L.5 12l5.75 10h11.5l5.75-10-5.75-10H6.25zm1.703 10a4 4 0 1 1 8 0 4 4 0 0 1-8 0z';

var colorPicker = 'M1.73 18.751l8.23-8.231 3.52 3.52-8.232 8.23a2.487 2.487 0 0 1-3.519 0 2.487 2.487 0 0 1 0-3.519zM22.026 1.972a3.318 3.318 0 0 1 0 4.693l-3.907 3.908.116.118a1.493 1.493 0 1 1-2.111 2.111l-4.928-4.927a1.494 1.494 0 0 1 2.112-2.112l.117.117 3.908-3.908a3.318 3.318 0 0 1 4.693 0z';

var compass = 'M12.868 12.9A1.25 1.25 0 1 0 11.1 11.13a1.25 1.25 0 0 0 1.77 1.768m2.268 1.134c-.207.517-.62.924-1.139 1.124L5.62 18.38l3.223-8.377c.2-.52.607-.933 1.124-1.139l8.617-3.447-3.447 8.617zm5.348-10.519c-4.686-4.686-12.284-4.686-16.97 0-4.687 4.687-4.687 12.285 0 16.971 4.686 4.686 12.284 4.686 16.97 0 4.686-4.686 4.686-12.284 0-16.97z';

var compose = 'M2.337 19.942l5.671-1.977L19.265 6.706c.981-.98.981-2.57 0-3.55l-1.42-1.421a2.51 2.51 0 0 0-3.55 0L3.036 12.992l-1.978 5.671a1.005 1.005 0 0 0 1.279 1.279M23 22c0 .55-.45 1-1 1H2c-.55 0-1-.45-1-1s.45-1 1-1h20c.55 0 1 .45 1 1';

var crop = 'M22.5 4a1.5 1.5 0 1 1 0 3H20v11.5a1.5 1.5 0 0 1-1.5 1.5H7v2.5a1.5 1.5 0 1 1-3 0V20H1.5a1.5 1.5 0 1 1 0-3H4V5.5A1.5 1.5 0 0 1 5.5 4H17V1.5a1.5 1.5 0 1 1 3 0V4h2.5zM7 17h10V7H7v10zm5-3a2 2 0 1 1 .001-4.001A2 2 0 0 1 12 14z';

var dash = 'M20 16H4c-2.2 0-4-1.8-4-4s1.8-4 4-4h16c2.2 0 4 1.8 4 4s-1.8 4-4 4';

var download = 'M21 14a2 2 0 0 1 2 2v6a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2v-6a2 2 0 0 1 4 0v4h14v-4a2 2 0 0 1 2-2zM8.815 6.987l1.176 1.178V2a2 2 0 0 1 4 0v6.178l1.196-1.193a2 2 0 1 1 2.826 2.831l-6.025 6.013-6.004-6.016a2 2 0 0 1 2.831-2.826z';

var edit = 'M13.386 6.018l4.596 4.596L7.097 21.499 1 22.999l1.501-6.096L13.386 6.018zm8.662-4.066a3.248 3.248 0 0 1 0 4.596L19.75 8.848 15.154 4.25l2.298-2.299a3.248 3.248 0 0 1 4.596 0z';

var ellipsis = 'M12 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3M3 9c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm18 0c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3z';

var ellipsisCircleOutline = 'M12 10.5c.9 0 1.5.6 1.5 1.5s-.6 1.5-1.5 1.5-1.5-.6-1.5-1.5.6-1.5 1.5-1.5zm-4.5 0c.9 0 1.5.6 1.5 1.5s-.6 1.5-1.5 1.5S6 12.9 6 12s.6-1.5 1.5-1.5zm9 0c.9 0 1.5.6 1.5 1.5s-.6 1.5-1.5 1.5S15 12.9 15 12s.6-1.5 1.5-1.5zM12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.6 0 12 0zm0 22.2C6.45 22.2 1.8 17.7 1.8 12 1.8 6.3 6.3 1.8 12 1.8c5.7 0 10.2 4.5 10.2 10.2 0 5.7-4.65 10.2-10.2 10.2z';

var envelope = 'M21.53 7.508l-7.586 7.452c-.536.526-1.24.79-1.944.79a2.77 2.77 0 0 1-1.945-.79L2.47 7.508a.728.728 0 0 1 0-1.043.76.76 0 0 1 1.061 0l7.586 7.452c.487.48 1.28.48 1.768 0l7.585-7.452a.76.76 0 0 1 1.061 0 .728.728 0 0 1 0 1.043zM1 19h22V5H1v14z';

var eye = 'M10,12 C10,13.105 10.895,14 12,14 C13.105,14 14,13.105 14,12 C14,10.895 13.105,10 12,10 C10.895,10 10,10.895 10,12 Z M12,17 C9.239,17 7,14.761 7,12 C7,9.239 9.239,7 12,7 C14.761,7 17,9.239 17,12 C17,14.761 14.761,17 12,17 M12,3.5 C6.455,3.5 1.751,7.051 0,12 C1.751,16.949 6.455,20.5 12,20.5 C17.545,20.5 22.249,16.949 24,12 C22.249,7.051 17.545,3.5 12,3.5';

var facebook = 'M17.75 3.984l-2.312.001c-1.811 0-2.163.842-2.163 2.077v2.724h4.323l-.563 4.267h-3.76V24H8.769V13.053H5V8.786h3.769V5.64C8.769 1.988 11.05 0 14.383 0c1.596 0 2.967.116 3.367.168v3.816z';

var faceHappy = 'M12.023 20.713c-2.944 0-5.378-1.96-5.356-4.906.017-2.117 1.728-.536 5.33-.545 3.6-.01 5.322-1.645 5.327.548.007 2.946-2.356 4.903-5.3 4.903m4.439-9.83a1.675 1.675 0 1 1 0-3.351 1.675 1.675 0 0 1 0 3.35M6.093 9.207a1.675 1.675 0 1 1 3.35 0 1.675 1.675 0 0 1-3.35 0m17.906 2.782C23.994 5.367 18.623 0 12 0 5.373 0 0 5.373 0 12c0 6.628 5.373 12 12 12C18.624 24 23.995 18.633 24 12.01L24 12l-.001-.01';

var faceSad = 'M17.088 17.841a1.2 1.2 0 0 1-1.593.58 4.517 4.517 0 0 0-.744-.217c-.738-.168-1.653-.27-2.75-.271-1.098 0-2.012.103-2.752.27-.411.094-.657.18-.741.217a1.199 1.199 0 1 1-1.014-2.174c.237-.11.643-.251 1.223-.383.915-.207 2.008-.33 3.284-.33 1.276.001 2.369.123 3.281.33.582.132.988.273 1.226.384.601.279.86.992.58 1.594zm-.624-6.959a1.675 1.675 0 1 1 0-3.35 1.675 1.675 0 0 1 0 3.35zM6.093 9.207a1.675 1.675 0 1 1 3.35 0 1.675 1.675 0 0 1-3.35 0zM24 11.989C23.995 5.367 18.624 0 12.002 0 5.373 0 0 5.373 0 12c0 6.628 5.373 12 12.002 12C18.623 24 23.995 18.633 24 12.01v-.02z';

var faceSmiley = 'M16.5 11a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3m.449 5.95A6.947 6.947 0 0 1 12 19a6.96 6.96 0 0 1-4.948-2.048.999.999 0 0 1 0-1.414.999.999 0 0 1 1.414-.001A4.968 4.968 0 0 0 12 17c1.336 0 2.592-.52 3.535-1.464a1 1 0 0 1 1.414 1.414M6 9.5a1.5 1.5 0 1 1 3 0 1.5 1.5 0 0 1-3 0M12 0C5.373 0 0 5.373 0 12s5.373 12 12 12 12-5.373 12-12S18.627 0 12 0';

var filter = 'M24 3.5c0-1.1-.9-2-2-2H2c-1.1 0-2 .9-2 2 0 .55.22 1.05.58 1.41L9 13.46v9.04l6-2v-7.05l8.37-8.5c.39-.36.63-.88.63-1.45';

var fillOpaque = 'M6 18h12V6H6v12zm14.5 1.75a.75.75 0 0 1-.75.75H4.25a.75.75 0 0 1-.75-.75V4.25a.75.75 0 0 1 .75-.75h15.5a.75.75 0 0 1 .75.75v15.5zM19.75 1H4.25A3.254 3.254 0 0 0 1 4.25v15.5A3.254 3.254 0 0 0 4.25 23h15.5A3.254 3.254 0 0 0 23 19.75V4.25A3.254 3.254 0 0 0 19.75 1z';

var fillTransparent = 'M10 14v-4h4v4h-4zm-4-4V6h4v4H6zm8 0V6h4v4h-4zm0 8v-4h4v4h-4zm-8 0v-4h4v4H6zm14.5 1.75a.75.75 0 0 1-.75.75H4.25a.75.75 0 0 1-.75-.75V4.25a.75.75 0 0 1 .75-.75h15.5a.75.75 0 0 1 .75.75v15.5zM19.75 1H4.25A3.254 3.254 0 0 0 1 4.25v15.5A3.254 3.254 0 0 0 4.25 23h15.5A3.254 3.254 0 0 0 23 19.75V4.25A3.254 3.254 0 0 0 19.75 1z';

var flag = 'M17 7.5L22 0H2v22c0 1.1.9 2 2 2s2-.9 2-2v-7h16l-5-7.5z';

var flashlight = 'M6 7.08V10H1V7.08A6.086 6.086 0 0 1 7.079 1H10v5H6v1.08zM6 18h4v5H7.079A6.086 6.086 0 0 1 1 16.921V14h5v4zM16.92 1A6.086 6.086 0 0 1 23 7.079V10h-5V6h-4V1h2.92zM18 16.92V14h5v2.92A6.086 6.086 0 0 1 16.921 23H14v-5h4v-1.08z';

var flipHorizontal = 'M12 4.118v16.384H3.815L12 4.118zm10.778 15.975L13.792 2.107A1.98 1.98 0 0 0 12 1c-.712 0-1.423.37-1.792 1.107L1.22 20.093C.541 21.422 1.51 23 3.006 23h17.99c1.495 0 2.462-1.578 1.782-2.907z';

var flipVertical = 'M19.882 12H3.498V3.814L19.882 12zm2.012-1.792L3.907 1.22A1.98 1.98 0 0 0 2.999 1C1.951 1 1 1.843 1 3.005v17.99C1 22.157 1.951 23 3 23c.3 0 .61-.07.907-.221l17.987-8.987c1.475-.737 1.475-2.847 0-3.584z';

var gif = 'M19.5 3h-15C2.02 3 0 5.03 0 7.5v9C0 18.98 2.02 21 4.5 21h15c2.47 0 4.5-2.02 4.5-4.5v-9C24 5.03 21.97 3 19.5 3zm-7.41 12.88v-7.8h1.59v7.8h-1.59zm3.45-7.8h5.58v1.34h-4v1.88h3.39v1.35h-3.39v3.23h-1.58v-7.8zm-11.4 6.83c-.33-.37-.58-.79-.76-1.28-.17-.49-.26-1.03-.26-1.62 0-.66.11-1.26.33-1.8.22-.55.53-1.01.95-1.39.32-.29.68-.51 1.1-.66.41-.15.88-.23 1.4-.23.49 0 .93.06 1.32.19s.72.31 1 .54c.27.23.5.51.67.83.17.32.29.67.35 1.04H8.69a1.67 1.67 0 0 0-.56-.93c-.29-.24-.69-.36-1.19-.36-.37 0-.7.07-.97.21-.27.14-.5.34-.69.59-.18.25-.32.54-.41.88-.09.34-.13.7-.13 1.09 0 .4.05.77.15 1.1.1.34.25.63.43.88.19.24.42.43.69.57.27.14.57.21.9.21.31 0 .59-.05.83-.16.25-.1.46-.23.64-.4.17-.17.31-.36.4-.57.1-.21.14-.42.14-.64v-.04H7.05v-1.22h3.28v4.14H9.14l-.05-1.05h-.03c-.27.45-.58.77-.94.94a2.8 2.8 0 0 1-1.25.27c-.59 0-1.11-.1-1.56-.3-.46-.2-.85-.48-1.17-.83z';

var globe = 'M15.49 20.83c.87-2.01 1.37-4.75 1.48-7.58h4.44a9.53 9.53 0 0 1-5.92 7.58zm-12.9-7.58h4.44c.11 2.83.61 5.57 1.49 7.58-3.15-1.25-5.47-4.12-5.93-7.58zM8.52 3.17c-.88 2.01-1.38 4.75-1.49 7.58H2.59c.46-3.46 2.78-6.33 5.93-7.58zm1.01 7.58C9.76 5.43 11.4 2.54 12 2.5h.01c.67.06 2.24 3.01 2.46 8.25H9.53zm2.48 10.75H12c-.6-.04-2.24-2.93-2.47-8.25h4.94c-.22 5.24-1.79 8.19-2.46 8.25zm9.4-10.75h-4.44c-.11-2.83-.61-5.57-1.48-7.58a9.53 9.53 0 0 1 5.92 7.58zM24 12C24 5.39 18.62.01 12.01 0H12C5.38 0 0 5.38 0 12s5.38 12 12 12h.01C18.62 24 24 18.61 24 12z';

var globeChecked = 'M6.8 9.8H3.1C3.5 7 5.4 4.6 8 3.6c-.7 1.7-1.1 3.9-1.2 6.2m-3.7 2.1h3.7c.1 2.3.5 4.6 1.2 6.2-2.6-1-4.5-3.3-4.9-6.2m7.8-8.8c.5 0 1.8 2.4 2 6.7H8.8c.2-4.3 1.6-6.7 2.1-6.7M9.5 16.3c-.3-1.1-.6-2.6-.7-4.4h2.7c.9-1 2.1-1.7 3.5-2.1-.1-2.3-.5-4.5-1.3-6.2 2.6 1 4.4 3.3 4.9 6.1.7.1 1.5.4 2.1.8-.2-5.3-4.5-9.5-9.8-9.5C5.4 1 1 5.4 1 10.9c0 5.3 4.2 9.6 9.5 9.8-.6-1.1-1-2.3-1-3.7v-.7m10.8-.5L16.2 20l-2.5-2.5c-.3-.3-.3-.8 0-1.1.3-.3.8-.3 1 0l1.5 1.5 3.1-3.2c.2-.3.7-.3 1 0 .3.3.3.8 0 1.1M17 11c-3.3 0-6 2.7-6 6s2.7 6 6 6 6-2.7 6-6-2.7-6-6-6';

var gmail = 'M3.173 4L12 10.194 20.556 4H3.173zM12 13.29L1 5.806V20h22V5.548L12 13.29z';

var googlePlus = 'M7 11v2.4h3.97c-.16 1.029-1.2 3.02-3.97 3.02-2.39 0-4.34-1.979-4.34-4.42 0-2.44 1.95-4.42 4.34-4.42 1.36 0 2.27.58 2.79 1.08l1.9-1.83C10.47 5.69 8.89 5 7 5c-3.87 0-7 3.13-7 7s3.13 7 7 7c4.04 0 6.721-2.84 6.721-6.84 0-.46-.051-.81-.111-1.16H7zm17 0v2h-3v3h-2v-3h-3v-2h3V8h2v3h3z';

var graphBar = 'M1 23V10h5v13H1zm8.5 0V1h5v22h-5zm8.5 0V7h4.999v16H18z';

var knoop = 'M15 10.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5m0 6c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5m-6-6c-.83 0-1.5-.67-1.5-1.5S8.17 7.5 9 7.5s1.5.67 1.5 1.5-.67 1.5-1.5 1.5m0 6c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5M12 0C5.37 0 0 5.37 0 12s5.37 12 12 12 12-5.37 12-12S18.63 0 12 0';

var lightbulb = 'M20 8c0 2.23-.91 4.24-2.39 5.7h.02c-.99.97-1.6 2.31-1.63 3.8V19H8v-1.5c-.03-1.5-.65-2.85-1.64-3.83A7.955 7.955 0 0 1 4 8c0-4.42 3.58-8 8-8s8 3.58 8 8zM8 22.5V21h8v1.5c0 .83-.67 1.5-1.5 1.5h-5c-.83 0-1.5-.67-1.5-1.5z';

var logout = 'M12 14a2 2 0 0 0 2-2V3a2 2 0 0 0-4 0v9a2 2 0 0 0 2 2m11-2c0 2.938-1.144 5.701-3.222 7.778A10.925 10.925 0 0 1 12 23a10.925 10.925 0 0 1-7.778-3.222A10.925 10.925 0 0 1 1 12c0-2.938 1.144-5.701 3.222-7.778A2 2 0 0 1 7.05 7.051 6.952 6.952 0 0 0 5 12c0 1.87.728 3.627 2.05 4.949A6.953 6.953 0 0 0 12 19c1.87 0 3.627-.728 4.949-2.05A6.953 6.953 0 0 0 19 12c0-1.87-.728-3.627-2.05-4.949a2 2 0 1 1 2.828-2.829A10.925 10.925 0 0 1 23 12';

var logoLarge = 'M18.656 11.196l-3.333 2.573 1.25 4.089c.25.817-.687 1.477-1.359.958L12 16.334l-3.214 2.482c-.673.519-1.609-.141-1.359-.958l1.25-4.09-3.334-2.572c-.66-.511-.304-1.578.53-1.578h4.073L11.17 5.62c.252-.826 1.41-.826 1.662 0l1.222 3.998h4.075c.833 0 1.19 1.067.528 1.578zM21.75 3.5H2.25a1.25 1.25 0 0 1 0-2.5h19.5a1.25 1.25 0 0 1 0 2.5zm0 19.5H2.25a1.25 1.25 0 0 1 0-2.5h19.5a1.25 1.25 0 0 1 0 2.5z';

var logoSmall = 'M15.804 14.54L13.9 16.01l.714 2.337c.143.467-.392.845-.777.547L12 17.477l-1.837 1.418c-.384.297-.92-.08-.776-.547l.714-2.337-1.904-1.47c-.378-.293-.174-.902.3-.902h2.329l.7-2.285a.495.495 0 0 1 .949 0l.699 2.285h2.328c.476 0 .68.61.302.902zM21.75 9.5H2.25a1.25 1.25 0 0 1 0-2.5h19.5a1.25 1.25 0 0 1 0 2.5zm0 13.5H2.25a1.25 1.25 0 0 1 0-2.5h19.5a1.25 1.25 0 0 1 0 2.5z';

var handle = 'M3 15h18a1 1 0 0 1 0 2H3a1 1 0 0 1 0-2zm0-4h18a1 1 0 0 1 0 2H3a1 1 0 0 1 0-2zm0-4h18a1 1 0 0 1 0 2H3a1 1 0 1 1 0-2z';

var handPointing = 'M17.776,22.390 C13.775,23.978 9.246,22.359 7.219,18.770 C7.040,18.503 6.860,18.218 6.688,17.910 C5.132,15.163 3.028,13.782 2.588,13.581 C2.149,13.378 0.595,12.613 1.100,11.692 C1.381,11.180 2.163,10.801 2.878,10.726 C4.000,10.481 5.897,11.034 7.772,12.222 L4.054,3.419 C3.741,2.677 3.989,1.850 4.609,1.379 C4.612,1.376 4.616,1.373 4.621,1.369 C4.676,1.327 4.734,1.289 4.796,1.253 C4.810,1.247 4.821,1.239 4.835,1.231 C4.901,1.195 4.970,1.160 5.042,1.132 C5.044,1.131 5.044,1.131 5.045,1.131 C5.045,1.131 5.045,1.131 5.047,1.129 C5.119,1.101 5.193,1.079 5.267,1.060 C5.281,1.057 5.295,1.054 5.309,1.049 C5.380,1.035 5.449,1.021 5.518,1.013 C5.525,1.013 5.529,1.011 5.534,1.011 C6.317,0.928 7.093,1.347 7.406,2.088 L9.592,7.261 C9.643,6.623 10.055,6.035 10.709,5.776 C11.633,5.410 12.689,5.839 13.069,6.734 C13.071,6.742 13.074,6.752 13.077,6.759 C13.143,6.136 13.552,5.565 14.191,5.312 C15.117,4.946 16.173,5.373 16.551,6.271 C16.567,6.305 16.578,6.341 16.591,6.379 C16.680,5.784 17.079,5.249 17.695,5.006 C18.619,4.640 19.619,4.970 19.999,5.867 L20.001,5.872 C20.001,5.872 21.115,8.039 22.366,11.651 C22.413,11.791 22.457,11.931 22.495,12.072 C24.027,16.161 21.967,20.728 17.776,22.390';

var heart = 'M11.98 22.25L1.82 11.95C-.28 9.83-.65 6.4 1.18 4.03a5.763 5.763 0 0 1 8.7-.56l2.1 2.14 1.95-1.98c2.1-2.13 5.48-2.5 7.82-.65 2.8 2.23 2.99 6.35.55 8.82L11.98 22.25z';

var heartBroken = 'M11.98 22.25L1.82 11.95C-.28 9.83-.65 6.4 1.18 4.03a5.763 5.763 0 0 1 8.7-.56l2.1 2.14 1.95-1.98c2.1-2.13 5.48-2.5 7.82-.65 2.8 2.23 2.99 6.35.55 8.82L11.98 22.25zM15.3 9.54c.4-.4.4-1.06 0-1.46-.4-.4-1.05-.4-1.45 0L12 9.94l-1.85-1.86c-.4-.4-1.05-.4-1.45 0-.4.4-.4 1.06 0 1.46l1.85 1.86-1.85 1.86c-.4.4-.4 1.05 0 1.45.4.4 1.05.41 1.45 0L12 12.85l1.85 1.86c.4.41 1.05.41 1.45 0 .4-.4.4-1.05 0-1.45l-1.85-1.86 1.85-1.86z';

var impressum = 'M10 12c0-1.103.897-2 2-2s2 .897 2 2-.897 2-2 2-2-.897-2-2m2-5c-1.103 0-2-.897-2-2s.897-2 2-2 2 .897 2 2h3c0-2.757-2.243-5-5-5S7 2.243 7 5a4.98 4.98 0 0 0 1.438 3.5A4.98 4.98 0 0 0 7 12c0 2.757 2.243 5 5 5 1.103 0 2 .897 2 2s-.897 2-2 2-2-.897-2-2H7c0 2.757 2.243 5 5 5s5-2.243 5-5a4.98 4.98 0 0 0-1.438-3.5A4.98 4.98 0 0 0 17 12c0-2.757-2.243-5-5-5';

var link = 'M21 15.05c1.1 0 2 .9 2 2V21c0 1.1-.9 2-2 2H3c-1.1 0-2-.9-2-2V3c0-1.1.9-2 2-2h4a2 2 0 1 1 0 4H5v14h14v-1.95c0-1.1.9-2 2-2zM12 14c-.51 0-1.02-.2-1.41-.59-.79-.78-.79-2.04 0-2.82L16.16 5 14 5.01c-1.1 0-2-.9-2-2 0-1.11.89-2 2-2L20.99 1h2v2l.01 7a2 2 0 1 1-4 0V7.83l-5.59 5.58c-.39.39-.9.59-1.41.59z';

var location = 'M12 4.5c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3m7.5 3C19.5 3.36 16.14 0 12 0 7.86 0 4.5 3.36 4.5 7.5c0 1.3.36 2.5.94 3.56H5.4L12 24l6.6-12.94h-.04c.58-1.06.94-2.26.94-3.56';

var lock = 'M8 10V7c0-2.206 1.794-4 4-4s4 1.794 4 4v3H8zm11 .017V7c0-3.86-3.141-7-7-7S5 3.14 5 7v3.017a8.698 8.698 0 0 0-1.75 5.233 8.75 8.75 0 1 0 17.5 0A8.698 8.698 0 0 0 19 10.017z';

var marginsLarge = 'M18.75 1A4.255 4.255 0 0 1 23 5.25v13.5A4.255 4.255 0 0 1 18.75 23H5.25A4.255 4.255 0 0 1 1 18.75V5.25A4.255 4.255 0 0 1 5.25 1h13.5zM5.5 18.5h13v-13h-13v13zm9.97-1.97l-1.5-1.5-1.47 1.47v-4h4l-1.47 1.47 1.5 1.5-1.06 1.06zM7.5 11.5l1.47-1.47-1.5-1.5 1.06-1.06 1.5 1.5L11.5 7.5v4h-4z';

var marginsMedium = 'M7.53 6.47l1.5 1.5L10.5 6.5v4h-4l1.47-1.47-1.5-1.5 1.06-1.06zm9.97 7.03l-1.47 1.47 1.5 1.5-1.06 1.06-1.5-1.5-1.47 1.47v-4h4zm2 5.75a.25.25 0 0 1-.25.25H4.75a.25.25 0 0 1-.25-.25V4.75a.25.25 0 0 1 .25-.25h14.5a.25.25 0 0 1 .25.25v14.5zM19.25 1H4.75A3.754 3.754 0 0 0 1 4.75v14.5A3.754 3.754 0 0 0 4.75 23h14.5A3.754 3.754 0 0 0 23 19.25V4.75A3.754 3.754 0 0 0 19.25 1z';

var marginsSmall = 'M18.5 14.5l-1.47 1.47 1.5 1.5-1.06 1.06-1.5-1.5-1.47 1.47v-4h4zM6.53 5.47l1.5 1.5L9.5 5.5v4h-4l1.47-1.47-1.5-1.5 1.06-1.06zM20.5 19.75a.75.75 0 0 1-.75.75H4.25a.75.75 0 0 1-.75-.75V4.25a.75.75 0 0 1 .75-.75h15.5a.75.75 0 0 1 .75.75v15.5zM19.75 1H4.25A3.254 3.254 0 0 0 1 4.25v15.5A3.254 3.254 0 0 0 4.25 23h15.5A3.254 3.254 0 0 0 23 19.75V4.25A3.254 3.254 0 0 0 19.75 1z';

var maximize = 'M11 2.25c0 .69-.56 1.25-1.25 1.25H5.268l5.366 5.366a1.25 1.25 0 0 1-1.768 1.768L3.5 5.268V9.75a1.25 1.25 0 0 1-2.5 0V1h8.75c.69 0 1.25.56 1.25 1.25zM21.75 13c.69 0 1.25.56 1.25 1.25V23h-8.75a1.25 1.25 0 0 1 0-2.5h4.482l-5.366-5.366a1.25 1.25 0 0 1 1.768-1.768l5.366 5.366V14.25c0-.69.56-1.25 1.25-1.25z';

var megaphone = 'M14 17.5c0 1.378-1.122 2.5-2.5 2.5A2.503 2.503 0 0 1 9 17.5V17h5v.5zm8.947-1.87L18.701 2.712a1.022 1.022 0 0 0-1.566-.521l-15.7 11.24c-.37.264-.525.744-.382 1.179l.551 1.678c.14.425.532.712.974.712H7v.5a4.5 4.5 0 0 0 9 0V17h5.973c.7 0 1.195-.696.974-1.37z';

var menu = 'M21.5 9.5c1.38 0 2.5 1.13 2.5 2.5a2.5 2.5 0 0 1-2.5 2.5h-19C1.13 14.5 0 13.38 0 12c0-1.37 1.13-2.5 2.5-2.5h19zm-19-3C1.13 6.5 0 5.38 0 4c0-1.37 1.13-2.5 2.5-2.5h19C22.88 1.5 24 2.63 24 4a2.5 2.5 0 0 1-2.5 2.5h-19zm19 11c1.38 0 2.5 1.13 2.5 2.5a2.5 2.5 0 0 1-2.5 2.5h-19C1.13 22.5 0 21.38 0 20c0-1.37 1.13-2.5 2.5-2.5h19z';

var minimize = 'M1 9.75c0-.69.56-1.25 1.25-1.25h4.482L1.366 3.134a1.25 1.25 0 0 1 1.768-1.768L8.5 6.732V2.25a1.25 1.25 0 0 1 2.5 0V11H2.25C1.56 11 1 10.44 1 9.75zM14.25 23c-.69 0-1.25-.56-1.25-1.25V13h8.75a1.25 1.25 0 0 1 0 2.5h-4.482l5.366 5.366a1.25 1.25 0 0 1-1.768 1.768L15.5 17.268v4.482c0 .69-.56 1.25-1.25 1.25z';

var move = 'M14.3 18.17a1.25 1.25 0 0 1 1.77 0c.49.49.49 1.28 0 1.76L12 24l-4.07-4.07c-.48-.48-.48-1.27 0-1.76a1.25 1.25 0 0 1 1.77 0l1.05 1.04v-3.96a1.25 1.25 0 0 1 2.5 0v3.96l1.05-1.04zm-9.51-4.92l1.04 1.05c.49.49.49 1.28 0 1.77-.48.48-1.28.48-1.76 0L0 12l4.07-4.07c.48-.48 1.28-.48 1.76 0 .49.49.49 1.28 0 1.77l-1.04 1.05h3.96a1.25 1.25 0 0 1 0 2.5H4.79zm15.14-5.32L24 12l-4.07 4.07c-.48.48-1.27.48-1.76 0a1.25 1.25 0 0 1 0-1.77l1.04-1.05h-3.96a1.25 1.25 0 0 1 0-2.5h3.96L18.17 9.7a1.25 1.25 0 0 1 0-1.77c.49-.48 1.28-.48 1.76 0zM9.7 5.83c-.49.49-1.28.49-1.77 0-.48-.49-.48-1.28 0-1.76L12 0l4.07 4.07c.49.48.49 1.27 0 1.76s-1.28.49-1.77 0l-1.05-1.04v3.96a1.25 1.25 0 0 1-2.5 0V4.79L9.7 5.83z';

var mute = 'M5.00,7.94 L5.00,7.96 L12.00,1.00 L12.00,23.00 L5.00,16.91 L5.00,16.94 L2.00,16.94 C0.90,16.94 0.00,16.04 0.00,14.94 L0.00,9.94 C0.00,8.83 0.90,7.94 2.00,7.94 L5.00,7.94 Z M23.63,14.12 C24.12,14.60 24.12,15.39 23.63,15.88 C23.15,16.37 22.35,16.37 21.87,15.88 L19.75,13.77 L17.63,15.88 C17.15,16.37 16.35,16.37 15.87,15.88 C15.38,15.39 15.38,14.60 15.87,14.12 L17.98,12.00 L15.87,9.88 C15.38,9.39 15.38,8.60 15.87,8.12 C16.35,7.63 17.15,7.63 17.63,8.12 L19.75,10.23 L21.86,8.12 C22.35,7.63 23.15,7.63 23.63,8.12 C24.12,8.60 24.12,9.40 23.63,9.88 L21.52,12.00 L23.63,14.12 Z';

var overlayText = 'M20 1a3 3 0 0 1 3 3v16a3 3 0 0 1-3 3H4a3 3 0 0 1-3-3V4a3 3 0 0 1 3-3h16zm-6.718 4.133a1.403 1.403 0 0 0-2.564 0l-5.597 12.6a1.396 1.396 0 0 0 .714 1.846 1.401 1.401 0 0 0 1.85-.711L8.56 16.9h6.882l.874 1.967a1.404 1.404 0 0 0 1.851.71 1.397 1.397 0 0 0 .713-1.845l-5.597-12.6zM9.803 14.1L12 9.155l2.197 4.945H9.803z';

var pause = 'M7 0c1.65 0 3 1.35 3 3v18c0 1.65-1.35 3-3 3s-3-1.35-3-3V3c0-1.65 1.35-3 3-3zm10 0c1.65 0 3 1.35 3 3v18c0 1.65-1.35 3-3 3s-3-1.35-3-3V3c0-1.65 1.35-3 3-3z';

var people = 'M8 11a4.5 4.5 0 1 1 0-9 4.5 4.5 0 0 1 0 9zm10 3c3.314 0 6 2.713 6 6.061V22H0v-1.919C0 15.618 3.582 12 8 12c2.614 0 4.927 1.272 6.387 3.23A5.927 5.927 0 0 1 18 14zm0-1a3.25 3.25 0 1 1 0-6.5 3.25 3.25 0 0 1 0 6.5z';

var person = 'M12 12c5.523 0 10 4.477 10 10v2H2v-2c0-5.523 4.477-10 10-10zm0-1a5.5 5.5 0 1 1 0-11 5.5 5.5 0 1 1 0 11z';

var personAdd = 'M16.5 12a7.5 7.5 0 0 1 7.5 7.5V21H9v-1.5a7.5 7.5 0 0 1 7.5-7.5zm0-1a4 4 0 1 1 0-8 4 4 0 0 1 0 8zm-7.25 1H6.5v2.75a1.25 1.25 0 0 1-2.5 0V12H1.25a1.25 1.25 0 0 1 0-2.5H4V6.75a1.25 1.25 0 0 1 2.5 0V9.5h2.75a1.25 1.25 0 0 1 0 2.5z';

var pin = 'M18 13.5c0-2.22-1.21-4.15-3-5.19V2.45A2.5 2.5 0 0 0 17 0H7a2.5 2.5 0 0 0 2 2.45v5.86c-1.79 1.04-3 2.97-3 5.19h5v8.46L12 24l1-2.04V13.5h5z';

var pinHide = 'M9.13 6.37c.49.48.49 1.27 0 1.76l-2.61 2.62 2.61 2.62c.49.48.49 1.27 0 1.76-.48.49-1.27.49-1.76 0l-2.62-2.61-2.62 2.61c-.48.49-1.28.49-1.76 0-.49-.49-.49-1.28 0-1.76l2.61-2.62L.37 8.13c-.49-.49-.49-1.28 0-1.76.48-.49 1.28-.49 1.76 0l2.62 2.61 2.62-2.61c.49-.49 1.28-.49 1.76 0zM20.5 8.69c1.49.87 2.5 2.46 2.5 4.31h-4v7.96L18 23l-1-2.04V13h-4c0-1.85 1.01-3.44 2.5-4.31V2.93c-.86-.22-1.5-1-1.5-1.93h8c0 .93-.64 1.71-1.5 1.93v5.76z';

var pinterest = 'M0 12c0 5.123 3.211 9.497 7.73 11.218-.11-.937-.227-2.482.025-3.566.217-.932 1.401-5.938 1.401-5.938s-.357-.715-.357-1.774c0-1.66.962-2.9 2.161-2.9 1.02 0 1.512.765 1.512 1.682 0 1.025-.653 2.557-.99 3.978-.281 1.189.597 2.159 1.769 2.159 2.123 0 3.756-2.239 3.756-5.471 0-2.861-2.056-4.86-4.991-4.86-3.398 0-5.393 2.549-5.393 5.184 0 1.027.395 2.127.889 2.726a.36.36 0 0 1 .083.343c-.091.378-.293 1.189-.332 1.355-.053.218-.173.265-.4.159-1.492-.694-2.424-2.875-2.424-4.627 0-3.769 2.737-7.229 7.892-7.229 4.144 0 7.365 2.953 7.365 6.899 0 4.117-2.595 7.431-6.199 7.431-1.211 0-2.348-.63-2.738-1.373 0 0-.599 2.282-.744 2.84-.282 1.084-1.064 2.456-1.549 3.235C9.584 23.815 10.77 24 12 24c6.627 0 12-5.373 12-12S18.627 0 12 0 0 5.373 0 12';

var play = 'M20.62 9.48L6.63.48C4.63-.8 2 .63 2 3v18c0 2.37 2.63 3.8 4.63 2.52l13.99-9c1.84-1.18 1.84-3.86 0-5.04';

var questionMark = 'M14.34 21.2c0 1.57-1.19 2.8-2.78 2.8-1.58 0-2.77-1.23-2.77-2.8 0-1.57 1.19-2.8 2.77-2.8 1.59 0 2.78 1.23 2.78 2.8m-2.53-10.88c1.41-1.23 3.3-2.05 3.3-3.87 0-1.45-1.24-2.36-2.95-2.36-2.12 0-3.52 1.48-3.55 3.43H3.75C3.88 3.3 6.96 0 12.34 0c4.86 0 7.91 2.52 7.91 6.32 0 2.36-1.09 3.81-2.3 4.78-1.68 1.33-2.84 1.89-3.49 2.61-.5.57-.62 1.04-.65 1.95H9.45c0-2.64.65-3.9 2.36-5.34';

var remove = 'M17.75 13.25H6.25a1.25 1.25 0 0 1 0-2.5h11.5a1.25 1.25 0 0 1 0 2.5M12 0C5.37 0 0 5.37 0 12s5.37 12 12 12 12-5.37 12-12S18.63 0 12 0';

var report = 'M7.91 18.89A8.013 8.013 0 0 0 18.89 7.91L7.91 18.89zm-2.82-2.83L16.06 5.09A8.015 8.015 0 0 0 5.09 16.06zM12 24C5.37 24 0 18.63 0 12S5.37 0 12 0s12 5.37 12 12-5.37 12-12 12z';

var rotate = 'M11.003 9.96c1.105 0 2 .899 2 2.006v9.028a2.004 2.004 0 0 1-2 2.006H2.001C.896 23 0 22.102 0 20.994v-9.028C0 10.86.896 9.96 2 9.96h9.003zm12.63 1.872c.489.49.489 1.283 0 1.773l-3.885 3.896-3.878-3.897a1.256 1.256 0 0 1 .002-1.773 1.248 1.248 0 0 1 1.768.002l.865.87V7.27a3.76 3.76 0 0 0-3.75-3.762H7.251c-.69 0-1.25-.562-1.25-1.254 0-.693.56-1.254 1.25-1.254h7.502c3.447 0 6.252 2.812 6.252 6.27v5.424l.86-.862c.489-.49 1.28-.49 1.768 0z';

var search = 'M10 16c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6m13.12 2.88l-4.26-4.26A9.842 9.842 0 0 0 20 10c0-5.52-4.48-10-10-10S0 4.48 0 10s4.48 10 10 10c1.67 0 3.24-.41 4.62-1.14l4.26 4.26a3 3 0 0 0 4.24 0 3 3 0 0 0 0-4.24';

var security = 'M21 9.587c0 6.06-3.721 11.246-9 13.413-5.279-2.167-9-7.353-9-13.413V3a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v6.587z';

var send = 'M6 6l-6 6 7.67 2.56L21 3 9.44 16.34 12 24l6-6 6-18';

var share = 'M21 14c1.1 0 2 .9 2 2v6c0 1.1-.9 2-2 2H3c-1.1 0-2-.9-2-2v-6c0-1.1.9-2 2-2s2 .9 2 2v4h14v-4c0-1.1.9-2 2-2zM8.82 8.84c-.78.78-2.05.79-2.83 0-.78-.78-.79-2.04-.01-2.82L11.99 0l6.02 6.01c.78.78.79 2.05.01 2.83-.78.78-2.05.79-2.83 0l-1.2-1.19v6.18a2 2 0 1 1-4 0V7.66L8.82 8.84z';

var shoppingBag = 'M9.5 5a2.5 2.5 0 0 1 5 0v2h-5V5zM17 7V5c0-2.76-2.24-5-5-5S7 2.24 7 5v2H2v15c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V7h-5z';

var smiley = 'M12.03 19.29h-.06c-3.48-.03-4.92-2.31-4.98-2.41a.896.896 0 0 1 .27-1.22.82.82 0 0 1 1.17.26c.06.08 1.06 1.58 3.57 1.59 2.51-.01 3.52-1.6 3.56-1.67.25-.41.78-.54 1.18-.28.39.26.52.8.28 1.21-.06.1-1.5 2.49-4.99 2.52zM18 9.43c0 .95-.77 1.71-1.71 1.71-.95 0-1.72-.76-1.72-1.71s.77-1.72 1.72-1.72c.94 0 1.71.77 1.71 1.72zm-12 0c0-.95.77-1.72 1.71-1.72.95 0 1.72.77 1.72 1.72s-.77 1.71-1.72 1.71c-.94 0-1.71-.76-1.71-1.71z';

var smileyOutline = 'M12.03 19.29h-.06c-3.48-.03-4.92-2.31-4.98-2.41a.896.896 0 0 1 .27-1.22.82.82 0 0 1 1.17.26c.06.08 1.06 1.58 3.57 1.59 2.51-.01 3.52-1.6 3.56-1.67.25-.41.78-.54 1.18-.28.39.26.52.8.28 1.21-.06.1-1.5 2.49-4.99 2.52zM18 9.43c0 .95-.77 1.71-1.71 1.71-.95 0-1.72-.76-1.72-1.71s.77-1.72 1.72-1.72c.94 0 1.71.77 1.71 1.72zm-12 0c0-.95.77-1.72 1.71-1.72.95 0 1.72.77 1.72 1.72s-.77 1.71-1.72 1.71c-.94 0-1.71-.76-1.71-1.71zM12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.6 0 12 0zm0 22.2C6.45 22.2 1.8 17.7 1.8 12 1.8 6.3 6.3 1.8 12 1.8c5.7 0 10.2 4.5 10.2 10.2 0 5.7-4.65 10.2-10.2 10.2z';

var sound = 'M20.48 3.51A11.92 11.92 0 0 1 24 12c0 3.2-1.25 6.22-3.51 8.48-.25.25-.57.37-.89.37-.32 0-.64-.12-.88-.37-.49-.48-.49-1.27 0-1.76A9.465 9.465 0 0 0 21.5 12c0-2.54-.99-4.93-2.79-6.72-.48-.49-.48-1.28 0-1.77a1.25 1.25 0 0 1 1.77 0zM5 7.94v.02L12 1v22l-7-6.09v.03H2c-1.1 0-2-.9-2-2v-5a2 2 0 0 1 2-2h3zm11.95-.89A6.96 6.96 0 0 1 19 12c0 1.87-.73 3.63-2.05 4.95-.24.24-.56.36-.88.36-.32 0-.64-.12-.89-.36a1.25 1.25 0 0 1 0-1.77c.85-.85 1.32-1.98 1.32-3.18 0-1.2-.47-2.33-1.32-3.18a1.25 1.25 0 0 1 0-1.77 1.25 1.25 0 0 1 1.77 0z';

var speech = 'M12 0C5.85 0 .75 4.94.75 11.08c0 2.7.9 5.24 2.7 7.19L2.1 23.51c-.15.3.3.6.6.45l5.25-2.55c1.35.45 2.7.75 4.05.75 6.15 0 11.25-4.94 11.25-11.08S18.15 0 12 0';

var speechEllipsis = 'M18 12.5a1.5 1.5 0 1 1 .001-3.001A1.5 1.5 0 0 1 18 12.5m-6 0a1.5 1.5 0 1 1 .001-3.001A1.5 1.5 0 0 1 12 12.5m-6 0a1.5 1.5 0 1 1 .001-3.001A1.5 1.5 0 0 1 6 12.5M12 0C5.925 0 1 4.925 1 11c0 2.653.94 5.086 2.504 6.986L2 24l5.336-3.049A10.93 10.93 0 0 0 12 22c6.075 0 11-4.925 11-11S18.075 0 12 0';

var star = 'M22.46 10.736l-5.237 4.044 1.964 6.424c.393 1.285-1.079 2.323-2.136 1.506L12 18.81l-5.051 3.9c-1.057.817-2.529-.221-2.135-1.506l1.963-6.424-5.237-4.044c-1.039-.802-.477-2.48.83-2.48h6.402l1.921-6.282c.398-1.3 2.216-1.3 2.614 0l1.921 6.283h6.402c1.308 0 1.869 1.677.83 2.479';

var switchAccount = 'M7.184 22.56a1.5 1.5 0 0 0-.002-2.121l-1.442-1.44 8.76-.003a1.5 1.5 0 1 0-.001-3l-8.755.003 1.437-1.44a1.5 1.5 0 1 0-2.123-2.118L0 17.508l5.063 5.054a1.5 1.5 0 0 0 2.121-.002m9.637-10.998a1.501 1.501 0 0 1-.002-2.121L18.256 8 9.5 8.005a1.5 1.5 0 0 1-.001-3L18.26 5l-1.442-1.44a1.494 1.494 0 0 1-.441-1.061 1.498 1.498 0 0 1 2.56-1.061L24 6.493l-5.058 5.067a1.5 1.5 0 0 1-2.121.002';

var tag = 'M6 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2m7.36-6.2l8.84 8.84a2.71 2.71 0 0 1 0 3.85l-7.71 7.71a2.71 2.71 0 0 1-3.85 0L1.8 13.36c-.51-.51-.8-1.2-.8-1.92V3.73C1 2.22 2.22 1 3.73 1h7.71c.72 0 1.41.29 1.92.8';

var terms = 'M21 18H11a2 2 0 1 0 0 4h10a2 2 0 1 0 0-4M4 17a3 3 0 1 0 0 6 3 3 0 0 0 0-6m17-7H11a2 2 0 1 0 0 4h10a2 2 0 1 0 0-4M4 9a3 3 0 1 0 0 6 3 3 0 0 0 0-6m7-3h10a2 2 0 1 0 0-4H11a2 2 0 1 0 0 4M7 4a3 3 0 1 1-6 0 3 3 0 0 1 6 0';

var textAlignCenter = 'M0 4.5h24v-3H0v3zm3 6h18V7.499H3V10.5zm-3 6h24v-3H0v3zm3 6h18v-3H3v3z';

var textAlignLeft = 'M0 4.5h24v-3H0v3zm0 6h18V7.499H0V10.5zm0 6h24v-3H0v3zm0 6h18v-3H0v3z';

var textAlignRight = 'M24 4.5H0v-3h24v3zm0 6H6v-3h18v3zm0 6H0v-3h24v3zm0 6H6v-3h18v3z';

var textExtraSmall = 'M2.25 11.5a1.25 1.25 0 0 1 0-2.5h19.5a1.25 1.25 0 0 1 0 2.5H2.25zm19.5 9a1.25 1.25 0 0 1 0 2.5H2.25a1.25 1.25 0 0 1 0-2.5h19.5zM12 13c.218 0 .416.127.504.324l2.199 4.91A.545.545 0 0 1 14.2 19a.55.55 0 0 1-.504-.325l-.344-.766h-2.703l-.344.766a.553.553 0 0 1-.727.278.543.543 0 0 1-.28-.72l2.198-4.909A.553.553 0 0 1 12 13zm-.863 3.818h1.727L12 14.891l-.863 1.927z';

var textLarge = 'M2.25 3.5a1.25 1.25 0 0 1 0-2.5h19.5a1.25 1.25 0 0 1 0 2.5H2.25zm19.5 17a1.25 1.25 0 0 1 0 2.5H2.25a1.25 1.25 0 0 1 0-2.5h19.5zM12 5c.508 0 .968.297 1.174.757l5.131 11.454a1.266 1.266 0 0 1-.654 1.678 1.288 1.288 0 0 1-1.696-.647l-.8-1.788h-6.31l-.8 1.788a1.29 1.29 0 0 1-1.697.647 1.266 1.266 0 0 1-.654-1.678l5.13-11.454C11.03 5.297 11.491 5 12 5zm-2.014 8.908h4.027L12 9.413l-2.014 4.495z';

var textMedium = 'M2.25 6.5a1.25 1.25 0 0 1 0-2.5h19.5a1.25 1.25 0 0 1 0 2.5H2.25zm19.5 14a1.25 1.25 0 0 1 0 2.5H2.25a1.25 1.25 0 0 1 0-2.5h19.5zM12 8c.399 0 .762.232.923.595l4.032 9a.996.996 0 0 1-.515 1.319 1.013 1.013 0 0 1-1.333-.51L14.479 17H9.522l-.629 1.404a1.014 1.014 0 0 1-1.333.51.996.996 0 0 1-.515-1.319l4.031-9A1.01 1.01 0 0 1 12 8zm-1.582 7h3.164L12 11.467 10.418 15z';

var textSmall = 'M2.25 9.5a1.25 1.25 0 0 1 0-2.5h19.5a1.25 1.25 0 0 1 0 2.5H2.25zm19.5 11a1.25 1.25 0 0 1 0 2.5H2.25a1.25 1.25 0 0 1 0-2.5h19.5zM12 11c.29 0 .554.169.671.433l2.932 6.545a.724.724 0 0 1-.67 1.022.735.735 0 0 1-.673-.432l-.458-1.023h-3.604l-.458 1.023a.74.74 0 0 1-.97.37.725.725 0 0 1-.374-.96l2.932-6.545A.734.734 0 0 1 12 11zm-1.15 5.09h2.301l-1.15-2.568-1.152 2.569z';

var twitter = 'M7.548 21.5c9.056 0 14.01-7.31 14.01-13.65 0-.208 0-.414-.015-.62A9.88 9.88 0 0 0 24 4.747c-.899.388-1.852.642-2.828.754a4.838 4.838 0 0 0 2.165-2.653c-.967.559-2.024.953-3.127 1.164-1.526-1.58-3.952-1.968-5.916-.944-1.964 1.025-2.98 3.205-2.475 5.32C7.859 8.194 4.17 6.372 1.67 3.375.363 5.567 1.031 8.372 3.195 9.78a4.986 4.986 0 0 1-2.235-.6v.06c0 2.284 1.653 4.25 3.95 4.703a5.042 5.042 0 0 1-2.223.082c.645 1.954 2.494 3.293 4.6 3.332A10.048 10.048 0 0 1 0 19.345a14.21 14.21 0 0 0 7.548 2.151';

var viewTypeDefault = 'M13.5 24V13.5H24V24H13.5zM0 10.5V0h10.5v10.5H0zm13.5 0V0H24v10.5H13.5zM0 24V13.5h10.5V24H0z';

var viewTypeDense = 'M17.999 24H24v-6h-6.001v6zm-9-17.999V0h6v6.001H9zM0 6.001V0h6v6.001H0zm17.999 0V0H24v6.001h-6.001zM0 15.001V9h6v6H0zm9 0V9h6v6H9zm8.999 0V9H24v6h-6.001zM0 24v-6h6v6H0zm9 0v-6h6v6H9z';

var viewTypeList = 'M0 13.502v-3h24v3H0zm0-7.5V3h24v3.002H0zm0 15v-3h24v3H0z';

var icons = {
  add: add,
  'add-circle': addCircle,
  'add-pin': addPin,
  'align-bottom-center': alignBottomCenter,
  'align-bottom-left': alignBottomLeft,
  'align-bottom-right': alignBottomRight,
  'align-bottom': alignBottom,
  'align-middle': alignMiddle,
  'align-top-center': alignTopCenter,
  'align-top-left': alignTopLeft,
  'align-top-right': alignTopRight,
  'align-top': alignTop,
  'angled-pin': angledPin,
  apps: apps,
  'arrow-back': arrowBack,
  'arrow-circle-down': arrowCircleDown,
  'arrow-circle-forward': arrowCircleForward,
  'arrow-down': arrowDown,
  'arrow-forward': arrowForward,
  'arrow-up': arrowUp,
  'arrow-up-right': arrowUpRight,
  bell: bell,
  camera: camera,
  'camera-roll': cameraRoll,
  cancel: cancel,
  'canonical-pin': canonicalPin,
  'color-picker': colorPicker,
  check: check,
  'check-circle': checkCircle,
  'circle-outline': circleOutline,
  clear: clear,
  clock: clock,
  cog: cog,
  compass: compass,
  compose: compose,
  crop: crop,
  dash: dash,
  download: download,
  edit: edit,
  ellipsis: ellipsis,
  'ellipsis-circle-outline': ellipsisCircleOutline,
  envelope: envelope,
  eye: eye,
  facebook: facebook,
  'face-happy': faceHappy,
  'face-sad': faceSad,
  'face-smiley': faceSmiley,
  'fill-opaque': fillOpaque,
  'fill-transparent': fillTransparent,
  filter: filter,
  flag: flag,
  flashlight: flashlight,
  flipHorizontal: flipHorizontal,
  flipVertical: flipVertical,
  gif: gif,
  globe: globe,
  'globe-checked': globeChecked,
  gmail: gmail,
  'google-plus': googlePlus,
  'graph-bar': graphBar,
  handle: handle,
  'hand-pointing': handPointing,
  heart: heart,
  'heart-broken': heartBroken,
  impressum: impressum,
  knoop: knoop,
  lightbulb: lightbulb,
  link: link,
  location: location,
  lock: lock,
  'logo-large': logoLarge,
  'logo-small': logoSmall,
  logout: logout,
  'margins-large': marginsLarge,
  'margins-medium': marginsMedium,
  'margins-small': marginsSmall,
  maximize: maximize,
  megaphone: megaphone,
  menu: menu,
  minimize: minimize,
  move: move,
  mute: mute,
  'overlay-text': overlayText,
  pause: pause,
  people: people,
  person: person,
  'person-add': personAdd,
  pin: pin,
  'pin-hide': pinHide,
  pinterest: pinterest,
  play: play,
  'question-mark': questionMark,
  remove: remove,
  report: report,
  rotate: rotate,
  search: search,
  security: security,
  'shopping-bag': shoppingBag,
  smiley: smiley,
  'smiley-outline': smileyOutline,
  send: send,
  share: share,
  sound: sound,
  speech: speech,
  'speech-ellipsis': speechEllipsis,
  star: star,
  'switch-account': switchAccount,
  tag: tag,
  terms: terms,
  'text-align-left': textAlignLeft,
  'text-align-center': textAlignCenter,
  'text-align-right': textAlignRight,
  'text-extra-small': textExtraSmall,
  'text-large': textLarge,
  'text-medium': textMedium,
  'text-small': textSmall,
  twitter: twitter,
  'view-type-default': viewTypeDefault,
  'view-type-dense': viewTypeDense,
  'view-type-list': viewTypeList
};

var IconNames = Object.keys(icons);

function Icon(props) {
  var accessibilityLabel = props.accessibilityLabel,
      _props$color = props.color,
      color = _props$color === undefined ? 'gray' : _props$color,
      icon = props.icon,
      inline = props.inline,
      _props$size = props.size,
      size = _props$size === undefined ? 16 : _props$size,
      dangerouslySetSvgPath = props.dangerouslySetSvgPath;


  var cs = classnames(styles$1.icon, colors[color], defineProperty({}, styles$1.iconBlock, !inline));

  var path = icon && icons[icon] ||
  /* eslint-disable-next-line no-underscore-dangle */
  dangerouslySetSvgPath && dangerouslySetSvgPath.__path || undefined;

  var ariaHidden = accessibilityLabel === '' ? true : null;

  return createElement(
    'svg',
    {
      className: cs,
      height: size,
      width: size,
      viewBox: '0 0 24 24',
      'aria-hidden': ariaHidden,
      'aria-label': accessibilityLabel,
      role: 'img'
    },
    createElement(
      'title',
      null,
      accessibilityLabel
    ),
    createElement('path', { d: path })
  );
}

Icon.icons = IconNames;

Icon.propTypes = {
  accessibilityLabel: PropTypes.string.isRequired,
  color: PropTypes.oneOf(['blue', 'darkGray', 'eggplant', 'gray', 'green', 'lightGray', 'maroon', 'midnight', 'navy', 'olive', 'orange', 'orchid', 'pine', 'purple', 'red', 'watermelon', 'white']),
  dangerouslySetSvgPath: PropTypes.shape({
    __path: PropTypes.string
  }),
  icon: PropTypes.oneOf(IconNames),
  inline: PropTypes.bool,
  size: PropTypes.oneOfType([PropTypes.number, PropTypes.string])
};

var styles$2 = { "img": "_u3 _45 _y8 _4h", "scaled-img": "_u4 _4f", "contain": "_u5 _u4 _4f", "cover": "_u6 _u4 _4f" };

var shouldScaleImage = function shouldScaleImage(fit) {
  return fit === 'cover' || fit === 'contain';
};

var Image = function (_React$PureComponent) {
  inherits(Image, _React$PureComponent);

  function Image() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, Image);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Image.__proto__ || Object.getPrototypeOf(Image)).call.apply(_ref, [this].concat(args))), _this), _this.handleLoad = function () {
      if (_this.props.onLoad) {
        _this.props.onLoad();
      }
    }, _this.handleError = function () {
      if (_this.props.onError) {
        _this.props.onError();
      }
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(Image, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      if (shouldScaleImage(this.props.fit)) {
        this.loadImage();
      }
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      var _props = this.props,
          fit = _props.fit,
          src = _props.src;

      if (shouldScaleImage(fit) && prevProps.src !== src) {
        this.loadImage();
      }
    }
  }, {
    key: 'loadImage',
    value: function loadImage() {
      if (typeof window !== 'undefined') {
        var image = new window.Image();
        image.onload = this.handleLoad;
        image.onerror = this.handleError;
        image.src = this.props.src;
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _props2 = this.props,
          alt = _props2.alt,
          color = _props2.color,
          children = _props2.children,
          fit = _props2.fit,
          naturalHeight = _props2.naturalHeight,
          naturalWidth = _props2.naturalWidth,
          sizes = _props2.sizes,
          src = _props2.src,
          srcSet = _props2.srcSet;


      var isScaledImage = shouldScaleImage(fit);
      var childContent = children ? createElement(
        Box,
        { position: 'absolute', top: true, left: true, bottom: true, right: true, overflow: 'hidden' },
        children
      ) : null;

      return isScaledImage ? createElement(
        'div',
        {
          'aria-label': alt,
          className: styles$2[fit],
          style: {
            backgroundColor: color,
            backgroundImage: 'url(\'' + src + '\')'
          },
          role: 'img'
        },
        childContent
      ) : createElement(
        Box,
        {
          position: 'relative',
          dangerouslySetInlineStyle: {
            __style: {
              backgroundColor: color,
              paddingBottom: naturalHeight / naturalWidth * 100 + '%'
            }
          }
        },
        createElement('img', {
          alt: alt,
          className: styles$2.img,
          onError: this.handleError,
          onLoad: this.handleLoad,
          sizes: sizes,
          src: src,
          srcSet: srcSet
        }),
        childContent
      );
    }
  }]);
  return Image;
}(PureComponent);

Image.propTypes = {
  alt: PropTypes.string.isRequired,
  children: PropTypes.node,
  color: PropTypes.string,
  fit: PropTypes.oneOf(['contain', 'cover', 'none']),
  naturalHeight: PropTypes.number.isRequired,
  naturalWidth: PropTypes.number.isRequired,
  onError: PropTypes.func,
  onLoad: PropTypes.func,
  sizes: PropTypes.string,
  src: PropTypes.string.isRequired,
  srcSet: PropTypes.string
};
Image.defaultProps = {
  color: 'transparent',
  fit: 'none'
};

var styles$3 = { "Mask": "_ub _49 _4f", "square": "_uc _2v", "rounded": "_ud _2y", "circle": "_ue _2w", "wash": "_uf _4h _4l _4m _4k _4j" };

function Mask(props) {
  var children = props.children,
      _props$shape = props.shape,
      shape = _props$shape === undefined ? 'square' : _props$shape,
      width = props.width,
      height = props.height,
      _props$wash = props.wash,
      wash = _props$wash === undefined ? false : _props$wash;

  return createElement(
    'div',
    { className: classnames(styles$3.Mask, styles$3[shape]), style: { width: width, height: height } },
    children,
    wash && createElement('div', { className: styles$3.wash })
  );
}

Mask.propTypes = {
  children: PropTypes.node,
  height: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  shape: PropTypes.oneOf(['circle', 'rounded', 'square']),
  width: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  wash: PropTypes.bool
};

var typography = { "antialiased": "_0", "sansSerif": "_1", "letterSpacing": "_2", "leadingShort": "_3", "leadingTall": "_4", "fontWeightNormal": "_5", "fontWeightBold": "_6", "fontStyleRegular": "_7", "fontStyleItalic": "_8", "underline": "_9", "noUnderline": "_a", "breakWord": "_b", "truncate": "_c", "alignLeft": "_d", "alignRight": "_e", "alignCenter": "_f", "textJustify": "_g" };

var Square = function Square(props) {
  return createElement(
    Box,
    _extends({}, props, { position: 'relative' }),
    createElement(Box, {
      dangerouslySetInlineStyle: { __style: { paddingBottom: '100%' } },
      position: 'relative'
    }),
    createElement(
      Box,
      { position: 'absolute', top: true, left: true, bottom: true, right: true },
      props.children
    )
  );
};

var DefaultAvatar = function DefaultAvatar(_ref) {
  var name = _ref.name;

  var firstInitial = name ? [].concat(toConsumableArray(name))[0].toUpperCase() : '';
  return createElement(
    Square,
    { color: 'gray', shape: 'circle' },
    firstInitial && createElement(
      'svg',
      {
        width: '100%',
        viewBox: '-50 -50 100 100',
        version: '1.1',
        preserveAspectRatio: 'xMidYMid meet',
        xmlns: 'http://www.w3.org/2000/svg'
      },
      createElement(
        'title',
        null,
        name
      ),
      createElement(
        'text',
        {
          fontSize: '50px',
          fill: '#fff',
          dominantBaseline: 'central',
          textAnchor: 'middle',
          className: [typography.antialiased, typography.sansSerif, typography.leadingSmall, typography.fontWeightBold].join(' ')
        },
        firstInitial
      )
    )
  );
};

var sizes = {
  sm: 24,
  md: 40,
  lg: 72
};

var Avatar = function (_React$PureComponent) {
  inherits(Avatar, _React$PureComponent);

  function Avatar() {
    var _ref2;

    var _temp, _this, _ret;

    classCallCheck(this, Avatar);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref2 = Avatar.__proto__ || Object.getPrototypeOf(Avatar)).call.apply(_ref2, [this].concat(args))), _this), _this.state = {
      isImageLoaded: true
    }, _this.handleImageError = function () {
      return _this.setState({ isImageLoaded: false });
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(Avatar, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          name = _props.name,
          outline = _props.outline,
          size = _props.size,
          src = _props.src,
          verified = _props.verified;
      var isImageLoaded = this.state.isImageLoaded;

      var width = size ? sizes[size] : '100%';
      var height = size ? sizes[size] : '';
      return createElement(
        Box,
        _extends({
          color: 'white'
        }, outline ? {
          dangerouslySetInlineStyle: {
            __style: {
              boxShadow: '0 0 0 2px #fff'
            }
          }
        } : {}, {
          width: width,
          height: height,
          position: 'relative',
          shape: 'circle'
        }),
        src && isImageLoaded ? createElement(
          Mask,
          { shape: 'circle', wash: true },
          createElement(Image, {
            alt: name,
            color: '#EFEFEF',
            naturalHeight: 1,
            naturalWidth: 1,
            src: src,
            onError: this.handleImageError
          })
        ) : createElement(DefaultAvatar, { name: name }),
        verified && createElement(
          Box,
          {
            position: 'absolute',
            width: '20%',
            height: '20%',
            minWidth: 8,
            minHeight: 8,
            dangerouslySetInlineStyle: {
              __style: {
                bottom: '4%',
                right: '4%'
              }
            }
          },
          createElement(
            Box,
            {
              color: 'white',
              width: '100%',
              height: '100%',
              shape: 'circle',
              dangerouslySetInlineStyle: {
                __style: {
                  boxShadow: '0 0 0 2px #fff'
                }
              }
            },
            createElement(Icon, {
              color: 'red',
              icon: 'check-circle',
              accessibilityLabel: '',
              size: '100%'
            })
          )
        )
      );
    }
  }]);
  return Avatar;
}(PureComponent);

Avatar.propTypes = {
  name: PropTypes.string.isRequired,
  outline: PropTypes.bool,
  src: PropTypes.string,
  size: PropTypes.oneOf(['sm', 'md', 'lg']),
  verified: PropTypes.bool
};

var styles$4 = { "button": "_r3 _4q", "solid": "_r4 _33", "enabled": "_r5 _xu _z9", "sm": "_r6 _4n", "md": "_r7 _4o", "lg": "_r8 _4p", "block": "_r9 _y8 _45", "inline": "_ra _47", "disabled": "_rb _39", "gray": "_rc _39", "red": "_rd _35", "blue": "_re _3l", "transparent": "_rf _42", "white": "_rg _37" };

var styles$5 = { "Text": "_w7 _0 _1 _2", "fontSize1": "_w8", "fontSize2": "_w9", "fontSize3": "_wa", "fontSize4": "_wb", "fontSize5": "_wc", "smFontSize1": "_wd", "smFontSize2": "_we", "smFontSize3": "_wf", "smFontSize4": "_wg", "smFontSize5": "_wh", "mdFontSize1": "_wi", "mdFontSize2": "_wj", "mdFontSize3": "_wk", "mdFontSize4": "_wl", "mdFontSize5": "_wm", "lgFontSize1": "_wn", "lgFontSize2": "_wo", "lgFontSize3": "_wp", "lgFontSize4": "_wq", "lgFontSize5": "_wr" };

var SIZE_SCALE = {
  xs: 1,
  sm: 2,
  md: 3,
  lg: 4,
  xl: 5
};

function Text(_ref) {
  var _ref$align = _ref.align,
      align = _ref$align === undefined ? 'left' : _ref$align,
      _ref$bold = _ref.bold,
      bold = _ref$bold === undefined ? false : _ref$bold,
      children = _ref.children,
      _ref$color = _ref.color,
      color = _ref$color === undefined ? 'darkGray' : _ref$color,
      _ref$inline = _ref.inline,
      inline = _ref$inline === undefined ? false : _ref$inline,
      _ref$italic = _ref.italic,
      italic = _ref$italic === undefined ? false : _ref$italic,
      _ref$overflow = _ref.overflow,
      overflow = _ref$overflow === undefined ? 'breakWord' : _ref$overflow,
      _ref$size = _ref.size,
      size = _ref$size === undefined ? 'md' : _ref$size,
      smSize = _ref.smSize,
      mdSize = _ref.mdSize,
      lgSize = _ref.lgSize,
      leading = _ref.leading,
      _ref$truncate = _ref.truncate,
      truncate = _ref$truncate === undefined ? false : _ref$truncate,
      _ref$__dangerouslyInc = _ref.__dangerouslyIncreaseLineHeight,
      __dangerouslyIncreaseLineHeight = _ref$__dangerouslyInc === undefined ? false : _ref$__dangerouslyInc;

  var scale = SIZE_SCALE[size];
  var smScale = SIZE_SCALE[smSize];
  var mdScale = SIZE_SCALE[mdSize];
  var lgScale = SIZE_SCALE[lgSize];

  var cs = classnames(styles$5.Text, styles$5['fontSize' + scale], lgSize && styles$5['lgFontSize' + lgScale], mdSize && styles$5['mdFontSize' + mdScale], smSize && styles$5['smFontSize' + smScale], color === 'blue' && colors.blue, color === 'darkGray' && colors.darkGray, color === 'eggplant' && colors.eggplant, color === 'gray' && colors.gray, color === 'green' && colors.green, color === 'lightGray' && colors.lightGray, color === 'maroon' && colors.maroon, color === 'midnight' && colors.midnight, color === 'navy' && colors.navy, color === 'olive' && colors.olive, color === 'orange' && colors.orange, color === 'orchid' && colors.orchid, color === 'pine' && colors.pine, color === 'purple' && colors.purple, color === 'red' && colors.red, color === 'watermelon' && colors.watermelon, color === 'white' && colors.white, leading === 'short' && typography.leadingShort, (leading === 'tall' || __dangerouslyIncreaseLineHeight) && typography.leadingTall, align === 'center' && typography.alignCenter, align === 'justify' && typography.alignJustify, align === 'left' && typography.alignLeft, align === 'right' && typography.alignRight, overflow === 'breakWord' && typography.breakWord, italic && typography.fontStyleItalic, !italic && typography.fontStyleNormal, bold && typography.fontWeightBold, !bold && typography.fontWeightNormal, truncate && typography.truncate);
  var Tag = inline ? 'span' : 'div';

  return createElement(
    Tag,
    _extends({
      className: cs
    }, truncate && typeof children === 'string' ? { title: children } : null),
    children
  );
}

Text.propTypes = {
  __dangerouslyIncreaseLineHeight: PropTypes.bool,
  align: PropTypes.oneOf(['left', 'right', 'center', 'justify']),
  bold: PropTypes.bool,
  children: PropTypes.node,
  color: PropTypes.oneOf(['green', 'pine', 'olive', 'blue', 'navy', 'midnight', 'purple', 'orchid', 'eggplant', 'maroon', 'watermelon', 'orange', 'darkGray', 'gray', 'lightGray', 'red', 'white']),
  inline: PropTypes.bool,
  italic: PropTypes.bool,
  leading: PropTypes.oneOf(['tall', 'short']),
  lgSize: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl']),
  mdSize: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl']),
  overflow: PropTypes.oneOf(['normal', 'breakWord']),
  size: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl']),
  smSize: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl']),
  truncate: PropTypes.bool
};

function Button(props) {
  var _classnames;

  var accessibilityExpanded = props.accessibilityExpanded,
      accessibilityHaspopup = props.accessibilityHaspopup,
      accessibilityLabel = props.accessibilityLabel,
      _props$color = props.color,
      color = _props$color === undefined ? 'gray' : _props$color,
      _props$disabled = props.disabled,
      disabled = _props$disabled === undefined ? false : _props$disabled,
      _props$inline = props.inline,
      inline = _props$inline === undefined ? false : _props$inline,
      name = props.name,
      onClick = props.onClick,
      _props$size = props.size,
      size = _props$size === undefined ? 'md' : _props$size,
      text = props.text,
      _props$type = props.type,
      type = _props$type === undefined ? 'button' : _props$type;


  var textColor = {
    blue: 'white',
    gray: 'darkGray',
    red: 'white',
    transparent: 'white',
    white: 'darkGray'
  };

  var classes = classnames(styles$4.button, (_classnames = {}, defineProperty(_classnames, styles$4.sm, size === 'sm'), defineProperty(_classnames, styles$4.md, size === 'md'), defineProperty(_classnames, styles$4.lg, size === 'lg'), defineProperty(_classnames, styles$4.solid, color !== 'transparent'), defineProperty(_classnames, styles$4[color], !disabled), defineProperty(_classnames, styles$4.disabled, disabled), defineProperty(_classnames, styles$4.enabled, !disabled), defineProperty(_classnames, styles$4.inline, inline), defineProperty(_classnames, styles$4.block, !inline), _classnames));

  /* eslint-disable react/button-has-type */
  return createElement(
    'button',
    {
      'aria-expanded': accessibilityExpanded,
      'aria-haspopup': accessibilityHaspopup,
      'aria-label': accessibilityLabel,
      className: classes,
      disabled: disabled,
      name: name,
      onClick: function (_onClick) {
        function onClick(_x) {
          return _onClick.apply(this, arguments);
        }

        onClick.toString = function () {
          return _onClick.toString();
        };

        return onClick;
      }(function (event) {
        return onClick && onClick({ event: event });
      }),
      type: type
    },
    createElement(
      Text,
      {
        align: 'center',
        bold: true,
        color: disabled ? 'gray' : textColor[color],
        overflow: 'normal',
        size: size
      },
      text
    )
  );
  /* eslint-enable react/button-has-type */
}

Button.propTypes = {
  accessibilityExpanded: PropTypes.bool,
  accessibilityHaspopup: PropTypes.bool,
  accessibilityLabel: PropTypes.string,
  color: PropTypes.oneOf(['blue', 'gray', 'red', 'transparent', 'white']),
  disabled: PropTypes.bool,
  inline: PropTypes.bool,
  name: PropTypes.string,
  onClick: PropTypes.func,
  size: PropTypes.oneOf(['sm', 'md', 'lg']),
  text: PropTypes.string.isRequired,
  type: PropTypes.oneOf(['button', 'submit'])
};

var styles$6 = { "card": "_rt _4h _2y _4j _4k _4l _4m _4r", "hover": "_ru", "animateIn": "_rv" };

var Card = function (_React$Component) {
  inherits(Card, _React$Component);

  function Card() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, Card);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Card.__proto__ || Object.getPrototypeOf(Card)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      hovered: false
    }, _this.handleMouseEnter = function (event) {
      var onMouseEnter = _this.props.onMouseEnter;

      _this.setState({ hovered: true }, onMouseEnter && function () {
        return onMouseEnter({ event: event });
      });
    }, _this.handleMouseLeave = function (event) {
      var onMouseLeave = _this.props.onMouseLeave;

      _this.setState({ hovered: false }, onMouseLeave && function () {
        return onMouseLeave({ event: event });
      });
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(Card, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          active = _props.active,
          children = _props.children,
          image = _props.image;
      var hovered = this.state.hovered;


      var classes = classnames(styles$6.card, defineProperty({}, styles$6.hover, active || active == null && hovered));

      return createElement(
        Box,
        {
          onMouseEnter: this.handleMouseEnter,
          onMouseLeave: this.handleMouseLeave,
          position: 'relative'
        },
        image && createElement(
          Box,
          { marginBottom: 1 },
          image
        ),
        createElement(
          Box,
          null,
          children
        ),
        createElement('div', { className: classes })
      );
    }
  }]);
  return Card;
}(Component);

Card.propTypes = {
  active: PropTypes.bool,
  children: PropTypes.node,
  image: PropTypes.node,
  onMouseEnter: PropTypes.func,
  onMouseLeave: PropTypes.func
};

var styles$7 = { "border": "_rh", "borderError": "_ri", "borderDark": "_rj", "check": "_rk _45 _4q _4s _50 _5a", "checkEnabled": "_rl _z9", "checkFocused": "_rm _xv", "checkSm": "_rn", "checkMd": "_ro", "input": "_rp _4h _od", "inputEnabled": "_rq _z9", "inputSm": "_rr", "inputMd": "_rs" };

var Checkbox = function (_React$Component) {
  inherits(Checkbox, _React$Component);

  function Checkbox() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, Checkbox);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Checkbox.__proto__ || Object.getPrototypeOf(Checkbox)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      focused: false
    }, _this.handleChange = function (event) {
      var checked = event.target.checked;

      _this.props.onChange({ event: event, checked: checked });
    }, _this.handleClick = function (event) {
      var onClick = _this.props.onClick;

      if (onClick) {
        var _checked = event.currentTarget.checked;

        onClick({ event: event, checked: _checked });
      }
    }, _this.handleBlur = function () {
      return _this.setState({ focused: false });
    }, _this.handleFocus = function () {
      return _this.setState({ focused: true });
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(Checkbox, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      if (this.props.indeterminate) {
        this.setIndeterminate(!!this.props.indeterminate);
      }
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(previousProps) {
      if (previousProps.indeterminate !== this.props.indeterminate) {
        this.setIndeterminate(!!this.props.indeterminate);
      }
    }
  }, {
    key: 'setIndeterminate',
    value: function setIndeterminate(indeterminate) {
      if (this.input) {
        this.input.indeterminate = indeterminate;
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _classnames,
          _this2 = this,
          _classnames2;

      var _props = this.props,
          checked = _props.checked,
          disabled = _props.disabled,
          hasError = _props.hasError,
          id = _props.id,
          indeterminate = _props.indeterminate,
          name = _props.name,
          size = _props.size;


      var borderStyle = styles$7.border;
      if (!disabled && (checked || indeterminate)) {
        borderStyle = styles$7.borderDark;
      } else if (hasError) {
        borderStyle = styles$7.borderError;
      }

      return createElement(
        Box,
        { position: 'relative' },
        createElement('input', {
          checked: checked,
          className: classnames(styles$7.input, (_classnames = {}, defineProperty(_classnames, styles$7.inputEnabled, !disabled), defineProperty(_classnames, styles$7.indeterminate, indeterminate), defineProperty(_classnames, styles$7.inputSm, size === 'sm'), defineProperty(_classnames, styles$7.inputMd, size === 'md'), _classnames)),
          disabled: disabled,
          id: id,
          name: name,
          onBlur: this.handleBlur,
          onChange: this.handleChange,
          onClick: this.handleClick,
          onFocus: this.handleFocus,
          ref: function ref(el) {
            _this2.input = el;
          },
          type: 'checkbox'
        }),
        createElement(
          'div',
          {
            className: classnames(borderStyle, styles$7.check,
            // eslint-disable-next-line no-nested-ternary
            disabled ? checked || indeterminate ? colors.grayBg : colors.lightGrayBg : checked || indeterminate ? colors.darkGrayBg : colors.whiteBg, (_classnames2 = {}, defineProperty(_classnames2, styles$7.checkEnabled, !disabled), defineProperty(_classnames2, styles$7.checkFocused, this.state.focused), defineProperty(_classnames2, styles$7.checkMd, size === 'md'), defineProperty(_classnames2, styles$7.checkSm, size === 'sm'), _classnames2))
          },
          (checked || indeterminate) && createElement(Icon, {
            accessibilityLabel: '',
            color: 'white',
            icon: indeterminate ? 'dash' : 'check',
            size: size === 'sm' ? 8 : 12
          })
        )
      );
    }
  }]);
  return Checkbox;
}(Component);

Checkbox.propTypes = {
  checked: PropTypes.bool,
  disabled: PropTypes.bool,
  hasError: PropTypes.bool,
  id: PropTypes.string.isRequired,
  indeterminate: PropTypes.bool,
  name: PropTypes.string,
  onChange: PropTypes.func.isRequired,
  onClick: PropTypes.func,
  size: PropTypes.oneOf(['sm', 'md'])
};
Checkbox.defaultProps = {
  checked: false,
  disabled: false,
  hasError: false,
  indeterminate: false,
  size: 'md'
};

var Collection = function (_React$PureComponent) {
  inherits(Collection, _React$PureComponent);

  function Collection() {
    classCallCheck(this, Collection);
    return possibleConstructorReturn(this, (Collection.__proto__ || Object.getPrototypeOf(Collection)).apply(this, arguments));
  }

  createClass(Collection, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          Item = _props.Item,
          layout$$1 = _props.layout,
          _props$viewportTop = _props.viewportTop,
          viewportTop = _props$viewportTop === undefined ? 0 : _props$viewportTop,
          _props$viewportLeft = _props.viewportLeft,
          viewportLeft = _props$viewportLeft === undefined ? 0 : _props$viewportLeft;

      // Calculate the full dimensions of the item layer

      var width = Math.max.apply(Math, toConsumableArray(layout$$1.map(function (item) {
        return item.left + item.width;
      })));
      var height = Math.max.apply(Math, toConsumableArray(layout$$1.map(function (item) {
        return item.top + item.height;
      })));

      // Default the viewport to being the full width of the content layer
      var _props2 = this.props,
          _props2$viewportWidth = _props2.viewportWidth,
          viewportWidth = _props2$viewportWidth === undefined ? width : _props2$viewportWidth,
          _props2$viewportHeigh = _props2.viewportHeight,
          viewportHeight = _props2$viewportHeigh === undefined ? height : _props2$viewportHeigh;

      // Calculates which items from the item layer to render in the viewport
      // layer.

      var items = layout$$1.reduce(function (acc, position, idx) {
        if (position.top + position.height > viewportTop && position.top < viewportHeight + viewportTop && position.left < viewportWidth + viewportLeft && position.left + position.width > viewportLeft) {
          acc.push(_extends({ idx: idx }, position));
        }
        return acc;
      }, []);

      return createElement(
        'div',
        { className: layout.relative, style: { width: width, height: height } },
        items.map(function (_ref) {
          var idx = _ref.idx,
              style = objectWithoutProperties(_ref, ['idx']);
          return createElement(
            'div',
            { key: idx, className: layout.absolute, style: style },
            createElement(Item, { idx: idx })
          );
        })
      );
    }
  }]);
  return Collection;
}(PureComponent);

Collection.propTypes = {
  // eslint-disable-next-line react/forbid-prop-types
  Item: PropTypes.any,
  layout: PropTypes.arrayOf(PropTypes.exact({
    top: PropTypes.number.isRequired,
    left: PropTypes.number.isRequired,
    width: PropTypes.number.isRequired,
    height: PropTypes.number.isRequired
  }).isRequired),
  viewportHeight: PropTypes.number,
  viewportLeft: PropTypes.number,
  viewportTop: PropTypes.number,
  viewportWidth: PropTypes.number
};
Collection.defaultProps = {
  layout: [],
  viewportLeft: 0,
  viewportTop: 0
};

/*

This function just implements the design constraints for asymetrical columns in
a very simple way. It's not perfect, but it's very predictible. If you do
anything, improve it so that it takes these constraints and generates them
for n > 4.

1 + n columns:
  first column is 50/50
  can't have 3 columns in a row be 50/50

*/
var UP = [0.75, 0.25];
var DOWN = [0.25, 0.75];
var MID = [0.5, 0.5];
var columnLayout = function columnLayout(numOfColumns) {
  switch (numOfColumns) {
    case 1:
      return [[MID], [UP], [DOWN]];
    case 2:
      return [[UP, MID], [DOWN, MID], [MID, UP], [MID, DOWN]];
    case 4:
      return [[MID, UP, MID, MID], [MID, DOWN, MID, MID], [MID, MID, UP, MID], [MID, MID, DOWN, MID], [MID, UP, MID, DOWN], [MID, DOWN, MID, UP]];
    case 3:
    default:
      return [[MID, UP, MID], [MID, DOWN, MID], [MID, MID, UP], [MID, MID, DOWN]];
  }
};

var paddingAll = function paddingAll(gutter, positions) {
  return positions.map(function (_ref) {
    var top = _ref.top,
        left = _ref.left,
        width = _ref.width,
        height = _ref.height;
    return {
      top: top,
      left: left,
      width: width - gutter,
      height: height - gutter
    };
  });
};

var mindex = function mindex(arr) {
  return arr.reduce(function (minIndex, item, i) {
    return item < arr[minIndex] ? i : minIndex;
  }, 0);
};

var columnsForCollageWithCover = function columnsForCollageWithCover(numOfColumns) {
  return numOfColumns === 4 ? 2 : 1;
};

function getCollageLayout(_ref2) {
  var gutter = _ref2.gutter,
      cover = _ref2.cover,
      numCols = _ref2.columns,
      h = _ref2.height,
      w = _ref2.width,
      layoutKey = _ref2.layoutKey;

  var positions = [];
  var width = w + gutter;
  var height = h + gutter;

  // If there's a cover image, we'll add that later. It should be a little
  // less than half the width of the collage. We do this now (and not later
  // when we add the cover image) because of `columnLayout`'s constraints
  // needing the exact number of columns that are displayed.
  var gridCols = cover ? columnsForCollageWithCover(numCols) : numCols;

  // Selects the layout that we're going to use for the grid
  var columns = columnLayout(gridCols);
  var layoutIdx = layoutKey % columns.length;
  var layout = columns[layoutIdx];

  // This does a really simple version of our masonry layout. Why replicate
  // that here? a.) fewer dependencies and b.) we need the algorithm to
  // roughly preserve the order of the collages from when they were ordered
  // by Masonry.
  var colHeights = new Array(gridCols).fill(0);
  var colCounts = new Array(gridCols).fill(0);

  // We iterate over every position that we think we could _potentially_ have
  // so that we can fill them with empty sections if need be.
  for (var i = 0; i < 2 * gridCols; i += 1) {
    var col = mindex(colHeights);
    var colIdx = colCounts[col];
    var itemHeight = layout[col][colIdx] * height;

    positions.push({
      top: colHeights[col],
      left: col * (width / numCols),
      width: width / numCols,
      height: itemHeight
    });

    colHeights[col] += itemHeight;
    colCounts[col] += 1;
  }

  // If we have a cover image, figure out how big it is, then move all the
  // existing columns over.
  if (cover) {
    var coverImageWidth = Math.ceil(numCols / 2) * (width / numCols);
    positions = positions.map(function (position) {
      return _extends({}, position, {
        left: coverImageWidth + position.left
      });
    });
    positions.unshift({ top: 0, left: 0, width: coverImageWidth, height: height });
  }

  // This adds the space between any items that we have. It's nice to do
  // this as a separate pass after everything else, because the math earlier
  // becomes easier and it's less brittle to change.
  if (gutter) {
    positions = paddingAll(gutter, positions);
  }

  return positions;
}

function Collage(props) {
  var columns = props.columns,
      cover = props.cover,
      gutter = props.gutter,
      height = props.height,
      layoutKey = props.layoutKey,
      renderImage = props.renderImage,
      width = props.width;

  var positions = getCollageLayout({
    columns: columns,
    cover: !!cover,
    width: width,
    height: height,
    gutter: gutter || 0,
    layoutKey: layoutKey || 0
  });
  return createElement(Collection, {
    Item: function Item(_ref3) {
      var index = _ref3.idx;
      return renderImage({
        index: index,
        width: positions[index].width,
        height: positions[index].height
      });
    },
    layout: positions
  });
}

Collage.propTypes = {
  columns: PropTypes.oneOf([2, 3, 4]).isRequired,
  cover: PropTypes.bool,
  gutter: PropTypes.number,
  height: PropTypes.number.isRequired,
  layoutKey: PropTypes.number,
  renderImage: PropTypes.func.isRequired,
  width: PropTypes.number.isRequired
};

var styles$8 = { "deprecatedColumn": "_rw", "xsCol0": "_rx", "xsCol1": "_ry _xx", "xsCol2": "_rz _xy", "xsCol3": "_s0 _xz", "xsCol4": "_s1 _y0", "xsCol5": "_s2 _y1", "xsCol6": "_s3 _y2", "xsCol7": "_s4 _y3", "xsCol8": "_s5 _y4", "xsCol9": "_s6 _y5", "xsCol10": "_s7 _y6", "xsCol11": "_s8 _y7", "xsCol12": "_s9 _y8", "smCol0": "_sa", "smCol1": "_sb _y9", "smCol2": "_sc _ya", "smCol3": "_sd _yb", "smCol4": "_se _yc", "smCol5": "_sf _yd", "smCol6": "_sg _ye", "smCol7": "_sh _yf", "smCol8": "_si _yg", "smCol9": "_sj _yh", "smCol10": "_sk _yi", "smCol11": "_sl _yj", "smCol12": "_sm _yk", "mdCol0": "_sn", "mdCol1": "_so _yl", "mdCol2": "_sp _ym", "mdCol3": "_sq _yn", "mdCol4": "_sr _yo", "mdCol5": "_ss _yp", "mdCol6": "_st _yq", "mdCol7": "_su _yr", "mdCol8": "_sv _ys", "mdCol9": "_sw _yt", "mdCol10": "_sx _yu", "mdCol11": "_sy _yv", "mdCol12": "_sz _yw", "lgCol0": "_t0", "lgCol1": "_t1 _yx", "lgCol2": "_t2 _yy", "lgCol3": "_t3 _yz", "lgCol4": "_t4 _z0", "lgCol5": "_t5 _z1", "lgCol6": "_t6 _z2", "lgCol7": "_t7 _z3", "lgCol8": "_t8 _z4", "lgCol9": "_t9 _z5", "lgCol10": "_ta _z6", "lgCol11": "_tb _z7", "lgCol12": "_tc _z8" };

function Column(props) {
  var children = props.children;

  var cs = classnames((props.xs !== undefined || props.sm !== undefined || props.md !== undefined || props.lg !== undefined) && styles$8.deprecatedColumn, props.xs && styles$8['xsCol' + props.xs], props.sm && styles$8['smCol' + props.sm], props.md && styles$8['mdCol' + props.md], props.lg && styles$8['lgCol' + props.lg], props.span != null && styles$8['xsCol' + props.span], props.smSpan != null && styles$8['smCol' + props.smSpan], props.mdSpan != null && styles$8['mdCol' + props.mdSpan], props.lgSpan != null && styles$8['lgCol' + props.lgSpan]);
  return createElement(
    'div',
    { className: cs },
    children
  );
}

Column.propTypes = {
  children: PropTypes.node,
  xs: PropTypes.number,
  sm: PropTypes.number,
  md: PropTypes.number,
  lg: PropTypes.number,
  span: PropTypes.number,
  smSpan: PropTypes.number,
  mdSpan: PropTypes.number,
  lgSpan: PropTypes.number
};

function Container(props) {
  var children = props.children;

  return createElement(
    Box,
    { justifyContent: 'center', display: 'flex' },
    createElement(
      Box,
      { maxWidth: 800, width: '100%' },
      children
    )
  );
}

Container.propTypes = {
  children: PropTypes.node
};

var styles$9 = { "divider": "_td _45 _2r _od" };

function Divider() {
  return createElement('hr', { className: styles$9.divider });
}

function Caret(props) {
  var direction = props.direction;

  var path = void 0;
  switch (direction) {
    case 'up':
      path = 'M0 0 L12 12 L24 0';
      break;
    case 'right':
      path = 'M24 0 L12 12 L24 24';
      break;
    case 'down':
      path = 'M0 24 L12 12 L24 24';
      break;
    case 'left':
      path = 'M0 0 L12 12 L0 24';
      break;
    default:
  }

  return createElement(
    'svg',
    { width: '24', height: '24' },
    createElement('path', { d: path })
  );
}

Caret.propTypes = {
  direction: PropTypes.oneOf(['up', 'right', 'down', 'left'])
};

var styles$a = { "container": "_xp _4h", "contents": "_xq _4h _45 _4q _2y", "dimensions": "_xr", "innerContents": "_xs _4s _4d _2y", "caret": "_xt _4h" };

/* Needed until this Flow issue is fixed: https://github.com/facebook/flow/issues/380 */
/* eslint quote-props: 0 */
var SPACES_INDEX_MAP = {
  '0': 'up',
  '1': 'right',
  '2': 'down',
  '3': 'left'
};

var DIR_INDEX_MAP = {
  up: 0,
  right: 1,
  down: 2,
  left: 3
};

var MARGIN = 24;
var CARET_HEIGHT = 24;
var CARET_OFFSET_FROM_SIDE = 24;
var BORDER_RADIUS = 8;

/**
 * Determines the main direction the flyout opens
 */
function getMainDir(flyoutSize, idealDirection, triggerRect, windowSize) {
  // Calculates the available space if we were to place the flyout in the 4 main directions
  // to determine which 'quadrant' to position the flyout inside of
  var up = triggerRect.top - flyoutSize.height - CARET_HEIGHT;
  var right = windowSize.width - flyoutSize.width - CARET_HEIGHT - triggerRect.right;
  var down = windowSize.height - flyoutSize.height - CARET_HEIGHT - triggerRect.bottom;
  var left = triggerRect.left - flyoutSize.width - CARET_HEIGHT;

  // overrides available space when the trigger is close to the edge of the screen
  // trigger is too close to top/bottom of screen for left & right flyouts
  if (triggerRect.top < BORDER_RADIUS || windowSize.height - triggerRect.bottom < BORDER_RADIUS) {
    left = 0;
    right = 0;
  }

  // trigger is too close to the left/right of screen for up & down flyouts
  if (triggerRect.left < BORDER_RADIUS || windowSize.width - triggerRect.right < BORDER_RADIUS) {
    up = 0;
    down = 0;
  }

  var spaces = [up, right, down, left];

  // Identify best direction of available spaces
  var max = Math.max.apply(Math, spaces);

  // Chose the main direction for the flyout based on available spaces & user preference
  var mainDir = void 0;
  if (idealDirection && spaces[DIR_INDEX_MAP[idealDirection]] > 0) {
    // user pref
    mainDir = idealDirection;
  } else {
    // If no direction pref, chose the direction in which there is the most space available
    mainDir = SPACES_INDEX_MAP[spaces.indexOf(max)];
  }
  return mainDir;
}

/**
 * Determines the sub direction of how the flyout is positioned within the main dir
 */
function getSubDir(flyoutSize, mainDir, triggerRect, windowSize) {
  // Now that we have the main direction, chose from 3 caret placements for that direction
  var offset = void 0;
  var triggerMid = void 0;
  var windowSpaceAvailable = void 0;

  if (mainDir === 'right' || mainDir === 'left') {
    offset = flyoutSize.height / 2;
    triggerMid = triggerRect.top + (triggerRect.bottom - triggerRect.top) / 2;
    windowSpaceAvailable = windowSize.height;
  } else {
    // (mainDir === 'up' || mainDir === 'down')
    offset = flyoutSize.width / 2;
    triggerMid = triggerRect.left + (triggerRect.right - triggerRect.left) / 2;
    windowSpaceAvailable = windowSize.width;
  }

  var aboveOrLeft = triggerMid - offset - MARGIN;
  var belowOrRight = windowSpaceAvailable - triggerMid - offset - MARGIN;
  var subDir = void 0;
  if (aboveOrLeft > 0 && belowOrRight > 0) {
    // caret should go in middle b/c it can
    subDir = 'middle';
  } else if (belowOrRight > 0) {
    // caret should go at top for left/right and left for up/down
    subDir = mainDir === 'left' || mainDir === 'right' ? 'up' : 'left';
  } else {
    // caret should go at bottom for left/right and right for up/down
    subDir = mainDir === 'left' || mainDir === 'right' ? 'down' : 'right';
  }
  return subDir;
}

/**
 * Calculates the amount the flyout & caret need to shift over to align with designs
 */
function calcEdgeShifts(subDir, triggerRect, windowSize) {
  // Target values for flyout and caret shifts
  var flyoutVerticalShift = CARET_OFFSET_FROM_SIDE - (triggerRect.height - CARET_HEIGHT) / 2;
  var flyoutHorizontalShift = CARET_OFFSET_FROM_SIDE - (triggerRect.width - CARET_HEIGHT) / 2;
  var caretVerticalShift = CARET_HEIGHT;
  var caretHorizontalShift = CARET_HEIGHT;

  // Covers edge case where trigger is in a corner and we need to adjust the offset of the caret
  // to something smaller than normal in order
  var isCloseVertically = triggerRect.top - flyoutVerticalShift < 0 || triggerRect.bottom + flyoutVerticalShift > windowSize.height;
  var isCloseHorizontally = triggerRect.left - flyoutHorizontalShift < 0 || triggerRect.right + flyoutHorizontalShift > windowSize.width;
  if (isCloseVertically) {
    flyoutVerticalShift = BORDER_RADIUS - (triggerRect.height - CARET_HEIGHT) / 2;
    caretVerticalShift = BORDER_RADIUS;
  }
  if (isCloseHorizontally) {
    flyoutHorizontalShift = BORDER_RADIUS - (triggerRect.width - CARET_HEIGHT) / 2;
    caretHorizontalShift = BORDER_RADIUS;
  }

  return {
    flyout: {
      x: flyoutHorizontalShift,
      y: flyoutVerticalShift
    },
    caret: {
      x: caretHorizontalShift,
      y: caretVerticalShift
    }
  };
}

/**
 * Calculates flyout and caret offsets for styling
 */
function adjustOffsets(base, edgeShift, flyoutSize, mainDir, subDir, triggerRect) {
  var flyoutLeft = base.left;
  var flyoutTop = base.top;

  var caretTop = mainDir === 'down' ? -CARET_HEIGHT : null;
  var caretRight = mainDir === 'left' ? -CARET_HEIGHT : null;
  var caretBottom = null;
  var caretLeft = mainDir === 'right' ? -CARET_HEIGHT : null;

  if (subDir === 'up') {
    flyoutTop = base.top - edgeShift.flyout.y;
    caretTop = edgeShift.caret.y;
  } else if (subDir === 'down') {
    flyoutTop = base.top - flyoutSize.height + triggerRect.height + edgeShift.flyout.y;
    caretBottom = edgeShift.caret.y;
  } else if (subDir === 'left') {
    flyoutLeft = base.left - edgeShift.flyout.x;
    caretLeft = edgeShift.caret.x;
  } else if (subDir === 'right') {
    flyoutLeft = base.left - flyoutSize.width + triggerRect.width + edgeShift.flyout.x;
    caretRight = edgeShift.caret.x;
  } else if (subDir === 'middle') {
    if (mainDir === 'left' || mainDir === 'right') {
      var triggerMid = flyoutTop + triggerRect.height / 2;
      flyoutTop = triggerMid - flyoutSize.height / 2;
      caretTop = (flyoutSize.height - CARET_HEIGHT) / 2;
    }
    if (mainDir === 'up' || mainDir === 'down') {
      var _triggerMid = flyoutLeft + triggerRect.width / 2;
      flyoutLeft = _triggerMid - flyoutSize.width / 2;
      caretLeft = (flyoutSize.width - CARET_HEIGHT) / 2;
    }
  }

  return {
    flyoutOffset: {
      top: flyoutTop,
      left: flyoutLeft
    },
    caretOffset: {
      top: caretTop,
      right: caretRight,
      bottom: caretBottom,
      left: caretLeft
    }
  };
}

/* Calculates baseline top and left offset for flyout */
function baseOffsets(relativeOffset, flyoutSize, mainDir, triggerRect, windowSize) {
  var HALF_CARET = CARET_HEIGHT / 2;
  // TOP OFFSET
  var top = void 0;
  if (mainDir === 'down') {
    top = windowSize.scrollY + triggerRect.bottom + HALF_CARET;
  } else if (mainDir === 'up') {
    top = windowSize.scrollY + (triggerRect.top - flyoutSize.height - HALF_CARET);
  } else {
    // left and right
    top = windowSize.scrollY + triggerRect.top;
  }

  // LEFT OFFSET
  var left = void 0;
  if (mainDir === 'left') {
    left = windowSize.scrollX + (triggerRect.left - flyoutSize.width - HALF_CARET);
  } else if (mainDir === 'right') {
    left = windowSize.scrollX + triggerRect.right + HALF_CARET;
  } else {
    // down and up
    left = windowSize.scrollX + triggerRect.left;
  }

  // Adjusts for the relative parent container
  top -= relativeOffset.y;
  left -= relativeOffset.x;
  return { top: top, left: left };
}

var Contents = function (_React$Component) {
  inherits(Contents, _React$Component);

  function Contents() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, Contents);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Contents.__proto__ || Object.getPrototypeOf(Contents)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      flyoutOffset: {
        top: undefined,
        right: undefined,
        bottom: undefined,
        left: undefined
      },
      caretOffset: {
        top: undefined,
        right: undefined,
        bottom: undefined,
        left: undefined
      },
      mainDir: null
    }, _this.setFlyoutPosition = function (props) {
      var relativeOffset = props.relativeOffset,
          idealDirection = props.idealDirection,
          positionRelativeToAnchor = props.positionRelativeToAnchor,
          triggerRect = props.triggerRect,
          width = props.width;

      // Scroll not needed for relative elements
      // We can't use window.scrollX / window.scrollY since it's not supported by IE11

      var scrollX = positionRelativeToAnchor ? 0 : window.pageXOffset || document.documentElement && document.documentElement.scrollLeft || 0;
      var scrollY = positionRelativeToAnchor ? 0 : window.pageYOffset || document.documentElement && document.documentElement.scrollTop || 0;

      var windowSize = {
        height: window.innerHeight,
        width: window.innerWidth,
        scrollX: scrollX,
        scrollY: scrollY
      };

      var flyoutSize = {
        height: _this.flyout ? _this.flyout.clientHeight : 0,
        width: width
      };

      // First choose one of 4 main direction
      var mainDir = getMainDir(flyoutSize, idealDirection, triggerRect, windowSize);

      // Now that we have the main direction, chose from 3 caret placements for that direction
      var subDir = getSubDir(flyoutSize, mainDir, triggerRect, windowSize);

      // Gets the base offset that positions the flyout based on the main direction only
      var base = baseOffsets(relativeOffset, flyoutSize, mainDir, triggerRect, windowSize);

      // Gets the edge shifts for the flyout
      var edgeShifts = calcEdgeShifts(subDir, triggerRect, windowSize);

      // Adjusts for the subdirection of the caret

      var _adjustOffsets = adjustOffsets(base, edgeShifts, flyoutSize, mainDir, subDir, triggerRect),
          flyoutOffset = _adjustOffsets.flyoutOffset,
          caretOffset = _adjustOffsets.caretOffset;

      _this.setState({
        caretOffset: caretOffset,
        flyoutOffset: flyoutOffset,
        mainDir: mainDir
      });
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(Contents, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      this.setFlyoutPosition(this.props);
      setTimeout(function () {
        if (_this2.props.shouldFocus && _this2.flyout) {
          _this2.flyout.focus();
        }
      });
      window.addEventListener('resize', this.props.onResize);
      window.addEventListener('keydown', this.props.onKeyDown);
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      this.setFlyoutPosition(nextProps);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      window.removeEventListener('resize', this.props.onResize);
      window.removeEventListener('keydown', this.props.onKeyDown);
    }

    /**
     * Determines the main direciton, sub direction, and corresponding offsets needed
     * to correctly position the offset
     */

  }, {
    key: 'render',
    value: function render() {
      var _this3 = this;

      var _props = this.props,
          bgColor = _props.bgColor,
          children = _props.children,
          width = _props.width;

      // Needed to prevent UI thrashing

      var visibility = this.state.mainDir === null ? 'hidden' : 'visible';
      var background = bgColor + 'Bg';
      var stroke = bgColor === 'white' ? '#efefef' : null;
      var borderColor = bgColor === 'white' ? 'lightGray' : bgColor;

      return createElement(
        'div',
        {
          className: styles$a.container,
          style: _extends({ stroke: stroke, visibility: visibility }, this.state.flyoutOffset)
        },
        createElement(
          'div',
          {
            className: classnames(colors[background], colors[borderColor], styles$a.dimensions, styles$a.contents),
            ref: function ref(c) {
              _this3.flyout = c;
            },
            tabIndex: -1
          },
          createElement(
            'div',
            {
              className: classnames(styles$a.dimensions, styles$a.innerContents),
              style: { width: width }
            },
            children
          ),
          createElement(
            'div',
            {
              className: classnames(colors[bgColor], styles$a.caret),
              style: _extends({}, this.state.caretOffset)
            },
            createElement(Caret, { direction: this.state.mainDir })
          )
        )
      );
    }
  }]);
  return Contents;
}(Component);
Contents.propTypes = {
  bgColor: PropTypes.oneOf(['blue', 'darkGray', 'orange', 'white']),
  children: PropTypes.node,
  idealDirection: PropTypes.oneOf(['up', 'right', 'down', 'left']),
  onKeyDown: PropTypes.func.isRequired,
  onResize: PropTypes.func.isRequired,
  relativeOffset: PropTypes.exact({ x: PropTypes.number, y: PropTypes.number }),
  positionRelativeToAnchor: PropTypes.bool,
  shouldFocus: PropTypes.bool,
  triggerRect: PropTypes.exact({
    bottom: PropTypes.number,
    height: PropTypes.number,
    left: PropTypes.number,
    right: PropTypes.number,
    top: PropTypes.number,
    width: PropTypes.number
  }),
  width: PropTypes.number
};

var OutsideEventBehavior = function (_React$Component) {
  inherits(OutsideEventBehavior, _React$Component);

  function OutsideEventBehavior() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, OutsideEventBehavior);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = OutsideEventBehavior.__proto__ || Object.getPrototypeOf(OutsideEventBehavior)).call.apply(_ref, [this].concat(args))), _this), _this.handleClickEvent = function (event) {
      // eslint-disable-next-line react/no-find-dom-node
      var el = findDOMNode(_this);
      if (!_this.props.onClick || !el || event.target instanceof Node && el.contains(event.target)) {
        return;
      }
      _this.props.onClick(event);
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(OutsideEventBehavior, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      document.addEventListener('click', this.handleClickEvent, {
        capture: true
      });
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      document.removeEventListener('click', this.handleClickEvent, {
        capture: true
      });
    }
  }, {
    key: 'render',
    value: function render() {
      return this.props.children;
    }
  }]);
  return OutsideEventBehavior;
}(Component);

var SIZE_WIDTH_MAP = {
  xs: 185,
  sm: 230,
  md: 284,
  lg: 320,
  xl: 375
};

var ESCAPE_KEY_CODE = 27;

var Controller = function (_React$Component) {
  inherits(Controller, _React$Component);

  function Controller() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, Controller);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Controller.__proto__ || Object.getPrototypeOf(Controller)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      relativeOffset: {
        x: 0,
        y: 0
      },
      triggerBoundingRect: {
        bottom: 0,
        height: 0,
        left: 0,
        right: 0,
        top: 0,
        width: 0
      }
    }, _this.handleKeyDown = function (event) {
      if (event.keyCode === ESCAPE_KEY_CODE) {
        _this.props.onDismiss();
      }
    }, _this.handlePageClick = function (event) {
      if (event.target instanceof Node && _this.props.anchor && !_this.props.anchor.contains(event.target)) {
        _this.props.onDismiss();
      }
    }, _this.handleResize = function () {
      _this.updateTriggerRect(_this.props);
    }, _this.updateTriggerRect = function (props) {
      var anchor = props.anchor,
          positionRelativeToAnchor = props.positionRelativeToAnchor;

      var triggerBoundingRect = void 0;
      var relativeOffset = void 0;
      if (anchor) {
        triggerBoundingRect = anchor.getBoundingClientRect();

        // Needed for correct positioning within Contents.js
        relativeOffset = {
          x: positionRelativeToAnchor ? triggerBoundingRect.left - anchor.offsetLeft : 0,
          y: positionRelativeToAnchor ? triggerBoundingRect.top - anchor.offsetTop : 0
        };
      }

      _this.setState({ relativeOffset: relativeOffset, triggerBoundingRect: triggerBoundingRect });
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(Controller, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.updateTriggerRect(this.props);
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      this.updateTriggerRect(nextProps);
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          anchor = _props.anchor,
          bgColor = _props.bgColor,
          children = _props.children,
          idealDirection = _props.idealDirection,
          positionRelativeToAnchor = _props.positionRelativeToAnchor,
          shouldFocus = _props.shouldFocus;

      if (!anchor) {
        return null;
      }
      var size = this.props.size ? this.props.size : 'sm';
      var width = typeof size === 'string' ? SIZE_WIDTH_MAP[size] : size;
      return createElement(
        OutsideEventBehavior,
        { onClick: this.handlePageClick },
        createElement(
          Contents,
          {
            bgColor: bgColor,
            idealDirection: idealDirection,
            onKeyDown: this.handleKeyDown,
            onResize: this.handleResize,
            positionRelativeToAnchor: positionRelativeToAnchor,
            relativeOffset: this.state.relativeOffset,
            shouldFocus: shouldFocus,
            triggerRect: this.state.triggerBoundingRect,
            width: width
          },
          children
        )
      );
    }
  }]);
  return Controller;
}(Component);


Controller.propTypes = {
  anchor: PropTypes.shape({
    contains: PropTypes.func,
    getBoundingClientRect: PropTypes.func
  }),
  bgColor: PropTypes.oneOf(['blue', 'darkGray', 'orange', 'white']),
  children: PropTypes.node,
  idealDirection: PropTypes.oneOf(['up', 'right', 'down', 'left']),
  onDismiss: PropTypes.func.isRequired,
  positionRelativeToAnchor: PropTypes.bool,
  shouldFocus: PropTypes.bool,
  size: PropTypes.oneOfType([PropTypes.number, PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl'])] // default: sm
  )
};

function Flyout(props) {
  var anchor = props.anchor,
      children = props.children,
      idealDirection = props.idealDirection,
      onDismiss = props.onDismiss,
      _props$positionRelati = props.positionRelativeToAnchor,
      positionRelativeToAnchor = _props$positionRelati === undefined ? true : _props$positionRelati,
      _props$color = props.color,
      color = _props$color === undefined ? 'white' : _props$color,
      _props$shouldFocus = props.shouldFocus,
      shouldFocus = _props$shouldFocus === undefined ? true : _props$shouldFocus,
      size = props.size;


  if (!anchor) {
    return null;
  }

  return createElement(
    Controller,
    {
      anchor: anchor,
      bgColor: color,
      idealDirection: idealDirection,
      onDismiss: onDismiss,
      positionRelativeToAnchor: positionRelativeToAnchor,
      shouldFocus: shouldFocus,
      size: size
    },
    children
  );
}

Flyout.propTypes = {
  anchor: PropTypes.shape({
    contains: PropTypes.func,
    getBoundingClientRect: PropTypes.func
  }),
  children: PropTypes.node,
  idealDirection: PropTypes.oneOf(['up', 'right', 'down', 'left']),
  onDismiss: PropTypes.func.isRequired,
  positionRelativeToAnchor: PropTypes.bool,
  color: PropTypes.oneOf(['blue', 'orange', 'white', 'darkGray']),
  size: PropTypes.oneOfType([PropTypes.number, PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl'])] // default: sm
  )
};

var styles$b = { "wash": "_te _4h _4j _4m _4k _4l" };

function zip(a, b) {
  return a.map(function (item, idx) {
    return [item, b[idx]];
  });
}

var BORDER_WIDTH = 2;

var AVATAR_SIZES = {
  sm: 24,
  md: 40,
  lg: 72
};

var avatarLayout = function avatarLayout(n, size) {
  switch (n) {
    case 0:
    case 1:
      return [{ top: 0, left: 0, width: size, height: size, textLayout: 'center' }];
    case 2:
      return [{
        top: 0,
        left: 0,
        width: 'calc(50% - ' + BORDER_WIDTH / 2 + 'px)',
        height: size,
        textLayout: 'center'
      }, {
        top: 0,
        left: 'calc(50% + ' + BORDER_WIDTH / 2 + 'px)',
        width: 'calc(50% - ' + BORDER_WIDTH / 2 + 'px)',
        height: size,
        textLayout: 'center'
      }];
    default:
      return [{
        top: 0,
        left: 0,
        width: 'calc(50% - ' + BORDER_WIDTH / 2 + 'px)',
        height: size,
        textLayout: 'center'
      }, {
        top: 0,
        left: 'calc(50% + ' + BORDER_WIDTH / 2 + 'px)',
        width: 'calc(50%)',
        height: 'calc(50% - ' + BORDER_WIDTH / 2 + 'px)',
        textLayout: 'topLeft'
      }, {
        top: 'calc(50% + ' + BORDER_WIDTH / 2 + 'px)',
        left: 'calc(50% + ' + BORDER_WIDTH / 2 + 'px)',
        width: 'calc(50%)',
        height: 'calc(50% - ' + BORDER_WIDTH / 2 + 'px)',
        textLayout: 'bottomLeft'
      }];
  }
};

var degToRad = function degToRad(deg) {
  return deg * (Math.PI / 180);
};

var DefaultAvatar$1 = function DefaultAvatar(props) {
  var size = props.size,
      name = props.name,
      textLayout = props.textLayout;


  var quarterPadding = 'calc(' + Math.sin(degToRad(45)) + ' * (' + size + ') / 2)';

  var initial = createElement(
    'svg',
    {
      width: '100%',
      viewBox: '-50 -50 100 100',
      version: '1.1',
      preserveAspectRatio: 'xMidYMid meet',
      xmlns: 'http://www.w3.org/2000/svg'
    },
    createElement(
      'title',
      null,
      name
    ),
    createElement(
      'text',
      {
        fontSize: '50px',
        fill: '#fff',
        dominantBaseline: 'central',
        textAnchor: 'middle',
        className: [typography.antialiased, typography.sansSerif, typography.leadingSmall, typography.fontWeightBold].join(' ')
      },
      name ? [].concat(toConsumableArray(name))[0].toUpperCase() : ''
    )
  );
  switch (textLayout) {
    case 'bottomLeft':
      return createElement(
        Box,
        {
          'aria-label': name,
          color: 'gray',
          height: '100%',
          display: 'flex',
          alignItems: 'end',
          dangerouslySetInlineStyle: {
            __style: {
              paddingBottom: quarterPadding,
              paddingRight: quarterPadding
            }
          }
        },
        initial
      );
    case 'topLeft':
      return createElement(
        Box,
        {
          'aria-label': name,
          color: 'gray',
          height: '100%',
          display: 'flex',
          alignItems: 'start',
          dangerouslySetInlineStyle: {
            __style: {
              paddingTop: quarterPadding,
              paddingRight: quarterPadding
            }
          }
        },
        initial
      );
    default:
      return createElement(
        Box,
        {
          'aria-label': name,
          color: 'gray',
          height: '100%',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center'
        },
        initial
      );
  }
};

function GroupAvatar(props) {
  var collaborators = props.collaborators,
      outline = props.outline,
      size = props.size;

  var avatarWidth = size ? AVATAR_SIZES[size] : '100%';
  var avatarHeight = size ? AVATAR_SIZES[size] : '';
  var positions = avatarLayout(collaborators.length, avatarWidth);
  return createElement(
    Box,
    {
      color: 'white',
      overflow: 'hidden',
      shape: 'circle',
      width: avatarWidth,
      height: avatarHeight,
      position: 'relative',
      dangerouslySetInlineStyle: {
        __style: _extends({}, outline ? { boxShadow: '0 0 0 2px #fff' } : {}, {
          // willChange: transform fixes a strange behavior where the border of the children
          // are not properly trimmed even though overflow: hidden is set
          willChange: 'transform'
        })
      }
    },
    createElement(Box, { dangerouslySetInlineStyle: { __style: { paddingBottom: '100%' } } }),
    zip(positions, collaborators).map(function (_ref, idx) {
      var _ref2 = slicedToArray(_ref, 2),
          position = _ref2[0],
          _ref2$ = _ref2[1],
          collaborator = _ref2$ === undefined ? { name: '', src: undefined } : _ref2$;

      var width = position.width,
          height = position.height,
          top = position.top,
          left = position.left,
          textLayout = position.textLayout;
      var name = collaborator.name,
          src = collaborator.src;

      return createElement(
        Box,
        {
          key: idx,
          position: 'absolute',
          width: width,
          height: height,
          dangerouslySetInlineStyle: { __style: { top: top, left: left } }
        },
        src ? createElement(Image, {
          alt: name,
          color: '#EFEFEF',
          src: src,
          naturalWidth: 1,
          naturalHeight: 1,
          fit: 'cover'
        }) : createElement(DefaultAvatar$1, {
          name: name,
          textLayout: textLayout,
          size: height
        }),
        createElement('div', { className: styles$b.wash })
      );
    })
  );
}

GroupAvatar.propTypes = {
  collaborators: PropTypes.arrayOf(PropTypes.exact({
    name: PropTypes.string.isRequired,
    src: PropTypes.string
  })).isRequired,
  outline: PropTypes.bool,
  size: PropTypes.oneOf(['sm', 'md', 'lg'])
};

var styles$c = { "Heading": "_tf _0 _1 _2", "fontSize1": "_tg", "fontSize2": "_th", "fontSize3": "_ti", "fontSize4": "_tj", "fontSize5": "_tk", "smFontSize1": "_tl", "smFontSize2": "_tm", "smFontSize3": "_tn", "smFontSize4": "_to", "smFontSize5": "_tp", "mdFontSize1": "_tq", "mdFontSize2": "_tr", "mdFontSize3": "_ts", "mdFontSize4": "_tt", "mdFontSize5": "_tu", "lgFontSize1": "_tv", "lgFontSize2": "_tw", "lgFontSize3": "_tx", "lgFontSize4": "_ty", "lgFontSize5": "_tz" };

var defaultHeadingLevels = {
  xs: 5,
  sm: 4,
  md: 3,
  lg: 2,
  xl: 1
};

var SIZE_SCALE$1 = {
  xs: 1,
  sm: 2,
  md: 3,
  lg: 4,
  xl: 5
};

function Heading(props) {
  var accessibilityLevel = props.accessibilityLevel,
      children = props.children,
      _props$color = props.color,
      color = _props$color === undefined ? 'darkGray' : _props$color,
      _props$id = props.id,
      id = _props$id === undefined ? null : _props$id,
      lgSize = props.lgSize,
      mdSize = props.mdSize,
      _props$overflow = props.overflow,
      overflow = _props$overflow === undefined ? 'breakWord' : _props$overflow,
      _props$size = props.size,
      size = _props$size === undefined ? 'md' : _props$size,
      smSize = props.smSize,
      _props$truncate = props.truncate,
      truncate = _props$truncate === undefined ? false : _props$truncate;


  var cs = classnames(styles$c.Heading, styles$c['fontSize' + SIZE_SCALE$1[size]], smSize && styles$c['smFontSize' + SIZE_SCALE$1[smSize]], mdSize && styles$c['mdFontSize' + SIZE_SCALE$1[mdSize]], lgSize && styles$c['lgFontSize' + SIZE_SCALE$1[lgSize]], colors[color], overflow === 'breakWord' && typography.breakWord, truncate && typography.truncate);

  var headingLevel = accessibilityLevel || defaultHeadingLevels[size];
  return createElement('h' + headingLevel, _extends({
    className: cs,
    id: id
  }, truncate && typeof children === 'string' ? { title: children } : null), children);
}

Heading.propTypes = {
  accessibilityLevel: PropTypes.oneOf([1, 2, 3, 4, 5, 6]),
  children: PropTypes.node,
  color: PropTypes.oneOf(['blue', 'darkGray', 'eggplant', 'gray', 'green', 'lightGray', 'maroon', 'midnight', 'navy', 'olive', 'orange', 'orchid', 'pine', 'purple', 'red', 'watermelon', 'white']),
  id: PropTypes.string,
  overflow: PropTypes.oneOf(['normal', 'breakWord']),
  size: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl']),
  smSize: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl']),
  mdSize: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl']),
  lgSize: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl']),
  truncate: PropTypes.bool
};

var styles$d = { "button": "_u2 _45 _33 _oi _z9" };

var styles$e = { "pog": "_um _2w _4s _50 _5a", "focused": "_un _xv", "transparent": "_uo _42", "hovered": "_up", "white": "_uq _37", "active": "_ur", "lightGray": "_us _39", "gray": "_ut _3b" };

var SIZE_NAME_TO_PIXEL = {
  xs: 24,
  sm: 32,
  md: 40,
  lg: 48,
  xl: 56
};

var defaultIconButtonIconColors = {
  transparent: 'gray',
  gray: 'white',
  lightGray: 'gray',
  white: 'gray'
};

function Pog(props) {
  var _classnames;

  var _props$active = props.active,
      active = _props$active === undefined ? false : _props$active,
      _props$bgColor = props.bgColor,
      bgColor = _props$bgColor === undefined ? 'transparent' : _props$bgColor,
      _props$focused = props.focused,
      focused = _props$focused === undefined ? false : _props$focused,
      _props$hovered = props.hovered,
      hovered = _props$hovered === undefined ? false : _props$hovered,
      _props$iconColor = props.iconColor,
      iconColor = _props$iconColor === undefined ? defaultIconButtonIconColors[bgColor] : _props$iconColor,
      icon = props.icon,
      _props$size = props.size,
      size = _props$size === undefined ? 'md' : _props$size;


  var iconSize = SIZE_NAME_TO_PIXEL[size] / 2;

  var inlineStyle = {
    height: SIZE_NAME_TO_PIXEL[size],
    width: SIZE_NAME_TO_PIXEL[size]
  };

  var classes = classnames(styles$e.pog, styles$e[bgColor], (_classnames = {}, defineProperty(_classnames, styles$e.active, active), defineProperty(_classnames, styles$e.focused, focused), defineProperty(_classnames, styles$e.hovered, hovered && !focused && !active), _classnames));

  return createElement(
    'div',
    { className: classes, style: inlineStyle },
    createElement(
      Box,
      { shape: 'circle' },
      createElement(Icon, {
        color: iconColor,
        icon: icon,
        size: iconSize,
        accessibilityLabel: ''
      })
    )
  );
}

Pog.propTypes = {
  active: PropTypes.bool,
  bgColor: PropTypes.oneOf(['transparent', 'gray', 'lightGray', 'white']),
  focused: PropTypes.bool,
  hovered: PropTypes.bool,
  iconColor: PropTypes.oneOf(['gray', 'darkGray', 'red', 'blue', 'white']),
  icon: PropTypes.oneOf(Object.keys(icons)).isRequired,
  size: PropTypes.oneOf(Object.keys(SIZE_NAME_TO_PIXEL))
};

var IconButton = function (_React$Component) {
  inherits(IconButton, _React$Component);

  function IconButton() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, IconButton);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = IconButton.__proto__ || Object.getPrototypeOf(IconButton)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      active: false,
      focused: false,
      hovered: false
    }, _this.handleBlur = function () {
      return _this.setState({ focused: false });
    }, _this.handleFocus = function () {
      _this.setState({ focused: true });
    }, _this.handleMouseDown = function () {
      _this.setState({ active: true });
    }, _this.handleMouseEnter = function () {
      _this.setState({ hovered: true });
    }, _this.handleMouseLeave = function () {
      _this.setState({
        active: false,
        hovered: false
      });
    }, _this.handleMouseUp = function () {
      _this.setState({ active: false });
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(IconButton, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          accessibilityExpanded = _props.accessibilityExpanded,
          accessibilityHaspopup = _props.accessibilityHaspopup,
          accessibilityLabel = _props.accessibilityLabel,
          bgColor = _props.bgColor,
          iconColor = _props.iconColor,
          icon = _props.icon,
          size = _props.size,
          onClick = _props.onClick;
      var _state = this.state,
          active = _state.active,
          focused = _state.focused,
          hovered = _state.hovered;


      return createElement(
        'button',
        {
          'aria-expanded': accessibilityExpanded,
          'aria-haspopup': accessibilityHaspopup,
          'aria-label': accessibilityLabel,
          className: styles$d.button,
          onBlur: this.handleBlur,
          onClick: function (_onClick) {
            function onClick(_x) {
              return _onClick.apply(this, arguments);
            }

            onClick.toString = function () {
              return _onClick.toString();
            };

            return onClick;
          }(function (event) {
            return onClick && onClick({ event: event });
          }),
          onFocus: this.handleFocus,
          onMouseDown: this.handleMouseDown,
          onMouseEnter: this.handleMouseEnter,
          onMouseLeave: this.handleMouseLeave,
          onMouseUp: this.handleMouseUp,
          title: accessibilityLabel,
          type: 'button'
        },
        createElement(Pog, {
          active: active,
          bgColor: bgColor,
          focused: focused,
          hovered: hovered,
          iconColor: iconColor,
          icon: icon,
          size: size
        })
      );
    }
  }]);
  return IconButton;
}(Component);

IconButton.propTypes = {
  accessibilityExpanded: PropTypes.bool,
  accessibilityHaspopup: PropTypes.bool,
  accessibilityLabel: PropTypes.string.isRequired,
  bgColor: PropTypes.oneOf(['transparent', 'gray', 'lightGray', 'white']),
  icon: PropTypes.oneOf(Object.keys(icons)).isRequired,
  iconColor: PropTypes.oneOf(['gray', 'darkGray', 'red', 'blue', 'white']),
  onClick: PropTypes.func,
  size: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl'])
};

var styles$f = { "label": "_u7 _45 _z9" };

function Label(props) {
  var children = props.children,
      htmlFor = props.htmlFor;


  return createElement(
    'label',
    { className: styles$f.label, htmlFor: htmlFor },
    children
  );
}

Label.propTypes = {
  children: PropTypes.node,
  htmlFor: PropTypes.string.isRequired
};

var Layer = function (_React$Component) {
  inherits(Layer, _React$Component);

  function Layer(props) {
    classCallCheck(this, Layer);

    var _this = possibleConstructorReturn(this, (Layer.__proto__ || Object.getPrototypeOf(Layer)).call(this, props));

    _this.state = {
      mounted: false
    };

    if (typeof document !== 'undefined' && document.createElement) {
      _this.el = document.createElement('div');
    } else {
      // eslint-disable-next-line no-console
      console.warn('Using Layer without document present. Children will not be rendered.');
    }
    return _this;
  }

  createClass(Layer, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      if (typeof document !== 'undefined' && document.body) {
        document.body.appendChild(this.el);
        this.setState({ mounted: true });
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      if (document.body) {
        document.body.removeChild(this.el);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var children = this.props.children;

      return this.state.mounted && createPortal(children, this.el);
    }
  }]);
  return Layer;
}(Component);

/*
  Much of the math and understanding about this component comes from @vjeaux's
  excellent blog post on image resizing.

  http://blog.vjeux.com/2013/image/css-container-and-cover.html

  I highly recommend you read that first before continuing on reading.
*/

var aspectRatio = function aspectRatio(width, height) {
  return width / height;
};

function Letterbox(_ref) {
  var children = _ref.children,
      contentAspectRatio = _ref.contentAspectRatio,
      height = _ref.height,
      width = _ref.width;

  var viewportAspectRatio = aspectRatio(width, height);

  var contentHeight = void 0;
  var contentWidth = void 0;

  if (contentAspectRatio < viewportAspectRatio) {
    contentWidth = width;
    contentHeight = width / contentAspectRatio;
  } else {
    contentWidth = height * contentAspectRatio;
    contentHeight = height;
  }

  var offsetTop = (contentHeight - height) / -2;
  var offsetLeft = (contentWidth - width) / -2;

  return createElement(
    Mask,
    { width: width, height: height },
    createElement(
      'div',
      { style: { marginTop: offsetTop, marginLeft: offsetLeft } },
      createElement(
        Mask,
        { width: contentWidth, height: contentHeight },
        children
      )
    )
  );
}

Letterbox.propTypes = {
  children: PropTypes.node,
  contentAspectRatio: PropTypes.number.isRequired,
  height: PropTypes.number.isRequired,
  width: PropTypes.number.isRequired
};

var styles$g = { "link": "_u8 _a", "accessibleFocusStyle": "_u9 _xu", "block": "_ua _45" };

var TAB_KEY_CODE = 9;

var Link = function (_React$Component) {
  inherits(Link, _React$Component);

  function Link() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, Link);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Link.__proto__ || Object.getPrototypeOf(Link)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      enableFocusStyles: true
    }, _this.handleClick = function (event) {
      var _this$props = _this.props,
          href = _this$props.href,
          onClick = _this$props.onClick;

      if (onClick && href) {
        onClick({ event: event });
      }
    }, _this.handleMouseDown = function () {
      var _this$props2 = _this.props,
          href = _this$props2.href,
          target = _this$props2.target;

      if (target === 'blank' && href) {
        _this.setState({ enableFocusStyles: false });
      }
    }, _this.handleKeyUp = function (event) {
      var _this$props3 = _this.props,
          href = _this$props3.href,
          target = _this$props3.target;

      if (target === 'blank' && event.keyCode === TAB_KEY_CODE && href) {
        _this.setState({ enableFocusStyles: true });
      }
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(Link, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          children = _props.children,
          _props$inline = _props.inline,
          inline = _props$inline === undefined ? false : _props$inline,
          _props$target = _props.target,
          target = _props$target === undefined ? null : _props$target,
          href = _props.href;

      var rel = target === 'blank' ? 'noopener noreferrer' : null;
      var linkTarget = target ? '_' + target : null;

      return createElement(
        'a',
        {
          className: classnames(styles$g.link, this.state.enableFocusStyles ? styles$g.accessibleFocusStyle : '', inline ? '' : styles$g.block),
          href: href,
          onMouseDown: this.handleMouseDown,
          onKeyUp: this.handleKeyUp,
          onClick: this.handleClick,
          rel: rel,
          target: linkTarget
        },
        children
      );
    }
  }]);
  return Link;
}(Component);

Link.propTypes = {
  children: PropTypes.node.isRequired,
  href: PropTypes.string.isRequired,
  inline: PropTypes.bool,
  onClick: PropTypes.func,
  target: PropTypes.oneOf([null, 'self', 'blank'])
};

/**
 * debounce prevents a particular function from being called until after a given
 * cooldown period (default 100ms). Every time the function is called, it resets
 * the cooldown.
 */

function debounce(fn) {
  var threshhold = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;

  var deferTimer = null;

  var debounced = function debounced() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (deferTimer) {
      clearTimeout(deferTimer);
    }

    deferTimer = setTimeout(function () {
      deferTimer = null;
      fn.apply(undefined, toConsumableArray(args));
    }, threshhold);
  };

  debounced.clearTimeout = function () {
    if (deferTimer) {
      clearTimeout(deferTimer);
    }
  };

  return debounced;
}

/**
 * FetchItems is a logic component that renders no content itself. Its job
 * is to manage when the given fetchMore method should be called based on
 * the given scroll/size props.
 *
 * While no element is actually passed to FetchItems, it is intended to be used
 * in conjunction with a large scroll container that uses async fetching to
 * load and render additional data. Based on the height of this container and
 * its current scroll position, FetchItems is responsible for triggering future
 * fetch calls.
 */

var FetchItems = function (_React$PureComponent) {
  inherits(FetchItems, _React$PureComponent);

  function FetchItems() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, FetchItems);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = FetchItems.__proto__ || Object.getPrototypeOf(FetchItems)).call.apply(_ref, [this].concat(args))), _this), _this.check = function () {
      var _this$props = _this.props,
          containerHeight = _this$props.containerHeight,
          isAtEnd = _this$props.isAtEnd,
          isFetching = _this$props.isFetching,
          fetchMore = _this$props.fetchMore,
          scrollHeight = _this$props.scrollHeight,
          scrollTop = _this$props.scrollTop;


      if (isAtEnd || isFetching || !fetchMore) {
        return;
      }
      var scrollBuffer = containerHeight * 3;

      if (scrollTop + scrollBuffer > scrollHeight) {
        fetchMore();
      }
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(FetchItems, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      setTimeout(this.check);
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate() {
      this.check();
    }
  }, {
    key: 'render',
    value: function render() {
      return null;
    }
  }]);
  return FetchItems;
}(PureComponent);

FetchItems.propTypes = {
  containerHeight: PropTypes.number.isRequired,
  isAtEnd: PropTypes.bool,
  isFetching: PropTypes.bool.isRequired,
  fetchMore: PropTypes.func,
  scrollHeight: PropTypes.number.isRequired,
  scrollTop: PropTypes.number.isRequired
};

var styles$h = { "Masonry": "_ug _4f", "Masonry__Item": "_uh _4h", "Masonry__Item__Mounted": "_ui" };

/**
 * ScrollContainer is a pass-through component that simply sets up an onScroll
 * handler on the given scrollContainer element (or the element that is
 * returned as result of calling the scrollContainer method). This allows for
 * the event listener subscription of the scrollContainer to be managed inside
 * the React lifecycle without adding bloat to Masonry or other onScroll
 * subscribers.
 *
 * Note that this Component renders its children without creating any
 * additional content. Also note that, while the component is built to manage
 * onScroll inside of the React lifecycle, it doesn't change onScroll events
 * or the API at all, so it could easily be adapted to other event types.
 */

function getScrollContainer(scrollContainer) {
  return typeof scrollContainer === 'function' ? scrollContainer() : scrollContainer;
}

var ScrollContainer = function (_React$Component) {
  inherits(ScrollContainer, _React$Component);

  function ScrollContainer() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, ScrollContainer);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ScrollContainer.__proto__ || Object.getPrototypeOf(ScrollContainer)).call.apply(_ref, [this].concat(args))), _this), _this.getScrollContainerRef = function () {
      return _this.scrollContainer;
    }, _this.handleScroll = function (event) {
      _this.props.onScroll(event);
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(ScrollContainer, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var scrollContainer = getScrollContainer(this.props.scrollContainer);
      if (scrollContainer) {
        this.updateScrollContainer(scrollContainer);
      }
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate() {
      var nextScrollContainer = getScrollContainer(this.props.scrollContainer);
      if (nextScrollContainer && nextScrollContainer !== this.scrollContainer) {
        this.updateScrollContainer(nextScrollContainer);
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      if (this.scrollContainer) {
        this.scrollContainer.removeEventListener('scroll', this.handleScroll);
      }
    }
  }, {
    key: 'updateScrollContainer',
    value: function updateScrollContainer(scrollContainer) {
      if (this.scrollContainer) {
        // cleanup existing scroll container if it exists
        this.scrollContainer.removeEventListener('scroll', this.handleScroll);
      }
      this.scrollContainer = scrollContainer;
      this.scrollContainer.addEventListener('scroll', this.handleScroll);
    }
  }, {
    key: 'render',
    value: function render() {
      return Children.only(this.props.children);
    }
  }]);
  return ScrollContainer;
}(Component);

ScrollContainer.propTypes = {
  children: PropTypes.node.isRequired,
  onScroll: PropTypes.func.isRequired,
  scrollContainer: PropTypes.oneOfType([PropTypes.object, PropTypes.func]).isRequired
};

/**
 * throttle limits the number of times a function can be called to a
 * given threshhold (100ms by default). The function is always called
 * on the leading and trailing edge.
 */

function throttle(fn) {
  var threshhold = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;

  var last = void 0;
  var deferTimer = void 0;
  var throttled = function throttled() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var now = Date.now();
    if (last !== undefined && now - last < threshhold) {
      clearTimeout(deferTimer);
      deferTimer = setTimeout(function () {
        last = now;
        fn.apply(undefined, toConsumableArray(args));
      }, threshhold - (now - last));
    } else {
      last = now;
      fn.apply(undefined, toConsumableArray(args));
    }
  };

  throttled.clearTimeout = function () {
    if (deferTimer) {
      clearTimeout(deferTimer);
    }
  };

  return throttled;
}

var MeasurementStore = function () {
  function MeasurementStore() {
    classCallCheck(this, MeasurementStore);
    this.map = new WeakMap();
  }

  createClass(MeasurementStore, [{
    key: 'get',
    value: function get$$1(key) {
      return this.map.get(key);
    }
  }, {
    key: 'has',
    value: function has(key) {
      return this.map.has(key);
    }
  }, {
    key: 'set',
    value: function set$$1(key, value) {
      this.map.set(key, value);
    }
  }, {
    key: 'reset',
    value: function reset() {
      this.map = new WeakMap();
    }
  }]);
  return MeasurementStore;
}();

/**
 * Measuring scroll positions, element heights, etc is different between
 * different browsers and the window object vs other DOM nodes. These
 * utils abstract away these differences.
 */

function getElementHeight(element) {
  return element === window ? window.innerHeight : element.clientHeight;
}

function getWindowScrollPos() {
  if (window.scrollY !== undefined) {
    // Modern browser
    return window.scrollY;
  }
  if (document.documentElement && document.documentElement.scrollTop !== undefined) {
    // IE support.
    return document.documentElement.scrollTop;
  }
  return 0;
}

function getRelativeScrollTop(element) {
  return element === window ? getWindowScrollPos() : element.scrollTop - element.getBoundingClientRect().top;
}

function getScrollHeight(element) {
  return element === window && document.documentElement ? document.documentElement.scrollHeight : element.scrollHeight;
}

function getScrollPos(element) {
  return element === window ? getWindowScrollPos() : element.scrollTop;
}

var DefaultLayoutSymbol = Symbol('default');
var UniformRowLayoutSymbol = Symbol('uniformRow');

var mindex$1 = function mindex(arr) {
  var idx = 0;
  for (var i = 0; i < arr.length; i += 1) {
    if (arr[i] < arr[idx]) {
      idx = i;
    }
  }
  return idx;
};

var offscreen = function offscreen(width) {
  var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;
  return {
    top: -9999,
    left: -9999,
    width: width,
    height: height
  };
};

var defaultLayout = (function (_ref) {
  var cache = _ref.cache,
      _ref$columnWidth = _ref.columnWidth,
      columnWidth = _ref$columnWidth === undefined ? 236 : _ref$columnWidth,
      _ref$gutter = _ref.gutter,
      gutter = _ref$gutter === undefined ? 14 : _ref$gutter,
      _ref$minCols = _ref.minCols,
      minCols = _ref$minCols === undefined ? 2 : _ref$minCols,
      width = _ref.width;
  return function (items) {
    if (width == null) {
      return items.map(function () {
        return offscreen(columnWidth);
      });
    }

    var columnWidthAndGutter = columnWidth + gutter;
    var columnCount = Math.max(Math.floor((width + gutter) / columnWidthAndGutter), minCols);
    // the total height of each column
    var heights = new Array(columnCount).fill(0);
    var centerOffset = Math.max(Math.floor((width - columnWidthAndGutter * columnCount + gutter) / 2), 0);

    return items.reduce(function (acc, item) {
      var positions = acc;
      // $FlowFixMe
      var height = cache.get(item);
      var position = void 0;

      if (height == null) {
        position = offscreen(columnWidth);
      } else {
        var heightAndGutter = height + gutter;
        var col = mindex$1(heights);
        var _top = heights[col];
        var _left = col * columnWidthAndGutter + centerOffset;

        heights[col] += heightAndGutter;
        position = { top: _top, left: _left, width: columnWidth, height: height };
      }
      positions.push(position);
      return positions;
    }, []);
  };
});

var offscreen$1 = function offscreen(width) {
  var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;
  return {
    top: -9999,
    left: -9999,
    width: width,
    height: height
  };
};

var uniformRowLayout = (function (_ref) {
  var cache = _ref.cache,
      _ref$columnWidth = _ref.columnWidth,
      columnWidth = _ref$columnWidth === undefined ? 236 : _ref$columnWidth,
      _ref$gutter = _ref.gutter,
      gutter = _ref$gutter === undefined ? 14 : _ref$gutter,
      width = _ref.width,
      _ref$minCols = _ref.minCols,
      minCols = _ref$minCols === undefined ? 3 : _ref$minCols;
  return function (items) {
    if (width == null) {
      return items.map(function () {
        return offscreen$1(columnWidth);
      });
    }

    var columnWidthAndGutter = columnWidth + gutter;
    var columnCount = Math.max(Math.floor((width + gutter) / columnWidthAndGutter), minCols);

    var positions = [];
    var heights = [];

    for (var i = 0; i < items.length; i += 1) {
      var position = void 0;
      var _height = cache.get(items[i]);

      if (_height == null) {
        position = offscreen$1(columnWidth);
      } else {
        var column = i % columnCount;
        var row = Math.floor(i / columnCount);

        if (column === 0 || _height > heights[row]) {
          heights[row] = _height;
        }

        var _top = row > 0 ? heights.slice(0, row).reduce(function (sum, y) {
          return sum + y + gutter;
        }, 0) : 0;

        position = {
          top: _top,
          left: column * columnWidthAndGutter,
          width: columnWidth,
          height: _height
        };
      }
      positions.push(position);
    }
    return positions;
  };
});

var mindex$2 = function mindex(arr) {
  var idx = 0;
  for (var i = 0; i < arr.length; i += 1) {
    if (arr[i] < arr[idx]) {
      idx = i;
    }
  }
  return idx;
};

var fullWidthLayout = (function (_ref) {
  var _ref$gutter = _ref.gutter,
      gutter = _ref$gutter === undefined ? 0 : _ref$gutter,
      cache = _ref.cache,
      _ref$minCols = _ref.minCols,
      minCols = _ref$minCols === undefined ? 2 : _ref$minCols,
      _ref$idealColumnWidth = _ref.idealColumnWidth,
      idealColumnWidth = _ref$idealColumnWidth === undefined ? 240 : _ref$idealColumnWidth,
      width = _ref.width;

  if (width == null) {
    return function (items) {
      return items.map(function () {
        return {
          top: Infinity,
          left: Infinity,
          width: Infinity,
          height: Infinity
        };
      });
    };
  }

  // "This is kind of crazy!" - you
  // Yes, indeed. The "guessing" here is meant to replicate the pass that the
  // original implementation takes with CSS.
  var colguess = Math.floor(width / idealColumnWidth);
  var columnCount = Math.max(Math.floor((width - colguess * gutter) / idealColumnWidth), minCols);
  var columnWidth = Math.floor(width / columnCount);

  return function (items) {
    // the total height of each column
    var heights = new Array(columnCount).fill(0);

    return items.reduce(function (acc, item) {
      var positions = acc;
      var height = cache.get(item);
      var position = void 0;

      if (height == null) {
        position = {
          top: Infinity,
          left: Infinity,
          width: columnWidth,
          height: Infinity
        };
      } else {
        var col = mindex$2(heights);
        var _top = heights[col];
        var _left = col * columnWidth + gutter / 2;

        heights[col] += height;
        position = {
          top: _top,
          left: _left,
          width: columnWidth - gutter,
          height: height
        };
      }

      positions.push(position);
      return positions;
    }, []);
  };
});

var MasonryLayout = function MasonryLayout() {
  classCallCheck(this, MasonryLayout);
};

var UniformRowLayout = function UniformRowLayout() {
  classCallCheck(this, UniformRowLayout);
};

var RESIZE_DEBOUNCE = 300;
// Multiplied against container height.
// The amount of extra buffer space for populating visible items.
var VIRTUAL_BUFFER_FACTOR = 0.7;

var layoutNumberToCssDimension = function layoutNumberToCssDimension(n) {
  return n !== Infinity ? n : undefined;
};

/**
 * NOTE: This is to be replaced by MasonryInfiniteBeta when it is ready
 * NOTE: Please do not modify this or make sure changes in here are also
 *       replicated in MasonryBeta.
 */

var Masonry = function (_React$Component) {
  inherits(Masonry, _React$Component);
  createClass(Masonry, null, [{
    key: 'createMeasurementStore',
    value: function createMeasurementStore() {
      return new MeasurementStore();
    }

    /**
     * Delays resize handling in case the scroll container is still being resized.
     */

  }]);

  function Masonry(props) {
    classCallCheck(this, Masonry);

    var _this = possibleConstructorReturn(this, (Masonry.__proto__ || Object.getPrototypeOf(Masonry)).call(this, props));

    _this.handleResize = debounce(function () {
      if (_this.gridWrapper) {
        _this.setState({ width: _this.gridWrapper.clientWidth });
      }
    }, RESIZE_DEBOUNCE);
    _this.updateScrollPosition = throttle(function () {
      if (!_this.scrollContainer) {
        return;
      }
      var scrollContainer = _this.scrollContainer.getScrollContainerRef();

      if (!scrollContainer) {
        return;
      }

      _this.setState({
        scrollTop: getScrollPos(scrollContainer)
      });
    });
    _this.measureContainerAsync = debounce(function () {
      _this.measureContainer();
    }, 0);

    _this.setGridWrapperRef = function (ref) {
      _this.gridWrapper = ref;
    };

    _this.setScrollContainerRef = function (ref) {
      _this.scrollContainer = ref;
    };

    _this.fetchMore = function () {
      var loadItems = _this.props.loadItems;

      if (loadItems && typeof loadItems === 'function') {
        _this.setState({
          isFetching: true
        }, function () {
          return loadItems({ from: _this.props.items.length });
        });
      }
    };

    _this.renderMasonryComponent = function (itemData, idx, position) {
      var _this$props = _this.props,
          Component$$1 = _this$props.comp,
          virtualize = _this$props.virtualize,
          virtualBoundsTop = _this$props.virtualBoundsTop,
          virtualBoundsBottom = _this$props.virtualBoundsBottom;
      var top = position.top,
          left = position.left,
          width = position.width,
          height = position.height;


      var isVisible = void 0;
      if (_this.props.scrollContainer) {
        var virtualBuffer = _this.containerHeight * VIRTUAL_BUFFER_FACTOR;
        var offsetScrollPos = _this.state.scrollTop - _this.containerOffset;
        var viewportTop = virtualBoundsTop ? offsetScrollPos - virtualBoundsTop : offsetScrollPos - virtualBuffer;
        var viewportBottom = virtualBoundsBottom ? offsetScrollPos + _this.containerHeight + virtualBoundsBottom : offsetScrollPos + _this.containerHeight + virtualBuffer;

        isVisible = !(position.top + position.height < viewportTop || position.top > viewportBottom);
      } else {
        // if no scroll container is passed in, items should always be visible
        isVisible = true;
      }

      var itemComponent = createElement(
        'div',
        {
          key: 'item-' + idx,
          className: [styles$h.Masonry__Item, styles$h.Masonry__Item__Mounted].join(' '),
          'data-grid-item': true,
          style: {
            top: 0,
            left: 0,
            transform: 'translateX(' + left + 'px) translateY(' + top + 'px)',
            WebkitTransform: 'translateX(' + left + 'px) translateY(' + top + 'px)',
            width: layoutNumberToCssDimension(width),
            height: layoutNumberToCssDimension(height)
          }
        },
        createElement(Component$$1, { data: itemData, itemIdx: idx, isMeasuring: false })
      );

      return virtualize ? isVisible && itemComponent || null : itemComponent;
    };

    _this.containerHeight = 0;
    _this.containerOffset = 0;

    _this.state = {
      hasPendingMeasurements: props.items.some(function (item) {
        return !!item && !props.measurementStore.has(item);
      }),
      isFetching: false,
      // eslint-disable-next-line react/no-unused-state
      items: props.items,
      scrollTop: 0,
      width: undefined
    };
    return _this;
  }

  /**
   * Adds hooks after the component mounts.
   */


  createClass(Masonry, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      window.addEventListener('resize', this.handleResize);

      this.measureContainer();

      var scrollTop = this.state.scrollTop;

      if (this.scrollContainer != null) {
        var _scrollContainer = this.scrollContainer.getScrollContainerRef();
        if (_scrollContainer) {
          scrollTop = getScrollPos(_scrollContainer);
        }
      }

      this.setState(function (prevState) {
        return {
          scrollTop: scrollTop,
          width: _this2.gridWrapper ? _this2.gridWrapper.clientWidth : prevState.width
        };
      });
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps, prevState) {
      var _this3 = this;

      var _props = this.props,
          items = _props.items,
          measurementStore = _props.measurementStore;


      this.measureContainerAsync();

      if (prevState.width != null && this.state.width !== prevState.width) {
        measurementStore.reset();
      }
      // calculate whether we still have pending measurements
      var hasPendingMeasurements = items.some(function (item) {
        return !!item && !measurementStore.has(item);
      });
      if (hasPendingMeasurements || hasPendingMeasurements !== this.state.hasPendingMeasurements || prevState.width == null) {
        this.insertAnimationFrame = requestAnimationFrame(function () {
          _this3.setState({
            hasPendingMeasurements: hasPendingMeasurements
          });
        });
      }
    }

    /**
     * Remove listeners when unmounting.
     */

  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      if (this.insertAnimationFrame) {
        cancelAnimationFrame(this.insertAnimationFrame);
      }

      // Make sure async methods are cancelled.
      this.measureContainerAsync.clearTimeout();
      this.handleResize.clearTimeout();
      this.updateScrollPosition.clearTimeout();

      window.removeEventListener('resize', this.handleResize);
    }
  }, {
    key: 'measureContainer',
    value: function measureContainer() {
      if (this.scrollContainer != null) {
        var _scrollContainer2 = this.scrollContainer;

        var scrollContainerRef = _scrollContainer2.getScrollContainerRef();
        if (scrollContainerRef) {
          this.containerHeight = getElementHeight(scrollContainerRef);
          var el = this.gridWrapper;
          if (el instanceof HTMLElement) {
            var relativeScrollTop = getRelativeScrollTop(scrollContainerRef);
            this.containerOffset = el.getBoundingClientRect().top + relativeScrollTop;
          }
        }
      }
    }

    /**
     * Clear measurements/positions and force a reflow of the entire grid.
     * Only use this if absolutely necessary - ex: We need to reflow items if the
     * number of columns we would display should change after a resize.
     */

  }, {
    key: 'reflow',
    value: function reflow() {
      this.props.measurementStore.reset();
      this.measureContainer();
      this.forceUpdate();
    }
  }, {
    key: 'render',
    value: function render() {
      var _this4 = this;

      var _props2 = this.props,
          columnWidth = _props2.columnWidth,
          Component$$1 = _props2.comp,
          flexible = _props2.flexible,
          gutter = _props2.gutterWidth,
          measurementStore = _props2.measurementStore,
          items = _props2.items,
          minCols = _props2.minCols;
      var _state = this.state,
          hasPendingMeasurements = _state.hasPendingMeasurements,
          width = _state.width;


      var layout = void 0;
      if (flexible && width !== null) {
        layout = fullWidthLayout({
          gutter: gutter,
          cache: measurementStore,
          minCols: minCols,
          idealColumnWidth: columnWidth,
          width: width
        });
      } else if (this.props.layout === UniformRowLayoutSymbol || this.props.layout instanceof UniformRowLayout) {
        layout = uniformRowLayout({
          cache: measurementStore,
          columnWidth: columnWidth,
          gutter: gutter,
          minCols: minCols,
          width: width
        });
      } else {
        layout = defaultLayout({
          cache: measurementStore,
          columnWidth: columnWidth,
          gutter: gutter,
          minCols: minCols,
          width: width
        });
      }

      var gridBody = void 0;
      if (width == null && hasPendingMeasurements) {
        // When hyrdating from a server render, we don't have the width of the grid
        // and the measurement store is empty
        gridBody = createElement(
          'div',
          {
            className: styles$h.Masonry,
            style: { height: 0, width: '100%' },
            ref: this.setGridWrapperRef
          },
          items.filter(function (item) {
            return item;
          }).map(function (item, i) {
            return createElement(
              'div',
              { // keep this in sync with renderMasonryComponent
                className: 'static',
                'data-grid-item': true,
                key: i,
                style: {
                  top: 0,
                  left: 0,
                  transform: 'translateX(0px) translateY(0px)',
                  WebkitTransform: 'translateX(0px) translateY(0px)',
                  width: flexible ? undefined : layoutNumberToCssDimension(columnWidth) // we can't set a width for server rendered flexible items
                },
                ref: function ref(el) {
                  if (el && !flexible) {
                    // only measure flexible items on client
                    measurementStore.set(item, el.clientHeight);
                  }
                }
              },
              createElement(Component$$1, { data: item, itemIdx: i, isMeasuring: false })
            );
          })
        );
      } else if (width == null) {
        // When the width is empty (usually after a re-mount) render an empty
        // div to collect the width for layout
        gridBody = createElement('div', { style: { width: '100%' }, ref: this.setGridWrapperRef });
      } else {
        // Full layout is possible
        var itemsToRender = items.filter(function (item) {
          return item && measurementStore.has(item);
        });
        var itemsToMeasure = items.filter(function (item) {
          return item && !measurementStore.has(item);
        }).slice(0, minCols);

        var positions = layout(itemsToRender);
        var measuringPositions = layout(itemsToMeasure);
        // Math.max() === -Infinity when there are no positions
        var height = positions.length ? Math.max.apply(Math, toConsumableArray(positions.map(function (pos) {
          return pos.top + pos.height;
        }))) : 0;
        gridBody = createElement(
          'div',
          { style: { width: '100%' }, ref: this.setGridWrapperRef },
          createElement(
            'div',
            { className: styles$h.Masonry, style: { height: height, width: width } },
            itemsToRender.map(function (item, i) {
              return _this4.renderMasonryComponent(item, i, positions[i]);
            })
          ),
          createElement(
            'div',
            { className: styles$h.Masonry, style: { width: width } },
            itemsToMeasure.map(function (data, i) {
              // itemsToMeasure is always the length of minCols, so i will always be 0..minCols.length
              // we normalize the index here relative to the item list as a whole so that itemIdx is correct
              // and so that React doesnt reuse the measurement nodes
              var measurementIndex = itemsToRender.length + i;
              var position = measuringPositions[i];
              return createElement(
                'div',
                {
                  key: 'measuring-' + measurementIndex,
                  style: {
                    visibility: 'hidden',
                    position: 'absolute',
                    top: layoutNumberToCssDimension(position.top),
                    left: layoutNumberToCssDimension(position.left),
                    width: layoutNumberToCssDimension(position.width),
                    height: layoutNumberToCssDimension(position.height)
                  },
                  ref: function ref(el) {
                    if (el) {
                      measurementStore.set(data, el.clientHeight);
                    }
                  }
                },
                createElement(Component$$1, {
                  data: data,
                  itemIdx: measurementIndex,
                  isMeasuring: true
                })
              );
            })
          ),
          this.scrollContainer && createElement(FetchItems, {
            containerHeight: this.containerHeight,
            fetchMore: this.fetchMore,
            isFetching: this.state.isFetching || this.state.hasPendingMeasurements,
            scrollHeight: height,
            scrollTop: this.state.scrollTop
          })
        );
      }

      return this.props.scrollContainer ? createElement(
        ScrollContainer,
        {
          ref: this.setScrollContainerRef,
          onScroll: this.updateScrollPosition,
          scrollContainer: this.props.scrollContainer
        },
        gridBody
      ) : gridBody;
    }
  }], [{
    key: 'getDerivedStateFromProps',
    value: function getDerivedStateFromProps(props, state) {
      var items = props.items,
          measurementStore = props.measurementStore;
      // whenever we're receiving new props, determine whether any items need to be measured
      // TODO - we should treat items as immutable

      var hasPendingMeasurements = items.some(function (item) {
        return !measurementStore.has(item);
      });

      // Shallow compare all items, if any change reflow the grid.
      for (var i = 0; i < items.length; i += 1) {
        // We've reached the end of our current props and everything matches.
        // If we hit this case it means we need to insert new items.
        if (state.items[i] === undefined) {
          return {
            hasPendingMeasurements: hasPendingMeasurements,
            items: items,
            isFetching: false
          };
        }

        // Reset grid items when:
        if (
        // An item object ref does not match.
        items[i] !== state.items[i] ||
        // Or less items than we currently have are passed in.
        items.length < state.items.length) {
          return {
            hasPendingMeasurements: hasPendingMeasurements,
            items: items,
            isFetching: false
          };
        }
      }

      // Reset items if new items array is empty.
      if (items.length === 0 && state.items.length > 0) {
        return {
          hasPendingMeasurements: hasPendingMeasurements,
          items: items,
          isFetching: false
        };
      }
      if (hasPendingMeasurements !== state.hasPendingMeasurements) {
        // make sure we always update hasPendingMeasurements
        return {
          hasPendingMeasurements: hasPendingMeasurements,
          items: items
        };
      }

      // Return null to indicate no change to state.
      return null;
    }
  }]);
  return Masonry;
}(Component);

Masonry.propTypes = {
  /**
   * The preferred/target item width. If `flexible` is set, the item width will
   * grow to fill column space, and shrink to fit if below min columns.
   */
  columnWidth: PropTypes.number,

  /**
   * The component to render.
   */
  /* eslint react/no-unused-prop-types: 0 */
  comp: PropTypes.func.isRequired,

  /**
   * The preferred/target item width. Item width will grow to fill
   * column space, and shrink to fit if below min columns.
   */
  flexible: PropTypes.bool,

  /**
   * The amount of space between each item.
   */
  gutterWidth: PropTypes.number,

  /**
   * An array of all objects to display in the grid.
   */
  items: PropTypes.arrayOf(PropTypes.shape({})).isRequired,

  /**
   * Measurement Store
   */
  measurementStore: PropTypes.instanceOf(MeasurementStore),

  /**
   * Layout system to use for items
   */
  layout: PropTypes.oneOfType([PropTypes.instanceOf(MasonryLayout), PropTypes.instanceOf(UniformRowLayout), PropTypes.symbol]),

  /**
   * A callback which the grid calls when we need to load more items as the user scrolls.
   * The callback should update the state of the items, and pass those in as props
   * to this component.
   */
  loadItems: PropTypes.func,

  /**
   * Minimum number of columns to display.
   */
  minCols: PropTypes.number,

  /**
   * Function that the grid calls to get the scroll container.
   * This is required if the grid is expected to be scrollable.
   */
  scrollContainer: PropTypes.func,

  /**
   * Whether or not to use actual virtualization
   */
  virtualize: PropTypes.bool
};
Masonry.defaultProps = {
  columnWidth: 236,
  measurementStore: new MeasurementStore(),
  minCols: 3,
  layout: DefaultLayoutSymbol,
  loadItems: function loadItems() {},
  virtualize: false
};

var RESIZE_DEBOUNCE$1 = 300;
// Multiplied against container height.
// The amount of extra buffer space for populating visible items.
var VIRTUAL_BUFFER_FACTOR$1 = 0.7;

var layoutNumberToCssDimension$1 = function layoutNumberToCssDimension(n) {
  return n !== Infinity ? n : undefined;
};

function layoutClass(_ref, _ref2) {
  var columnWidth = _ref.columnWidth,
      flexible = _ref.flexible,
      gutter = _ref.gutterWidth,
      layout = _ref.layout,
      measurementStore = _ref.measurementStore,
      minCols = _ref.minCols;
  var width = _ref2.width;

  if (flexible && width !== null) {
    return fullWidthLayout({
      gutter: gutter,
      cache: measurementStore,
      minCols: minCols,
      idealColumnWidth: columnWidth,
      width: width
    });
  }
  if (layout === UniformRowLayoutSymbol || layout instanceof UniformRowLayout) {
    return uniformRowLayout({
      cache: measurementStore,
      columnWidth: columnWidth,
      gutter: gutter,
      minCols: minCols,
      width: width
    });
  }
  return defaultLayout({
    cache: measurementStore,
    columnWidth: columnWidth,
    gutter: gutter,
    minCols: minCols,
    width: width
  });
}

function statesForRendering(props, state) {
  var measurementStore = props.measurementStore,
      minCols = props.minCols;
  var items = state.items;

  // Full layout is possible
  // $FlowIssue https://github.com/facebook/flow/issues/6151

  var itemsToRender = items.filter(function (item) {
    return item && measurementStore.has(item);
  });

  var layout = layoutClass(props, state);
  var renderPositions = layout(itemsToRender);
  // Math.max() === -Infinity when there are no renderPositions
  var height = renderPositions.length ? Math.max.apply(Math, toConsumableArray(renderPositions.map(function (pos) {
    return pos.top + pos.height;
  }))) : 0;

  // $FlowIssue https://github.com/facebook/flow/issues/6151
  var itemsToMeasure = items.filter(function (item) {
    return item && !measurementStore.has(item);
  }).slice(0, minCols);
  var measuringPositions = layout(itemsToMeasure);

  return {
    height: height,
    itemsToRender: itemsToRender,
    itemsToMeasure: itemsToMeasure,
    measuringPositions: measuringPositions,
    renderPositions: renderPositions
  };
}

/**
 * The will be the new MasonryBeta that will not have any fetching concerns.
 *
 * For now, it differs with Masonry only by not having any fetching logic.
 *
 * It is in beta until it can be battle tested.
 */

var MasonryBeta = function (_React$Component) {
  inherits(MasonryBeta, _React$Component);

  function MasonryBeta(props) {
    classCallCheck(this, MasonryBeta);

    var _this = possibleConstructorReturn(this, (MasonryBeta.__proto__ || Object.getPrototypeOf(MasonryBeta)).call(this, props));

    _this.handleResize = debounce(function () {
      if (_this.gridWrapper) {
        _this.setState({ width: _this.gridWrapper.clientWidth });
      }
    }, RESIZE_DEBOUNCE$1);
    _this.updateScrollPosition = throttle(function () {
      if (!_this.scrollContainer) {
        return;
      }
      var scrollContainer = _this.scrollContainer.getScrollContainerRef();

      if (!scrollContainer) {
        return;
      }

      _this.setState({
        scrollTop: getScrollPos(scrollContainer)
      });

      _this.handleVirtualizationWindowUpdate();
    });
    _this.measureContainerAsync = debounce(function () {
      _this.measureContainer();
    }, 0);

    _this.setGridWrapperRef = function (ref) {
      _this.gridWrapper = ref;
    };

    _this.setScrollContainerRef = function (ref) {
      _this.scrollContainer = ref;
    };

    _this.handleVirtualizationWindowUpdate = function () {
      var _this$state = _this.state,
          height = _this$state.height,
          width = _this$state.width;

      if (typeof _this.props.onVirtualizationWindowUpdate === 'function' && _this.containerHeight) {
        var _viewport = {
          top: _this.state.scrollTop,
          left: 0,
          height: _this.containerHeight,
          width: width || 0
        };
        var _content = {
          top: _this.containerOffset,
          left: 0,
          height: height,
          width: width || 0
        };

        _this.props.onVirtualizationWindowUpdate(_content, _viewport);
      }
    };

    _this.handleOnAutoMeasuringUpdate = function (state) {
      if (_this.props.onAutoMeasuringUpdate) {
        _this.props.onAutoMeasuringUpdate(state);
      }
    };

    _this.renderMasonryComponent = function (itemData, idx, position) {
      var _this$props = _this.props,
          Component$$1 = _this$props.comp,
          virtualize = _this$props.virtualize,
          virtualBoundsTop = _this$props.virtualBoundsTop,
          virtualBoundsBottom = _this$props.virtualBoundsBottom;
      var top = position.top,
          left = position.left,
          width = position.width,
          height = position.height;


      var isVisible = void 0;
      if (_this.props.scrollContainer) {
        var virtualBuffer = _this.containerHeight * VIRTUAL_BUFFER_FACTOR$1;
        var offsetScrollPos = _this.state.scrollTop - _this.containerOffset;
        var viewportTop = virtualBoundsTop ? offsetScrollPos - virtualBoundsTop : offsetScrollPos - virtualBuffer;
        var viewportBottom = virtualBoundsBottom ? offsetScrollPos + _this.containerHeight + virtualBoundsBottom : offsetScrollPos + _this.containerHeight + virtualBuffer;

        isVisible = !(position.top + position.height < viewportTop || position.top > viewportBottom);
      } else {
        // if no scroll container is passed in, items should always be visible
        isVisible = true;
      }

      var itemComponent = createElement(
        'div',
        {
          key: 'item-' + idx,
          className: [styles$h.Masonry__Item, styles$h.Masonry__Item__Mounted].join(' '),
          'data-grid-item': true,
          style: {
            top: 0,
            left: 0,
            transform: 'translateX(' + left + 'px) translateY(' + top + 'px)',
            WebkitTransform: 'translateX(' + left + 'px) translateY(' + top + 'px)',
            width: layoutNumberToCssDimension$1(width),
            height: layoutNumberToCssDimension$1(height)
          }
        },
        createElement(Component$$1, { data: itemData, itemIdx: idx, isMeasuring: false })
      );

      return virtualize ? isVisible && itemComponent || null : itemComponent;
    };

    _this.containerHeight = 0;
    _this.containerOffset = 0;

    _this.state = {
      hasPendingMeasurements: props.items.some(function (item) {
        return !!item && !props.measurementStore.has(item);
      }),
      height: 0,
      itemsToRender: [],
      itemsToMeasure: [],
      // eslint-disable-next-line react/no-unused-state
      items: props.items,
      measuringPositions: [],
      renderPositions: [],
      scrollTop: 0,
      width: undefined
    };
    return _this;
  }

  /**
   * Adds hooks after the component mounts.
   */

  /**
   * Delays resize handling in case the scroll container is still being resized.
   */


  createClass(MasonryBeta, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      window.addEventListener('resize', this.handleResize);

      this.measureContainer();

      var scrollTop = this.state.scrollTop;

      if (this.scrollContainer != null) {
        var _scrollContainer = this.scrollContainer.getScrollContainerRef();
        if (_scrollContainer) {
          scrollTop = getScrollPos(_scrollContainer);
        }
      }

      this.setState(function (prevState) {
        var width = _this2.gridWrapper ? _this2.gridWrapper.clientWidth : prevState.width;
        var stateWithWidth = _extends({}, _this2.state, { width: width });
        return _extends({
          scrollTop: scrollTop,
          width: width
        }, statesForRendering(_this2.props, stateWithWidth));
      });

      // need to make sure parent component has the correct pending measurement value
      this.handleOnAutoMeasuringUpdate(this.state.hasPendingMeasurements ? 'measuring' : 'idle');
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps, prevState) {
      var _this3 = this;

      var _props = this.props,
          items = _props.items,
          measurementStore = _props.measurementStore;


      this.measureContainerAsync();

      if (prevState.width != null && this.state.width !== prevState.width) {
        measurementStore.reset();
      }
      // calculate whether we still have pending measurements
      var hasPendingMeasurements = items.some(function (item) {
        return !!item && !measurementStore.has(item);
      });

      if (hasPendingMeasurements && !prevState.hasPendingMeasurements) {
        this.handleOnAutoMeasuringUpdate('measuring');
      } else if (!hasPendingMeasurements && prevState.hasPendingMeasurements) {
        this.handleOnAutoMeasuringUpdate('idle');
      }
      this.handleVirtualizationWindowUpdate();

      if (hasPendingMeasurements || hasPendingMeasurements !== this.state.hasPendingMeasurements || prevState.width == null) {
        this.insertAnimationFrame = requestAnimationFrame(function () {
          var renderingStates = statesForRendering(_this3.props, _this3.state);
          _this3.setState(_extends({
            hasPendingMeasurements: hasPendingMeasurements
          }, renderingStates));
        });
      } else if (hasPendingMeasurements || prevState.items !== items) {
        this.insertAnimationFrame = requestAnimationFrame(function () {
          var renderingStates = statesForRendering(_this3.props, _this3.state);
          _this3.setState(_extends({}, renderingStates));
        });
      }
    }

    /**
     * Remove listeners when unmounting.
     */

  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      if (this.insertAnimationFrame) {
        cancelAnimationFrame(this.insertAnimationFrame);
      }

      // Make sure async methods are cancelled.
      this.measureContainerAsync.clearTimeout();
      this.handleResize.clearTimeout();
      this.updateScrollPosition.clearTimeout();

      window.removeEventListener('resize', this.handleResize);
    }
  }, {
    key: 'measureContainer',
    value: function measureContainer() {
      if (this.scrollContainer != null) {
        var _scrollContainer2 = this.scrollContainer;

        var scrollContainerRef = _scrollContainer2.getScrollContainerRef();
        if (scrollContainerRef) {
          this.containerHeight = getElementHeight(scrollContainerRef);
          var el = this.gridWrapper;
          if (el instanceof HTMLElement) {
            var relativeScrollTop = getRelativeScrollTop(scrollContainerRef);
            this.containerOffset = el.getBoundingClientRect().top + relativeScrollTop;
          }
        }
      }
    }

    /**
     * Clear measurements/positions and force a reflow of the entire grid.
     * Only use this if absolutely necessary - ex: We need to reflow items if the
     * number of columns we would display should change after a resize.
     */

  }, {
    key: 'reflow',
    value: function reflow() {
      this.props.measurementStore.reset();
      this.measureContainer();
      this.handleVirtualizationWindowUpdate();
      this.forceUpdate();
    }
  }, {
    key: 'render',
    value: function render() {
      var _this4 = this;

      var _props2 = this.props,
          columnWidth = _props2.columnWidth,
          Component$$1 = _props2.comp,
          flexible = _props2.flexible,
          measurementStore = _props2.measurementStore,
          items = _props2.items;
      var _state = this.state,
          hasPendingMeasurements = _state.hasPendingMeasurements,
          height = _state.height,
          itemsToMeasure = _state.itemsToMeasure,
          itemsToRender = _state.itemsToRender,
          measuringPositions = _state.measuringPositions,
          renderPositions = _state.renderPositions,
          width = _state.width;

      var gridBody = void 0;
      if (width == null && hasPendingMeasurements) {
        // When hyrdating from a server render, we don't have the width of the grid
        // and the measurement store is empty
        gridBody = createElement(
          'div',
          {
            className: styles$h.Masonry,
            style: { height: 0, width: '100%' },
            ref: this.setGridWrapperRef
          },
          items.filter(function (item) {
            return item;
          }).map(function (item, i) {
            return createElement(
              'div',
              { // keep this in sync with renderMasonryComponent
                className: 'static',
                'data-grid-item': true,
                key: i,
                style: {
                  top: 0,
                  left: 0,
                  transform: 'translateX(0px) translateY(0px)',
                  WebkitTransform: 'translateX(0px) translateY(0px)',
                  width: flexible ? undefined : layoutNumberToCssDimension$1(columnWidth) // we can't set a width for server rendered flexible items
                },
                ref: function ref(el) {
                  if (el && !flexible) {
                    // only measure flexible items on client
                    measurementStore.set(item, el.clientHeight);
                  }
                }
              },
              createElement(Component$$1, { data: item, itemIdx: i, isMeasuring: false })
            );
          })
        );
      } else if (width == null) {
        // When the width is empty (usually after a re-mount) render an empty
        // div to collect the width for layout
        gridBody = createElement('div', { style: { width: '100%' }, ref: this.setGridWrapperRef });
      } else {
        gridBody = createElement(
          'div',
          { style: { width: '100%' }, ref: this.setGridWrapperRef },
          createElement(
            'div',
            { className: styles$h.Masonry, style: { height: height, width: width } },
            itemsToRender.map(function (item, i) {
              return (
                // $FlowFixMe this is the right definition, it an Array<T>
                _this4.renderMasonryComponent(item, i, renderPositions[i])
              );
            })
          ),
          createElement(
            'div',
            { className: styles$h.Masonry, style: { width: width } },
            itemsToMeasure.map(function (data, i) {
              // itemsToMeasure is always the length of minCols, so i will always be 0..minCols.length
              // we normalize the index here relative to the item list as a whole so that itemIdx is correct
              // and so that React doesnt reuse the measurement nodes
              var measurementIndex = itemsToRender.length + i;
              var position = measuringPositions[i];
              return createElement(
                'div',
                {
                  key: 'measuring-' + measurementIndex,
                  style: {
                    visibility: 'hidden',
                    position: 'absolute',
                    top: layoutNumberToCssDimension$1(position.top),
                    left: layoutNumberToCssDimension$1(position.left),
                    width: layoutNumberToCssDimension$1(position.width),
                    height: layoutNumberToCssDimension$1(position.height)
                  },
                  ref: function ref(el) {
                    if (el) {
                      measurementStore.set(data, el.clientHeight);
                    }
                  }
                },
                createElement(Component$$1, {
                  data: data,
                  itemIdx: measurementIndex,
                  isMeasuring: true
                })
              );
            })
          )
        );
      }

      return this.props.scrollContainer ? createElement(
        ScrollContainer,
        {
          ref: this.setScrollContainerRef,
          onScroll: this.updateScrollPosition,
          scrollContainer: this.props.scrollContainer
        },
        gridBody
      ) : gridBody;
    }
  }], [{
    key: 'getDerivedStateFromProps',
    value: function getDerivedStateFromProps(props, state) {
      var items = props.items,
          measurementStore = props.measurementStore;
      // whenever we're receiving new props, determine whether any items need to be measured
      // TODO - we should treat items as immutable

      var hasPendingMeasurements = items.some(function (item) {
        return item && !measurementStore.has(item);
      });

      var newState = _extends({}, state, {
        hasPendingMeasurements: hasPendingMeasurements,
        items: items
      });

      // Shallow compare all items, if any change reflow the grid.
      for (var i = 0; i < items.length; i += 1) {
        // We've reached the end of our current props and everything matches.
        // If we hit this case it means we need to insert new items.
        if (state.items[i] === undefined) {
          return _extends({
            hasPendingMeasurements: hasPendingMeasurements,
            items: items
          }, statesForRendering(props, newState));
        }

        // Reset grid items when:
        if (
        // An item object ref does not match.
        items[i] !== state.items[i] ||
        // Or less items than we currently have are passed in.
        items.length < state.items.length) {
          return _extends({
            hasPendingMeasurements: hasPendingMeasurements,
            items: items
          }, statesForRendering(props, newState));
        }
      }

      // Reset items if new items array is empty.
      if (items.length === 0 && state.items.length > 0) {
        return _extends({
          hasPendingMeasurements: hasPendingMeasurements,
          items: items
        }, statesForRendering(props, newState));
      }
      if (hasPendingMeasurements !== state.hasPendingMeasurements) {
        // make sure we always update hasPendingMeasurements
        return _extends({
          hasPendingMeasurements: hasPendingMeasurements,
          items: items
        }, statesForRendering(props, newState));
      }

      // Return null to indicate no change to state.
      return null;
    }
  }]);
  return MasonryBeta;
}(Component);

MasonryBeta.propTypes = {
  /**
   * The preferred/target item width. If `flexible` is set, the item width will
   * grow to fill column space, and shrink to fit if below min columns.
   */
  columnWidth: PropTypes.number,

  /**
   * The component to render.
   */
  /* eslint react/no-unused-prop-types: 0 */
  comp: PropTypes.func.isRequired,

  /**
   * The preferred/target item width. Item width will grow to fill
   * column space, and shrink to fit if below min columns.
   */
  flexible: PropTypes.bool,

  /**
   * The amount of space between each item.
   */
  gutterWidth: PropTypes.number,

  /**
   * An array of all objects to display in the grid.
   */
  items: PropTypes.arrayOf(PropTypes.shape({})).isRequired,

  /**
   * Measurement Store
   */
  measurementStore: PropTypes.instanceOf(MeasurementStore),

  /**
   * Layout system to use for items
   */
  layout: PropTypes.oneOfType([PropTypes.instanceOf(MasonryLayout), PropTypes.instanceOf(UniformRowLayout), PropTypes.symbol]),

  /**
   * A callback which the grid calls when we need to load more items as the user scrolls.
   * The callback should update the state of the items, and pass those in as props
   * to this component.
   */
  loadItems: PropTypes.func,

  /**
   * Minimum number of columns to display.
   */
  minCols: PropTypes.number,

  /**
   * Function that the grid calls to get the scroll container.
   * This is required if the grid is expected to be scrollable.
   */
  scrollContainer: PropTypes.func,

  /**
   * Whether or not to use actual virtualization
   */
  virtualize: PropTypes.bool
};
MasonryBeta.defaultProps = {
  columnWidth: 236,
  measurementStore: new MeasurementStore(),
  minCols: 3,
  layout: DefaultLayoutSymbol,
  loadItems: function loadItems() {},
  virtualize: false
};

/**
 * This MasonryInfiniteBeta is backward compatible with Masonry and
 * serves to help with migrating to a Masrony that doesn't have
 * the scrol fetch concerns.
 *
 * It is in beta so that it can be battle tested.
 *
 */
var MasonryInfiniteBeta = function (_React$Component) {
  inherits(MasonryInfiniteBeta, _React$Component);
  createClass(MasonryInfiniteBeta, null, [{
    key: 'createMeasurementStore',
    value: function createMeasurementStore() {
      return new MeasurementStore();
    }
  }]);

  function MasonryInfiniteBeta(props) {
    classCallCheck(this, MasonryInfiniteBeta);

    var _this = possibleConstructorReturn(this, (MasonryInfiniteBeta.__proto__ || Object.getPrototypeOf(MasonryInfiniteBeta)).call(this, props));

    _this.onVirtualizationWindowUpdate = function (content, viewport) {
      var _this$state = _this.state,
          containerHeight = _this$state.containerHeight,
          scrollTop = _this$state.scrollTop,
          scrollHeight = _this$state.scrollHeight;

      if (viewport.height !== containerHeight || viewport.top !== scrollTop || content.height !== scrollHeight) {
        _this.setState({
          containerHeight: viewport.height,
          scrollTop: viewport.top,
          scrollHeight: content.height
        });
      }
    };

    _this.setRef = function (ref) {
      if (ref) {
        _this.gridRef = ref;
      }
    };

    _this.fetchMore = function () {
      var loadItems = _this.props.loadItems;

      if (loadItems && typeof loadItems === 'function') {
        _this.setState({
          isFetching: true
        }, function () {
          return loadItems({ from: _this.props.items.length });
        });
      }
    };

    _this.handleOnAutoMeasuringUpdate = function (state) {
      var hasPendingMeasurements = state === 'measuring';
      if (_this.state.hasPendingMeasurements !== hasPendingMeasurements) {
        _this.setState({ hasPendingMeasurements: hasPendingMeasurements });
      }

      if (typeof _this.props.onAutoMeasuringUpdate === 'function') {
        _this.props.onAutoMeasuringUpdate(state);
      }
    };

    _this.reflow = function () {
      if (_this.gridRef) {
        _this.gridRef.reflow();
      }
    };

    _this.handleResize = function () {
      if (_this.gridRef) {
        _this.gridRef.handleResize();
      }
    };

    _this.state = {
      containerHeight: 0,
      hasPendingMeasurements: false,
      isFetching: false,
      // eslint-disable-next-line react/no-unused-state
      items: props.items,
      scrollTop: 0,
      scrollHeight: 0
    };
    return _this;
  }

  /**
   * Content layer and Viewport layer is as defined in Collection.
   */


  createClass(MasonryInfiniteBeta, [{
    key: 'render',
    value: function render() {
      return this.props.scrollContainer ? createElement(
        Fragment,
        null,
        createElement(FetchItems, {
          containerHeight: this.state.containerHeight,
          fetchMore: this.fetchMore,
          isFetching: this.state.isFetching || this.state.hasPendingMeasurements,
          scrollHeight: this.state.scrollHeight,
          scrollTop: this.state.scrollTop
        }),
        createElement(MasonryBeta, _extends({}, this.props, {
          onVirtualizationWindowUpdate: this.onVirtualizationWindowUpdate,
          onAutoMeasuringUpdate: this.handleOnAutoMeasuringUpdate,
          ref: this.setRef
        }))
      ) : createElement(MasonryBeta, _extends({}, this.props, { ref: this.setRef }));
    }
  }], [{
    key: 'getDerivedStateFromProps',
    value: function getDerivedStateFromProps(props, state) {
      var items = props.items;

      // assume immutable items

      if (props.items !== state.items) {
        return {
          items: items,
          isFetching: false
        };
      }

      // Return null to indicate no change to state.
      return null;
    }
  }]);
  return MasonryInfiniteBeta;
}(Component);

MasonryInfiniteBeta.defaultProps = MasonryBeta.defaultProps;

var NoScrollBehavior = function (_React$Component) {
  inherits(NoScrollBehavior, _React$Component);

  function NoScrollBehavior(props) {
    classCallCheck(this, NoScrollBehavior);

    var _this = possibleConstructorReturn(this, (NoScrollBehavior.__proto__ || Object.getPrototypeOf(NoScrollBehavior)).call(this, props));

    _this.prevOverflow = null;
    return _this;
  }

  createClass(NoScrollBehavior, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      if (typeof window !== 'undefined') {
        this.prevOverflow = window.document.body.style.overflow;
        window.document.body.style.overflow = 'hidden';
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      if (typeof window !== 'undefined') {
        window.document.body.style.overflow = this.prevOverflow;
      }
    }
  }, {
    key: 'render',
    value: function render() {
      return this.props.children;
    }
  }]);
  return NoScrollBehavior;
}(Component);

function queryFocusableAll(el) {
  var selector = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'iframe', 'object', 'embed', '[tabindex="-1"]', '[tabindex="0"]', '[contenteditable]', 'audio[controls]', 'video[controls]', 'summary'].join(',');
  return el.querySelectorAll(selector);
}

var focusElement = function focusElement(el) {
  if (typeof el.focus === 'function') {
    el.focus();
  }
};

var TrapFocusBehavior = function (_React$Component) {
  inherits(TrapFocusBehavior, _React$Component);

  function TrapFocusBehavior() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, TrapFocusBehavior);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TrapFocusBehavior.__proto__ || Object.getPrototypeOf(TrapFocusBehavior)).call.apply(_ref, [this].concat(args))), _this), _this.setElRef = function (el) {
      if (el) {
        _this.el = el;
      }
    }, _this.handleFocus = function (event) {
      if (!_this.el || event.target instanceof Node && _this.el.contains(event.target)) {
        return;
      }

      event.stopPropagation();
      event.preventDefault();
      _this.focusFirstChild();
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(TrapFocusBehavior, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.previouslyFocusedEl = document.activeElement;
      this.focusFirstChild();
      document.addEventListener('focus', this.handleFocus, true);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      document.removeEventListener('focus', this.handleFocus, true);
      if (this.previouslyFocusedEl) {
        focusElement(this.previouslyFocusedEl);
      }
    }
  }, {
    key: 'focusFirstChild',
    value: function focusFirstChild() {
      var el = this.el;

      if (el) {
        focusElement(queryFocusableAll(el)[0]);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      return createElement(
        'div',
        { ref: this.setElRef },
        this.props.children
      );
    }
  }]);
  return TrapFocusBehavior;
}(Component);

var styles$i = { "Backdrop": "_uj _4h _4m _4j _4k _4l _zb _3d", "container": "_uk _4g _4q _4s _5a _4m _4j _50 _y8", "wrapper": "_ul _4f _49 _4s _37 _2y _70 _6y" };

var SIZE_WIDTH_MAP$1 = {
  sm: 414,
  md: 544,
  lg: 804
};

var ESCAPE_KEY_CODE$1 = 27;

var Backdrop = function Backdrop(_ref) {
  var children = _ref.children;
  return createElement(
    Fragment,
    null,
    createElement('div', { className: styles$i.Backdrop }),
    children
  );
};

var Modal = function (_React$Component) {
  inherits(Modal, _React$Component);

  function Modal() {
    var _ref2;

    var _temp, _this, _ret;

    classCallCheck(this, Modal);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref2 = Modal.__proto__ || Object.getPrototypeOf(Modal)).call.apply(_ref2, [this].concat(args))), _this), _this.handleOutsideClick = function () {
      _this.props.onDismiss();
    }, _this.handleCloseClick = function () {
      _this.props.onDismiss();
    }, _this.handleKeyUp = function (event) {
      if (event.keyCode === ESCAPE_KEY_CODE$1) {
        _this.props.onDismiss();
      }
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(Modal, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      window.addEventListener('keyup', this.handleKeyUp);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      window.removeEventListener('keyup', this.handleKeyUp);
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          accessibilityCloseLabel = _props.accessibilityCloseLabel,
          accessibilityModalLabel = _props.accessibilityModalLabel,
          children = _props.children,
          footer = _props.footer,
          heading = _props.heading,
          _props$role = _props.role,
          role = _props$role === undefined ? 'dialog' : _props$role,
          _props$size = _props.size,
          size = _props$size === undefined ? 'sm' : _props$size;

      var width = SIZE_WIDTH_MAP$1[size];

      return createElement(
        NoScrollBehavior,
        null,
        createElement(
          TrapFocusBehavior,
          null,
          createElement(
            'div',
            {
              'aria-label': accessibilityModalLabel,
              className: styles$i.container,
              role: role
            },
            createElement(
              Backdrop,
              null,
              createElement(
                OutsideEventBehavior,
                { onClick: this.handleOutsideClick },
                createElement(
                  'div',
                  { className: styles$i.wrapper, tabIndex: -1, style: { width: width } },
                  createElement(
                    Box,
                    {
                      flex: 'grow',
                      position: 'relative',
                      display: 'flex',
                      direction: 'column',
                      width: '100%'
                    },
                    createElement(
                      Box,
                      { fit: true },
                      role === 'dialog' ? createElement(
                        Box,
                        {
                          dangerouslySetInlineStyle: {
                            __style: { paddingLeft: 50, paddingRight: 50 }
                          },
                          display: 'flex',
                          justifyContent: 'center',
                          paddingY: 5
                        },
                        createElement(
                          Heading,
                          { size: 'xs', accessibilityLevel: 1 },
                          heading
                        )
                      ) : createElement(
                        Box,
                        { display: 'flex', padding: 4 },
                        createElement(
                          Heading,
                          { size: 'sm', accessibilityLevel: 1 },
                          heading
                        )
                      ),
                      role === 'dialog' && createElement(
                        Box,
                        { padding: 2, position: 'absolute', top: true, right: true },
                        createElement(IconButton, {
                          accessibilityLabel: accessibilityCloseLabel,
                          icon: 'cancel',
                          onClick: this.handleCloseClick
                        })
                      ),
                      role === 'dialog' && createElement(Divider, null)
                    ),
                    createElement(
                      Box,
                      { flex: 'grow', overflow: 'auto', position: 'relative' },
                      children
                    ),
                    createElement(
                      Box,
                      { fit: true },
                      footer && createElement(
                        Box,
                        null,
                        role === 'dialog' && createElement(Divider, null),
                        createElement(
                          Box,
                          { padding: 4 },
                          footer
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      );
    }
  }]);
  return Modal;
}(Component);

Modal.propTypes = {
  children: PropTypes.node,
  accessibilityCloseLabel: PropTypes.string.isRequired,
  footer: PropTypes.node,
  heading: PropTypes.string.isRequired,
  accessibilityModalLabel: PropTypes.string.isRequired,
  onDismiss: PropTypes.func,
  role: PropTypes.oneOf(['alertdialog', 'dialog']),
  size: PropTypes.oneOf(['sm', 'md', 'lg'])
};

var styles$j = { "innerCircle": "_uu _4q", "PulseAnimation": "_uv", "outerCircle": "_uw", "AppearAnimation": "_ux" };

function Pulsar(props) {
  var paused = props.paused,
      _props$size = props.size,
      size = _props$size === undefined ? 135 : _props$size;


  return createElement(
    Box,
    {
      dangerouslySetInlineStyle: {
        __style: {
          animationIterationCount: paused ? 0 : 'infinite',
          outline: 'none',
          boxShadow: 'none'
        }
      },
      display: paused ? 'none' : 'block',
      height: size,
      position: 'relative',
      width: size
    },
    createElement(
      'div',
      { className: styles$j.innerCircle },
      createElement('div', { className: styles$j.outerCircle })
    )
  );
}

Pulsar.propTypes = {
  paused: PropTypes.bool,
  size: PropTypes.number
};

var styles$k = { "RadioButton": "_uy _45 _4q _2w _4s _50 _5a", "RadioButtonSm": "_uz", "RadioButtonMd": "_v0", "RadioButtonIsFocused": "_v1 _xv", "RadioButtonWhiteBg": "_v2 _37", "RadioButtonLightGrayBg": "_v3 _39", "Input": "_v4 _4h _od", "InputEnabled": "_v5 _z9", "InputSm": "_v6", "InputMd": "_v7", "Check": "_v8 _2w", "CheckEnabled": "_v9 _3d", "CheckDisabled": "_va _3b" };

var RadioButton = function (_React$Component) {
  inherits(RadioButton, _React$Component);

  function RadioButton() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, RadioButton);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = RadioButton.__proto__ || Object.getPrototypeOf(RadioButton)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      focused: false
    }, _this.handleChange = function (event) {
      var checked = event.target.checked;

      _this.props.onChange({ checked: checked, event: event });
    }, _this.handleBlur = function () {
      return _this.setState({ focused: false });
    }, _this.handleFocus = function () {
      _this.setState({ focused: true });
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(RadioButton, [{
    key: 'render',
    value: function render() {
      var _classnames, _classnames2, _classnames3;

      var _props = this.props,
          checked = _props.checked,
          disabled = _props.disabled,
          id = _props.id,
          name = _props.name,
          size = _props.size,
          value = _props.value;

      return createElement(
        'div',
        {
          className: classnames(styles$k.RadioButton, (_classnames = {}, defineProperty(_classnames, styles$k.RadioButtonIsFocused, this.state.focused), defineProperty(_classnames, styles$k.RadioButtonSm, size === 'sm'), defineProperty(_classnames, styles$k.RadioButtonMd, size === 'md'), defineProperty(_classnames, styles$k.RadioButtonWhiteBg, !disabled || checked), defineProperty(_classnames, styles$k.RadioButtonLightGrayBg, disabled && !checked), _classnames))
        },
        createElement('input', {
          checked: checked,
          className: classnames(styles$k.Input, (_classnames2 = {}, defineProperty(_classnames2, styles$k.InputEnabled, !disabled), defineProperty(_classnames2, styles$k.InputSm, size === 'sm'), defineProperty(_classnames2, styles$k.InputMd, size === 'md'), _classnames2)),
          disabled: disabled,
          id: id,
          name: name,
          onBlur: this.handleBlur,
          onChange: this.handleChange,
          onFocus: this.handleFocus,
          type: 'radio',
          value: value
        }),
        checked && createElement('div', {
          className: classnames(styles$k.Check, (_classnames3 = {}, defineProperty(_classnames3, styles$k.CheckSm, size === 'sm'), defineProperty(_classnames3, styles$k.CheckMd, size === 'md'), defineProperty(_classnames3, styles$k.CheckEnabled, !disabled), defineProperty(_classnames3, styles$k.CheckDisabled, disabled), _classnames3))
        })
      );
    }
  }]);
  return RadioButton;
}(Component);

RadioButton.propTypes = {
  checked: PropTypes.bool,
  disabled: PropTypes.bool,
  id: PropTypes.string.isRequired,
  name: PropTypes.string,
  onChange: PropTypes.func.isRequired,
  value: PropTypes.string.isRequired,
  size: PropTypes.oneOf(['sm', 'md'])
};
RadioButton.defaultProps = {
  checked: false,
  disabled: false,
  size: 'md'
};

var ScrollFetch = function (_React$PureComponent) {
  inherits(ScrollFetch, _React$PureComponent);

  function ScrollFetch() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, ScrollFetch);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ScrollFetch.__proto__ || Object.getPrototypeOf(ScrollFetch)).call.apply(_ref, [this].concat(args))), _this), _this.updatePosition = throttle(function () {
      _this.setState(_this.getScrollState());
    }), _this.state = {
      containerHeight: 0,
      scrollHeight: 0,
      scrollTop: 0
    }, _this.getScrollHeight = function () {
      var container = _this.props.container;

      if (!container) {
        return 0;
      }
      return getScrollHeight(container);
    }, _temp), possibleConstructorReturn(_this, _ret);
  }
  /**
   * Fetches additional items if needed.
   */


  createClass(ScrollFetch, [{
    key: 'componentDidMount',


    /**
     * Adds scroll listener after the component mounts.
     */
    value: function componentDidMount() {
      var _this2 = this;

      var container = this.props.container;

      if (!container) {
        return;
      }
      setTimeout(function () {
        _this2.setState(_extends({
          containerHeight: getElementHeight(container)
        }, _this2.getScrollState()));
      });
    }

    /**
     * Update scroll buffer and check after the component updates.
     */

  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate() {
      // setTimeout so the parent component can calculate renderHeight().
      this.updatePosition();
    }

    /**
     * Returns the scrollable content height.
     */

  }, {
    key: 'getScrollState',
    value: function getScrollState() {
      var _props = this.props,
          container = _props.container,
          renderHeight = _props.renderHeight;

      if (!container) {
        return null;
      }
      var scrollHeight = renderHeight || this.getScrollHeight;

      return {
        scrollHeight: scrollHeight(),
        scrollTop: getScrollPos(container)
      };
    }
  }, {
    key: 'render',
    value: function render() {
      var _state = this.state,
          containerHeight = _state.containerHeight,
          scrollHeight = _state.scrollHeight,
          scrollTop = _state.scrollTop;
      var _props2 = this.props,
          container = _props2.container,
          fetchMore = _props2.fetchMore,
          isAtEnd = _props2.isAtEnd,
          isFetching = _props2.isFetching;


      var props = {
        containerHeight: containerHeight,
        fetchMore: fetchMore,
        isAtEnd: isAtEnd,
        isFetching: isFetching,
        scrollHeight: scrollHeight,
        scrollTop: scrollTop
      };

      if (!container || isAtEnd) {
        return null;
      }
      return createElement(
        ScrollContainer,
        {
          onScroll: this.updatePosition,
          scrollContainer: container
        },
        createElement(FetchItems, props)
      );
    }
  }]);
  return ScrollFetch;
}(PureComponent);


ScrollFetch.propTypes = {
  /**
   * The scroll container to use. Defaults to window.
   */
  container: PropTypes.shape({
    addEventListener: PropTypes.func,
    removeEventListener: PropTypes.func
  }),
  renderHeight: PropTypes.func,
  isAtEnd: PropTypes.bool,
  isFetching: PropTypes.bool,
  fetchMore: PropTypes.func
};

ScrollFetch.defaultProps = {
  container: typeof window !== 'undefined' ? window : null
};

var styles$l = { "input": "_vb _xu _2q _4q _4o _3c _w7 _0 _1 _2 _wa _6 _39 _y8", "clear": "_vc _33 _z9 _6s _6r _4f" };

var SearchField = function (_React$Component) {
  inherits(SearchField, _React$Component);

  function SearchField() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, SearchField);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = SearchField.__proto__ || Object.getPrototypeOf(SearchField)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      focused: false,
      hovered: false
    }, _this.handleChange = function (event) {
      _this.props.onChange({
        value: event.currentTarget.value,
        syntheticEvent: event
      });
    }, _this.handleClear = function (event) {
      _this.props.onChange({
        value: '',
        syntheticEvent: event
      });
    }, _this.handleMouseEnter = function () {
      return _this.setState({ hovered: true });
    }, _this.handleMouseLeave = function () {
      return _this.setState({ hovered: false });
    }, _this.handleFocus = function (event) {
      _this.setState({ focused: true });

      if (_this.props.onFocus) {
        _this.props.onFocus({
          value: event.currentTarget.value,
          syntheticEvent: event
        });
      }
    }, _this.handleBlur = function (event) {
      _this.setState({ focused: false });

      if (_this.props.onBlur) {
        _this.props.onBlur({ event: event });
      }
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(SearchField, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          accessibilityLabel = _props.accessibilityLabel,
          autoComplete = _props.autoComplete,
          id = _props.id,
          placeholder = _props.placeholder,
          value = _props.value;

      // This mirrors the built in browser behavior. If there's a value, show the
      // clear button if you're hovering or if you've focused on the field

      var showClear = (this.state.focused || this.state.hovered) && value && value.length > 0;

      return createElement(
        Box,
        {
          display: 'flex',
          position: 'relative',
          alignItems: 'center',
          onMouseEnter: this.handleMouseEnter,
          onMouseLeave: this.handleMouseLeave,
          onFocus: this.handleFocus,
          onBlur: this.handleBlur,
          color: 'white'
        },
        createElement(
          Box,
          {
            dangerouslySetInlineStyle: {
              __style: {
                pointerEvents: 'none',
                // Added the following lines for Safari support
                top: '50%',
                transform: 'translateY(-50%)'
              }
            },
            position: 'absolute',
            left: true,
            paddingX: 4
          },
          createElement(Icon, { icon: 'search', accessibilityLabel: '' })
        ),
        createElement('input', {
          'aria-label': accessibilityLabel,
          autoComplete: autoComplete,
          className: styles$l.input,
          id: id,
          onChange: this.handleChange,
          placeholder: placeholder,
          role: 'searchbox',
          type: 'search',
          value: value
        }),
        showClear && createElement(
          Box,
          { position: 'absolute', right: true, top: true },
          createElement(
            'button',
            {
              className: styles$l.clear,
              onClick: this.handleClear,
              tabIndex: -1,
              type: 'button'
            },
            createElement(Icon, { icon: 'clear', accessibilityLabel: '' })
          )
        )
      );
    }
  }]);
  return SearchField;
}(Component);

SearchField.propTypes = {
  accessibilityLabel: PropTypes.string.isRequired,
  autoComplete: PropTypes.oneOf(['on', 'off', 'username', 'name']),
  id: PropTypes.string.isRequired,
  onBlur: PropTypes.func,
  onChange: PropTypes.func.isRequired,
  onFocus: PropTypes.func,
  placeholder: PropTypes.string,
  value: PropTypes.string
};

var styles$m = { "SegmentedControl": "_vd _4q _39 _4s _5b", "md": "_ve _4o", "lg": "_vf _4p", "item": "_vg _xu _5j _od _33 _z9", "itemIsNotSelected": "_vh", "itemIsSelected": "_vi _37" };

function SegmentedControl(props) {
  var _classnames;

  var items = props.items,
      onChange = props.onChange,
      selectedItemIndex = props.selectedItemIndex,
      _props$size = props.size,
      size = _props$size === undefined ? 'md' : _props$size;

  return createElement(
    'div',
    {
      className: classnames(styles$m.SegmentedControl, (_classnames = {}, defineProperty(_classnames, styles$m.md, size === 'md'), defineProperty(_classnames, styles$m.lg, size === 'lg'), _classnames)),
      role: 'tablist'
    },
    items.map(function (item, i) {
      var _classnames2;

      var isSelected = i === selectedItemIndex;
      var cs = classnames(styles$m.item, (_classnames2 = {}, defineProperty(_classnames2, styles$m.itemIsNotSelected, !isSelected), defineProperty(_classnames2, styles$m.itemIsSelected, isSelected), _classnames2));
      return createElement(
        'button',
        {
          'aria-selected': isSelected,
          className: cs,
          key: i,
          onClick: function onClick(e) {
            return onChange({ event: e, activeIndex: i });
          },
          role: 'tab',
          type: 'button'
        },
        typeof item === 'string' ? createElement(
          Text,
          {
            bold: true,
            color: isSelected ? 'darkGray' : 'gray',
            align: 'center',
            size: size
          },
          item
        ) : createElement(
          Box,
          { display: 'flex', justifyContent: 'center' },
          item
        )
      );
    })
  );
}

SegmentedControl.propTypes = {
  items: PropTypes.arrayOf(PropTypes.node).isRequired,
  onChange: PropTypes.func.isRequired,
  selectedItemIndex: PropTypes.number.isRequired
};

var styles$n = { "select": "_vj _xu _w7 _0 _1 _2 _wa _3c _z9 _4f _4o _42 _y8", "normal": "_vk", "errored": "_vl", "enabled": "_vm _3c _37", "disabled": "_vn _3a _39" };

var SelectList = function (_React$Component) {
  inherits(SelectList, _React$Component);

  function SelectList() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, SelectList);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = SelectList.__proto__ || Object.getPrototypeOf(SelectList)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      focused: false,
      errorIsOpen: false
    }, _this.handleOnChange = function (event) {
      if (event.target instanceof HTMLSelectElement && _this.props.value !== event.target.value) {
        _this.props.onChange({ event: event, value: event.target.value });

        if (_this.props.errorMessage) {
          _this.setState({ errorIsOpen: false });
        }
      }
    }, _this.handleBlur = function () {
      if (_this.props.errorMessage) {
        _this.setState({ errorIsOpen: false });
      }
    }, _this.handleFocus = function () {
      if (_this.props.errorMessage) {
        _this.setState({ errorIsOpen: true });
      }
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(SelectList, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          disabled = _props.disabled,
          errorMessage = _props.errorMessage,
          id = _props.id,
          idealErrorDirection = _props.idealErrorDirection,
          name = _props.name,
          options = _props.options,
          placeholder = _props.placeholder,
          value = _props.value;


      var classes = classnames(styles$n.select, disabled ? styles$n.disabled : styles$n.enabled, errorMessage ? styles$n.errored : styles$n.normal);

      return createElement(
        Box,
        {
          color: disabled ? 'lightGray' : 'white',
          dangerouslySetInlineStyle: { __style: { borderRadius: 4 } },
          display: 'flex',
          position: 'relative',
          width: '100%'
        },
        createElement(
          Box,
          {
            alignItems: 'center',
            bottom: true,
            dangerouslySetInlineStyle: {
              __style: { paddingRight: 14, paddingTop: 2 }
            },
            display: 'flex',
            position: 'absolute',
            right: true,
            top: true
          },
          createElement(Icon, {
            icon: 'arrow-down',
            size: 12,
            color: disabled ? 'gray' : 'darkGray',
            accessibilityLabel: ''
          })
        ),
        createElement(
          'select',
          {
            'aria-describedby': errorMessage && this.state.focused ? id + '-gestalt-error' : null,
            'aria-invalid': errorMessage ? 'true' : 'false',
            className: classes,
            disabled: disabled,
            id: id,
            name: name,
            onBlur: this.handleBlur,
            onFocus: this.handleFocus,
            onChange: this.handleOnChange,
            ref: function ref(c) {
              _this2.select = c;
            },
            value: value
          },
          placeholder && !value && createElement(
            'option',
            { selected: true, disabled: true, value: true, hidden: true },
            placeholder
          ),
          options.map(function (option) {
            return createElement(
              'option',
              { key: option.value, value: option.value },
              option.label
            );
          })
        ),
        errorMessage && this.state.errorIsOpen && createElement(
          Flyout,
          {
            anchor: this.select,
            color: 'orange',
            idealDirection: idealErrorDirection,
            onDismiss: function onDismiss() {
              return _this2.setState({ errorIsOpen: false });
            },
            shouldFocus: false,
            size: 'sm'
          },
          createElement(
            Box,
            { padding: 3 },
            createElement(
              Text,
              { bold: true, color: 'white' },
              createElement(
                'span',
                { id: id + '-gestalt-error' },
                errorMessage
              )
            )
          )
        )
      );
    }
  }], [{
    key: 'getDerivedStateFromProps',
    value: function getDerivedStateFromProps(props, state) {
      if (props.errorMessage !== state.errorMessage) {
        return {
          errorIsOpen: !!props.errorMessage,
          errorMessage: props.errorMessage
        };
      }

      return null;
    }
  }]);
  return SelectList;
}(Component);

SelectList.propTypes = {
  disabled: PropTypes.bool,
  errorMessage: PropTypes.string,
  id: PropTypes.string.isRequired,
  idealErrorDirection: PropTypes.string,
  name: PropTypes.string,
  onChange: PropTypes.func.isRequired,
  options: PropTypes.arrayOf(PropTypes.exact({
    label: PropTypes.string.isRequired,
    value: PropTypes.string.isRequired
  })),
  placeholder: PropTypes.string,
  value: PropTypes.string
};
SelectList.defaultProps = {
  disabled: false,
  idealErrorDirection: 'right',
  options: []
};

var styles$o = { "icon": "_vo _45", "spin": "_vp" };

var SIZE = 40;

function Spinner(_ref) {
  var accessibilityLabel = _ref.accessibilityLabel,
      show = _ref.show;

  return show ? createElement(
    Box,
    { xs: { display: 'flex' }, justifyContent: 'around', overflow: 'hidden' },
    createElement(
      'div',
      { className: styles$o.icon },
      createElement(Icon, {
        icon: 'knoop',
        accessibilityLabel: accessibilityLabel,
        size: SIZE
      })
    )
  ) : createElement('div', null);
}

Spinner.propTypes = {
  show: PropTypes.bool.isRequired,
  accessibilityLabel: PropTypes.string.isRequired
};

function Sticky(props) {
  var _props$dangerouslySet = props.dangerouslySetZIndex,
      dangerouslySetZIndex = _props$dangerouslySet === undefined ? { __zIndex: 1 } : _props$dangerouslySet,
      children = props.children;

  var style = {
    top: props.top != null ? props.top : undefined,
    left: props.left != null ? props.left : undefined,
    right: props.right != null ? props.right : undefined,
    bottom: props.bottom != null ? props.bottom : undefined,
    // eslint-disable-next-line no-underscore-dangle
    zIndex: dangerouslySetZIndex.__zIndex
  };
  return createElement(
    'div',
    { className: layout.sticky, style: style },
    children
  );
}

Sticky.propTypes = {
  children: PropTypes.node,
  dangerouslySetZIndex: PropTypes.exact({
    __zIndex: PropTypes.number
  }),
  top: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  left: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  bottom: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  right: PropTypes.oneOfType([PropTypes.number, PropTypes.string])
};

var styles$p = { "switch": "_vq _45 _4q _4f", "focused": "_vr _xv", "switchDarkGray": "_vs _3d", "switchGray": "_vt _3b", "switchLightGray": "_vu _39", "switchWhite": "_vv _37", "slider": "_vw _4q _4h _37 _2w", "sliderRight": "_vx", "sliderLeft": "_vy", "sliderDark": "_vz", "sliderLight": "_w0", "checkbox": "_w1 _4h _y8 _od _33 _oi", "checkboxEnabled": "_w2 _z9" };

var Switch = function (_React$Component) {
  inherits(Switch, _React$Component);

  function Switch() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, Switch);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Switch.__proto__ || Object.getPrototypeOf(Switch)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      focused: false
    }, _this.handleBlur = function () {
      return _this.setState({ focused: false });
    }, _this.handleChange = function (event) {
      var checked = event.target.checked;

      _this.props.onChange({
        event: event,
        value: checked
      });
    }, _this.handleFocus = function () {
      _this.setState({ focused: true });
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(Switch, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          disabled = _props.disabled,
          id = _props.id,
          name = _props.name,
          switched = _props.switched;


      var switchStyles = classnames(styles$p.switch, defineProperty({}, styles$p.focused, this.state.focused),
      // eslint-disable-next-line no-nested-ternary
      disabled ? switched ? styles$p.switchGray : styles$p.switchLightGray : switched ? styles$p.switchDarkGray : styles$p.switchWhite);

      var sliderStyles = classnames(styles$p.slider, switched ? styles$p.sliderRight : styles$p.sliderLeft, switched && !disabled ? styles$p.sliderDark : styles$p.sliderLight);

      var inputStyles = classnames(styles$p.checkbox, defineProperty({}, styles$p.checkboxEnabled, !disabled));

      return createElement(
        'div',
        { className: switchStyles },
        createElement('input', {
          checked: switched,
          className: inputStyles,
          disabled: disabled,
          id: id,
          name: name,
          onBlur: this.handleBlur,
          onChange: this.handleChange,
          onFocus: this.handleFocus,
          type: 'checkbox'
        }),
        createElement('div', { className: sliderStyles })
      );
    }
  }]);
  return Switch;
}(Component);

Switch.propTypes = {
  disabled: PropTypes.bool,
  id: PropTypes.string.isRequired,
  name: PropTypes.string,
  onChange: PropTypes.func.isRequired,
  switched: PropTypes.bool
};
Switch.defaultProps = {
  disabled: false,
  switched: false
};

var styles$q = { "Tabs": "_w3 _4s", "tab": "_w4 _xu _4q _4o _4s _4w undefined _5a _33 _2x _od _z9", "tabIsNotActive": "_w5 _42 _3a", "tabIsActive": "_w6 _39 _3c" };

var Tabs = function (_React$Component) {
  inherits(Tabs, _React$Component);

  function Tabs() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, Tabs);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Tabs.__proto__ || Object.getPrototypeOf(Tabs)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      focusedTabIndex: undefined,
      hoveredTabIndex: undefined
    }, _this.handleTabClick = function (i, e) {
      var onChange = _this.props.onChange;

      onChange({ activeTabIndex: i, event: e });
    }, _this.handleTabFocus = function (i) {
      return _this.setState({ focusedTabIndex: i });
    }, _this.handleTabBlur = function () {
      return _this.setState({ focusedTabIndex: undefined });
    }, _this.handleTabMouseEnter = function (i) {
      return _this.setState({ hoveredTabIndex: i });
    }, _this.handleTabMouseLeave = function () {
      return _this.setState({ hoveredTabIndex: undefined });
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(Tabs, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          tabs = _props.tabs,
          activeTabIndex = _props.activeTabIndex,
          wrap = _props.wrap;
      var _state = this.state,
          focusedTabIndex = _state.focusedTabIndex,
          hoveredTabIndex = _state.hoveredTabIndex;

      return createElement(
        'div',
        {
          className: classnames(styles$q.Tabs, wrap && layout.flexWrap),
          role: 'tablist'
        },
        tabs.map(function (_ref2, i) {
          var _classnames;

          var text = _ref2.text,
              href = _ref2.href;

          var isActive = i === activeTabIndex;
          var isHovered = i === hoveredTabIndex;
          var isFocused = i === focusedTabIndex;
          var cs = classnames(styles$q.tab, (_classnames = {}, defineProperty(_classnames, styles$q.tabIsNotActive, !isActive), defineProperty(_classnames, styles$q.tabIsActive, isActive), _classnames));
          return createElement(
            'a',
            {
              'aria-selected': isActive,
              className: cs,
              href: href,
              key: '' + i + href,
              onClick: function onClick(e) {
                return _this2.handleTabClick(i, e);
              },
              onFocus: function onFocus() {
                return _this2.handleTabFocus(i);
              },
              onBlur: _this2.handleTabBlur,
              onMouseEnter: function onMouseEnter() {
                return _this2.handleTabMouseEnter(i);
              },
              onMouseLeave: _this2.handleTabMouseLeave,
              role: 'tab'
            },
            createElement(
              Text,
              {
                bold: true,
                color: isActive || isHovered || isFocused ? 'darkGray' : 'gray',
                size: 'md'
              },
              text
            )
          );
        })
      );
    }
  }]);
  return Tabs;
}(Component);

Tabs.propTypes = {
  activeTabIndex: PropTypes.number.isRequired,
  tabs: PropTypes.arrayOf(PropTypes.exact({
    text: PropTypes.node,
    href: PropTypes.string
  })).isRequired,
  onChange: PropTypes.func.isRequired,
  wrap: PropTypes.bool
};

var styles$r = { "textArea": "_ws _xu _4q _w7 _0 _1 _2 _wa _4 _y8", "normal": "_wt", "errored": "_wu", "enabled": "_wv _3c _37", "disabled": "_ww _3a _39" };

var TextArea = function (_React$Component) {
  inherits(TextArea, _React$Component);

  function TextArea() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, TextArea);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TextArea.__proto__ || Object.getPrototypeOf(TextArea)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      focused: false,
      errorIsOpen: false
    }, _this.handleChange = function (event) {
      _this.props.onChange({
        event: event,
        value: event.currentTarget.value
      });

      if (_this.props.errorMessage) {
        _this.setState({ errorIsOpen: true });
      }
    }, _this.handleBlur = function (event) {
      if (_this.props.errorMessage) {
        _this.setState({ errorIsOpen: false });
      }
      if (_this.props.onBlur) {
        _this.props.onBlur({
          event: event,
          value: event.currentTarget.value
        });
      }
    }, _this.handleFocus = function (event) {
      if (_this.props.errorMessage) {
        _this.setState({ errorIsOpen: true });
      }
      if (_this.props.onFocus) {
        _this.props.onFocus({
          event: event,
          value: event.currentTarget.value
        });
      }
    }, _this.handleKeyDown = function (event) {
      if (_this.props.onKeyDown) {
        _this.props.onKeyDown({
          event: event,
          value: event.currentTarget.value
        });
      }
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(TextArea, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          disabled = _props.disabled,
          errorMessage = _props.errorMessage,
          hasError = _props.hasError,
          id = _props.id,
          idealErrorDirection = _props.idealErrorDirection,
          name = _props.name,
          placeholder = _props.placeholder,
          rows = _props.rows,
          value = _props.value;


      var classes = classnames(styles$r.textArea, disabled ? styles$r.disabled : styles$r.enabled, hasError || errorMessage ? styles$r.errored : styles$r.normal);

      return createElement(
        'span',
        null,
        createElement('textarea', {
          'aria-describedby': errorMessage && this.state.focused ? id + '-gestalt-error' : null,
          'aria-invalid': errorMessage || hasError ? 'true' : 'false',
          className: classes,
          disabled: disabled,
          id: id,
          name: name,
          onBlur: this.handleBlur,
          onChange: this.handleChange,
          onFocus: this.handleFocus,
          onKeyDown: this.handleKeyDown,
          placeholder: placeholder,
          ref: function ref(c) {
            _this2.textarea = c;
          },
          rows: rows,
          value: value
        }),
        errorMessage && this.state.errorIsOpen ? createElement(
          Flyout,
          {
            anchor: this.textarea,
            color: 'orange',
            idealDirection: idealErrorDirection,
            onDismiss: function onDismiss() {
              return _this2.setState({ errorIsOpen: false });
            },
            shouldFocus: false,
            size: 'sm'
          },
          createElement(
            Box,
            { padding: 3 },
            createElement(
              Text,
              { bold: true, color: 'white' },
              createElement(
                'span',
                { id: id + '-gestalt-error' },
                errorMessage
              )
            )
          )
        ) : null
      );
    }
  }], [{
    key: 'getDerivedStateFromProps',
    value: function getDerivedStateFromProps(props, state) {
      if (props.errorMessage !== state.errorMessage) {
        return {
          errorIsOpen: !!props.errorMessage,
          errorMessage: props.errorMessage
        };
      }

      return null;
    }
  }]);
  return TextArea;
}(Component);

TextArea.propTypes = {
  disabled: PropTypes.bool,
  errorMessage: PropTypes.string,
  hasError: PropTypes.bool,
  id: PropTypes.string.isRequired,
  idealErrorDirection: PropTypes.string,
  name: PropTypes.string,
  onBlur: PropTypes.func,
  onChange: PropTypes.func.isRequired,
  onFocus: PropTypes.func,
  onKeyDown: PropTypes.func,
  placeholder: PropTypes.string,
  rows: PropTypes.number,
  value: PropTypes.string
};
TextArea.defaultProps = {
  disabled: false,
  hasError: false,
  idealErrorDirection: 'right',
  rows: 3
};

var styles$s = { "textField": "_wx _xu _4q _4o _w7 _0 _1 _2 _wa _y8", "normal": "_wy", "errored": "_wz", "enabled": "_x0 _3c _37", "disabled": "_x1 _3a _39" };

var TextField = function (_React$Component) {
  inherits(TextField, _React$Component);

  function TextField() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, TextField);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TextField.__proto__ || Object.getPrototypeOf(TextField)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      focused: false,
      errorIsOpen: false
    }, _this.handleChange = function (event) {
      _this.props.onChange({
        event: event,
        value: event.currentTarget.value
      });
    }, _this.handleBlur = function (event) {
      if (_this.props.errorMessage) {
        _this.setState({ errorIsOpen: false });
      }
      if (_this.props.onBlur) {
        _this.props.onBlur({
          event: event,
          value: event.currentTarget.value
        });
      }
    }, _this.handleFocus = function (event) {
      if (_this.props.errorMessage) {
        _this.setState({ errorIsOpen: true });
      }
      if (_this.props.onFocus) {
        _this.props.onFocus({
          event: event,
          value: event.currentTarget.value
        });
      }
    }, _this.handleKeyDown = function (event) {
      if (_this.props.onKeyDown) {
        _this.props.onKeyDown({
          event: event,
          value: event.currentTarget.value
        });
      }
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(TextField, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          autoComplete = _props.autoComplete,
          disabled = _props.disabled,
          errorMessage = _props.errorMessage,
          hasError = _props.hasError,
          id = _props.id,
          idealErrorDirection = _props.idealErrorDirection,
          name = _props.name,
          placeholder = _props.placeholder,
          type = _props.type,
          value = _props.value;


      var classes = classnames(styles$s.textField, disabled ? styles$s.disabled : styles$s.enabled, hasError || errorMessage ? styles$s.errored : styles$s.normal);

      // type='number' doesn't work on ios safari without a pattern
      // https://stackoverflow.com/questions/14447668/input-type-number-is-not-showing-a-number-keypad-on-ios
      var pattern = type === 'number' ? '\\d*' : undefined;

      return createElement(
        'span',
        null,
        createElement('input', {
          'aria-describedby': errorMessage && this.state.focused ? id + '-gestalt-error' : null,
          'aria-invalid': errorMessage || hasError ? 'true' : 'false',
          autoComplete: autoComplete,
          className: classes,
          disabled: disabled,
          id: id,
          name: name,
          onBlur: this.handleBlur,
          onChange: this.handleChange,
          onFocus: this.handleFocus,
          onKeyDown: this.handleKeyDown,
          pattern: pattern,
          placeholder: placeholder,
          ref: function ref(c) {
            _this2.textfield = c;
          },
          type: type,
          value: value
        }),
        errorMessage && this.state.errorIsOpen && createElement(
          Flyout,
          {
            anchor: this.textfield,
            color: 'orange',
            idealDirection: idealErrorDirection,
            onDismiss: function onDismiss() {
              return _this2.setState({ errorIsOpen: false });
            },
            shouldFocus: false,
            size: 'sm'
          },
          createElement(
            Box,
            { padding: 3 },
            createElement(
              Text,
              { bold: true, color: 'white' },
              createElement(
                'span',
                { id: id + '-gestalt-error' },
                errorMessage
              )
            )
          )
        )
      );
    }
  }], [{
    key: 'getDerivedStateFromProps',
    value: function getDerivedStateFromProps(props, state) {
      if (props.errorMessage !== state.errorMessage) {
        return {
          errorIsOpen: !!props.errorMessage,
          errorMessage: props.errorMessage
        };
      }

      return null;
    }
  }]);
  return TextField;
}(Component);

TextField.propTypes = {
  autoComplete: PropTypes.oneOf(['current-password', 'on', 'off', 'username']),
  disabled: PropTypes.bool,
  errorMessage: PropTypes.string,
  hasError: PropTypes.bool,
  id: PropTypes.string.isRequired,
  idealErrorDirection: PropTypes.string,
  name: PropTypes.string,
  onBlur: PropTypes.func,
  onChange: PropTypes.func.isRequired,
  onFocus: PropTypes.func,
  onKeyDown: PropTypes.func,
  placeholder: PropTypes.string,
  type: PropTypes.oneOf(['date', 'email', 'number', 'password', 'text', 'url']),
  value: PropTypes.string
};
TextField.defaultProps = {
  disabled: false,
  hasError: false,
  idealErrorDirection: 'right',
  type: 'text'
};

function Toast(props) {
  var _props$color = props.color,
      color = _props$color === undefined ? 'darkGray' : _props$color,
      icon = props.icon,
      thumbnail = props.thumbnail,
      text = props.text;


  var contents = void 0;
  // Confirmation Toasts
  if (text instanceof Array && text.length > 1) {
    contents = createElement(
      Box,
      { xs: { display: 'flex' } },
      createElement(
        Box,
        { xs: { display: 'flexColumn' }, flex: 'none', justifyContent: 'center' },
        thumbnail ? createElement(
          Mask,
          { shape: 'rounded', height: 48, width: 48 },
          thumbnail
        ) : null
      ),
      createElement(
        Box,
        {
          xs: { display: 'flexColumn' },
          justifyContent: 'center',
          dangerouslySetInlineStyle: { __style: { paddingLeft: 10 } }
        },
        createElement(
          Box,
          {
            dangerouslySetInlineStyle: { __style: { fontWeight: 'normal' } }
          },
          createElement(
            Text,
            { color: 'white', size: 'lg' },
            text[0]
          )
        ),
        createElement(
          Text,
          { bold: true, color: 'white', size: 'lg' },
          text[1]
        )
      )
    );
  } else {
    // Toasts as Guides
    contents = createElement(
      Box,
      {
        xs: { display: 'flex' },
        justifyContent: 'between',
        alignItems: 'center'
      },
      createElement(
        Text,
        { bold: true, color: 'white', size: 'lg' },
        text
      ),
      icon && createElement(
        Box,
        { dangerouslySetInlineStyle: { __style: { paddingLeft: 24 } } },
        createElement(Icon, { accessibilityLabel: '', color: 'white', icon: icon, size: 36 })
      )
    );
  }

  return createElement(
    Box,
    { marginBottom: 3, paddingX: 4, maxWidth: 376, width: '100vw' },
    createElement(
      Box,
      { color: color, fit: true, paddingX: 8, paddingY: 5, shape: 'pill' },
      contents
    )
  );
}

Toast.propTypes = {
  color: PropTypes.oneOf(['darkGray', 'orange']),
  icon: PropTypes.oneOf(['arrow-circle-forward']), // leaving open to additional icons in the future
  text: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]).isRequired,
  thumbnail: PropTypes.node
};

var styles$t = { "touchable": "_x2 _xu", "fullHeight": "_x3", "fullWidth": "_x4 _y8", "square": "_x5 _2v", "circle": "_x6 _2w", "rounded": "_x7 _2y", "roundedTop": "_x8 _2z", "roundedRight": "_x9 _30", "roundedBottom": "_xa _31", "roundedLeft": "_xb _32", "pill": "_xc _2x", "pointer": "_xd _z9", "zoomIn": "_xe _za", "zoomOut": "_xf _zb", "copy": "_xg _zc", "move": "_xh _zd", "noDrop": "_xi _ze", "grab": "_xj _zf", "grabbing": "_xk _zg" };

var SPACE_CHAR_CODE = 32;
var ENTER_CHAR_CODE = 13;

var Touchable = function (_React$Component) {
  inherits(Touchable, _React$Component);

  function Touchable() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, Touchable);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Touchable.__proto__ || Object.getPrototypeOf(Touchable)).call.apply(_ref, [this].concat(args))), _this), _this.handleKeyPress = function (event) {
      var onTouch = _this.props.onTouch;
      // Check to see if space or enter were pressed

      if (onTouch && (event.charCode === SPACE_CHAR_CODE || event.charCode === ENTER_CHAR_CODE)) {
        // Prevent the default action to stop scrolling when space is pressed
        event.preventDefault();
        onTouch({ event: event });
      }
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(Touchable, [{
    key: 'render',
    value: function render() {
      var _classnames;

      var _props = this.props,
          children = _props.children,
          _props$fullWidth = _props.fullWidth,
          fullWidth = _props$fullWidth === undefined ? true : _props$fullWidth,
          fullHeight = _props.fullHeight,
          _props$mouseCursor = _props.mouseCursor,
          mouseCursor = _props$mouseCursor === undefined ? 'pointer' : _props$mouseCursor,
          onMouseEnter = _props.onMouseEnter,
          onMouseLeave = _props.onMouseLeave,
          onTouch = _props.onTouch,
          _props$shape = _props.shape,
          shape = _props$shape === undefined ? 'square' : _props$shape;


      var classes = classnames(styles$t.touchable, styles$t[mouseCursor], styles$t[shape], (_classnames = {}, defineProperty(_classnames, styles$t.fullHeight, fullHeight), defineProperty(_classnames, styles$t.fullWidth, fullWidth), _classnames));

      return createElement(
        'div',
        {
          className: classes,
          onClick: function onClick(event) {
            return onTouch && onTouch({ event: event });
          },
          onMouseEnter: function (_onMouseEnter) {
            function onMouseEnter(_x) {
              return _onMouseEnter.apply(this, arguments);
            }

            onMouseEnter.toString = function () {
              return _onMouseEnter.toString();
            };

            return onMouseEnter;
          }(function (event) {
            return onMouseEnter && onMouseEnter({ event: event });
          }),
          onMouseLeave: function (_onMouseLeave) {
            function onMouseLeave(_x2) {
              return _onMouseLeave.apply(this, arguments);
            }

            onMouseLeave.toString = function () {
              return _onMouseLeave.toString();
            };

            return onMouseLeave;
          }(function (event) {
            return onMouseLeave && onMouseLeave({ event: event });
          }),
          onKeyPress: this.handleKeyPress,
          role: 'button',
          tabIndex: '0'
        },
        children
      );
    }
  }]);
  return Touchable;
}(Component);


Touchable.propTypes = {
  children: PropTypes.node,
  fullHeight: PropTypes.bool,
  fullWidth: PropTypes.bool,
  mouseCursor: PropTypes.oneOf(['copy', 'grab', 'grabbing', 'move', 'noDrop', 'pointer', 'zoomIn', 'zoomOut']),
  onTouch: PropTypes.func,
  onMouseEnter: PropTypes.func,
  onMouseLeave: PropTypes.func,
  shape: PropTypes.oneOf(['square', 'rounded', 'pill', 'circle', 'roundedTop', 'roundedBottom', 'roundedLeft', 'roundedRight'])
};

var styles$u = { "video": "_xl _45 _4h _y8", "player": "_xm _4f _y8", "playhead": "_xn _4s _50 _y8 _z9", "controls": "_xo _4h _4s _50 _4l _4m _4k _6e _6d" };

var VideoPlayhead = function (_React$PureComponent) {
  inherits(VideoPlayhead, _React$PureComponent);

  function VideoPlayhead() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, VideoPlayhead);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = VideoPlayhead.__proto__ || Object.getPrototypeOf(VideoPlayhead)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      seeking: false
    }, _this.setPlayheadRef = function (ref) {
      _this.playhead = ref;
    }, _this.seek = function (clientX) {
      if (_this.playhead) {
        var _this$props = _this.props,
            _duration = _this$props.duration,
            _seek = _this$props.seek;

        var _this$playhead$getBou = _this.playhead.getBoundingClientRect(),
            left = _this$playhead$getBou.left,
            width = _this$playhead$getBou.width;

        var percent = Math.max(0, Math.min((clientX - left) / width, 1));
        var newTime = percent * _duration;
        _seek(newTime);
      }
    }, _this.stopClick = function (event) {
      return event.stopPropagation();
    }, _this.handleMouseDown = function (event) {
      _this.setState({ seeking: true });
      _this.seek(event.clientX);
    }, _this.handleMouseMove = function (event) {
      var seeking = _this.state.seeking;

      if (seeking) {
        _this.seek(event.clientX);
      }
    }, _this.handleMouseUp = function () {
      _this.setState({ seeking: false });
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(VideoPlayhead, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          currentTime = _props.currentTime,
          duration = _props.duration;

      var width = Math.floor(currentTime * 10000 / duration) / 100 + '%';
      return createElement(
        Box,
        {
          position: 'relative',
          display: 'flex',
          flex: 'grow',
          alignItems: 'center',
          height: 16
        },
        createElement(
          'div',
          {
            'aria-valuemax': duration,
            'aria-valuemin': '0',
            'aria-valuenow': currentTime,
            className: styles$u.playhead,
            onClick: this.stopClick,
            onKeyPress: this.stopClick,
            onMouseDown: this.handleMouseDown,
            onMouseMove: this.handleMouseMove,
            onMouseUp: this.handleMouseUp,
            ref: this.setPlayheadRef,
            role: 'progressbar',
            tabIndex: '-1'
          },
          createElement(
            Box,
            {
              left: true,
              right: true,
              position: 'absolute',
              color: 'lightGray',
              shape: 'rounded',
              height: 4
            },
            createElement(Box, { color: 'white', shape: 'rounded', height: '100%', width: width })
          ),
          createElement(
            Box,
            {
              position: 'absolute',
              shape: 'rounded',
              height: 4,
              dangerouslySetInlineStyle: { __style: { left: width } }
            },
            createElement(Box, {
              shape: 'circle',
              width: 16,
              height: 16,
              color: 'white',
              marginLeft: -2,
              dangerouslySetInlineStyle: { __style: { marginTop: -6 } }
            })
          )
        )
      );
    }
  }]);
  return VideoPlayhead;
}(PureComponent);

VideoPlayhead.propTypes = {
  currentTime: PropTypes.number.isRequired,
  duration: PropTypes.number.isRequired,
  seek: PropTypes.func.isRequired
};

var fullscreenEnabled = function fullscreenEnabled() {
  return (
    // $FlowIssue - vendor prefix missing from Flow
    document.fullscreenEnabled ||
    // $FlowIssue - vendor prefix missing from Flow
    document.webkitFullscreenEnabled ||
    // $FlowIssue - vendor prefix missing from Flow
    document.mozFullScreenEnabled ||
    // $FlowIssue - vendor prefix missing from Flow
    document.msFullscreenEnabled
  );
};

var timeToString = function timeToString(time) {
  var rounded = Math.floor(time || 0);
  var minutes = Math.floor(rounded / 60);
  var seconds = rounded - minutes * 60;
  var minutesStr = minutes < 10 ? '0' + minutes : minutes;
  var secondsStr = seconds < 10 ? '0' + seconds : seconds;
  return minutesStr + ':' + secondsStr;
};

var VideoControls = function (_React$Component) {
  inherits(VideoControls, _React$Component);

  function VideoControls() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, VideoControls);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = VideoControls.__proto__ || Object.getPrototypeOf(VideoControls)).call.apply(_ref, [this].concat(args))), _this), _this.handleFullscreenChange = function (_ref2) {
      var event = _ref2.event;
      var onFullscreenChange = _this.props.onFullscreenChange;

      event.stopPropagation();
      onFullscreenChange();
    }, _this.handlePlayingChange = function (_ref3) {
      var event = _ref3.event;
      var _this$props = _this.props,
          playing = _this$props.playing,
          onPause = _this$props.onPause,
          onPlay = _this$props.onPlay;

      if (playing) {
        onPause(event);
      } else {
        onPlay(event);
      }
    }, _this.handleVolumeChange = function (_ref4) {
      var event = _ref4.event;
      var onVolumeChange = _this.props.onVolumeChange;

      onVolumeChange(event);
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(VideoControls, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          accessibilityMaximizeLabel = _props.accessibilityMaximizeLabel,
          accessibilityMinimizeLabel = _props.accessibilityMinimizeLabel,
          accessibilityMuteLabel = _props.accessibilityMuteLabel,
          accessibilityPauseLabel = _props.accessibilityPauseLabel,
          accessibilityPlayLabel = _props.accessibilityPlayLabel,
          accessibilityUnmuteLabel = _props.accessibilityUnmuteLabel,
          currentTime = _props.currentTime,
          duration = _props.duration,
          fullscreen = _props.fullscreen,
          playing = _props.playing,
          seek = _props.seek,
          volume = _props.volume;

      var muted = volume === 0;
      var showFullscreenButton = typeof document !== 'undefined' && !!fullscreenEnabled();
      return createElement(
        'div',
        { className: styles$u.controls },
        createElement(
          Box,
          { padding: 2 },
          createElement(
            Touchable,
            { onTouch: this.handlePlayingChange, fullWidth: false },
            createElement(Icon, {
              accessibilityLabel: playing ? accessibilityPauseLabel : accessibilityPlayLabel,
              color: 'white',
              icon: playing ? 'pause' : 'play',
              size: 20
            })
          )
        ),
        createElement(
          Box,
          { width: 50, padding: 2 },
          createElement(
            Text,
            { color: 'white', align: 'right', size: 'xs' },
            timeToString(currentTime)
          )
        ),
        createElement(
          Box,
          { padding: 2, flex: 'grow' },
          createElement(VideoPlayhead, {
            currentTime: currentTime,
            duration: duration,
            seek: seek
          })
        ),
        createElement(
          Box,
          { width: 50, padding: 2 },
          createElement(
            Text,
            { color: 'white', align: 'right', size: 'xs' },
            timeToString(duration)
          )
        ),
        createElement(
          Box,
          { padding: 2 },
          createElement(
            Touchable,
            { onTouch: this.handleVolumeChange, fullWidth: false },
            createElement(Icon, {
              accessibilityLabel: muted ? accessibilityUnmuteLabel : accessibilityMuteLabel,
              color: 'white',
              icon: muted ? 'mute' : 'sound',
              size: 20
            })
          )
        ),
        showFullscreenButton && createElement(
          Box,
          { padding: 2 },
          createElement(
            Touchable,
            { onTouch: this.handleFullscreenChange, fullWidth: false },
            createElement(Icon, {
              accessibilityLabel: fullscreen ? accessibilityMinimizeLabel : accessibilityMaximizeLabel,
              color: 'white',
              icon: fullscreen ? 'minimize' : 'maximize',
              size: 20
            })
          )
        )
      );
    }
  }]);
  return VideoControls;
}(Component);

VideoControls.propTypes = {
  accessibilityMaximizeLabel: PropTypes.string.isRequired,
  accessibilityMinimizeLabel: PropTypes.string.isRequired,
  accessibilityMuteLabel: PropTypes.string.isRequired,
  accessibilityPauseLabel: PropTypes.string.isRequired,
  accessibilityPlayLabel: PropTypes.string.isRequired,
  accessibilityUnmuteLabel: PropTypes.string.isRequired,
  currentTime: PropTypes.number.isRequired,
  duration: PropTypes.number.isRequired,
  fullscreen: PropTypes.bool.isRequired,
  onFullscreenChange: PropTypes.func.isRequired,
  onPause: PropTypes.func.isRequired,
  onPlay: PropTypes.func.isRequired,
  onVolumeChange: PropTypes.func.isRequired,
  playing: PropTypes.bool.isRequired,
  seek: PropTypes.func.isRequired,
  volume: PropTypes.number.isRequired
};

// For more information on fullscreen and vendor prefixes see
// https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API

var requestFullscreen = function requestFullscreen(element) {
  if (element.requestFullscreen) {
    element.requestFullscreen();
    // $FlowIssue - vendor prefix missing from Flow
  } else if (element.webkitRequestFullscreen) {
    // $FlowIssue - vendor prefix missing from Flow
    element.webkitRequestFullscreen();
    // $FlowIssue - vendor prefix missing from Flow
  } else if (element.mozRequestFullScreen) {
    // $FlowIssue - vendor prefix missing from Flow
    element.mozRequestFullScreen();
    // $FlowIssue - vendor prefix missing from Flow
  } else if (element.msRequestFullscreen) {
    // $FlowIssue - vendor prefix missing from Flow
    element.msRequestFullscreen();
  }
};

var exitFullscreen = function exitFullscreen() {
  // $FlowIssue - vendor prefix missing from Flow
  if (document.exitFullscreen) {
    // $FlowIssue - vendor prefix missing from Flow
    document.exitFullscreen();
    // $FlowIssue - vendor prefix missing from Flow
  } else if (document.webkitExitFullscreen) {
    // $FlowIssue - vendor prefix missing from Flow
    document.webkitExitFullscreen();
    // $FlowIssue - vendor prefix missing from Flow
  } else if (document.mozCancelFullScreen) {
    // $FlowIssue - vendor prefix missing from Flow
    document.mozCancelFullScreen();
    // $FlowIssue - vendor prefix missing from Flow
  } else if (document.msExitFullscreen) {
    // $FlowIssue - vendor prefix missing from Flow
    document.msExitFullscreen();
  }
};

// Normally document.fullscreen suffices here as a flag, but IE11 does not
// have a vendor specific version so we must instead use the actual element
var isFullscreen = function isFullscreen() {
  return (
    // $FlowIssue - vendor prefix missing from Flow
    document.fullscreenElement ||
    // $FlowIssue - vendor prefix missing from Flow
    document.webkitFullscreenElement ||
    // $FlowIssue - vendor prefix missing from Flow
    document.mozFullScreenElement ||
    // $FlowIssue - vendor prefix missing from Flow
    document.msFullscreenElement
  );
};

var addFullscreenEventListener = function addFullscreenEventListener(listener) {
  document.addEventListener('fullscreenchange', listener);
  document.addEventListener('webkitfullscreenchange', listener);
  document.addEventListener('mozfullscreenchange', listener);
  document.addEventListener('MSFullscreenChange', listener);
};

var removeFullscreenEventListener = function removeFullscreenEventListener(listener) {
  document.removeEventListener('fullscreenchange', listener);
  document.removeEventListener('webkitfullscreenchange', listener);
  document.removeEventListener('mozfullscreenchange', listener);
  document.removeEventListener('MSFullscreenChange', listener);
};

var isNewSource = function isNewSource(oldSource, newSource) {
  if ((typeof oldSource === 'undefined' ? 'undefined' : _typeof(oldSource)) !== (typeof newSource === 'undefined' ? 'undefined' : _typeof(newSource))) {
    // If the source type changed from string to Array
    // or vice versa, we have a new source
    return true;
  }
  if (Array.isArray(newSource)) {
    if (oldSource.length !== newSource.length) {
      // If the sources are both an Array, and the lengths
      // do not match we evaluate as a new source
      return true;
    }
    // If the sources are both an Array and the same length,
    // verify every element stayed the same
    return newSource.some(function (source, index) {
      return !Array.isArray(oldSource) || source.type !== oldSource[index].type || source.src !== oldSource[index].src;
    });
  }
  // If the sources are both a string, simply compare
  // the new with the old
  return newSource !== oldSource;
};

var Video = function (_React$PureComponent) {
  inherits(Video, _React$PureComponent);

  function Video() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, Video);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Video.__proto__ || Object.getPrototypeOf(Video)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      currentTime: 0,
      duration: 0,
      fullscreen: false
    }, _this.setPlayerRef = function (ref) {
      _this.player = ref;
    }, _this.setVideoRef = function (ref) {
      _this.video = ref;
    }, _this.setPlaybackRate = function (playbackRate) {
      if (_this.video) {
        _this.video.playbackRate = playbackRate;
      }
    }, _this.setVolume = function (volume) {
      if (_this.video) {
        _this.video.volume = volume;
      }
    }, _this.load = function () {
      if (_this.video) {
        _this.video.load();
      }
    }, _this.pause = function () {
      if (_this.video) {
        _this.video.pause();
      }
    }, _this.play = function () {
      if (_this.video) {
        _this.video.play();
      }
    }, _this.seek = function (time) {
      if (_this.video) {
        _this.video.currentTime = time;
      }
    }, _this.toggleFullscreen = function () {
      if (isFullscreen()) {
        exitFullscreen();
      } else if (_this.player) {
        requestFullscreen(_this.player);
      }
    }, _this.handleCanPlay = function (event) {
      var onReady = _this.props.onReady;


      if (onReady) {
        onReady({ event: event });
      }
    }, _this.handleDurationChange = function (event) {
      var onDurationChange = _this.props.onDurationChange;

      var duration = _this.video && _this.video.duration || 0;
      _this.setState({ duration: duration });

      if (onDurationChange) {
        onDurationChange({ event: event, duration: duration });
      }
    }, _this.handleEnded = function (event) {
      var onEnded = _this.props.onEnded;


      if (onEnded) {
        onEnded({ event: event });
      }
    }, _this.handleFullscreenChange = function (event) {
      var onFullscreenChange = _this.props.onFullscreenChange;

      var fullscreen = !!isFullscreen();
      _this.setState({ fullscreen: fullscreen });

      if (onFullscreenChange) {
        onFullscreenChange({ event: event, fullscreen: fullscreen });
      }
    }, _this.handlePlay = function (event) {
      var onPlay = _this.props.onPlay;


      if (onPlay) {
        onPlay({ event: event });
      }
    }, _this.handlePause = function (event) {
      var onPause = _this.props.onPause;


      if (onPause) {
        onPause({ event: event });
      }
    }, _this.handleProgress = function (event) {
      var onLoadedChange = _this.props.onLoadedChange;

      var _ref2 = _this.video || {},
          buffered = _ref2.buffered;

      var loaded = buffered && buffered.length > 0 ? buffered.end(buffered.length - 1) : 0;

      if (onLoadedChange) {
        onLoadedChange({ event: event, loaded: loaded });
      }
    }, _this.handleSeek = function (event) {
      var onSeek = _this.props.onSeek;


      if (onSeek) {
        onSeek({ event: event });
      }
    }, _this.handleTimeUpdate = function (event) {
      var onTimeChange = _this.props.onTimeChange;

      var currentTime = _this.video && _this.video.currentTime || 0;
      _this.setState({ currentTime: currentTime });

      if (onTimeChange) {
        onTimeChange({ event: event, time: currentTime });
      }
    }, _this.handleVolumeChange = function (event) {
      var onVolumeChange = _this.props.onVolumeChange;

      var muted = _this.video && _this.video.muted || false;

      if (onVolumeChange) {
        onVolumeChange({ event: event, volume: muted ? 1 : 0 });
      }
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(Video, [{
    key: 'componentDidMount',


    /**
     * React lifecycle hooks pertinent to Video
     */

    value: function componentDidMount() {
      var _props = this.props,
          playbackRate = _props.playbackRate,
          playing = _props.playing,
          volume = _props.volume;
      // Set up event listeners to catch backdoors in fullscreen
      // changes such as using the ESC key to exit

      if (typeof document !== 'undefined') {
        addFullscreenEventListener(this.handleFullscreenChange);
      }
      // Load the video to hydrate the DOM after a server render
      this.load();
      // Set the initial volume
      this.setVolume(volume);
      // Set the initial playback rate
      this.setPlaybackRate(playbackRate);
      // Simulate an autoplay effect if the component
      if (playing) {
        this.play();
      }
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      // If the video source changed, reload the video
      if (isNewSource(prevProps.src, this.props.src)) {
        this.load();
      }
      // If the volume changed, set the new volume
      if (prevProps.volume !== this.props.volume) {
        this.setVolume(this.props.volume);
      }
      // If the playback rate changed, set the new rate
      if (prevProps.playbackRate !== this.props.playbackRate) {
        this.setPlaybackRate(this.props.playbackRate);
      }
      // If the playback changed, play or pause the video
      if (prevProps.playing !== this.props.playing) {
        if (this.props.playing) {
          this.play();
        } else {
          this.pause();
        }
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      removeFullscreenEventListener(this.handleFullscreenChange);
    }

    /**
     * DOM reference housekeeping that is needed for functionality
     */

    // The player element encapsulates the actual video DOM
    // element as well as the controls to bring both fullscreen


    // The actual reference to the video HTML DOM element


    /**
     * Functions that directly interact with the HTML video element
     */

    // Set the video to the desired playback rate: 1 (normal)


    // Set the video to the desired volume: 0 (muted) -> 1 (max)


    // Change the video source and re-load the video


    // Pause the video


    // Play the video


    // Seek the video to the desired time


    // Enter/exit fullscreen video player mode


    /**
     * Handlers for various media events on the video
     */

    // Sent when enough data is available that the media can be played


    // The metadata has loaded or changed, indicating a change in
    // duration of the media


    // Sent when playback completes.


    // Sent when the video is switched to/out-of fullscreen mode


    // Sent when playback of the media starts after having been paused.


    // Sent when playback is paused.


    // Sent periodically to inform interested parties of progress downloading the media


    // Sent when a seek operation completes.


    // The time indicated by the element's currentTime attribute has changed


    // Sent when the audio volume changes

  }, {
    key: 'render',
    value: function render() {
      var _props2 = this.props,
          aspectRatio = _props2.aspectRatio,
          captions = _props2.captions,
          loop = _props2.loop,
          playing = _props2.playing,
          playsInline = _props2.playsInline,
          poster = _props2.poster,
          preload = _props2.preload,
          src = _props2.src,
          volume = _props2.volume;
      var _state = this.state,
          currentTime = _state.currentTime,
          duration = _state.duration,
          fullscreen = _state.fullscreen;


      var paddingBottom = fullscreen && '0' || 1 / aspectRatio * 100 + '%';

      return createElement(
        'div',
        {
          ref: this.setPlayerRef,
          className: styles$u.player,
          style: { paddingBottom: paddingBottom, height: fullscreen ? '100%' : 0 }
        },
        createElement(
          'video',
          {
            autoPlay: playing,
            loop: loop,
            muted: volume === 0,
            playsInline: playsInline,
            poster: poster,
            preload: preload,
            src: typeof src === 'string' ? src : undefined,
            ref: this.setVideoRef,
            className: styles$u.video,
            onCanPlay: this.handleCanPlay,
            onDurationChange: this.handleDurationChange,
            onEnded: this.handleEnded,
            onSeeked: this.handleSeek,
            onTimeUpdate: this.handleTimeUpdate,
            onProgress: this.handleProgress
          },
          Array.isArray(src) && src.map(function (source) {
            return createElement('source', { key: source.src, src: source.src, type: source.type });
          }),
          createElement('track', { kind: 'captions', src: captions })
        ),
        this.props.controls && createElement(VideoControls, {
          accessibilityMaximizeLabel: this.props.accessibilityMaximizeLabel,
          accessibilityMinimizeLabel: this.props.accessibilityMinimizeLabel,
          accessibilityMuteLabel: this.props.accessibilityMuteLabel,
          accessibilityPauseLabel: this.props.accessibilityPauseLabel,
          accessibilityPlayLabel: this.props.accessibilityPlayLabel,
          accessibilityUnmuteLabel: this.props.accessibilityUnmuteLabel,
          currentTime: currentTime,
          duration: duration,
          fullscreen: fullscreen,
          onPlay: this.handlePlay,
          onPause: this.handlePause,
          onFullscreenChange: this.toggleFullscreen,
          onVolumeChange: this.handleVolumeChange,
          playing: playing,
          seek: this.seek,
          volume: volume
        })
      );
    }
  }]);
  return Video;
}(PureComponent);

Video.propTypes = {
  accessibilityMaximizeLabel: PropTypes.string,
  accessibilityMinimizeLabel: PropTypes.string,
  accessibilityMuteLabel: PropTypes.string,
  accessibilityPauseLabel: PropTypes.string,
  accessibilityPlayLabel: PropTypes.string,
  accessibilityUnmuteLabel: PropTypes.string,
  aspectRatio: PropTypes.number.isRequired,
  captions: PropTypes.string.isRequired,
  controls: PropTypes.bool,
  loop: PropTypes.bool,
  onDurationChange: PropTypes.func,
  onEnded: PropTypes.func,
  onFullscreenChange: PropTypes.func,
  onLoadedChange: PropTypes.func,
  onPlay: PropTypes.func,
  onPause: PropTypes.func,
  onReady: PropTypes.func,
  onSeek: PropTypes.func,
  onTimeChange: PropTypes.func,
  onVolumeChange: PropTypes.func,
  playbackRate: PropTypes.number,
  playing: PropTypes.bool,
  playsInline: PropTypes.bool,
  poster: PropTypes.string,
  preload: PropTypes.oneOf(['auto', 'metadata', 'none']),
  src: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.shape({
    type: PropTypes.oneOf(['video/m3u8', 'video/mp4', 'video/ogg']).isRequired,
    src: PropTypes.string.isRequired
  }))]).isRequired,
  volume: PropTypes.number
};
Video.defaultProps = {
  playbackRate: 1,
  playing: false,
  preload: 'auto',
  volume: 1
};

export { Avatar, Box, Button, Card, Checkbox, Collage, Collection, Column, Container, Divider, Flyout, GroupAvatar, Heading, Icon, IconButton, Image, Label, Layer, Letterbox, Link, Mask, Masonry, MasonryBeta, MasonryInfiniteBeta, MasonryLayout as MasonryDefaultLayout, UniformRowLayout as MasonryUniformRowLayout, Modal, Pog, Pulsar, RadioButton, ScrollFetch, SearchField, SegmentedControl, SelectList, Spinner, Sticky, Switch, Tabs, Text, TextArea, TextField, Toast, Touchable, Video };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VzdGFsdC5lcy5qcyIsInNvdXJjZXMiOlsiLi4vc3JjL3N0eWxlLmpzIiwiLi4vc3JjL3RyYW5zZm9ybXMuanMiLCIuLi9zcmMvQm94LmpzIiwiLi4vc3JjL2ljb25zL2luZGV4LmpzIiwiLi4vc3JjL0ljb24uanMiLCIuLi9zcmMvSW1hZ2UuanMiLCIuLi9zcmMvTWFzay5qcyIsIi4uL3NyYy9BdmF0YXIuanMiLCIuLi9zcmMvVGV4dC5qcyIsIi4uL3NyYy9CdXR0b24uanMiLCIuLi9zcmMvQ2FyZC5qcyIsIi4uL3NyYy9DaGVja2JveC5qcyIsIi4uL3NyYy9Db2xsZWN0aW9uLmpzIiwiLi4vc3JjL0NvbGxhZ2UuanMiLCIuLi9zcmMvQ29sdW1uLmpzIiwiLi4vc3JjL0NvbnRhaW5lci5qcyIsIi4uL3NyYy9EaXZpZGVyLmpzIiwiLi4vc3JjL0NhcmV0LmpzIiwiLi4vc3JjL0NvbnRlbnRzLmpzIiwiLi4vc3JjL2JlaGF2aW9ycy9PdXRzaWRlRXZlbnRCZWhhdmlvci5qcyIsIi4uL3NyYy9Db250cm9sbGVyLmpzIiwiLi4vc3JjL0ZseW91dC5qcyIsIi4uL3NyYy9Hcm91cEF2YXRhci5qcyIsIi4uL3NyYy9IZWFkaW5nLmpzIiwiLi4vc3JjL1BvZy5qcyIsIi4uL3NyYy9JY29uQnV0dG9uLmpzIiwiLi4vc3JjL0xhYmVsLmpzIiwiLi4vc3JjL0xheWVyLmpzIiwiLi4vc3JjL0xldHRlcmJveC5qcyIsIi4uL3NyYy9MaW5rLmpzIiwiLi4vc3JjL2RlYm91bmNlLmpzIiwiLi4vc3JjL0ZldGNoSXRlbXMuanMiLCIuLi9zcmMvU2Nyb2xsQ29udGFpbmVyLmpzIiwiLi4vc3JjL3Rocm90dGxlLmpzIiwiLi4vc3JjL01lYXN1cmVtZW50U3RvcmUuanMiLCIuLi9zcmMvc2Nyb2xsVXRpbHMuanMiLCIuLi9zcmMvbGVnYWN5TGF5b3V0U3ltYm9scy5qcyIsIi4uL3NyYy9kZWZhdWx0TGF5b3V0LmpzIiwiLi4vc3JjL3VuaWZvcm1Sb3dMYXlvdXQuanMiLCIuLi9zcmMvZnVsbFdpZHRoTGF5b3V0LmpzIiwiLi4vc3JjL2xheW91dHMvTWFzb25yeUxheW91dC5qcyIsIi4uL3NyYy9sYXlvdXRzL1VuaWZvcm1Sb3dMYXlvdXQuanMiLCIuLi9zcmMvTWFzb25yeS5qcyIsIi4uL3NyYy9NYXNvbnJ5QmV0YS5qcyIsIi4uL3NyYy9NYXNvbnJ5SW5maW5pdGVCZXRhLmpzIiwiLi4vc3JjL2JlaGF2aW9ycy9TdG9wU2Nyb2xsQmVoYXZpb3IuanMiLCIuLi9zcmMvYmVoYXZpb3JzL1RyYXBGb2N1c0JlaGF2aW9yLmpzIiwiLi4vc3JjL01vZGFsLmpzIiwiLi4vc3JjL1B1bHNhci5qcyIsIi4uL3NyYy9SYWRpb0J1dHRvbi5qcyIsIi4uL3NyYy9TY3JvbGxGZXRjaC5qcyIsIi4uL3NyYy9TZWFyY2hGaWVsZC5qcyIsIi4uL3NyYy9TZWdtZW50ZWRDb250cm9sLmpzIiwiLi4vc3JjL1NlbGVjdExpc3QuanMiLCIuLi9zcmMvU3Bpbm5lci5qcyIsIi4uL3NyYy9TdGlja3kuanMiLCIuLi9zcmMvU3dpdGNoLmpzIiwiLi4vc3JjL1RhYnMuanMiLCIuLi9zcmMvVGV4dEFyZWEuanMiLCIuLi9zcmMvVGV4dEZpZWxkLmpzIiwiLi4vc3JjL1RvYXN0LmpzIiwiLi4vc3JjL1RvdWNoYWJsZS5qcyIsIi4uL3NyYy9WaWRlb1BsYXloZWFkLmpzIiwiLi4vc3JjL1ZpZGVvQ29udHJvbHMuanMiLCIuLi9zcmMvVmlkZW8uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogQGZsb3cgKi9cblxuLypcblxuU3R5bGUgaXMgYSBtb25vaWQgdGhhdCBjYXB0dXJlIHRoZSBcInRvLWJlLWFwcGxpZWRcIiBzdHlsZXMgKGlubGluZSBhbmQgY2xhc3NlcylcbmZvciBhIEJveC4gSXQncyBiYXNpY2FsbHkgc2V0IHRoYXQgaXMgY2xvc2VkIHVuZGVyIGFuIGFzc29jaWF0aXZlIGJpbmFyeVxub3BlcmF0aW9uIGFuZCBoYXMgYW4gaWRlbnRpdHkgZWxlbWVudCBzdWNoIHRoYXQgZm9yIGFsbCBIQSBIQSBIQS4gWWVzLCBpdCdzIGFcbm1vbm9pZCwgd2hpY2ggc291bmRzIHNjYXJ5IGJ1dCBpdCdzIG5vdCByZWFsbHkgYW5kIGFjdHVhbGx5IHN1cGVyIHVzZWZ1bC4gQWxsXG50aGF0IG1lYW5zIGlzIHRoYXQgYmFzaWNhbGx5IHlvdSBjYW4gZG8gdHdvIHRoaW5ncyB3aXRoIGl0OlxuXG4gICAgMS4gY29uY2F0KGNvbmNhdChhLCBiKSwgYykgPT09IGNvbmNhdChhLCBjb25jYXQoYiwgYykpO1xuICAgIDIuIGNvbmNhdChpZGVudGl0eSgpLCBhKSA9PT0gY29uY2F0KGEsIGlkZW50aXR5KCkpID09PSBhO1xuXG5XaGF0IHRoYXQgbWVhbnMgaXMgdGhhdCBpdCdzIHJlYWxseSBlYXN5IHRvIGNvbXBvc2Ugc3R5bGVzIHRvZ2V0aGVyIGFuZCB0aGVcbm9yZGVyIGluIHdoaWNoIHlvdSBkbyBzbyBkb2Vzbid0IHJlYWxseSBtYXR0ZXIuXG5cbiovXG5cbnR5cGUgSW5saW5lU3R5bGUgPSB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB8IG51bWJlciB8IHZvaWQgfTtcblxuLy8gVE9ETzogVGhpcyB0eXBlIHNob3VsZCBiZSBvcGFxdWUsIGhvd2V2ZXIgdGhlIEJhYmVsIHBhcnNlciBkb2Vzbid0IHN1cHBvcnRcbi8vICAgICAgIHRoZSBvcGFxdWUgc3ludGF4IHlldC5cbmV4cG9ydCB0eXBlIFN0eWxlID0ge3xcbiAgY2xhc3NOYW1lOiBTZXQ8c3RyaW5nPixcbiAgaW5saW5lU3R5bGU6IElubGluZVN0eWxlLFxufH07XG5cbmV4cG9ydCBjb25zdCBpZGVudGl0eSA9ICgpOiBTdHlsZSA9PiAoe1xuICBjbGFzc05hbWU6IG5ldyBTZXQoKSxcbiAgaW5saW5lU3R5bGU6IHt9LFxufSk7XG5cbmV4cG9ydCBjb25zdCBmcm9tQ2xhc3NOYW1lID0gKC4uLmNsYXNzTmFtZXM6IEFycmF5PHN0cmluZz4pOiBTdHlsZSA9PiAoe1xuICBjbGFzc05hbWU6IG5ldyBTZXQoY2xhc3NOYW1lcyksXG4gIGlubGluZVN0eWxlOiB7fSxcbn0pO1xuXG5leHBvcnQgY29uc3QgZnJvbUlubGluZVN0eWxlID0gKGlubGluZVN0eWxlOiBJbmxpbmVTdHlsZSk6IFN0eWxlID0+ICh7XG4gIGNsYXNzTmFtZTogbmV3IFNldCgpLFxuICBpbmxpbmVTdHlsZSxcbn0pO1xuXG5leHBvcnQgY29uc3QgY29uY2F0ID0gKHN0eWxlczogQXJyYXk8U3R5bGU+KTogU3R5bGUgPT5cbiAgc3R5bGVzLnJlZHVjZShcbiAgICAoXG4gICAgICB7IGNsYXNzTmFtZTogY2xhc3NOYW1lQSwgaW5saW5lU3R5bGU6IGlubGluZVN0eWxlQSB9LFxuICAgICAgeyBjbGFzc05hbWU6IGNsYXNzTmFtZUIsIGlubGluZVN0eWxlOiBpbmxpbmVTdHlsZUIgfVxuICAgICkgPT4gKHtcbiAgICAgIGNsYXNzTmFtZTogbmV3IFNldChbLi4uY2xhc3NOYW1lQSwgLi4uY2xhc3NOYW1lQl0pLFxuICAgICAgaW5saW5lU3R5bGU6IHsgLi4uaW5saW5lU3R5bGVBLCAuLi5pbmxpbmVTdHlsZUIgfSxcbiAgICB9KSxcbiAgICBpZGVudGl0eSgpXG4gICk7XG5cbmV4cG9ydCBjb25zdCBtYXBDbGFzc05hbWUgPSAoZm46ICh4OiBzdHJpbmcpID0+IHN0cmluZykgPT4gKHtcbiAgY2xhc3NOYW1lLFxuICBpbmxpbmVTdHlsZSxcbn06IFN0eWxlKTogU3R5bGUgPT4gKHtcbiAgY2xhc3NOYW1lOiBuZXcgU2V0KEFycmF5LmZyb20oY2xhc3NOYW1lKS5tYXAoZm4pKSxcbiAgaW5saW5lU3R5bGUsXG59KTtcblxuZXhwb3J0IGNvbnN0IHRvUHJvcHMgPSAoe1xuICBjbGFzc05hbWUsXG4gIGlubGluZVN0eWxlLFxufTogU3R5bGUpOiB7IGNsYXNzTmFtZTogc3RyaW5nLCBzdHlsZTogSW5saW5lU3R5bGUgfSA9PiB7XG4gIGNvbnN0IHByb3BzID0ge307XG5cbiAgaWYgKGNsYXNzTmFtZS5zaXplID4gMCkge1xuICAgIC8vIFNvcnRpbmcgaGVyZSBlbnN1cmVzIHRoYXQgY2xhc3NOYW1lcyBhcmUgYWx3YXlzIHN0YWJsZSwgcmVkdWNpbmcgZGlmZlxuICAgIC8vIGNodXJuLiBCb3ggdXN1YWxseSBoYXMgYSBzbWFsbCBudW1iZXIgb2YgcHJvcGVydGllcyBzbyBpdCdzIG5vdCBhIHBlcmZcbiAgICAvLyBjb25jZXJuLlxuICAgIHByb3BzLmNsYXNzTmFtZSA9IEFycmF5LmZyb20oY2xhc3NOYW1lKVxuICAgICAgLnNvcnQoKVxuICAgICAgLmpvaW4oJyAnKTtcbiAgfVxuXG4gIGlmIChPYmplY3Qua2V5cyhpbmxpbmVTdHlsZSkubGVuZ3RoID4gMCkge1xuICAgIHByb3BzLnN0eWxlID0gaW5saW5lU3R5bGU7XG4gIH1cblxuICByZXR1cm4gcHJvcHM7XG59O1xuIiwiLy8gQGZsb3dcblxuaW1wb3J0IHtcbiAgY29uY2F0LFxuICBmcm9tQ2xhc3NOYW1lLFxuICBpZGVudGl0eSxcbiAgbWFwQ2xhc3NOYW1lLFxuICB0eXBlIFN0eWxlLFxufSBmcm9tICcuL3N0eWxlLmpzJztcblxuLypcblxuVHJhbnNmb3Jtc1xuXG5UaGVzZSBhcmUgYSBjb2xsZWN0aW9uIG9mIGEgZmV3IGZ1bmN0b3JzIHRoYXQgdGFrZSB2YWx1ZXMgYW5kIHJldHVybnMgU3R5bGUncy4gT01HLCBJIHVzZWQgdGhlIHdvcmQgZnVuY3RvciAtIGl0J3MgcmVhbGx5IGp1c3QgYSBmYW5jeSB3b3JkIGZvciBmdW5jdGlvbi5cblxuKi9cblxudHlwZSBGdW5jdG9yID0gKG46IG51bWJlcikgPT4gU3R5bGU7XG5cbi8vIEFkZHMgYSBjbGFzc25hbWUgd2hlbiBhIHByb3BlcnR5IGlzIHByZXNlbnQuXG4vL1xuLy8gICAgIDxCb3ggdG9wIC8+XG4vL1xuZXhwb3J0IGNvbnN0IHRvZ2dsZSA9ICguLi5jbGFzc05hbWVzOiBBcnJheTxzdHJpbmc+KSA9PiAodmFsPzogYm9vbGVhbikgPT5cbiAgdmFsID8gZnJvbUNsYXNzTmFtZSguLi5jbGFzc05hbWVzKSA6IGlkZW50aXR5KCk7XG5cbi8vIE1hcHMgc3RyaW5nIHZhbHVlcyB0byBjbGFzc2VzXG4vL1xuLy8gICAgIDxCb3ggYWxpZ25JdGVtcz1cImNlbnRlclwiIC8+XG4vL1xuZXhwb3J0IGNvbnN0IG1hcHBpbmcgPSAobWFwOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9KSA9PiAodmFsOiBzdHJpbmcpID0+XG4gIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtYXAsIHZhbClcbiAgICA/IGZyb21DbGFzc05hbWUobWFwW3ZhbF0pXG4gICAgOiBpZGVudGl0eSgpO1xuXG4vLyBNYXBzIGEgcmFuZ2Ugb2YgaW50ZWdlcnMgdG8gYSByYW5nZSBvZiBjbGFzc25hbWVzXG4vL1xuLy8gICAgIDxCb3ggcGFkZGluZz17MX0gLz5cbi8vXG5leHBvcnQgY29uc3QgcmFuZ2UgPSAoc2NhbGU6IHN0cmluZykgPT4gKG46IG51bWJlcikgPT5cbiAgZnJvbUNsYXNzTmFtZShgJHtzY2FsZX0ke24gPCAwID8gYE4ke01hdGguYWJzKG4pfWAgOiBufWApO1xuXG4vLyBMaWtlIGByYW5nZWAsIG1hcHMgYSByYW5nZSBvZiBpbnRlZ2VycyB0byBhIHJhbmdlIG9mIGNsYXNzbmFtZXMsIGV4Y2x1ZGluZ1xuLy8gemVybyB2YWx1ZXMuXG4vL1xuLy8gICAgIDxCb3ggcGFkZGluZz17MH0gLz5cbmV4cG9ydCBjb25zdCByYW5nZVdpdGhvdXRaZXJvID0gKHNjYWxlOiBzdHJpbmcpID0+IChuOiBudW1iZXIpID0+XG4gIG4gPT09IDAgPyBpZGVudGl0eSgpIDogcmFuZ2Uoc2NhbGUpKG4pO1xuXG4vLyBCaW5kcyBhIHN0cmluZyBjbGFzc25hbWUgdG8gdGhlIHZhbHVlIGluIGFuIG9iamVjdC4gVXNlZnVsIHdoZW4gaW50ZXJhY3Rpbmdcbi8vIHdpdGggcmFuZ2VzIHRoYXQgbmVlZCB0byBjb21lIGR5bmFtaWNhbGx5IGZyb20gYSBzdHlsZSBvYmplY3QuIFRoaXMgaXNcbi8vIHNpbWlsYXIgdG8gdGhlIE5QTSBwYWNrYWdlICdjbGFzc25hbWVzL2JpbmQnLlxuZXhwb3J0IGNvbnN0IGJpbmQgPSAoZm46IEZ1bmN0b3IsIHNjb3BlOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9KSA9PiAoXG4gIHZhbDogbnVtYmVyXG4pID0+IG1hcENsYXNzTmFtZShuYW1lID0+IHNjb3BlW25hbWVdKShmbih2YWwpKTtcblxuLy8gVGhpcyB0YWtlcyBhIHNlcmllcyBvZiB0aGUgcHJldmlvdXNseSBkZWZpbmVkIGZ1bmN0b3JzLCBydW5zIHRoZW0gYWxsXG4vLyBhZ2FpbnN0IGEgdmFsdWUgYW5kIHJldHVybnMgdGhlIHNldCBvZiB0aGVpciBjbGFzc25hbWVzLlxuZXhwb3J0IGNvbnN0IHVuaW9uID0gKC4uLmZuczogQXJyYXk8RnVuY3Rvcj4pID0+ICh2YWw6IG51bWJlcikgPT5cbiAgY29uY2F0KGZucy5tYXAoZm4gPT4gZm4odmFsKSkpO1xuIiwiLy8gQGZsb3dcblxuLypcblxuIyBXZWxjb21lIHRvIEJveCFcblxuVGhpcyBndWlkZSB3aWxsIGhlbHAgeW91IG5hdmlnYXRlIGFuZCB1bmRlcnN0YW5kIGl0cyBkZXNpZ24uIFRoaXMgZmlsZSBpcyByb3VnaGx5IG9yZ2FuaXplZCBsaWtlOlxuXG4gIDEuIEZsb3cgVHlwZXNcbiAgMi4gUHJvcCB0cmFuc2Zvcm1lcnNcbiAgMy4gQm94IGl0c2VsZlxuICA0LiBQcm9wVHlwZXNcblxuSSdsbCBleHBsYWluIGVhY2ggcGFydCBhcyB3ZSBnbyB0aHJvdWdoLiBKdXN0IHJlbWVtYmVyLCBpZiB5b3Ugd2FudCB0byBtYWtlIHVwZGF0ZXMsIFBMRUFTRSBQTEVBU0UgUExFQVNFIHVwZGF0ZSB0aGUgRmxvdyBUeXBlcyAmIFByb3BUeXBlcyAoZXZlbiB0aG91Z2ggdGhleSBsb29rIHNjYXJ5KS5cblxuKi9cblxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9Cb3guY3NzJztcbmltcG9ydCBib3JkZXJzIGZyb20gJy4vQm9yZGVycy5jc3MnO1xuaW1wb3J0IGNvbG9ycyBmcm9tICcuL0NvbG9ycy5jc3MnO1xuaW1wb3J0IGxheW91dCBmcm9tICcuL0xheW91dC5jc3MnO1xuaW1wb3J0IHdoaXRlc3BhY2UgZnJvbSAnLi9ib3hXaGl0ZXNwYWNlLmNzcyc7XG5pbXBvcnQgd2hpdGVzcGFjZUxlZ2FjeSBmcm9tICcuL1doaXRlc3BhY2UuY3NzJztcbmltcG9ydCB7XG4gIGNvbmNhdCxcbiAgZnJvbUNsYXNzTmFtZSxcbiAgZnJvbUlubGluZVN0eWxlLFxuICBpZGVudGl0eSxcbiAgbWFwQ2xhc3NOYW1lLFxuICB0b1Byb3BzLFxufSBmcm9tICcuL3N0eWxlLmpzJztcbmltcG9ydCB7XG4gIHVuaW9uLFxuICBiaW5kLFxuICByYW5nZSxcbiAgdG9nZ2xlLFxuICBtYXBwaW5nLFxuICByYW5nZVdpdGhvdXRaZXJvLFxufSBmcm9tICcuL3RyYW5zZm9ybXMuanMnO1xuXG4vKlxuXG4jIFByb1R5cGVzXG5cbkJveCdzIHR5cGUgZGVmaW5pdGlvbiBpcyBleGhhdXN0aXZlLiBXaXRoIHRoZSBleGNlcHRpb24gb2YgYGRhbmdlcm91c2x5U2V0SW5saW5lU3R5bGVgLCB2YWx1ZXMgc2hvdWxkbid0IGJlIGFtYmlnaW91cy4gVGhhdCBtZWFucyB0aGF0IHdlIGhhdmUgdG8gdHlwZSBvdXQgdGhpbmdzIGxpa2UgYm9pbnRzLCBidXQgdGhhdCdzIGFsc28gd2hlcmUgQm94J3MgbWFnaWMgbGllcy4gQWxzbywgYnkgcHV0dGluZyBpbiBleHRyYSBlZmZvcnQgYXJvdW5kIHR5cGUgZGVmaW5pdGlvbnMgaGVyZSwgd2UgY2FuIHNraXAgZXh0cmEgcnVudGltZSB0eXBlY2hlY2tzIGluIHRoZSB0cmFuc2Zvcm1lcnMgZm9yIHBlcmZvcm1hbmNlLlxuXG4qL1xuXG50eXBlIE5hdEJvaW50ID0gMSB8IDIgfCAzIHwgNCB8IDUgfCA2O1xudHlwZSBJbnRCb2ludCA9IC02IHwgLTUgfCAtNCB8IC0zIHwgLTIgfCAtMSB8IE5hdEJvaW50O1xudHlwZSBEaXNwbGF5ID0gJ25vbmUnIHwgJ2ZsZXgnIHwgJ2Jsb2NrJyB8ICdpbmxpbmVCbG9jaycgfCAndmlzdWFsbHlIaWRkZW4nO1xudHlwZSBEaXJlY3Rpb24gPSAncm93JyB8ICdjb2x1bW4nO1xudHlwZSBDb2x1bW4gPSAwIHwgMSB8IDIgfCAzIHwgNCB8IDUgfCA2IHwgNyB8IDggfCA5IHwgMTAgfCAxMSB8IDEyO1xudHlwZSBSZXNwb25zaXZlUHJvcHMgPSB7XG4gIGNvbHVtbj86IDEgfCAyIHwgMyB8IDQgfCA1IHwgNiB8IDcgfCA4IHwgOSB8IDEwIHwgMTEgfCAxMixcbiAgZGlzcGxheT86IGJvb2xlYW4gfCAnZmxleCcgfCAnZmxleENvbHVtbicgfCAnaW5saW5lQmxvY2snLFxufTtcbnR5cGUgTWFyZ2luID1cbiAgfCAtMTJcbiAgfCAtMTFcbiAgfCAtMTBcbiAgfCAtOVxuICB8IC04XG4gIHwgLTdcbiAgfCAtNlxuICB8IC01XG4gIHwgLTRcbiAgfCAtM1xuICB8IC0yXG4gIHwgLTFcbiAgfCAwXG4gIHwgMVxuICB8IDJcbiAgfCAzXG4gIHwgNFxuICB8IDVcbiAgfCA2XG4gIHwgN1xuICB8IDhcbiAgfCA5XG4gIHwgMTBcbiAgfCAxMVxuICB8IDEyO1xudHlwZSBQYWRkaW5nID0gMCB8IDEgfCAyIHwgMyB8IDQgfCA1IHwgNiB8IDcgfCA4IHwgOSB8IDEwIHwgMTEgfCAxMjtcbnR5cGUgUHJvcFR5cGUgPSB7XG4gIGNoaWxkcmVuPzogUmVhY3QuTm9kZSxcbiAgZGFuZ2Vyb3VzbHlTZXRJbmxpbmVTdHlsZT86IHtcbiAgICBfX3N0eWxlOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB8IG51bWJlciB8IHZvaWQgfSxcbiAgfSxcblxuICB4cz86IFJlc3BvbnNpdmVQcm9wcyxcbiAgc20/OiBSZXNwb25zaXZlUHJvcHMsXG4gIG1kPzogUmVzcG9uc2l2ZVByb3BzLFxuICBsZz86IFJlc3BvbnNpdmVQcm9wcyxcbiAgZGVwcmVjYXRlZFBhZGRpbmc/OiBOYXRCb2ludCB8IHsgeD86IE5hdEJvaW50LCB5PzogTmF0Qm9pbnQgfSxcbiAgZGVwcmVjYXRlZE1hcmdpbj86XG4gICAgfCBJbnRCb2ludFxuICAgIHwge1xuICAgICAgICB0b3A/OiBJbnRCb2ludCxcbiAgICAgICAgcmlnaHQ/OiBJbnRCb2ludCB8ICdhdXRvJyxcbiAgICAgICAgYm90dG9tPzogSW50Qm9pbnQsXG4gICAgICAgIGxlZnQ/OiBJbnRCb2ludCB8ICdhdXRvJyxcbiAgICAgIH0sXG5cbiAgZGlzcGxheT86IERpc3BsYXksXG4gIGNvbHVtbj86IENvbHVtbixcbiAgZGlyZWN0aW9uPzogRGlyZWN0aW9uLFxuICBzbURpc3BsYXk/OiBEaXNwbGF5LFxuICBzbUNvbHVtbj86IENvbHVtbixcbiAgc21EaXJlY3Rpb24/OiBEaXJlY3Rpb24sXG4gIG1kRGlzcGxheT86IERpc3BsYXksXG4gIG1kQ29sdW1uPzogQ29sdW1uLFxuICBtZERpcmVjdGlvbj86IERpcmVjdGlvbixcbiAgbGdEaXNwbGF5PzogRGlzcGxheSxcbiAgbGdDb2x1bW4/OiBDb2x1bW4sXG4gIGxnRGlyZWN0aW9uPzogRGlyZWN0aW9uLFxuXG4gIGFsaWduQ29udGVudD86ICdzdGFydCcgfCAnZW5kJyB8ICdjZW50ZXInIHwgJ2JldHdlZW4nIHwgJ2Fyb3VuZCcgfCAnc3RyZXRjaCcsXG4gIGFsaWduSXRlbXM/OiAnc3RhcnQnIHwgJ2VuZCcgfCAnY2VudGVyJyB8ICdiYXNlbGluZScgfCAnc3RyZXRjaCcsXG4gIGFsaWduU2VsZj86ICdhdXRvJyB8ICdzdGFydCcgfCAnZW5kJyB8ICdjZW50ZXInIHwgJ2Jhc2VsaW5lJyB8ICdzdHJldGNoJyxcbiAgYm90dG9tPzogYm9vbGVhbixcbiAgY29sb3I/OlxuICAgIHwgJ2JsdWUnXG4gICAgfCAnZGFya0dyYXknXG4gICAgfCAnZGFya1dhc2gnXG4gICAgfCAnZWdncGxhbnQnXG4gICAgfCAnZ3JheSdcbiAgICB8ICdncmVlbidcbiAgICB8ICdsaWdodEdyYXknXG4gICAgfCAnbGlnaHRXYXNoJ1xuICAgIHwgJ21hcm9vbidcbiAgICB8ICdtaWRuaWdodCdcbiAgICB8ICduYXZ5J1xuICAgIHwgJ29saXZlJ1xuICAgIHwgJ29yYW5nZSdcbiAgICB8ICdvcmNoaWQnXG4gICAgfCAncGluZSdcbiAgICB8ICdwdXJwbGUnXG4gICAgfCAncmVkJ1xuICAgIHwgJ3RyYW5zcGFyZW50J1xuICAgIHwgJ3dhdGVybWVsb24nXG4gICAgfCAnd2hpdGUnLFxuICBmaXQ/OiBib29sZWFuLFxuICBmbGV4PzogJ2dyb3cnIHwgJ3NocmluaycgfCAnbm9uZScsXG4gIGhlaWdodD86IG51bWJlciB8IHN0cmluZyxcbiAganVzdGlmeUNvbnRlbnQ/OiAnc3RhcnQnIHwgJ2VuZCcgfCAnY2VudGVyJyB8ICdiZXR3ZWVuJyB8ICdhcm91bmQnLFxuICBsZWZ0PzogYm9vbGVhbixcblxuICBtYXJnaW5TdGFydD86IE1hcmdpbixcbiAgbWFyZ2luRW5kPzogTWFyZ2luLFxuXG4gIG1hcmdpbj86IE1hcmdpbixcbiAgbWFyZ2luVG9wPzogTWFyZ2luLFxuICBtYXJnaW5SaWdodD86IE1hcmdpbixcbiAgbWFyZ2luQm90dG9tPzogTWFyZ2luLFxuICBtYXJnaW5MZWZ0PzogTWFyZ2luLFxuXG4gIHNtTWFyZ2luPzogTWFyZ2luLFxuICBzbU1hcmdpblRvcD86IE1hcmdpbixcbiAgc21NYXJnaW5SaWdodD86IE1hcmdpbixcbiAgc21NYXJnaW5Cb3R0b20/OiBNYXJnaW4sXG4gIHNtTWFyZ2luTGVmdD86IE1hcmdpbixcblxuICBtZE1hcmdpbj86IE1hcmdpbixcbiAgbWRNYXJnaW5Ub3A/OiBNYXJnaW4sXG4gIG1kTWFyZ2luUmlnaHQ/OiBNYXJnaW4sXG4gIG1kTWFyZ2luQm90dG9tPzogTWFyZ2luLFxuICBtZE1hcmdpbkxlZnQ/OiBNYXJnaW4sXG5cbiAgbGdNYXJnaW4/OiBNYXJnaW4sXG4gIGxnTWFyZ2luVG9wPzogTWFyZ2luLFxuICBsZ01hcmdpblJpZ2h0PzogTWFyZ2luLFxuICBsZ01hcmdpbkJvdHRvbT86IE1hcmdpbixcbiAgbGdNYXJnaW5MZWZ0PzogTWFyZ2luLFxuXG4gIG1heEhlaWdodD86IG51bWJlciB8IHN0cmluZyxcbiAgbWF4V2lkdGg/OiBudW1iZXIgfCBzdHJpbmcsXG4gIG1pbkhlaWdodD86IG51bWJlciB8IHN0cmluZyxcbiAgbWluV2lkdGg/OiBudW1iZXIgfCBzdHJpbmcsXG5cbiAgb3ZlcmZsb3c/OiAndmlzaWJsZScgfCAnaGlkZGVuJyB8ICdzY3JvbGwnIHwgJ3Njcm9sbFgnIHwgJ3Njcm9sbFknIHwgJ2F1dG8nLFxuXG4gIHBhZGRpbmc/OiBQYWRkaW5nLFxuICBzbVBhZGRpbmc/OiBQYWRkaW5nLFxuICBtZFBhZGRpbmc/OiBQYWRkaW5nLFxuICBsZ1BhZGRpbmc/OiBQYWRkaW5nLFxuXG4gIHBhZGRpbmdYPzogUGFkZGluZyxcbiAgc21QYWRkaW5nWD86IFBhZGRpbmcsXG4gIG1kUGFkZGluZ1g/OiBQYWRkaW5nLFxuICBsZ1BhZGRpbmdYPzogUGFkZGluZyxcblxuICBwYWRkaW5nWT86IFBhZGRpbmcsXG4gIHNtUGFkZGluZ1k/OiBQYWRkaW5nLFxuICBtZFBhZGRpbmdZPzogUGFkZGluZyxcbiAgbGdQYWRkaW5nWT86IFBhZGRpbmcsXG5cbiAgcG9zaXRpb24/OiAnc3RhdGljJyB8ICdhYnNvbHV0ZScgfCAncmVsYXRpdmUnIHwgJ2ZpeGVkJyxcbiAgcmlnaHQ/OiBib29sZWFuLFxuICBzaGFwZT86XG4gICAgfCAnc3F1YXJlJ1xuICAgIHwgJ3JvdW5kZWQnXG4gICAgfCAncGlsbCdcbiAgICB8ICdjaXJjbGUnXG4gICAgfCAncm91bmRlZFRvcCdcbiAgICB8ICdyb3VuZGVkQm90dG9tJ1xuICAgIHwgJ3JvdW5kZWRMZWZ0J1xuICAgIHwgJ3JvdW5kZWRSaWdodCcsXG4gIHNocmluaz86IGJvb2xlYW4sXG4gIHRvcD86IGJvb2xlYW4sXG4gIHdpZHRoPzogbnVtYmVyIHwgc3RyaW5nLFxuICB3cmFwPzogYm9vbGVhbixcbn07XG5cbi8vIC0tXG5cbi8qXG5cbiMgVHJhbnNmb3JtZXJzXG5cblRoaXMgaXMgd2hlcmUgdGhlIG1lYXQgYW5kIHRoZSBib25lcyBvZiBCb3gncyB0cmFuc2Zvcm1zIGFyZS4gWW91IGNhbiByZWFkIG1vcmUgYWJvdXQgdGhlIERTTCBpbiBgLi90cmFuc2Zvcm1zLmpzYCwgYnV0IGJhc2ljYWxseSB0aGV5IGFyZSBhIHNtYWxsIGRlY2xhcmF0aXZlIHdheSBvZiBzcGVjaWZ5aW5nIGhvdyBhIHByb3BlcnR5IChpLmUuIGBtYXJnaW5Ub3A9ezR9YCkgZ2V0cyB0dXJuZWQgaW50byBhIENTUyBjbGFzcyAoYG1hcmdpblRvcDRgKS5cblxuVGhlcmUncyBhIGxpdHRsZSBwcmVhbWJsZSBoZXJlLCBidXQgaXQgY3VsbWluYXRlcyBpbiBhIGJpZyBvYmplY3QgbWFwcGluZyB0aGUgYWN0dWFsIHByb3BlcnR5IG5hbWVzIHRvIHRoZSB0cmFuc2Zvcm1lciB2YWx1ZXMuXG5cbiovXG5cbmNvbnN0IG1hcmdpblN0YXJ0ID0gYmluZChyYW5nZVdpdGhvdXRaZXJvKCdtYXJnaW5TdGFydCcpLCB3aGl0ZXNwYWNlKTtcbmNvbnN0IG1hcmdpbkVuZCA9IGJpbmQocmFuZ2VXaXRob3V0WmVybygnbWFyZ2luRW5kJyksIHdoaXRlc3BhY2UpO1xuY29uc3QgbWFyZ2luVG9wID0gYmluZChyYW5nZVdpdGhvdXRaZXJvKCdtYXJnaW5Ub3AnKSwgd2hpdGVzcGFjZSk7XG5jb25zdCBtYXJnaW5SaWdodCA9IGJpbmQocmFuZ2VXaXRob3V0WmVybygnbWFyZ2luUmlnaHQnKSwgd2hpdGVzcGFjZSk7XG5jb25zdCBtYXJnaW5Cb3R0b20gPSBiaW5kKHJhbmdlV2l0aG91dFplcm8oJ21hcmdpbkJvdHRvbScpLCB3aGl0ZXNwYWNlKTtcbmNvbnN0IG1hcmdpbkxlZnQgPSBiaW5kKHJhbmdlV2l0aG91dFplcm8oJ21hcmdpbkxlZnQnKSwgd2hpdGVzcGFjZSk7XG5jb25zdCBtYXJnaW4gPSB1bmlvbihtYXJnaW5Ub3AsIG1hcmdpbkJvdHRvbSwgbWFyZ2luTGVmdCwgbWFyZ2luUmlnaHQpO1xuXG5jb25zdCBzbU1hcmdpblRvcCA9IGJpbmQocmFuZ2VXaXRob3V0WmVybygnc21NYXJnaW5Ub3AnKSwgd2hpdGVzcGFjZSk7XG5jb25zdCBzbU1hcmdpblJpZ2h0ID0gYmluZChyYW5nZVdpdGhvdXRaZXJvKCdzbU1hcmdpblJpZ2h0JyksIHdoaXRlc3BhY2UpO1xuY29uc3Qgc21NYXJnaW5Cb3R0b20gPSBiaW5kKHJhbmdlV2l0aG91dFplcm8oJ3NtTWFyZ2luQm90dG9tJyksIHdoaXRlc3BhY2UpO1xuY29uc3Qgc21NYXJnaW5MZWZ0ID0gYmluZChyYW5nZVdpdGhvdXRaZXJvKCdzbU1hcmdpbkxlZnQnKSwgd2hpdGVzcGFjZSk7XG5jb25zdCBzbU1hcmdpbiA9IHVuaW9uKFxuICBzbU1hcmdpblRvcCxcbiAgc21NYXJnaW5Cb3R0b20sXG4gIHNtTWFyZ2luTGVmdCxcbiAgc21NYXJnaW5SaWdodFxuKTtcblxuY29uc3QgbWRNYXJnaW5Ub3AgPSBiaW5kKHJhbmdlV2l0aG91dFplcm8oJ21kTWFyZ2luVG9wJyksIHdoaXRlc3BhY2UpO1xuY29uc3QgbWRNYXJnaW5SaWdodCA9IGJpbmQocmFuZ2VXaXRob3V0WmVybygnbWRNYXJnaW5SaWdodCcpLCB3aGl0ZXNwYWNlKTtcbmNvbnN0IG1kTWFyZ2luQm90dG9tID0gYmluZChyYW5nZVdpdGhvdXRaZXJvKCdtZE1hcmdpbkJvdHRvbScpLCB3aGl0ZXNwYWNlKTtcbmNvbnN0IG1kTWFyZ2luTGVmdCA9IGJpbmQocmFuZ2VXaXRob3V0WmVybygnbWRNYXJnaW5MZWZ0JyksIHdoaXRlc3BhY2UpO1xuY29uc3QgbWRNYXJnaW4gPSB1bmlvbihcbiAgbWRNYXJnaW5Ub3AsXG4gIG1kTWFyZ2luQm90dG9tLFxuICBtZE1hcmdpbkxlZnQsXG4gIG1kTWFyZ2luUmlnaHRcbik7XG5cbmNvbnN0IGxnTWFyZ2luVG9wID0gYmluZChyYW5nZVdpdGhvdXRaZXJvKCdsZ01hcmdpblRvcCcpLCB3aGl0ZXNwYWNlKTtcbmNvbnN0IGxnTWFyZ2luUmlnaHQgPSBiaW5kKHJhbmdlV2l0aG91dFplcm8oJ2xnTWFyZ2luUmlnaHQnKSwgd2hpdGVzcGFjZSk7XG5jb25zdCBsZ01hcmdpbkJvdHRvbSA9IGJpbmQocmFuZ2VXaXRob3V0WmVybygnbGdNYXJnaW5Cb3R0b20nKSwgd2hpdGVzcGFjZSk7XG5jb25zdCBsZ01hcmdpbkxlZnQgPSBiaW5kKHJhbmdlV2l0aG91dFplcm8oJ2xnTWFyZ2luTGVmdCcpLCB3aGl0ZXNwYWNlKTtcbmNvbnN0IGxnTWFyZ2luID0gdW5pb24oXG4gIGxnTWFyZ2luVG9wLFxuICBsZ01hcmdpbkJvdHRvbSxcbiAgbGdNYXJnaW5MZWZ0LFxuICBsZ01hcmdpblJpZ2h0XG4pO1xuXG5jb25zdCBwYWRkaW5nWCA9IGJpbmQocmFuZ2VXaXRob3V0WmVybygncGFkZGluZ1gnKSwgd2hpdGVzcGFjZSk7XG5jb25zdCBwYWRkaW5nWSA9IGJpbmQocmFuZ2VXaXRob3V0WmVybygncGFkZGluZ1knKSwgd2hpdGVzcGFjZSk7XG5jb25zdCBwYWRkaW5nID0gdW5pb24ocGFkZGluZ1gsIHBhZGRpbmdZKTtcblxuY29uc3Qgc21QYWRkaW5nWCA9IGJpbmQocmFuZ2VXaXRob3V0WmVybygnc21QYWRkaW5nWCcpLCB3aGl0ZXNwYWNlKTtcbmNvbnN0IHNtUGFkZGluZ1kgPSBiaW5kKHJhbmdlV2l0aG91dFplcm8oJ3NtUGFkZGluZ1knKSwgd2hpdGVzcGFjZSk7XG5jb25zdCBzbVBhZGRpbmcgPSB1bmlvbihzbVBhZGRpbmdYLCBzbVBhZGRpbmdZKTtcblxuY29uc3QgbWRQYWRkaW5nWCA9IGJpbmQocmFuZ2VXaXRob3V0WmVybygnbWRQYWRkaW5nWCcpLCB3aGl0ZXNwYWNlKTtcbmNvbnN0IG1kUGFkZGluZ1kgPSBiaW5kKHJhbmdlV2l0aG91dFplcm8oJ21kUGFkZGluZ1knKSwgd2hpdGVzcGFjZSk7XG5jb25zdCBtZFBhZGRpbmcgPSB1bmlvbihtZFBhZGRpbmdYLCBtZFBhZGRpbmdZKTtcblxuY29uc3QgbGdQYWRkaW5nWCA9IGJpbmQocmFuZ2VXaXRob3V0WmVybygnbGdQYWRkaW5nWCcpLCB3aGl0ZXNwYWNlKTtcbmNvbnN0IGxnUGFkZGluZ1kgPSBiaW5kKHJhbmdlV2l0aG91dFplcm8oJ2xnUGFkZGluZ1knKSwgd2hpdGVzcGFjZSk7XG5jb25zdCBsZ1BhZGRpbmcgPSB1bmlvbihsZ1BhZGRpbmdYLCBsZ1BhZGRpbmdZKTtcblxuLypcblxuVGhlc2UgZnVuY3Rpb25zIGFyZSBsZWdhY3kuIEknZCBsaWtlIHRvIGdldCByaWQgb2YgbW9zdCBvZiB0aGlzIGZpbGUncyBkZXBlbmRlbmN5IG9uIGltcG9ydGluZyBgLi9zdHlsZS5qc2AgZGlyZWN0bHkgb25jZSB0aGVzZSBhcmUgcmVtb3ZlZC5cblxuKi9cblxuY29uc3QgcHJlZml4ID0gKHByZTogc3RyaW5nKSA9PiBtYXBDbGFzc05hbWUobmFtZSA9PiBgJHtwcmV9JHtuYW1lfWApO1xuY29uc3QgZGlzcGxheSA9IHZhbHVlID0+IHtcbiAgc3dpdGNoICh2YWx1ZSkge1xuICAgIGNhc2UgJ2ZsZXgnOlxuICAgICAgcmV0dXJuIGZyb21DbGFzc05hbWUoJ0Rpc3BsYXlGbGV4JywgJ0RpcmVjdGlvblJvdycpO1xuICAgIGNhc2UgJ2ZsZXhDb2x1bW4nOlxuICAgICAgcmV0dXJuIGZyb21DbGFzc05hbWUoJ0Rpc3BsYXlGbGV4JywgJ0RpcmVjdGlvbkNvbHVtbicpO1xuICAgIGNhc2UgJ2lubGluZUJsb2NrJzpcbiAgICAgIHJldHVybiBmcm9tQ2xhc3NOYW1lKCdEaXNwbGF5SW5saW5lQmxvY2snKTtcbiAgICBjYXNlICd2aXN1YWxseUhpZGRlbic6XG4gICAgICByZXR1cm4gZnJvbUNsYXNzTmFtZSgnRGlzcGxheVZpc3VhbGx5SGlkZGVuJyk7XG4gICAgY2FzZSBmYWxzZTpcbiAgICAgIHJldHVybiBmcm9tQ2xhc3NOYW1lKCdEaXNwbGF5Tm9uZScpO1xuICAgIGRlZmF1bHQ6XG4gICAgICAvKiBibG9jayAqL1xuICAgICAgcmV0dXJuIGZyb21DbGFzc05hbWUoJ0Rpc3BsYXlCbG9jaycpO1xuICB9XG59O1xuY29uc3QgY29sdW1uID0gcmFuZ2UoJ0NvbCcpO1xuXG5jb25zdCBmb3JtYXRJbnRCb2ludCA9IHggPT4gKHggPCAwID8gYG4ke01hdGguYWJzKHgpfWAgOiB4LnRvU3RyaW5nKCkpO1xuXG4vKlxuXG5JdCdzIHByZWZlcmFibGUgdG8gcHV0IG5ldyBwcm9wZXJ0aWVzIGludG8gdGhhdCBvYmplY3QgZGlyZWN0bHkganVzdCBzbyBpdCdzIGVhc2llciB0byByZWFkLlxuXG4qL1xuXG5jb25zdCBwcm9wVG9GbiA9IHtcbiAgeHM6IHZhbHVlID0+IHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm4gaWRlbnRpdHkoKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcENsYXNzTmFtZShjID0+IHN0eWxlc1tjXSkoXG4gICAgICBwcmVmaXgoJ3hzJykoXG4gICAgICAgIGNvbmNhdChbXG4gICAgICAgICAgdmFsdWUuY29sdW1uID8gY29sdW1uKHZhbHVlLmNvbHVtbikgOiBpZGVudGl0eSgpLFxuICAgICAgICAgIHR5cGVvZiB2YWx1ZS5kaXNwbGF5ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyBkaXNwbGF5KHZhbHVlLmRpc3BsYXkpXG4gICAgICAgICAgICA6IGlkZW50aXR5KCksXG4gICAgICAgIF0pXG4gICAgICApXG4gICAgKTtcbiAgfSxcbiAgc206IHZhbHVlID0+IHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm4gaWRlbnRpdHkoKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcENsYXNzTmFtZShjID0+IHN0eWxlc1tjXSkoXG4gICAgICBwcmVmaXgoJ3NtJykoXG4gICAgICAgIGNvbmNhdChbXG4gICAgICAgICAgdmFsdWUuY29sdW1uID8gY29sdW1uKHZhbHVlLmNvbHVtbikgOiBpZGVudGl0eSgpLFxuICAgICAgICAgIHR5cGVvZiB2YWx1ZS5kaXNwbGF5ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyBkaXNwbGF5KHZhbHVlLmRpc3BsYXkpXG4gICAgICAgICAgICA6IGlkZW50aXR5KCksXG4gICAgICAgIF0pXG4gICAgICApXG4gICAgKTtcbiAgfSxcbiAgbWQ6IHZhbHVlID0+IHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm4gaWRlbnRpdHkoKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcENsYXNzTmFtZShjID0+IHN0eWxlc1tjXSkoXG4gICAgICBwcmVmaXgoJ21kJykoXG4gICAgICAgIGNvbmNhdChbXG4gICAgICAgICAgdmFsdWUuY29sdW1uID8gY29sdW1uKHZhbHVlLmNvbHVtbikgOiBpZGVudGl0eSgpLFxuICAgICAgICAgIHR5cGVvZiB2YWx1ZS5kaXNwbGF5ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyBkaXNwbGF5KHZhbHVlLmRpc3BsYXkpXG4gICAgICAgICAgICA6IGlkZW50aXR5KCksXG4gICAgICAgIF0pXG4gICAgICApXG4gICAgKTtcbiAgfSxcbiAgbGc6IHZhbHVlID0+IHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm4gaWRlbnRpdHkoKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcENsYXNzTmFtZShjID0+IHN0eWxlc1tjXSkoXG4gICAgICBwcmVmaXgoJ2xnJykoXG4gICAgICAgIGNvbmNhdChbXG4gICAgICAgICAgdmFsdWUuY29sdW1uID8gY29sdW1uKHZhbHVlLmNvbHVtbikgOiBpZGVudGl0eSgpLFxuICAgICAgICAgIHR5cGVvZiB2YWx1ZS5kaXNwbGF5ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyBkaXNwbGF5KHZhbHVlLmRpc3BsYXkpXG4gICAgICAgICAgICA6IGlkZW50aXR5KCksXG4gICAgICAgIF0pXG4gICAgICApXG4gICAgKTtcbiAgfSxcblxuICBkaXNwbGF5OiBtYXBwaW5nKHtcbiAgICBub25lOiBzdHlsZXMueHNEaXNwbGF5Tm9uZSxcbiAgICBmbGV4OiBzdHlsZXMueHNEaXNwbGF5RmxleCxcbiAgICBibG9jazogc3R5bGVzLnhzRGlzcGxheUJsb2NrLFxuICAgIGlubGluZUJsb2NrOiBzdHlsZXMueHNEaXNwbGF5SW5saW5lQmxvY2ssXG4gICAgdmlzdWFsbHlIaWRkZW46IHN0eWxlcy54c0Rpc3BsYXlWaXN1YWxseUhpZGRlbixcbiAgfSksXG4gIGNvbHVtbjogYmluZChyYW5nZSgneHNDb2wnKSwgc3R5bGVzKSxcbiAgZGlyZWN0aW9uOiBtYXBwaW5nKHtcbiAgICByb3c6IHN0eWxlcy54c0RpcmVjdGlvblJvdyxcbiAgICBjb2x1bW46IHN0eWxlcy54c0RpcmVjdGlvbkNvbHVtbixcbiAgfSksXG5cbiAgc21EaXNwbGF5OiBtYXBwaW5nKHtcbiAgICBub25lOiBzdHlsZXMuc21EaXNwbGF5Tm9uZSxcbiAgICBmbGV4OiBzdHlsZXMuc21EaXNwbGF5RmxleCxcbiAgICBibG9jazogc3R5bGVzLnNtRGlzcGxheUJsb2NrLFxuICAgIGlubGluZUJsb2NrOiBzdHlsZXMuc21EaXNwbGF5SW5saW5lQmxvY2ssXG4gICAgdmlzdWFsbHlIaWRkZW46IHN0eWxlcy5zbURpc3BsYXlWaXN1YWxseUhpZGRlbixcbiAgfSksXG4gIHNtQ29sdW1uOiBiaW5kKHJhbmdlKCdzbUNvbCcpLCBzdHlsZXMpLFxuICBzbURpcmVjdGlvbjogbWFwcGluZyh7XG4gICAgcm93OiBzdHlsZXMuc21EaXJlY3Rpb25Sb3csXG4gICAgY29sdW1uOiBzdHlsZXMuc21EaXJlY3Rpb25Db2x1bW4sXG4gIH0pLFxuXG4gIG1kRGlzcGxheTogbWFwcGluZyh7XG4gICAgbm9uZTogc3R5bGVzLm1kRGlzcGxheU5vbmUsXG4gICAgZmxleDogc3R5bGVzLm1kRGlzcGxheUZsZXgsXG4gICAgYmxvY2s6IHN0eWxlcy5tZERpc3BsYXlCbG9jayxcbiAgICBpbmxpbmVCbG9jazogc3R5bGVzLm1kRGlzcGxheUlubGluZUJsb2NrLFxuICAgIHZpc3VhbGx5SGlkZGVuOiBzdHlsZXMubWREaXNwbGF5VmlzdWFsbHlIaWRkZW4sXG4gIH0pLFxuICBtZENvbHVtbjogYmluZChyYW5nZSgnbWRDb2wnKSwgc3R5bGVzKSxcbiAgbWREaXJlY3Rpb246IG1hcHBpbmcoe1xuICAgIHJvdzogc3R5bGVzLm1kRGlyZWN0aW9uUm93LFxuICAgIGNvbHVtbjogc3R5bGVzLm1kRGlyZWN0aW9uQ29sdW1uLFxuICB9KSxcblxuICBsZ0Rpc3BsYXk6IG1hcHBpbmcoe1xuICAgIG5vbmU6IHN0eWxlcy5sZ0Rpc3BsYXlOb25lLFxuICAgIGZsZXg6IHN0eWxlcy5sZ0Rpc3BsYXlGbGV4LFxuICAgIGJsb2NrOiBzdHlsZXMubGdEaXNwbGF5QmxvY2ssXG4gICAgaW5saW5lQmxvY2s6IHN0eWxlcy5sZ0Rpc3BsYXlJbmxpbmVCbG9jayxcbiAgICB2aXN1YWxseUhpZGRlbjogc3R5bGVzLmxnRGlzcGxheVZpc3VhbGx5SGlkZGVuLFxuICB9KSxcbiAgbGdDb2x1bW46IGJpbmQocmFuZ2UoJ2xnQ29sJyksIHN0eWxlcyksXG4gIGxnRGlyZWN0aW9uOiBtYXBwaW5nKHtcbiAgICByb3c6IHN0eWxlcy5sZ0RpcmVjdGlvblJvdyxcbiAgICBjb2x1bW46IHN0eWxlcy5sZ0RpcmVjdGlvbkNvbHVtbixcbiAgfSksXG5cbiAgYWxpZ25Db250ZW50OiBtYXBwaW5nKHtcbiAgICBzdGFydDogbGF5b3V0LmNvbnRlbnRTdGFydCxcbiAgICBlbmQ6IGxheW91dC5jb250ZW50RW5kLFxuICAgIGNlbnRlcjogbGF5b3V0LmNvbnRlbnRDZW50ZXIsXG4gICAgYmV0d2VlbjogbGF5b3V0LmNvbnRlbnRCZXR3ZWVuLFxuICAgIGFyb3VuZDogbGF5b3V0LmNvbnRlbnRBcm91bmQsXG4gICAgLy8gZGVmYXVsdDogc3RyZXRjaFxuICB9KSxcbiAgYWxpZ25JdGVtczogbWFwcGluZyh7XG4gICAgc3RhcnQ6IGxheW91dC5pdGVtc1N0YXJ0LFxuICAgIGVuZDogbGF5b3V0Lml0ZW1zRW5kLFxuICAgIGNlbnRlcjogbGF5b3V0Lml0ZW1zQ2VudGVyLFxuICAgIGJhc2VsaW5lOiBsYXlvdXQuaXRlbXNCYXNlbGluZSxcbiAgICAvLyBkZWZhdWx0OiBzdHJldGNoXG4gIH0pLFxuICBhbGlnblNlbGY6IG1hcHBpbmcoe1xuICAgIHN0YXJ0OiBsYXlvdXQuc2VsZlN0YXJ0LFxuICAgIGVuZDogbGF5b3V0LnNlbGZFbmQsXG4gICAgY2VudGVyOiBsYXlvdXQuc2VsZkNlbnRlcixcbiAgICBiYXNlbGluZTogbGF5b3V0LnNlbGZCYXNlbGluZSxcbiAgICBzdHJldGNoOiBsYXlvdXQuc2VsZlN0cmV0Y2gsXG4gICAgLy8gZGVmYXVsdDogYXV0b1xuICB9KSxcbiAgYm90dG9tOiB0b2dnbGUobGF5b3V0LmJvdHRvbTApLFxuICBjb2xvcjogbWFwcGluZyh7XG4gICAgYmx1ZTogY29sb3JzLmJsdWVCZyxcbiAgICBkYXJrR3JheTogY29sb3JzLmRhcmtHcmF5QmcsXG4gICAgcGluZTogY29sb3JzLnBpbmVCZyxcbiAgICBncmF5OiBjb2xvcnMuZ3JheUJnLFxuICAgIHJlZDogY29sb3JzLnJlZEJnLFxuICAgIG9saXZlOiBjb2xvcnMub2xpdmVCZyxcbiAgICBsaWdodEdyYXk6IGNvbG9ycy5saWdodEdyYXlCZyxcbiAgICB3aGl0ZTogY29sb3JzLndoaXRlQmcsXG4gICAgb3JhbmdlOiBjb2xvcnMub3JhbmdlQmcsXG4gICAgZ3JlZW46IGNvbG9ycy5ncmVlbkJnLFxuICAgIG5hdnk6IGNvbG9ycy5uYXZ5QmcsXG4gICAgbWlkbmlnaHQ6IGNvbG9ycy5taWRuaWdodEJnLFxuICAgIHB1cnBsZTogY29sb3JzLnB1cnBsZUJnLFxuICAgIG9yY2hpZDogY29sb3JzLm9yY2hpZEJnLFxuICAgIGVnZ3BsYW50OiBjb2xvcnMuZWdncGxhbnRCZyxcbiAgICBtYXJvb246IGNvbG9ycy5tYXJvb25CZyxcbiAgICB3YXRlcm1lbG9uOiBjb2xvcnMud2F0ZXJtZWxvbkJnLFxuICAgIGxpZ2h0V2FzaDogY29sb3JzLmxpZ2h0V2FzaEJnLFxuICAgIGRhcmtXYXNoOiBjb2xvcnMuZGFya1dhc2hCZyxcbiAgICAvLyBkZWZhdWx0OiB0cmFuc3BhcmVudFxuICB9KSxcbiAgZml0OiB0b2dnbGUobGF5b3V0LmZpdCksXG4gIGZsZXg6IG1hcHBpbmcoe1xuICAgIGdyb3c6IGxheW91dC5mbGV4R3JvdyxcbiAgICBub25lOiBsYXlvdXQuZmxleE5vbmUsXG4gICAgLy8gZGVmYXVsdDogc2hyaW5rXG4gIH0pLFxuICBoZWlnaHQ6IGhlaWdodCA9PiBmcm9tSW5saW5lU3R5bGUoeyBoZWlnaHQgfSksXG4gIGp1c3RpZnlDb250ZW50OiBtYXBwaW5nKHtcbiAgICBlbmQ6IGxheW91dC5qdXN0aWZ5RW5kLFxuICAgIGNlbnRlcjogbGF5b3V0Lmp1c3RpZnlDZW50ZXIsXG4gICAgYmV0d2VlbjogbGF5b3V0Lmp1c3RpZnlCZXR3ZWVuLFxuICAgIGFyb3VuZDogbGF5b3V0Lmp1c3RpZnlBcm91bmQsXG4gICAgLy8gZGVmYXVsdDogc3RhcnRcbiAgfSksXG4gIGxlZnQ6IHRvZ2dsZShsYXlvdXQubGVmdDApLFxuICBkZXByZWNhdGVkTWFyZ2luOiB2YWx1ZSA9PiB7XG4gICAgbGV0IG10ID0gaWRlbnRpdHkoKTtcbiAgICBsZXQgbWIgPSBpZGVudGl0eSgpO1xuICAgIGxldCBtbCA9IGlkZW50aXR5KCk7XG4gICAgbGV0IG1yID0gaWRlbnRpdHkoKTtcbiAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgcmV0dXJuIGZyb21DbGFzc05hbWUod2hpdGVzcGFjZUxlZ2FjeVtgbSR7Zm9ybWF0SW50Qm9pbnQodmFsdWUpfWBdKTtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGlmICh2YWx1ZS50b3ApIHtcbiAgICAgICAgICBtdCA9IGZyb21DbGFzc05hbWUoXG4gICAgICAgICAgICB3aGl0ZXNwYWNlTGVnYWN5W2BtdCR7Zm9ybWF0SW50Qm9pbnQodmFsdWUudG9wKX1gXVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUuYm90dG9tKSB7XG4gICAgICAgICAgbWIgPSBmcm9tQ2xhc3NOYW1lKFxuICAgICAgICAgICAgd2hpdGVzcGFjZUxlZ2FjeVtgbWIke2Zvcm1hdEludEJvaW50KHZhbHVlLmJvdHRvbSl9YF1cbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlLmxlZnQpIHtcbiAgICAgICAgICBtbCA9IGZyb21DbGFzc05hbWUoXG4gICAgICAgICAgICB2YWx1ZS5sZWZ0ID09PSAnYXV0bydcbiAgICAgICAgICAgICAgPyB3aGl0ZXNwYWNlTGVnYWN5Lm1sQXV0b1xuICAgICAgICAgICAgICA6IHdoaXRlc3BhY2VMZWdhY3lbYG1sJHtmb3JtYXRJbnRCb2ludCh2YWx1ZS5sZWZ0KX1gXVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUucmlnaHQpIHtcbiAgICAgICAgICBtciA9IGZyb21DbGFzc05hbWUoXG4gICAgICAgICAgICB2YWx1ZS5yaWdodCA9PT0gJ2F1dG8nXG4gICAgICAgICAgICAgID8gd2hpdGVzcGFjZUxlZ2FjeS5tckF1dG9cbiAgICAgICAgICAgICAgOiB3aGl0ZXNwYWNlTGVnYWN5W2BtciR7Zm9ybWF0SW50Qm9pbnQodmFsdWUucmlnaHQpfWBdXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uY2F0KFttdCwgbWIsIG1sLCBtcl0pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGlkZW50aXR5KCk7XG4gICAgfVxuICB9LFxuICBtYXJnaW5TdGFydCxcbiAgbWFyZ2luRW5kLFxuICBtYXJnaW4sXG4gIG1hcmdpblRvcCxcbiAgbWFyZ2luUmlnaHQsXG4gIG1hcmdpbkJvdHRvbSxcbiAgbWFyZ2luTGVmdCxcbiAgc21NYXJnaW4sXG4gIHNtTWFyZ2luVG9wLFxuICBzbU1hcmdpblJpZ2h0LFxuICBzbU1hcmdpbkJvdHRvbSxcbiAgc21NYXJnaW5MZWZ0LFxuICBtZE1hcmdpbixcbiAgbWRNYXJnaW5Ub3AsXG4gIG1kTWFyZ2luUmlnaHQsXG4gIG1kTWFyZ2luQm90dG9tLFxuICBtZE1hcmdpbkxlZnQsXG4gIGxnTWFyZ2luLFxuICBsZ01hcmdpblRvcCxcbiAgbGdNYXJnaW5SaWdodCxcbiAgbGdNYXJnaW5Cb3R0b20sXG4gIGxnTWFyZ2luTGVmdCxcbiAgbWF4SGVpZ2h0OiBtYXhIZWlnaHQgPT4gZnJvbUlubGluZVN0eWxlKHsgbWF4SGVpZ2h0IH0pLFxuICBtYXhXaWR0aDogbWF4V2lkdGggPT4gZnJvbUlubGluZVN0eWxlKHsgbWF4V2lkdGggfSksXG4gIG1pbkhlaWdodDogbWluSGVpZ2h0ID0+IGZyb21JbmxpbmVTdHlsZSh7IG1pbkhlaWdodCB9KSxcbiAgbWluV2lkdGg6IG1pbldpZHRoID0+IGZyb21JbmxpbmVTdHlsZSh7IG1pbldpZHRoIH0pLFxuICBvdmVyZmxvdzogbWFwcGluZyh7XG4gICAgaGlkZGVuOiBsYXlvdXQub3ZlcmZsb3dIaWRkZW4sXG4gICAgc2Nyb2xsOiBsYXlvdXQub3ZlcmZsb3dTY3JvbGwsXG4gICAgYXV0bzogbGF5b3V0Lm92ZXJmbG93QXV0byxcbiAgICBzY3JvbGxYOiBsYXlvdXQub3ZlcmZsb3dTY3JvbGxYLFxuICAgIHNjcm9sbFk6IGxheW91dC5vdmVyZmxvd1Njcm9sbFksXG4gICAgLy8gZGVmYXVsdDogdmlzaWJsZVxuICB9KSxcbiAgZGVwcmVjYXRlZFBhZGRpbmc6IHZhbHVlID0+IHtcbiAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgcmV0dXJuIGZyb21DbGFzc05hbWUod2hpdGVzcGFjZUxlZ2FjeVtgcCR7dmFsdWV9YF0pO1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgcmV0dXJuIGNvbmNhdChbXG4gICAgICAgICAgdmFsdWUueFxuICAgICAgICAgICAgPyBmcm9tQ2xhc3NOYW1lKHdoaXRlc3BhY2VMZWdhY3lbYHB4JHt2YWx1ZS54fWBdKVxuICAgICAgICAgICAgOiBpZGVudGl0eSgpLFxuICAgICAgICAgIHZhbHVlLnlcbiAgICAgICAgICAgID8gZnJvbUNsYXNzTmFtZSh3aGl0ZXNwYWNlTGVnYWN5W2BweSR7dmFsdWUueX1gXSlcbiAgICAgICAgICAgIDogaWRlbnRpdHkoKSxcbiAgICAgICAgXSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gaWRlbnRpdHkoKTtcbiAgICB9XG4gIH0sXG4gIHBhZGRpbmcsXG4gIHBhZGRpbmdYLFxuICBwYWRkaW5nWSxcbiAgc21QYWRkaW5nLFxuICBzbVBhZGRpbmdYLFxuICBzbVBhZGRpbmdZLFxuICBtZFBhZGRpbmcsXG4gIG1kUGFkZGluZ1gsXG4gIG1kUGFkZGluZ1ksXG4gIGxnUGFkZGluZyxcbiAgbGdQYWRkaW5nWCxcbiAgbGdQYWRkaW5nWSxcbiAgcG9zaXRpb246IG1hcHBpbmcoe1xuICAgIGFic29sdXRlOiBsYXlvdXQuYWJzb2x1dGUsXG4gICAgcmVsYXRpdmU6IGxheW91dC5yZWxhdGl2ZSxcbiAgICBmaXhlZDogbGF5b3V0LmZpeGVkLFxuICAgIC8vIGRlZmF1bHQ6IHN0YXRpY1xuICB9KSxcbiAgcmlnaHQ6IHRvZ2dsZShsYXlvdXQucmlnaHQwKSxcbiAgc2hhcGU6IG1hcHBpbmcoe1xuICAgIGNpcmNsZTogYm9yZGVycy5jaXJjbGUsXG4gICAgcGlsbDogYm9yZGVycy5waWxsLFxuICAgIHJvdW5kZWQ6IGJvcmRlcnMucm91bmRlZCxcbiAgICByb3VuZGVkQm90dG9tOiBib3JkZXJzLnJvdW5kZWRCb3R0b20sXG4gICAgcm91bmRlZExlZnQ6IGJvcmRlcnMucm91bmRlZExlZnQsXG4gICAgcm91bmRlZFJpZ2h0OiBib3JkZXJzLnJvdW5kZWRSaWdodCxcbiAgICByb3VuZGVkVG9wOiBib3JkZXJzLnJvdW5kZWRUb3AsXG4gICAgLy8gZGVmYXVsdDogc3F1YXJlXG4gIH0pLFxuICB0b3A6IHRvZ2dsZShsYXlvdXQudG9wMCksXG4gIHdpZHRoOiB3aWR0aCA9PiBmcm9tSW5saW5lU3R5bGUoeyB3aWR0aCB9KSxcbiAgd3JhcDogdG9nZ2xlKGxheW91dC5mbGV4V3JhcCksXG4gIGRhbmdlcm91c2x5U2V0SW5saW5lU3R5bGU6IHZhbHVlID0+XG4gICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVyc2NvcmUtZGFuZ2xlICovXG4gICAgdmFsdWUgJiYgdmFsdWUuX19zdHlsZSA/IGZyb21JbmxpbmVTdHlsZSh2YWx1ZS5fX3N0eWxlKSA6IGlkZW50aXR5KCksXG59O1xuXG4vKlxuXG4jIFRoZSBDb21wb25lbnRcblxuKi9cblxuY29uc3QgY29udGFpbnMgPSAoa2V5LCBhcnIpID0+IGFyci5pbmRleE9mKGtleSkgPj0gMDtcbmNvbnN0IG9taXQgPSAoa2V5cywgb2JqKSA9PlxuICBPYmplY3Qua2V5cyhvYmopLnJlZHVjZSgoYWNjLCBrKSA9PiB7XG4gICAgaWYgKGNvbnRhaW5zKGssIGtleXMpKSB7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgLi4uYWNjLFxuICAgICAgW2tdOiBvYmpba10sXG4gICAgfTtcbiAgfSwge30pO1xuXG4vLyAkRmxvd0lzc3VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy82MTAzXG5jb25zdCBCb3ggPSBSZWFjdC5mb3J3YXJkUmVmKFxuICAoeyBjaGlsZHJlbiwgLi4ucHJvcHMgfTogUHJvcFR5cGUsIHJlZjogUmVhY3QuRWxlbWVudFJlZjwqPikgPT4ge1xuICAgIC8vIEZsb3cgY2FuJ3QgcmVhc29uIGFib3V0IHRoZSBjb25zdGFudCBuYXR1cmUgb2YgT2JqZWN0LmtleXMgc28gd2UgY2FuJ3QgdXNlXG4gICAgLy8gYSBmdW5jdGlvbmFsIChyZWR1Y2UpIHN0eWxlIGhlcmUuXG5cbiAgICAvLyBCb3ggaXMgYSBcInBhc3MtdGhyb3VnaFwiIGNvbXBvbmVudCwgbWVhbmluZyB0aGF0IGlmIHlvdSBwYXNzIHByb3BlcnRpZXMgdG9cbiAgICAvLyBpdCB0aGF0IGl0IGRvZXNuJ3Qga25vdyBhYm91dCAoYGFyaWEtbGFiZWxgIGZvciBpbnN0YW5jZSkgaXQgcGFzc2VzXG4gICAgLy8gZGlyZWN0bHkgYmFjayB0byB0aGUgdW5kZXJseWluZyBgPGRpdi8+YC4gVGhhdCdzIGdlbmVyYWxseSB1c2VmdWwsIGJ1dFxuICAgIC8vIHdlJ2QgYWxzbyBsaWtlIHRvIHN0cmlwIG91dCBhIGZldyBuYXVnaHR5IHByb3BlcnRpZXMgdGhhdCBicmVhayBzdHlsZVxuICAgIC8vIGVuY2Fwc3VsYXRpb24gKGNsYXNzTmFtZSwgc3R5bGUpIG9yIGFjY2Vzc2liaWxpdHkgKG9uQ2xpY2spLlxuICAgIGxldCBibGFja2xpc3QgPSBbJ29uQ2xpY2snLCAnY2xhc3NOYW1lJywgJ3N0eWxlJ107XG5cbiAgICAvLyBBbGwgQm94J3MgYXJlIGJveC1zaXplZCBieSBkZWZhdWx0LCBzbyB3ZSBzdGFydCBvZmYgYnVpbGRpbmcgdXAgdGhlIHN0eWxlc1xuICAgIC8vIHRvIGJlIGFwcGxpZWQgd2l0aCBhIEJveCBiYXNlIGNsYXNzLlxuICAgIGxldCBzID0gZnJvbUNsYXNzTmFtZShzdHlsZXMuYm94KTtcblxuICAgIC8vIFRoaXMgbG9vcHMgdGhyb3VnaCBlYWNoIHByb3BlcnR5IGFuZCBpZiBpdCBleGlzdHMgaW4gdGhlIHByZXZpb3VzbHlcbiAgICAvLyBkZWZpbmVkIHRyYW5zZm9ybSBtYXAsIGNvbmNhdGVudGVzIHRoZSByZXN1bHRpbmcgc3R5bGVzIHRvIHRoZSBiYXNlXG4gICAgLy8gc3R5bGVzLiBJZiB0aGVyZSdzIGEgbWF0Y2gsIHdlIGFsc28gZG9uJ3QgcGFzcyB0aHJvdWdoIHRoYXQgcHJvcGVydHkuIFRoaXNcbiAgICAvLyBtZWFucyBCb3gncyBydW50aW1lIGlzIG9ubHkgZGVwZW5kZW50IG9uIHRoZSBudW1iZXIgb2YgcHJvcGVydGllcyBwYXNzZWRcbiAgICAvLyB0byBpdCAod2hpY2ggaXMgdHlwaWNhbGx5IHNtYWxsKSBpbnN0ZWFkIG9mIHRoZSB0b3RhbCBudW1iZXIgb2YgcG9zc2libGVcbiAgICAvLyBwcm9wZXJ0aWVzICh+MzAgb3Igc28pLiBXaGlsZSBpdCBtYXkgfmZlZWx+IGxpa2UgQm94IGlzIGlubmVmZmljaWVudCwgaXRzXG4gICAgLy8gYmlnZ2VzdCBwZXJmb3JtYW5jZSBpbXBhY3QgaXMgb24gc3RhcnR1cCB0aW1lIGJlY2F1c2UgdGhlcmUncyBzbyBtdWNoIGNvZGVcbiAgICAvLyBoZXJlLlxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgZm9yIChjb25zdCBwcm9wIGluIHByb3BzKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BUb0ZuLCBwcm9wKSkge1xuICAgICAgICBjb25zdCBmbiA9IHByb3BUb0ZuW3Byb3BdO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHByb3BzW3Byb3BdO1xuICAgICAgICBibGFja2xpc3QgPSBibGFja2xpc3QuY29uY2F0KHByb3ApO1xuICAgICAgICBzID0gY29uY2F0KFtzLCBmbih2YWx1ZSldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBbmQuLi4gbWFnaWMhXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgey4uLm9taXQoYmxhY2tsaXN0LCBwcm9wcyl9IHsuLi50b1Byb3BzKHMpfSByZWY9e3JlZn0+XG4gICAgICAgIHtjaGlsZHJlbn1cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbik7XG5cbi8vICBOT1RFOiBUaGlzIGlzIG5lZWRlZCBpbiBvcmRlciB0byBvdmVycmlkZSB0aGUgRm9yd2FyZFJlZiBkaXNwbGF5IG5hbWUgdGhhdCBpc1xuLy8gIHVzZWQgaW4gZGV2IHRvb2xzIGFuZCBpbiBzbmFwc2hvdCB0ZXN0aW5nLlxuQm94LmRpc3BsYXlOYW1lID0gJ0JveCc7XG5cbmV4cG9ydCBkZWZhdWx0IEJveDtcblxuLypcblxuIyBQcm9wVHlwZXNcblxuQW5kIHdlJ3JlIGRvbmUgaGVyZSA6KVxuXG4qL1xuXG5jb25zdCBDb2x1bW5Qcm9wVHlwZSA9IFByb3BUeXBlcy5vbmVPZihbXG4gIDAsXG4gIDEsXG4gIDIsXG4gIDMsXG4gIDQsXG4gIDUsXG4gIDYsXG4gIDcsXG4gIDgsXG4gIDksXG4gIDEwLFxuICAxMSxcbiAgMTIsXG5dKTtcblxuY29uc3QgTWFyZ2luUHJvcFR5cGUgPSBQcm9wVHlwZXMub25lT2YoW1xuICAtMTIsXG4gIC0xMSxcbiAgLTEwLFxuICAtOSxcbiAgLTgsXG4gIC03LFxuICAtNixcbiAgLTUsXG4gIC00LFxuICAtMyxcbiAgLTIsXG4gIC0xLFxuICAwLFxuICAxLFxuICAyLFxuICAzLFxuICA0LFxuICA1LFxuICA2LFxuICA3LFxuICA4LFxuICA5LFxuICAxMCxcbiAgMTEsXG4gIDEyLFxuXSk7XG5cbmNvbnN0IFBhZGRpbmdQcm9wVHlwZSA9IFByb3BUeXBlcy5vbmVPZihbXG4gIDAsXG4gIDEsXG4gIDIsXG4gIDMsXG4gIDQsXG4gIDUsXG4gIDYsXG4gIDcsXG4gIDgsXG4gIDksXG4gIDEwLFxuICAxMSxcbiAgMTIsXG5dKTtcblxuQm94LnByb3BUeXBlcyA9IHtcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICBkYW5nZXJvdXNseVNldElubGluZVN0eWxlOiBQcm9wVHlwZXMuZXhhY3Qoe1xuICAgIF9fc3R5bGU6IFByb3BUeXBlcy5vYmplY3QsXG4gIH0pLFxuXG4gIHhzOiBQcm9wVHlwZXMuZXhhY3Qoe1xuICAgIGRpc3BsYXk6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xuICAgICAgUHJvcFR5cGVzLmJvb2wsXG4gICAgICBQcm9wVHlwZXMub25lT2YoWydmbGV4JywgJ2ZsZXhDb2x1bW4nLCAnaW5saW5lQmxvY2snXSksXG4gICAgXSksXG4gICAgY29sdW1uOiBQcm9wVHlwZXMubnVtYmVyLFxuICB9KSxcbiAgc206IFByb3BUeXBlcy5leGFjdCh7XG4gICAgZGlzcGxheTogUHJvcFR5cGVzLm9uZU9mVHlwZShbXG4gICAgICBQcm9wVHlwZXMuYm9vbCxcbiAgICAgIFByb3BUeXBlcy5vbmVPZihbJ2ZsZXgnLCAnZmxleENvbHVtbicsICdpbmxpbmVCbG9jayddKSxcbiAgICBdKSxcbiAgICBjb2x1bW46IFByb3BUeXBlcy5udW1iZXIsXG4gIH0pLFxuICBtZDogUHJvcFR5cGVzLmV4YWN0KHtcbiAgICBkaXNwbGF5OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcbiAgICAgIFByb3BUeXBlcy5ib29sLFxuICAgICAgUHJvcFR5cGVzLm9uZU9mKFsnZmxleCcsICdmbGV4Q29sdW1uJywgJ2lubGluZUJsb2NrJ10pLFxuICAgIF0pLFxuICAgIGNvbHVtbjogUHJvcFR5cGVzLm51bWJlcixcbiAgfSksXG4gIGxnOiBQcm9wVHlwZXMuZXhhY3Qoe1xuICAgIGRpc3BsYXk6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xuICAgICAgUHJvcFR5cGVzLmJvb2wsXG4gICAgICBQcm9wVHlwZXMub25lT2YoWydmbGV4JywgJ2ZsZXhDb2x1bW4nLCAnaW5saW5lQmxvY2snXSksXG4gICAgXSksXG4gICAgY29sdW1uOiBQcm9wVHlwZXMubnVtYmVyLFxuICB9KSxcbiAgZGVwcmVjYXRlZE1hcmdpbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbXG4gICAgUHJvcFR5cGVzLm51bWJlcixcbiAgICBQcm9wVHlwZXMuc2hhcGUoe1xuICAgICAgdG9wOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgYm90dG9tOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgbGVmdDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLm9uZU9mKFsnYXV0byddKV0pLFxuICAgICAgcmlnaHQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5vbmVPZihbJ2F1dG8nXSldKSxcbiAgICB9KSxcbiAgXSksXG4gIGRlcHJlY2F0ZWRQYWRkaW5nOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcbiAgICBQcm9wVHlwZXMubnVtYmVyLFxuICAgIFByb3BUeXBlcy5zaGFwZSh7XG4gICAgICB4OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgeTogUHJvcFR5cGVzLm51bWJlcixcbiAgICB9KSxcbiAgXSksXG5cbiAgZGlzcGxheTogUHJvcFR5cGVzLm9uZU9mKFtcbiAgICAnbm9uZScsXG4gICAgJ2ZsZXgnLFxuICAgICdibG9jaycsXG4gICAgJ2lubGluZUJsb2NrJyxcbiAgICAndmlzdWFsbHlIaWRkZW4nLFxuICBdKSxcbiAgZGlyZWN0aW9uOiBQcm9wVHlwZXMub25lT2YoWydyb3cnLCAnY29sdW1uJ10pLFxuICBjb2x1bW46IENvbHVtblByb3BUeXBlLFxuXG4gIHNtRGlzcGxheTogUHJvcFR5cGVzLm9uZU9mKFtcbiAgICAnbm9uZScsXG4gICAgJ2ZsZXgnLFxuICAgICdibG9jaycsXG4gICAgJ2lubGluZUJsb2NrJyxcbiAgICAndmlzdWFsbHlIaWRkZW4nLFxuICBdKSxcbiAgc21EaXJlY3Rpb246IFByb3BUeXBlcy5vbmVPZihbJ3JvdycsICdjb2x1bW4nXSksXG4gIHNtQ29sdW1uOiBDb2x1bW5Qcm9wVHlwZSxcblxuICBtZERpc3BsYXk6IFByb3BUeXBlcy5vbmVPZihbXG4gICAgJ25vbmUnLFxuICAgICdmbGV4JyxcbiAgICAnYmxvY2snLFxuICAgICdpbmxpbmVCbG9jaycsXG4gICAgJ3Zpc3VhbGx5SGlkZGVuJyxcbiAgXSksXG4gIG1kRGlyZWN0aW9uOiBQcm9wVHlwZXMub25lT2YoWydyb3cnLCAnY29sdW1uJ10pLFxuICBtZENvbHVtbjogQ29sdW1uUHJvcFR5cGUsXG5cbiAgbGdEaXNwbGF5OiBQcm9wVHlwZXMub25lT2YoW1xuICAgICdub25lJyxcbiAgICAnZmxleCcsXG4gICAgJ2Jsb2NrJyxcbiAgICAnaW5saW5lQmxvY2snLFxuICAgICd2aXN1YWxseUhpZGRlbicsXG4gIF0pLFxuICBsZ0RpcmVjdGlvbjogUHJvcFR5cGVzLm9uZU9mKFsncm93JywgJ2NvbHVtbiddKSxcbiAgbGdDb2x1bW46IENvbHVtblByb3BUeXBlLFxuXG4gIGFsaWduQ29udGVudDogUHJvcFR5cGVzLm9uZU9mKFtcbiAgICAnc3RhcnQnLFxuICAgICdlbmQnLFxuICAgICdjZW50ZXInLFxuICAgICdiZXR3ZWVuJyxcbiAgICAnYXJvdW5kJyxcbiAgICAnc3RyZXRjaCcsXG4gIF0pLFxuICBhbGlnbkl0ZW1zOiBQcm9wVHlwZXMub25lT2YoW1xuICAgICdzdGFydCcsXG4gICAgJ2VuZCcsXG4gICAgJ2NlbnRlcicsXG4gICAgJ2Jhc2VsaW5lJyxcbiAgICAnc3RyZXRjaCcsXG4gIF0pLFxuICBhbGlnblNlbGY6IFByb3BUeXBlcy5vbmVPZihbXG4gICAgJ2F1dG8nLFxuICAgICdzdGFydCcsXG4gICAgJ2VuZCcsXG4gICAgJ2NlbnRlcicsXG4gICAgJ2Jhc2VsaW5lJyxcbiAgICAnc3RyZXRjaCcsXG4gIF0pLFxuICBib3R0b206IFByb3BUeXBlcy5ib29sLFxuICBjb2xvcjogUHJvcFR5cGVzLm9uZU9mKFtcbiAgICAnYmx1ZScsXG4gICAgJ2RhcmtHcmF5JyxcbiAgICAnZGFya1dhc2gnLFxuICAgICdlZ2dwbGFudCcsXG4gICAgJ2dyYXknLFxuICAgICdncmVlbicsXG4gICAgJ2xpZ2h0R3JheScsXG4gICAgJ2xpZ2h0V2FzaCcsXG4gICAgJ21hcm9vbicsXG4gICAgJ21pZG5pZ2h0JyxcbiAgICAnbmF2eScsXG4gICAgJ29saXZlJyxcbiAgICAnb3JhbmdlJyxcbiAgICAnb3JjaGlkJyxcbiAgICAncGluZScsXG4gICAgJ3B1cnBsZScsXG4gICAgJ3JlZCcsXG4gICAgJ3RyYW5zcGFyZW50JyxcbiAgICAnd2F0ZXJtZWxvbicsXG4gICAgJ3doaXRlJyxcbiAgXSksXG4gIGZpdDogUHJvcFR5cGVzLmJvb2wsXG4gIGZsZXg6IFByb3BUeXBlcy5vbmVPZihbJ2dyb3cnLCAnc2hyaW5rJywgJ25vbmUnXSksXG4gIGdyb3c6IFByb3BUeXBlcy5ib29sLFxuICBoZWlnaHQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcbiAganVzdGlmeUNvbnRlbnQ6IFByb3BUeXBlcy5vbmVPZihbXG4gICAgJ3N0YXJ0JyxcbiAgICAnZW5kJyxcbiAgICAnY2VudGVyJyxcbiAgICAnYmV0d2VlbicsXG4gICAgJ2Fyb3VuZCcsXG4gIF0pLFxuICBsZWZ0OiBQcm9wVHlwZXMuYm9vbCxcblxuICBtYXJnaW5TdGFydDogTWFyZ2luUHJvcFR5cGUsXG4gIG1hcmdpbkVuZDogTWFyZ2luUHJvcFR5cGUsXG5cbiAgbWFyZ2luOiBNYXJnaW5Qcm9wVHlwZSxcbiAgbWFyZ2luVG9wOiBNYXJnaW5Qcm9wVHlwZSxcbiAgbWFyZ2luUmlnaHQ6IE1hcmdpblByb3BUeXBlLFxuICBtYXJnaW5Cb3R0b206IE1hcmdpblByb3BUeXBlLFxuICBtYXJnaW5MZWZ0OiBNYXJnaW5Qcm9wVHlwZSxcblxuICBzbU1hcmdpbjogTWFyZ2luUHJvcFR5cGUsXG4gIHNtTWFyZ2luVG9wOiBNYXJnaW5Qcm9wVHlwZSxcbiAgc21NYXJnaW5SaWdodDogTWFyZ2luUHJvcFR5cGUsXG4gIHNtTWFyZ2luQm90dG9tOiBNYXJnaW5Qcm9wVHlwZSxcbiAgc21NYXJnaW5MZWZ0OiBNYXJnaW5Qcm9wVHlwZSxcblxuICBtZE1hcmdpbjogTWFyZ2luUHJvcFR5cGUsXG4gIG1kTWFyZ2luVG9wOiBNYXJnaW5Qcm9wVHlwZSxcbiAgbWRNYXJnaW5SaWdodDogTWFyZ2luUHJvcFR5cGUsXG4gIG1kTWFyZ2luQm90dG9tOiBNYXJnaW5Qcm9wVHlwZSxcbiAgbWRNYXJnaW5MZWZ0OiBNYXJnaW5Qcm9wVHlwZSxcblxuICBsZ01hcmdpbjogTWFyZ2luUHJvcFR5cGUsXG4gIGxnTWFyZ2luVG9wOiBNYXJnaW5Qcm9wVHlwZSxcbiAgbGdNYXJnaW5SaWdodDogTWFyZ2luUHJvcFR5cGUsXG4gIGxnTWFyZ2luQm90dG9tOiBNYXJnaW5Qcm9wVHlwZSxcbiAgbGdNYXJnaW5MZWZ0OiBNYXJnaW5Qcm9wVHlwZSxcblxuICBtYXhIZWlnaHQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgbWF4V2lkdGg6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgbWluSGVpZ2h0OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG4gIG1pbldpZHRoOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG5cbiAgb3ZlcmZsb3c6IFByb3BUeXBlcy5vbmVPZihbXG4gICAgJ3Zpc2libGUnLFxuICAgICdoaWRkZW4nLFxuICAgICdzY3JvbGwnLFxuICAgICdzY3JvbGxYJyxcbiAgICAnc2Nyb2xsWScsXG4gICAgJ2F1dG8nLFxuICBdKSxcblxuICBwYWRkaW5nOiBQYWRkaW5nUHJvcFR5cGUsXG4gIHBhZGRpbmdYOiBQYWRkaW5nUHJvcFR5cGUsXG4gIHBhZGRpbmdZOiBQYWRkaW5nUHJvcFR5cGUsXG5cbiAgc21QYWRkaW5nOiBQYWRkaW5nUHJvcFR5cGUsXG4gIHNtUGFkZGluZ1g6IFBhZGRpbmdQcm9wVHlwZSxcbiAgc21QYWRkaW5nWTogUGFkZGluZ1Byb3BUeXBlLFxuXG4gIG1kUGFkZGluZzogUGFkZGluZ1Byb3BUeXBlLFxuICBtZFBhZGRpbmdYOiBQYWRkaW5nUHJvcFR5cGUsXG4gIG1kUGFkZGluZ1k6IFBhZGRpbmdQcm9wVHlwZSxcblxuICBsZ1BhZGRpbmc6IFBhZGRpbmdQcm9wVHlwZSxcbiAgbGdQYWRkaW5nWDogUGFkZGluZ1Byb3BUeXBlLFxuICBsZ1BhZGRpbmdZOiBQYWRkaW5nUHJvcFR5cGUsXG5cbiAgcG9zaXRpb246IFByb3BUeXBlcy5vbmVPZihbJ3N0YXRpYycsICdhYnNvbHV0ZScsICdyZWxhdGl2ZScsICdmaXhlZCddKSxcbiAgcmlnaHQ6IFByb3BUeXBlcy5ib29sLFxuICBzaGFwZTogUHJvcFR5cGVzLm9uZU9mKFtcbiAgICAnc3F1YXJlJyxcbiAgICAncm91bmRlZCcsXG4gICAgJ3BpbGwnLFxuICAgICdjaXJjbGUnLFxuICAgICdyb3VuZGVkVG9wJyxcbiAgICAncm91bmRlZEJvdHRvbScsXG4gICAgJ3JvdW5kZWRMZWZ0JyxcbiAgICAncm91bmRlZFJpZ2h0JyxcbiAgXSksXG4gIHRvcDogUHJvcFR5cGVzLmJvb2wsXG4gIHdpZHRoOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG4gIHdyYXA6IFByb3BUeXBlcy5ib29sLFxufTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgYWRkIGZyb20gJy4vYWRkLnN2Zyc7XG5pbXBvcnQgYWRkQ2lyY2xlIGZyb20gJy4vYWRkLWNpcmNsZS5zdmcnO1xuaW1wb3J0IGFkZFBpbiBmcm9tICcuL2FkZC1waW4uc3ZnJztcbmltcG9ydCBhbGlnbkJvdHRvbUNlbnRlciBmcm9tICcuL2FsaWduLWJvdHRvbS1jZW50ZXIuc3ZnJztcbmltcG9ydCBhbGlnbkJvdHRvbUxlZnQgZnJvbSAnLi9hbGlnbi1ib3R0b20tbGVmdC5zdmcnO1xuaW1wb3J0IGFsaWduQm90dG9tUmlnaHQgZnJvbSAnLi9hbGlnbi1ib3R0b20tcmlnaHQuc3ZnJztcbmltcG9ydCBhbGlnbkJvdHRvbSBmcm9tICcuL2FsaWduLWJvdHRvbS5zdmcnO1xuaW1wb3J0IGFsaWduTWlkZGxlIGZyb20gJy4vYWxpZ24tbWlkZGxlLnN2Zyc7XG5pbXBvcnQgYWxpZ25Ub3BDZW50ZXIgZnJvbSAnLi9hbGlnbi10b3AtY2VudGVyLnN2Zyc7XG5pbXBvcnQgYWxpZ25Ub3BMZWZ0IGZyb20gJy4vYWxpZ24tdG9wLWxlZnQuc3ZnJztcbmltcG9ydCBhbGlnblRvcFJpZ2h0IGZyb20gJy4vYWxpZ24tdG9wLXJpZ2h0LnN2Zyc7XG5pbXBvcnQgYWxpZ25Ub3AgZnJvbSAnLi9hbGlnbi10b3Auc3ZnJztcbmltcG9ydCBhbmdsZWRQaW4gZnJvbSAnLi9hbmdsZWQtcGluLnN2Zyc7XG5pbXBvcnQgYXBwcyBmcm9tICcuL2FwcHMuc3ZnJztcbmltcG9ydCBhcnJvd0JhY2sgZnJvbSAnLi9hcnJvdy1iYWNrLnN2Zyc7XG5pbXBvcnQgYXJyb3dDaXJjbGVGb3J3YXJkIGZyb20gJy4vYXJyb3ctY2lyY2xlLWZvcndhcmQuc3ZnJztcbmltcG9ydCBhcnJvd0NpcmNsZURvd24gZnJvbSAnLi9hcnJvdy1jaXJjbGUtZG93bi5zdmcnO1xuaW1wb3J0IGFycm93RG93biBmcm9tICcuL2Fycm93LWRvd24uc3ZnJztcbmltcG9ydCBhcnJvd0ZvcndhcmQgZnJvbSAnLi9hcnJvdy1mb3J3YXJkLnN2Zyc7XG5pbXBvcnQgYXJyb3dVcCBmcm9tICcuL2Fycm93LXVwLnN2Zyc7XG5pbXBvcnQgYXJyb3dVcFJpZ2h0IGZyb20gJy4vYXJyb3ctdXAtcmlnaHQuc3ZnJztcbmltcG9ydCBiZWxsIGZyb20gJy4vYmVsbC5zdmcnO1xuaW1wb3J0IGNhbWVyYSBmcm9tICcuL2NhbWVyYS5zdmcnO1xuaW1wb3J0IGNhbWVyYVJvbGwgZnJvbSAnLi9jYW1lcmEtcm9sbC5zdmcnO1xuaW1wb3J0IGNhbmNlbCBmcm9tICcuL2NhbmNlbC5zdmcnO1xuaW1wb3J0IGNhbm9uaWNhbFBpbiBmcm9tICcuL2Nhbm9uaWNhbC1waW4uc3ZnJztcbmltcG9ydCBjaGVjayBmcm9tICcuL2NoZWNrLnN2Zyc7XG5pbXBvcnQgY2hlY2tDaXJjbGUgZnJvbSAnLi9jaGVjay1jaXJjbGUuc3ZnJztcbmltcG9ydCBjaXJjbGVPdXRsaW5lIGZyb20gJy4vY2lyY2xlLW91dGxpbmUuc3ZnJztcbmltcG9ydCBjbGVhciBmcm9tICcuL2NsZWFyLnN2Zyc7XG5pbXBvcnQgY2xvY2sgZnJvbSAnLi9jbG9jay5zdmcnO1xuaW1wb3J0IGNvZyBmcm9tICcuL2NvZy5zdmcnO1xuaW1wb3J0IGNvbG9yUGlja2VyIGZyb20gJy4vY29sb3ItcGlja2VyLnN2Zyc7XG5pbXBvcnQgY29tcGFzcyBmcm9tICcuL2NvbXBhc3Muc3ZnJztcbmltcG9ydCBjb21wb3NlIGZyb20gJy4vY29tcG9zZS5zdmcnO1xuaW1wb3J0IGNyb3AgZnJvbSAnLi9jcm9wLnN2Zyc7XG5pbXBvcnQgZGFzaCBmcm9tICcuL2Rhc2guc3ZnJztcbmltcG9ydCBkb3dubG9hZCBmcm9tICcuL2Rvd25sb2FkLnN2Zyc7XG5pbXBvcnQgZWRpdCBmcm9tICcuL2VkaXQuc3ZnJztcbmltcG9ydCBlbGxpcHNpcyBmcm9tICcuL2VsbGlwc2lzLnN2Zyc7XG5pbXBvcnQgZWxsaXBzaXNDaXJjbGVPdXRsaW5lIGZyb20gJy4vZWxsaXBzaXMtY2lyY2xlLW91dGxpbmUuc3ZnJztcbmltcG9ydCBlbnZlbG9wZSBmcm9tICcuL2VudmVsb3BlLnN2Zyc7XG5pbXBvcnQgZXllIGZyb20gJy4vZXllLnN2Zyc7XG5pbXBvcnQgZmFjZWJvb2sgZnJvbSAnLi9mYWNlYm9vay5zdmcnO1xuaW1wb3J0IGZhY2VIYXBweSBmcm9tICcuL2ZhY2UtaGFwcHkuc3ZnJztcbmltcG9ydCBmYWNlU2FkIGZyb20gJy4vZmFjZS1zYWQuc3ZnJztcbmltcG9ydCBmYWNlU21pbGV5IGZyb20gJy4vZmFjZS1zbWlsZXkuc3ZnJztcbmltcG9ydCBmaWx0ZXIgZnJvbSAnLi9maWx0ZXIuc3ZnJztcbmltcG9ydCBmaWxsT3BhcXVlIGZyb20gJy4vZmlsbC1vcGFxdWUuc3ZnJztcbmltcG9ydCBmaWxsVHJhbnNwYXJlbnQgZnJvbSAnLi9maWxsLXRyYW5zcGFyZW50LnN2Zyc7XG5pbXBvcnQgZmxhZyBmcm9tICcuL2ZsYWcuc3ZnJztcbmltcG9ydCBmbGFzaGxpZ2h0IGZyb20gJy4vZmxhc2hsaWdodC5zdmcnO1xuaW1wb3J0IGZsaXBIb3Jpem9udGFsIGZyb20gJy4vZmxpcC1ob3Jpem9udGFsLnN2Zyc7XG5pbXBvcnQgZmxpcFZlcnRpY2FsIGZyb20gJy4vZmxpcC12ZXJ0aWNhbC5zdmcnO1xuaW1wb3J0IGdpZiBmcm9tICcuL2dpZi5zdmcnO1xuaW1wb3J0IGdsb2JlIGZyb20gJy4vZ2xvYmUuc3ZnJztcbmltcG9ydCBnbG9iZUNoZWNrZWQgZnJvbSAnLi9nbG9iZS1jaGVja2VkLnN2Zyc7XG5pbXBvcnQgZ21haWwgZnJvbSAnLi9nbWFpbC5zdmcnO1xuaW1wb3J0IGdvb2dsZVBsdXMgZnJvbSAnLi9nb29nbGUtcGx1cy5zdmcnO1xuaW1wb3J0IGdyYXBoQmFyIGZyb20gJy4vZ3JhcGgtYmFyLnN2Zyc7XG5pbXBvcnQga25vb3AgZnJvbSAnLi9rbm9vcC5zdmcnO1xuaW1wb3J0IGxpZ2h0YnVsYiBmcm9tICcuL2xpZ2h0YnVsYi5zdmcnO1xuaW1wb3J0IGxvZ291dCBmcm9tICcuL2xvZ291dC5zdmcnO1xuaW1wb3J0IGxvZ29MYXJnZSBmcm9tICcuL2xvZ28tbGFyZ2Uuc3ZnJztcbmltcG9ydCBsb2dvU21hbGwgZnJvbSAnLi9sb2dvLXNtYWxsLnN2Zyc7XG5pbXBvcnQgaGFuZGxlIGZyb20gJy4vaGFuZGxlLnN2Zyc7XG5pbXBvcnQgaGFuZFBvaW50aW5nIGZyb20gJy4vaGFuZC1wb2ludGluZy5zdmcnO1xuaW1wb3J0IGhlYXJ0IGZyb20gJy4vaGVhcnQuc3ZnJztcbmltcG9ydCBoZWFydEJyb2tlbiBmcm9tICcuL2hlYXJ0LWJyb2tlbi5zdmcnO1xuaW1wb3J0IGltcHJlc3N1bSBmcm9tICcuL2ltcHJlc3N1bS5zdmcnO1xuaW1wb3J0IGxpbmsgZnJvbSAnLi9saW5rLnN2Zyc7XG5pbXBvcnQgbG9jYXRpb24gZnJvbSAnLi9sb2NhdGlvbi5zdmcnO1xuaW1wb3J0IGxvY2sgZnJvbSAnLi9sb2NrLnN2Zyc7XG5pbXBvcnQgbWFyZ2luc0xhcmdlIGZyb20gJy4vbWFyZ2lucy1sYXJnZS5zdmcnO1xuaW1wb3J0IG1hcmdpbnNNZWRpdW0gZnJvbSAnLi9tYXJnaW5zLW1lZGl1bS5zdmcnO1xuaW1wb3J0IG1hcmdpbnNTbWFsbCBmcm9tICcuL21hcmdpbnMtc21hbGwuc3ZnJztcbmltcG9ydCBtYXhpbWl6ZSBmcm9tICcuL21heGltaXplLnN2Zyc7XG5pbXBvcnQgbWVnYXBob25lIGZyb20gJy4vbWVnYXBob25lLnN2Zyc7XG5pbXBvcnQgbWVudSBmcm9tICcuL21lbnUuc3ZnJztcbmltcG9ydCBtaW5pbWl6ZSBmcm9tICcuL21pbmltaXplLnN2Zyc7XG5pbXBvcnQgbW92ZSBmcm9tICcuL21vdmUuc3ZnJztcbmltcG9ydCBtdXRlIGZyb20gJy4vbXV0ZS5zdmcnO1xuaW1wb3J0IG92ZXJsYXlUZXh0IGZyb20gJy4vb3ZlcmxheS10ZXh0LnN2Zyc7XG5pbXBvcnQgcGF1c2UgZnJvbSAnLi9wYXVzZS5zdmcnO1xuaW1wb3J0IHBlb3BsZSBmcm9tICcuL3Blb3BsZS5zdmcnO1xuaW1wb3J0IHBlcnNvbiBmcm9tICcuL3BlcnNvbi5zdmcnO1xuaW1wb3J0IHBlcnNvbkFkZCBmcm9tICcuL3BlcnNvbi1hZGQuc3ZnJztcbmltcG9ydCBwaW4gZnJvbSAnLi9waW4uc3ZnJztcbmltcG9ydCBwaW5IaWRlIGZyb20gJy4vcGluLWhpZGUuc3ZnJztcbmltcG9ydCBwaW50ZXJlc3QgZnJvbSAnLi9waW50ZXJlc3Quc3ZnJztcbmltcG9ydCBwbGF5IGZyb20gJy4vcGxheS5zdmcnO1xuaW1wb3J0IHF1ZXN0aW9uTWFyayBmcm9tICcuL3F1ZXN0aW9uLW1hcmsuc3ZnJztcbmltcG9ydCByZW1vdmUgZnJvbSAnLi9yZW1vdmUuc3ZnJztcbmltcG9ydCByZXBvcnQgZnJvbSAnLi9yZXBvcnQuc3ZnJztcbmltcG9ydCByb3RhdGUgZnJvbSAnLi9yb3RhdGUuc3ZnJztcbmltcG9ydCBzZWFyY2ggZnJvbSAnLi9zZWFyY2guc3ZnJztcbmltcG9ydCBzZWN1cml0eSBmcm9tICcuL3NlY3VyaXR5LnN2Zyc7XG5pbXBvcnQgc2VuZCBmcm9tICcuL3NlbmQuc3ZnJztcbmltcG9ydCBzaGFyZSBmcm9tICcuL3NoYXJlLnN2Zyc7XG5pbXBvcnQgc2hvcHBpbmdCYWcgZnJvbSAnLi9zaG9wcGluZy1iYWcuc3ZnJztcbmltcG9ydCBzbWlsZXkgZnJvbSAnLi9zbWlsZXkuc3ZnJztcbmltcG9ydCBzbWlsZXlPdXRsaW5lIGZyb20gJy4vc21pbGV5LW91dGxpbmUuc3ZnJztcbmltcG9ydCBzb3VuZCBmcm9tICcuL3NvdW5kLnN2Zyc7XG5pbXBvcnQgc3BlZWNoIGZyb20gJy4vc3BlZWNoLnN2Zyc7XG5pbXBvcnQgc3BlZWNoRWxsaXBzaXMgZnJvbSAnLi9zcGVlY2gtZWxsaXBzaXMuc3ZnJztcbmltcG9ydCBzdGFyIGZyb20gJy4vc3Rhci5zdmcnO1xuaW1wb3J0IHN3aXRjaEFjY291bnQgZnJvbSAnLi9zd2l0Y2gtYWNjb3VudC5zdmcnO1xuaW1wb3J0IHRhZyBmcm9tICcuL3RhZy5zdmcnO1xuaW1wb3J0IHRlcm1zIGZyb20gJy4vdGVybXMuc3ZnJztcbmltcG9ydCB0ZXh0QWxpZ25DZW50ZXIgZnJvbSAnLi90ZXh0LWFsaWduLWNlbnRlci5zdmcnO1xuaW1wb3J0IHRleHRBbGlnbkxlZnQgZnJvbSAnLi90ZXh0LWFsaWduLWxlZnQuc3ZnJztcbmltcG9ydCB0ZXh0QWxpZ25SaWdodCBmcm9tICcuL3RleHQtYWxpZ24tcmlnaHQuc3ZnJztcbmltcG9ydCB0ZXh0RXh0cmFTbWFsbCBmcm9tICcuL3RleHQtZXh0cmEtc21hbGwuc3ZnJztcbmltcG9ydCB0ZXh0TGFyZ2UgZnJvbSAnLi90ZXh0LWxhcmdlLnN2Zyc7XG5pbXBvcnQgdGV4dE1lZGl1bSBmcm9tICcuL3RleHQtbWVkaXVtLnN2Zyc7XG5pbXBvcnQgdGV4dFNtYWxsIGZyb20gJy4vdGV4dC1zbWFsbC5zdmcnO1xuaW1wb3J0IHR3aXR0ZXIgZnJvbSAnLi90d2l0dGVyLnN2Zyc7XG5pbXBvcnQgdmlld1R5cGVEZWZhdWx0IGZyb20gJy4vdmlldy10eXBlLWRlZmF1bHQuc3ZnJztcbmltcG9ydCB2aWV3VHlwZURlbnNlIGZyb20gJy4vdmlldy10eXBlLWRlbnNlLnN2Zyc7XG5pbXBvcnQgdmlld1R5cGVMaXN0IGZyb20gJy4vdmlldy10eXBlLWxpc3Quc3ZnJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBhZGQsXG4gICdhZGQtY2lyY2xlJzogYWRkQ2lyY2xlLFxuICAnYWRkLXBpbic6IGFkZFBpbixcbiAgJ2FsaWduLWJvdHRvbS1jZW50ZXInOiBhbGlnbkJvdHRvbUNlbnRlcixcbiAgJ2FsaWduLWJvdHRvbS1sZWZ0JzogYWxpZ25Cb3R0b21MZWZ0LFxuICAnYWxpZ24tYm90dG9tLXJpZ2h0JzogYWxpZ25Cb3R0b21SaWdodCxcbiAgJ2FsaWduLWJvdHRvbSc6IGFsaWduQm90dG9tLFxuICAnYWxpZ24tbWlkZGxlJzogYWxpZ25NaWRkbGUsXG4gICdhbGlnbi10b3AtY2VudGVyJzogYWxpZ25Ub3BDZW50ZXIsXG4gICdhbGlnbi10b3AtbGVmdCc6IGFsaWduVG9wTGVmdCxcbiAgJ2FsaWduLXRvcC1yaWdodCc6IGFsaWduVG9wUmlnaHQsXG4gICdhbGlnbi10b3AnOiBhbGlnblRvcCxcbiAgJ2FuZ2xlZC1waW4nOiBhbmdsZWRQaW4sXG4gIGFwcHMsXG4gICdhcnJvdy1iYWNrJzogYXJyb3dCYWNrLFxuICAnYXJyb3ctY2lyY2xlLWRvd24nOiBhcnJvd0NpcmNsZURvd24sXG4gICdhcnJvdy1jaXJjbGUtZm9yd2FyZCc6IGFycm93Q2lyY2xlRm9yd2FyZCxcbiAgJ2Fycm93LWRvd24nOiBhcnJvd0Rvd24sXG4gICdhcnJvdy1mb3J3YXJkJzogYXJyb3dGb3J3YXJkLFxuICAnYXJyb3ctdXAnOiBhcnJvd1VwLFxuICAnYXJyb3ctdXAtcmlnaHQnOiBhcnJvd1VwUmlnaHQsXG4gIGJlbGwsXG4gIGNhbWVyYSxcbiAgJ2NhbWVyYS1yb2xsJzogY2FtZXJhUm9sbCxcbiAgY2FuY2VsLFxuICAnY2Fub25pY2FsLXBpbic6IGNhbm9uaWNhbFBpbixcbiAgJ2NvbG9yLXBpY2tlcic6IGNvbG9yUGlja2VyLFxuICBjaGVjayxcbiAgJ2NoZWNrLWNpcmNsZSc6IGNoZWNrQ2lyY2xlLFxuICAnY2lyY2xlLW91dGxpbmUnOiBjaXJjbGVPdXRsaW5lLFxuICBjbGVhcixcbiAgY2xvY2ssXG4gIGNvZyxcbiAgY29tcGFzcyxcbiAgY29tcG9zZSxcbiAgY3JvcCxcbiAgZGFzaCxcbiAgZG93bmxvYWQsXG4gIGVkaXQsXG4gIGVsbGlwc2lzLFxuICAnZWxsaXBzaXMtY2lyY2xlLW91dGxpbmUnOiBlbGxpcHNpc0NpcmNsZU91dGxpbmUsXG4gIGVudmVsb3BlLFxuICBleWUsXG4gIGZhY2Vib29rLFxuICAnZmFjZS1oYXBweSc6IGZhY2VIYXBweSxcbiAgJ2ZhY2Utc2FkJzogZmFjZVNhZCxcbiAgJ2ZhY2Utc21pbGV5JzogZmFjZVNtaWxleSxcbiAgJ2ZpbGwtb3BhcXVlJzogZmlsbE9wYXF1ZSxcbiAgJ2ZpbGwtdHJhbnNwYXJlbnQnOiBmaWxsVHJhbnNwYXJlbnQsXG4gIGZpbHRlcixcbiAgZmxhZyxcbiAgZmxhc2hsaWdodCxcbiAgZmxpcEhvcml6b250YWwsXG4gIGZsaXBWZXJ0aWNhbCxcbiAgZ2lmLFxuICBnbG9iZSxcbiAgJ2dsb2JlLWNoZWNrZWQnOiBnbG9iZUNoZWNrZWQsXG4gIGdtYWlsLFxuICAnZ29vZ2xlLXBsdXMnOiBnb29nbGVQbHVzLFxuICAnZ3JhcGgtYmFyJzogZ3JhcGhCYXIsXG4gIGhhbmRsZSxcbiAgJ2hhbmQtcG9pbnRpbmcnOiBoYW5kUG9pbnRpbmcsXG4gIGhlYXJ0LFxuICAnaGVhcnQtYnJva2VuJzogaGVhcnRCcm9rZW4sXG4gIGltcHJlc3N1bSxcbiAga25vb3AsXG4gIGxpZ2h0YnVsYixcbiAgbGluayxcbiAgbG9jYXRpb24sXG4gIGxvY2ssXG4gICdsb2dvLWxhcmdlJzogbG9nb0xhcmdlLFxuICAnbG9nby1zbWFsbCc6IGxvZ29TbWFsbCxcbiAgbG9nb3V0LFxuICAnbWFyZ2lucy1sYXJnZSc6IG1hcmdpbnNMYXJnZSxcbiAgJ21hcmdpbnMtbWVkaXVtJzogbWFyZ2luc01lZGl1bSxcbiAgJ21hcmdpbnMtc21hbGwnOiBtYXJnaW5zU21hbGwsXG4gIG1heGltaXplLFxuICBtZWdhcGhvbmUsXG4gIG1lbnUsXG4gIG1pbmltaXplLFxuICBtb3ZlLFxuICBtdXRlLFxuICAnb3ZlcmxheS10ZXh0Jzogb3ZlcmxheVRleHQsXG4gIHBhdXNlLFxuICBwZW9wbGUsXG4gIHBlcnNvbixcbiAgJ3BlcnNvbi1hZGQnOiBwZXJzb25BZGQsXG4gIHBpbixcbiAgJ3Bpbi1oaWRlJzogcGluSGlkZSxcbiAgcGludGVyZXN0LFxuICBwbGF5LFxuICAncXVlc3Rpb24tbWFyayc6IHF1ZXN0aW9uTWFyayxcbiAgcmVtb3ZlLFxuICByZXBvcnQsXG4gIHJvdGF0ZSxcbiAgc2VhcmNoLFxuICBzZWN1cml0eSxcbiAgJ3Nob3BwaW5nLWJhZyc6IHNob3BwaW5nQmFnLFxuICBzbWlsZXksXG4gICdzbWlsZXktb3V0bGluZSc6IHNtaWxleU91dGxpbmUsXG4gIHNlbmQsXG4gIHNoYXJlLFxuICBzb3VuZCxcbiAgc3BlZWNoLFxuICAnc3BlZWNoLWVsbGlwc2lzJzogc3BlZWNoRWxsaXBzaXMsXG4gIHN0YXIsXG4gICdzd2l0Y2gtYWNjb3VudCc6IHN3aXRjaEFjY291bnQsXG4gIHRhZyxcbiAgdGVybXMsXG4gICd0ZXh0LWFsaWduLWxlZnQnOiB0ZXh0QWxpZ25MZWZ0LFxuICAndGV4dC1hbGlnbi1jZW50ZXInOiB0ZXh0QWxpZ25DZW50ZXIsXG4gICd0ZXh0LWFsaWduLXJpZ2h0JzogdGV4dEFsaWduUmlnaHQsXG4gICd0ZXh0LWV4dHJhLXNtYWxsJzogdGV4dEV4dHJhU21hbGwsXG4gICd0ZXh0LWxhcmdlJzogdGV4dExhcmdlLFxuICAndGV4dC1tZWRpdW0nOiB0ZXh0TWVkaXVtLFxuICAndGV4dC1zbWFsbCc6IHRleHRTbWFsbCxcbiAgdHdpdHRlcixcbiAgJ3ZpZXctdHlwZS1kZWZhdWx0Jzogdmlld1R5cGVEZWZhdWx0LFxuICAndmlldy10eXBlLWRlbnNlJzogdmlld1R5cGVEZW5zZSxcbiAgJ3ZpZXctdHlwZS1saXN0Jzogdmlld1R5cGVMaXN0LFxufTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vSWNvbi5jc3MnO1xuaW1wb3J0IGljb25zIGZyb20gJy4vaWNvbnMvaW5kZXguanMnO1xuaW1wb3J0IGNvbG9ycyBmcm9tICcuL0NvbG9ycy5jc3MnO1xuXG50eXBlIEljb25Qcm9wcyA9IHtcbiAgYWNjZXNzaWJpbGl0eUxhYmVsOiBzdHJpbmcsXG4gIGNvbG9yPzpcbiAgICB8ICdibHVlJ1xuICAgIHwgJ2RhcmtHcmF5J1xuICAgIHwgJ2VnZ3BsYW50J1xuICAgIHwgJ2dyYXknXG4gICAgfCAnZ3JlZW4nXG4gICAgfCAnbGlnaHRHcmF5J1xuICAgIHwgJ21hcm9vbidcbiAgICB8ICdtaWRuaWdodCdcbiAgICB8ICduYXZ5J1xuICAgIHwgJ29saXZlJ1xuICAgIHwgJ29yYW5nZSdcbiAgICB8ICdvcmNoaWQnXG4gICAgfCAncGluZSdcbiAgICB8ICdwdXJwbGUnXG4gICAgfCAncmVkJ1xuICAgIHwgJ3dhdGVybWVsb24nXG4gICAgfCAnd2hpdGUnLFxuICBpbmxpbmU/OiBib29sZWFuLFxuICBzaXplPzogbnVtYmVyIHwgc3RyaW5nLFxufTtcblxudHlwZSBJY29uTm9QYXRoID0ge1xuICBpY29uOiAkS2V5czx0eXBlb2YgaWNvbnM+LFxuICBkYW5nZXJvdXNseVNldFN2Z1BhdGg/OiBudWxsLFxufTtcblxudHlwZSBQYXRoTm9JY29uID0ge1xuICBpY29uPzogbnVsbCxcbiAgZGFuZ2Vyb3VzbHlTZXRTdmdQYXRoOiB7IF9fcGF0aDogc3RyaW5nIH0sXG59O1xuXG50eXBlIFByb3BzID0gSWNvblByb3BzICYgKFBhdGhOb0ljb24gfCBJY29uTm9QYXRoKTtcblxuY29uc3QgSWNvbk5hbWVzID0gT2JqZWN0LmtleXMoaWNvbnMpO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBJY29uKHByb3BzOiBQcm9wcykge1xuICBjb25zdCB7XG4gICAgYWNjZXNzaWJpbGl0eUxhYmVsLFxuICAgIGNvbG9yID0gJ2dyYXknLFxuICAgIGljb24sXG4gICAgaW5saW5lLFxuICAgIHNpemUgPSAxNixcbiAgICBkYW5nZXJvdXNseVNldFN2Z1BhdGgsXG4gIH0gPSBwcm9wcztcblxuICBjb25zdCBjcyA9IGNsYXNzbmFtZXMoc3R5bGVzLmljb24sIGNvbG9yc1tjb2xvcl0sIHtcbiAgICBbc3R5bGVzLmljb25CbG9ja106ICFpbmxpbmUsXG4gIH0pO1xuXG4gIGNvbnN0IHBhdGggPVxuICAgIChpY29uICYmIGljb25zW2ljb25dKSB8fFxuICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZSAqL1xuICAgIChkYW5nZXJvdXNseVNldFN2Z1BhdGggJiYgZGFuZ2Vyb3VzbHlTZXRTdmdQYXRoLl9fcGF0aCkgfHxcbiAgICB1bmRlZmluZWQ7XG5cbiAgY29uc3QgYXJpYUhpZGRlbiA9IGFjY2Vzc2liaWxpdHlMYWJlbCA9PT0gJycgPyB0cnVlIDogbnVsbDtcblxuICByZXR1cm4gKFxuICAgIDxzdmdcbiAgICAgIGNsYXNzTmFtZT17Y3N9XG4gICAgICBoZWlnaHQ9e3NpemV9XG4gICAgICB3aWR0aD17c2l6ZX1cbiAgICAgIHZpZXdCb3g9XCIwIDAgMjQgMjRcIlxuICAgICAgYXJpYS1oaWRkZW49e2FyaWFIaWRkZW59XG4gICAgICBhcmlhLWxhYmVsPXthY2Nlc3NpYmlsaXR5TGFiZWx9XG4gICAgICByb2xlPVwiaW1nXCJcbiAgICA+XG4gICAgICA8dGl0bGU+e2FjY2Vzc2liaWxpdHlMYWJlbH08L3RpdGxlPlxuICAgICAgPHBhdGggZD17cGF0aH0gLz5cbiAgICA8L3N2Zz5cbiAgKTtcbn1cblxuSWNvbi5pY29ucyA9IEljb25OYW1lcztcblxuSWNvbi5wcm9wVHlwZXMgPSB7XG4gIGFjY2Vzc2liaWxpdHlMYWJlbDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICBjb2xvcjogUHJvcFR5cGVzLm9uZU9mKFtcbiAgICAnYmx1ZScsXG4gICAgJ2RhcmtHcmF5JyxcbiAgICAnZWdncGxhbnQnLFxuICAgICdncmF5JyxcbiAgICAnZ3JlZW4nLFxuICAgICdsaWdodEdyYXknLFxuICAgICdtYXJvb24nLFxuICAgICdtaWRuaWdodCcsXG4gICAgJ25hdnknLFxuICAgICdvbGl2ZScsXG4gICAgJ29yYW5nZScsXG4gICAgJ29yY2hpZCcsXG4gICAgJ3BpbmUnLFxuICAgICdwdXJwbGUnLFxuICAgICdyZWQnLFxuICAgICd3YXRlcm1lbG9uJyxcbiAgICAnd2hpdGUnLFxuICBdKSxcbiAgZGFuZ2Vyb3VzbHlTZXRTdmdQYXRoOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIF9fcGF0aDogUHJvcFR5cGVzLnN0cmluZyxcbiAgfSksXG4gIGljb246IFByb3BUeXBlcy5vbmVPZihJY29uTmFtZXMpLFxuICBpbmxpbmU6IFByb3BUeXBlcy5ib29sLFxuICBzaXplOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG59O1xuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgQm94IGZyb20gJy4vQm94LmpzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9JbWFnZS5jc3MnO1xuXG5jb25zdCBzaG91bGRTY2FsZUltYWdlID0gZml0ID0+IGZpdCA9PT0gJ2NvdmVyJyB8fCBmaXQgPT09ICdjb250YWluJztcblxudHlwZSBQcm9wcyA9IHt8XG4gIGFsdDogc3RyaW5nLFxuICBjaGlsZHJlbj86IFJlYWN0Lk5vZGUsXG4gIGNvbG9yOiBzdHJpbmcsXG4gIGZpdDogJ2NvbnRhaW4nIHwgJ2NvdmVyJyB8ICdub25lJyxcbiAgbmF0dXJhbEhlaWdodDogbnVtYmVyLFxuICBuYXR1cmFsV2lkdGg6IG51bWJlcixcbiAgb25FcnJvcj86ICgpID0+IHZvaWQsXG4gIG9uTG9hZD86ICgpID0+IHZvaWQsXG4gIHNpemVzPzogc3RyaW5nLFxuICBzcmM6IHN0cmluZyxcbiAgc3JjU2V0Pzogc3RyaW5nLFxufH07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEltYWdlIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudDxQcm9wcz4ge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIGFsdDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgICBjb2xvcjogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBmaXQ6IFByb3BUeXBlcy5vbmVPZihbJ2NvbnRhaW4nLCAnY292ZXInLCAnbm9uZSddKSxcbiAgICBuYXR1cmFsSGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gICAgbmF0dXJhbFdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gICAgb25FcnJvcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25Mb2FkOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBzaXplczogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBzcmM6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBzcmNTZXQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gIH07XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICBjb2xvcjogJ3RyYW5zcGFyZW50JyxcbiAgICBmaXQ6ICdub25lJyxcbiAgfTtcblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBpZiAoc2hvdWxkU2NhbGVJbWFnZSh0aGlzLnByb3BzLmZpdCkpIHtcbiAgICAgIHRoaXMubG9hZEltYWdlKCk7XG4gICAgfVxuICB9XG5cbiAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wczogUHJvcHMpIHtcbiAgICBjb25zdCB7IGZpdCwgc3JjIH0gPSB0aGlzLnByb3BzO1xuICAgIGlmIChzaG91bGRTY2FsZUltYWdlKGZpdCkgJiYgcHJldlByb3BzLnNyYyAhPT0gc3JjKSB7XG4gICAgICB0aGlzLmxvYWRJbWFnZSgpO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZUxvYWQgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMucHJvcHMub25Mb2FkKSB7XG4gICAgICB0aGlzLnByb3BzLm9uTG9hZCgpO1xuICAgIH1cbiAgfTtcblxuICBoYW5kbGVFcnJvciA9ICgpID0+IHtcbiAgICBpZiAodGhpcy5wcm9wcy5vbkVycm9yKSB7XG4gICAgICB0aGlzLnByb3BzLm9uRXJyb3IoKTtcbiAgICB9XG4gIH07XG5cbiAgbG9hZEltYWdlKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc3QgaW1hZ2UgPSBuZXcgd2luZG93LkltYWdlKCk7XG4gICAgICBpbWFnZS5vbmxvYWQgPSB0aGlzLmhhbmRsZUxvYWQ7XG4gICAgICBpbWFnZS5vbmVycm9yID0gdGhpcy5oYW5kbGVFcnJvcjtcbiAgICAgIGltYWdlLnNyYyA9IHRoaXMucHJvcHMuc3JjO1xuICAgIH1cbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBhbHQsXG4gICAgICBjb2xvcixcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgZml0LFxuICAgICAgbmF0dXJhbEhlaWdodCxcbiAgICAgIG5hdHVyYWxXaWR0aCxcbiAgICAgIHNpemVzLFxuICAgICAgc3JjLFxuICAgICAgc3JjU2V0LFxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgY29uc3QgaXNTY2FsZWRJbWFnZSA9IHNob3VsZFNjYWxlSW1hZ2UoZml0KTtcbiAgICBjb25zdCBjaGlsZENvbnRlbnQgPSBjaGlsZHJlbiA/IChcbiAgICAgIDxCb3ggcG9zaXRpb249XCJhYnNvbHV0ZVwiIHRvcCBsZWZ0IGJvdHRvbSByaWdodCBvdmVyZmxvdz1cImhpZGRlblwiPlxuICAgICAgICB7Y2hpbGRyZW59XG4gICAgICA8L0JveD5cbiAgICApIDogbnVsbDtcblxuICAgIHJldHVybiBpc1NjYWxlZEltYWdlID8gKFxuICAgICAgPGRpdlxuICAgICAgICBhcmlhLWxhYmVsPXthbHR9XG4gICAgICAgIGNsYXNzTmFtZT17c3R5bGVzW2ZpdF19XG4gICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjb2xvcixcbiAgICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IGB1cmwoJyR7c3JjfScpYCxcbiAgICAgICAgfX1cbiAgICAgICAgcm9sZT1cImltZ1wiXG4gICAgICA+XG4gICAgICAgIHtjaGlsZENvbnRlbnR9XG4gICAgICA8L2Rpdj5cbiAgICApIDogKFxuICAgICAgPEJveFxuICAgICAgICBwb3NpdGlvbj1cInJlbGF0aXZlXCJcbiAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbmxpbmVTdHlsZT17e1xuICAgICAgICAgIF9fc3R5bGU6IHtcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogY29sb3IsXG4gICAgICAgICAgICBwYWRkaW5nQm90dG9tOiBgJHsobmF0dXJhbEhlaWdodCAvIG5hdHVyYWxXaWR0aCkgKiAxMDB9JWAsXG4gICAgICAgICAgfSxcbiAgICAgICAgfX1cbiAgICAgID5cbiAgICAgICAgPGltZ1xuICAgICAgICAgIGFsdD17YWx0fVxuICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLmltZ31cbiAgICAgICAgICBvbkVycm9yPXt0aGlzLmhhbmRsZUVycm9yfVxuICAgICAgICAgIG9uTG9hZD17dGhpcy5oYW5kbGVMb2FkfVxuICAgICAgICAgIHNpemVzPXtzaXplc31cbiAgICAgICAgICBzcmM9e3NyY31cbiAgICAgICAgICBzcmNTZXQ9e3NyY1NldH1cbiAgICAgICAgLz5cbiAgICAgICAge2NoaWxkQ29udGVudH1cbiAgICAgIDwvQm94PlxuICAgICk7XG4gIH1cbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGN4IGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL01hc2suY3NzJztcblxudHlwZSBQcm9wcyA9IHt8XG4gIGNoaWxkcmVuPzogUmVhY3QuTm9kZSxcbiAgaGVpZ2h0PzogbnVtYmVyIHwgc3RyaW5nLFxuICBzaGFwZT86ICdjaXJjbGUnIHwgJ3JvdW5kZWQnIHwgJ3NxdWFyZScsXG4gIHdpZHRoPzogbnVtYmVyIHwgc3RyaW5nLFxuICB3YXNoPzogYm9vbGVhbixcbnx9O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBNYXNrKHByb3BzOiBQcm9wcykge1xuICBjb25zdCB7IGNoaWxkcmVuLCBzaGFwZSA9ICdzcXVhcmUnLCB3aWR0aCwgaGVpZ2h0LCB3YXNoID0gZmFsc2UgfSA9IHByb3BzO1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtjeChzdHlsZXMuTWFzaywgc3R5bGVzW3NoYXBlXSl9IHN0eWxlPXt7IHdpZHRoLCBoZWlnaHQgfX0+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgICB7d2FzaCAmJiA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLndhc2h9IC8+fVxuICAgIDwvZGl2PlxuICApO1xufVxuXG5NYXNrLnByb3BUeXBlcyA9IHtcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICBoZWlnaHQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgc2hhcGU6IFByb3BUeXBlcy5vbmVPZihbJ2NpcmNsZScsICdyb3VuZGVkJywgJ3NxdWFyZSddKSxcbiAgd2lkdGg6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgd2FzaDogUHJvcFR5cGVzLmJvb2wsXG59O1xuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgQm94IGZyb20gJy4vQm94LmpzJztcbmltcG9ydCBJY29uIGZyb20gJy4vSWNvbi5qcyc7XG5pbXBvcnQgSW1hZ2UgZnJvbSAnLi9JbWFnZS5qcyc7XG5pbXBvcnQgTWFzayBmcm9tICcuL01hc2suanMnO1xuaW1wb3J0IHR5cG9ncmFwaHkgZnJvbSAnLi9UeXBvZ3JhcGh5LmNzcyc7XG5cbmNvbnN0IFNxdWFyZSA9IChwcm9wczogKikgPT4gKFxuICA8Qm94IHsuLi5wcm9wc30gcG9zaXRpb249XCJyZWxhdGl2ZVwiPlxuICAgIDxCb3hcbiAgICAgIGRhbmdlcm91c2x5U2V0SW5saW5lU3R5bGU9e3sgX19zdHlsZTogeyBwYWRkaW5nQm90dG9tOiAnMTAwJScgfSB9fVxuICAgICAgcG9zaXRpb249XCJyZWxhdGl2ZVwiXG4gICAgLz5cbiAgICA8Qm94IHBvc2l0aW9uPVwiYWJzb2x1dGVcIiB0b3AgbGVmdCBib3R0b20gcmlnaHQ+XG4gICAgICB7cHJvcHMuY2hpbGRyZW59XG4gICAgPC9Cb3g+XG4gIDwvQm94PlxuKTtcblxuY29uc3QgRGVmYXVsdEF2YXRhciA9ICh7IG5hbWUgfTogeyBuYW1lOiBzdHJpbmcgfSkgPT4ge1xuICBjb25zdCBmaXJzdEluaXRpYWwgPSBuYW1lID8gWy4uLm5hbWVdWzBdLnRvVXBwZXJDYXNlKCkgOiAnJztcbiAgcmV0dXJuIChcbiAgICA8U3F1YXJlIGNvbG9yPVwiZ3JheVwiIHNoYXBlPVwiY2lyY2xlXCI+XG4gICAgICB7Zmlyc3RJbml0aWFsICYmIChcbiAgICAgICAgPHN2Z1xuICAgICAgICAgIHdpZHRoPVwiMTAwJVwiXG4gICAgICAgICAgdmlld0JveD1cIi01MCAtNTAgMTAwIDEwMFwiXG4gICAgICAgICAgdmVyc2lvbj1cIjEuMVwiXG4gICAgICAgICAgcHJlc2VydmVBc3BlY3RSYXRpbz1cInhNaWRZTWlkIG1lZXRcIlxuICAgICAgICAgIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICAgICAgICA+XG4gICAgICAgICAgPHRpdGxlPntuYW1lfTwvdGl0bGU+XG4gICAgICAgICAgPHRleHRcbiAgICAgICAgICAgIGZvbnRTaXplPVwiNTBweFwiXG4gICAgICAgICAgICBmaWxsPVwiI2ZmZlwiXG4gICAgICAgICAgICBkb21pbmFudEJhc2VsaW5lPVwiY2VudHJhbFwiXG4gICAgICAgICAgICB0ZXh0QW5jaG9yPVwibWlkZGxlXCJcbiAgICAgICAgICAgIGNsYXNzTmFtZT17W1xuICAgICAgICAgICAgICB0eXBvZ3JhcGh5LmFudGlhbGlhc2VkLFxuICAgICAgICAgICAgICB0eXBvZ3JhcGh5LnNhbnNTZXJpZixcbiAgICAgICAgICAgICAgdHlwb2dyYXBoeS5sZWFkaW5nU21hbGwsXG4gICAgICAgICAgICAgIHR5cG9ncmFwaHkuZm9udFdlaWdodEJvbGQsXG4gICAgICAgICAgICBdLmpvaW4oJyAnKX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICB7Zmlyc3RJbml0aWFsfVxuICAgICAgICAgIDwvdGV4dD5cbiAgICAgICAgPC9zdmc+XG4gICAgICApfVxuICAgIDwvU3F1YXJlPlxuICApO1xufTtcblxudHlwZSBTdGF0ZSA9IHt8IGlzSW1hZ2VMb2FkZWQ6IGJvb2xlYW4gfH07XG5cbnR5cGUgQXZhdGFyUHJvcHMgPSB7fFxuICBuYW1lOiBzdHJpbmcsXG4gIG91dGxpbmU/OiBib29sZWFuLFxuICBzaXplPzogJ3NtJyB8ICdtZCcgfCAnbGcnLFxuICBzcmM/OiBzdHJpbmcsXG4gIHZlcmlmaWVkPzogYm9vbGVhbixcbnx9O1xuXG5jb25zdCBzaXplcyA9IHtcbiAgc206IDI0LFxuICBtZDogNDAsXG4gIGxnOiA3Mixcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF2YXRhciBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQ8QXZhdGFyUHJvcHMsIFN0YXRlPiB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgbmFtZTogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIG91dGxpbmU6IFByb3BUeXBlcy5ib29sLFxuICAgIHNyYzogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBzaXplOiBQcm9wVHlwZXMub25lT2YoWydzbScsICdtZCcsICdsZyddKSxcbiAgICB2ZXJpZmllZDogUHJvcFR5cGVzLmJvb2wsXG4gIH07XG5cbiAgc3RhdGUgPSB7XG4gICAgaXNJbWFnZUxvYWRlZDogdHJ1ZSxcbiAgfTtcblxuICBoYW5kbGVJbWFnZUVycm9yID0gKCkgPT4gdGhpcy5zZXRTdGF0ZSh7IGlzSW1hZ2VMb2FkZWQ6IGZhbHNlIH0pO1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IG5hbWUsIG91dGxpbmUsIHNpemUsIHNyYywgdmVyaWZpZWQgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgeyBpc0ltYWdlTG9hZGVkIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHdpZHRoID0gc2l6ZSA/IHNpemVzW3NpemVdIDogJzEwMCUnO1xuICAgIGNvbnN0IGhlaWdodCA9IHNpemUgPyBzaXplc1tzaXplXSA6ICcnO1xuICAgIHJldHVybiAoXG4gICAgICA8Qm94XG4gICAgICAgIGNvbG9yPVwid2hpdGVcIlxuICAgICAgICB7Li4uKG91dGxpbmVcbiAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbmxpbmVTdHlsZToge1xuICAgICAgICAgICAgICAgIF9fc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgIGJveFNoYWRvdzogJzAgMCAwIDJweCAjZmZmJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfVxuICAgICAgICAgIDoge30pfVxuICAgICAgICB3aWR0aD17d2lkdGh9XG4gICAgICAgIGhlaWdodD17aGVpZ2h0fVxuICAgICAgICBwb3NpdGlvbj1cInJlbGF0aXZlXCJcbiAgICAgICAgc2hhcGU9XCJjaXJjbGVcIlxuICAgICAgPlxuICAgICAgICB7c3JjICYmIGlzSW1hZ2VMb2FkZWQgPyAoXG4gICAgICAgICAgPE1hc2sgc2hhcGU9XCJjaXJjbGVcIiB3YXNoPlxuICAgICAgICAgICAgPEltYWdlXG4gICAgICAgICAgICAgIGFsdD17bmFtZX1cbiAgICAgICAgICAgICAgY29sb3I9XCIjRUZFRkVGXCJcbiAgICAgICAgICAgICAgbmF0dXJhbEhlaWdodD17MX1cbiAgICAgICAgICAgICAgbmF0dXJhbFdpZHRoPXsxfVxuICAgICAgICAgICAgICBzcmM9e3NyY31cbiAgICAgICAgICAgICAgb25FcnJvcj17dGhpcy5oYW5kbGVJbWFnZUVycm9yfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L01hc2s+XG4gICAgICAgICkgOiAoXG4gICAgICAgICAgPERlZmF1bHRBdmF0YXIgbmFtZT17bmFtZX0gLz5cbiAgICAgICAgKX1cbiAgICAgICAge3ZlcmlmaWVkICYmIChcbiAgICAgICAgICA8Qm94XG4gICAgICAgICAgICBwb3NpdGlvbj1cImFic29sdXRlXCJcbiAgICAgICAgICAgIHdpZHRoPVwiMjAlXCJcbiAgICAgICAgICAgIGhlaWdodD1cIjIwJVwiXG4gICAgICAgICAgICBtaW5XaWR0aD17OH1cbiAgICAgICAgICAgIG1pbkhlaWdodD17OH1cbiAgICAgICAgICAgIGRhbmdlcm91c2x5U2V0SW5saW5lU3R5bGU9e3tcbiAgICAgICAgICAgICAgX19zdHlsZToge1xuICAgICAgICAgICAgICAgIGJvdHRvbTogJzQlJyxcbiAgICAgICAgICAgICAgICByaWdodDogJzQlJyxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgPlxuICAgICAgICAgICAgPEJveFxuICAgICAgICAgICAgICBjb2xvcj1cIndoaXRlXCJcbiAgICAgICAgICAgICAgd2lkdGg9XCIxMDAlXCJcbiAgICAgICAgICAgICAgaGVpZ2h0PVwiMTAwJVwiXG4gICAgICAgICAgICAgIHNoYXBlPVwiY2lyY2xlXCJcbiAgICAgICAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbmxpbmVTdHlsZT17e1xuICAgICAgICAgICAgICAgIF9fc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgIGJveFNoYWRvdzogJzAgMCAwIDJweCAjZmZmJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8SWNvblxuICAgICAgICAgICAgICAgIGNvbG9yPVwicmVkXCJcbiAgICAgICAgICAgICAgICBpY29uPVwiY2hlY2stY2lyY2xlXCJcbiAgICAgICAgICAgICAgICBhY2Nlc3NpYmlsaXR5TGFiZWw9XCJcIlxuICAgICAgICAgICAgICAgIHNpemU9XCIxMDAlXCJcbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvQm94PlxuICAgICAgICAgIDwvQm94PlxuICAgICAgICApfVxuICAgICAgPC9Cb3g+XG4gICAgKTtcbiAgfVxufVxuIiwiLy8gQGZsb3dcblxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjeCBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBjb2xvcnMgZnJvbSAnLi9Db2xvcnMuY3NzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9UZXh0LmNzcyc7XG5pbXBvcnQgdHlwb2dyYXBoeSBmcm9tICcuL1R5cG9ncmFwaHkuY3NzJztcblxuY29uc3QgU0laRV9TQ0FMRTogeyBbc2l6ZTogP3N0cmluZ106IG51bWJlciB9ID0ge1xuICB4czogMSxcbiAgc206IDIsXG4gIG1kOiAzLFxuICBsZzogNCxcbiAgeGw6IDUsXG59O1xuXG50eXBlIFByb3BzID0ge3xcbiAgYWxpZ24/OiAnbGVmdCcgfCAncmlnaHQnIHwgJ2NlbnRlcicgfCAnanVzdGlmeScsXG4gIGJvbGQ/OiBib29sZWFuLFxuICBjaGlsZHJlbj86IFJlYWN0Lk5vZGUsXG4gIGNvbG9yPzpcbiAgICB8ICdncmVlbidcbiAgICB8ICdwaW5lJ1xuICAgIHwgJ29saXZlJ1xuICAgIHwgJ2JsdWUnXG4gICAgfCAnbmF2eSdcbiAgICB8ICdtaWRuaWdodCdcbiAgICB8ICdwdXJwbGUnXG4gICAgfCAnb3JjaGlkJ1xuICAgIHwgJ2VnZ3BsYW50J1xuICAgIHwgJ21hcm9vbidcbiAgICB8ICd3YXRlcm1lbG9uJ1xuICAgIHwgJ29yYW5nZSdcbiAgICB8ICdkYXJrR3JheSdcbiAgICB8ICdncmF5J1xuICAgIHwgJ2xpZ2h0R3JheSdcbiAgICB8ICdyZWQnXG4gICAgfCAnd2hpdGUnLFxuICBpbmxpbmU/OiBib29sZWFuLFxuICBpdGFsaWM/OiBib29sZWFuLFxuICBvdmVyZmxvdz86ICdub3JtYWwnIHwgJ2JyZWFrV29yZCcsXG4gIHNpemU/OiAneHMnIHwgJ3NtJyB8ICdtZCcgfCAnbGcnIHwgJ3hsJyxcbiAgc21TaXplPzogJ3hzJyB8ICdzbScgfCAnbWQnIHwgJ2xnJyB8ICd4bCcsXG4gIG1kU2l6ZT86ICd4cycgfCAnc20nIHwgJ21kJyB8ICdsZycgfCAneGwnLFxuICBsZ1NpemU/OiAneHMnIHwgJ3NtJyB8ICdtZCcgfCAnbGcnIHwgJ3hsJyxcbiAgbGVhZGluZz86ICd0YWxsJyB8ICdzaG9ydCcsXG4gIHRydW5jYXRlPzogYm9vbGVhbixcbiAgX19kYW5nZXJvdXNseUluY3JlYXNlTGluZUhlaWdodD86IGJvb2xlYW4sXG58fTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gVGV4dCh7XG4gIGFsaWduID0gJ2xlZnQnLFxuICBib2xkID0gZmFsc2UsXG4gIGNoaWxkcmVuLFxuICBjb2xvciA9ICdkYXJrR3JheScsXG4gIGlubGluZSA9IGZhbHNlLFxuICBpdGFsaWMgPSBmYWxzZSxcbiAgb3ZlcmZsb3cgPSAnYnJlYWtXb3JkJyxcbiAgc2l6ZSA9ICdtZCcsXG4gIHNtU2l6ZSxcbiAgbWRTaXplLFxuICBsZ1NpemUsXG4gIGxlYWRpbmcsXG4gIHRydW5jYXRlID0gZmFsc2UsXG4gIF9fZGFuZ2Vyb3VzbHlJbmNyZWFzZUxpbmVIZWlnaHQgPSBmYWxzZSxcbn06IFByb3BzKSB7XG4gIGNvbnN0IHNjYWxlID0gU0laRV9TQ0FMRVtzaXplXTtcbiAgY29uc3Qgc21TY2FsZSA9IFNJWkVfU0NBTEVbc21TaXplXTtcbiAgY29uc3QgbWRTY2FsZSA9IFNJWkVfU0NBTEVbbWRTaXplXTtcbiAgY29uc3QgbGdTY2FsZSA9IFNJWkVfU0NBTEVbbGdTaXplXTtcblxuICBjb25zdCBjcyA9IGN4KFxuICAgIHN0eWxlcy5UZXh0LFxuICAgIHN0eWxlc1tgZm9udFNpemUke3NjYWxlfWBdLFxuICAgIGxnU2l6ZSAmJiBzdHlsZXNbYGxnRm9udFNpemUke2xnU2NhbGV9YF0sXG4gICAgbWRTaXplICYmIHN0eWxlc1tgbWRGb250U2l6ZSR7bWRTY2FsZX1gXSxcbiAgICBzbVNpemUgJiYgc3R5bGVzW2BzbUZvbnRTaXplJHtzbVNjYWxlfWBdLFxuICAgIGNvbG9yID09PSAnYmx1ZScgJiYgY29sb3JzLmJsdWUsXG4gICAgY29sb3IgPT09ICdkYXJrR3JheScgJiYgY29sb3JzLmRhcmtHcmF5LFxuICAgIGNvbG9yID09PSAnZWdncGxhbnQnICYmIGNvbG9ycy5lZ2dwbGFudCxcbiAgICBjb2xvciA9PT0gJ2dyYXknICYmIGNvbG9ycy5ncmF5LFxuICAgIGNvbG9yID09PSAnZ3JlZW4nICYmIGNvbG9ycy5ncmVlbixcbiAgICBjb2xvciA9PT0gJ2xpZ2h0R3JheScgJiYgY29sb3JzLmxpZ2h0R3JheSxcbiAgICBjb2xvciA9PT0gJ21hcm9vbicgJiYgY29sb3JzLm1hcm9vbixcbiAgICBjb2xvciA9PT0gJ21pZG5pZ2h0JyAmJiBjb2xvcnMubWlkbmlnaHQsXG4gICAgY29sb3IgPT09ICduYXZ5JyAmJiBjb2xvcnMubmF2eSxcbiAgICBjb2xvciA9PT0gJ29saXZlJyAmJiBjb2xvcnMub2xpdmUsXG4gICAgY29sb3IgPT09ICdvcmFuZ2UnICYmIGNvbG9ycy5vcmFuZ2UsXG4gICAgY29sb3IgPT09ICdvcmNoaWQnICYmIGNvbG9ycy5vcmNoaWQsXG4gICAgY29sb3IgPT09ICdwaW5lJyAmJiBjb2xvcnMucGluZSxcbiAgICBjb2xvciA9PT0gJ3B1cnBsZScgJiYgY29sb3JzLnB1cnBsZSxcbiAgICBjb2xvciA9PT0gJ3JlZCcgJiYgY29sb3JzLnJlZCxcbiAgICBjb2xvciA9PT0gJ3dhdGVybWVsb24nICYmIGNvbG9ycy53YXRlcm1lbG9uLFxuICAgIGNvbG9yID09PSAnd2hpdGUnICYmIGNvbG9ycy53aGl0ZSxcbiAgICBsZWFkaW5nID09PSAnc2hvcnQnICYmIHR5cG9ncmFwaHkubGVhZGluZ1Nob3J0LFxuICAgIChsZWFkaW5nID09PSAndGFsbCcgfHwgX19kYW5nZXJvdXNseUluY3JlYXNlTGluZUhlaWdodCkgJiZcbiAgICAgIHR5cG9ncmFwaHkubGVhZGluZ1RhbGwsXG4gICAgYWxpZ24gPT09ICdjZW50ZXInICYmIHR5cG9ncmFwaHkuYWxpZ25DZW50ZXIsXG4gICAgYWxpZ24gPT09ICdqdXN0aWZ5JyAmJiB0eXBvZ3JhcGh5LmFsaWduSnVzdGlmeSxcbiAgICBhbGlnbiA9PT0gJ2xlZnQnICYmIHR5cG9ncmFwaHkuYWxpZ25MZWZ0LFxuICAgIGFsaWduID09PSAncmlnaHQnICYmIHR5cG9ncmFwaHkuYWxpZ25SaWdodCxcbiAgICBvdmVyZmxvdyA9PT0gJ2JyZWFrV29yZCcgJiYgdHlwb2dyYXBoeS5icmVha1dvcmQsXG4gICAgaXRhbGljICYmIHR5cG9ncmFwaHkuZm9udFN0eWxlSXRhbGljLFxuICAgICFpdGFsaWMgJiYgdHlwb2dyYXBoeS5mb250U3R5bGVOb3JtYWwsXG4gICAgYm9sZCAmJiB0eXBvZ3JhcGh5LmZvbnRXZWlnaHRCb2xkLFxuICAgICFib2xkICYmIHR5cG9ncmFwaHkuZm9udFdlaWdodE5vcm1hbCxcbiAgICB0cnVuY2F0ZSAmJiB0eXBvZ3JhcGh5LnRydW5jYXRlXG4gICk7XG4gIGNvbnN0IFRhZyA9IGlubGluZSA/ICdzcGFuJyA6ICdkaXYnO1xuXG4gIHJldHVybiAoXG4gICAgPFRhZ1xuICAgICAgY2xhc3NOYW1lPXtjc31cbiAgICAgIHsuLi4odHJ1bmNhdGUgJiYgdHlwZW9mIGNoaWxkcmVuID09PSAnc3RyaW5nJ1xuICAgICAgICA/IHsgdGl0bGU6IGNoaWxkcmVuIH1cbiAgICAgICAgOiBudWxsKX1cbiAgICA+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9UYWc+XG4gICk7XG59XG5cblRleHQucHJvcFR5cGVzID0ge1xuICBfX2Rhbmdlcm91c2x5SW5jcmVhc2VMaW5lSGVpZ2h0OiBQcm9wVHlwZXMuYm9vbCxcbiAgYWxpZ246IFByb3BUeXBlcy5vbmVPZihbJ2xlZnQnLCAncmlnaHQnLCAnY2VudGVyJywgJ2p1c3RpZnknXSksXG4gIGJvbGQ6IFByb3BUeXBlcy5ib29sLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gIGNvbG9yOiBQcm9wVHlwZXMub25lT2YoW1xuICAgICdncmVlbicsXG4gICAgJ3BpbmUnLFxuICAgICdvbGl2ZScsXG4gICAgJ2JsdWUnLFxuICAgICduYXZ5JyxcbiAgICAnbWlkbmlnaHQnLFxuICAgICdwdXJwbGUnLFxuICAgICdvcmNoaWQnLFxuICAgICdlZ2dwbGFudCcsXG4gICAgJ21hcm9vbicsXG4gICAgJ3dhdGVybWVsb24nLFxuICAgICdvcmFuZ2UnLFxuICAgICdkYXJrR3JheScsXG4gICAgJ2dyYXknLFxuICAgICdsaWdodEdyYXknLFxuICAgICdyZWQnLFxuICAgICd3aGl0ZScsXG4gIF0pLFxuICBpbmxpbmU6IFByb3BUeXBlcy5ib29sLFxuICBpdGFsaWM6IFByb3BUeXBlcy5ib29sLFxuICBsZWFkaW5nOiBQcm9wVHlwZXMub25lT2YoWyd0YWxsJywgJ3Nob3J0J10pLFxuICBsZ1NpemU6IFByb3BUeXBlcy5vbmVPZihbJ3hzJywgJ3NtJywgJ21kJywgJ2xnJywgJ3hsJ10pLFxuICBtZFNpemU6IFByb3BUeXBlcy5vbmVPZihbJ3hzJywgJ3NtJywgJ21kJywgJ2xnJywgJ3hsJ10pLFxuICBvdmVyZmxvdzogUHJvcFR5cGVzLm9uZU9mKFsnbm9ybWFsJywgJ2JyZWFrV29yZCddKSxcbiAgc2l6ZTogUHJvcFR5cGVzLm9uZU9mKFsneHMnLCAnc20nLCAnbWQnLCAnbGcnLCAneGwnXSksXG4gIHNtU2l6ZTogUHJvcFR5cGVzLm9uZU9mKFsneHMnLCAnc20nLCAnbWQnLCAnbGcnLCAneGwnXSksXG4gIHRydW5jYXRlOiBQcm9wVHlwZXMuYm9vbCxcbn07XG4iLCIvLyBAZmxvd1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL0J1dHRvbi5jc3MnO1xuaW1wb3J0IFRleHQgZnJvbSAnLi9UZXh0LmpzJztcblxudHlwZSBQcm9wcyA9IHt8XG4gIGFjY2Vzc2liaWxpdHlFeHBhbmRlZD86IGJvb2xlYW4sXG4gIGFjY2Vzc2liaWxpdHlIYXNwb3B1cD86IGJvb2xlYW4sXG4gIGFjY2Vzc2liaWxpdHlMYWJlbD86IHN0cmluZyxcbiAgY29sb3I/OiAnZ3JheScgfCAncmVkJyB8ICdibHVlJyB8ICd0cmFuc3BhcmVudCcgfCAnd2hpdGUnLFxuICBkaXNhYmxlZD86IGJvb2xlYW4sXG4gIGlubGluZT86IGJvb2xlYW4sXG4gIG5hbWU/OiBzdHJpbmcsXG4gIG9uQ2xpY2s/OiAoeyBldmVudDogU3ludGhldGljTW91c2VFdmVudDw+IH0pID0+IHZvaWQsXG4gIHNpemU/OiAnc20nIHwgJ21kJyB8ICdsZycsXG4gIHRleHQ6IHN0cmluZyxcbiAgdHlwZT86ICdzdWJtaXQnIHwgJ2J1dHRvbicsXG58fTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQnV0dG9uKHByb3BzOiBQcm9wcykge1xuICBjb25zdCB7XG4gICAgYWNjZXNzaWJpbGl0eUV4cGFuZGVkLFxuICAgIGFjY2Vzc2liaWxpdHlIYXNwb3B1cCxcbiAgICBhY2Nlc3NpYmlsaXR5TGFiZWwsXG4gICAgY29sb3IgPSAnZ3JheScsXG4gICAgZGlzYWJsZWQgPSBmYWxzZSxcbiAgICBpbmxpbmUgPSBmYWxzZSxcbiAgICBuYW1lLFxuICAgIG9uQ2xpY2ssXG4gICAgc2l6ZSA9ICdtZCcsXG4gICAgdGV4dCxcbiAgICB0eXBlID0gJ2J1dHRvbicsXG4gIH0gPSBwcm9wcztcblxuICBjb25zdCB0ZXh0Q29sb3IgPSB7XG4gICAgYmx1ZTogJ3doaXRlJyxcbiAgICBncmF5OiAnZGFya0dyYXknLFxuICAgIHJlZDogJ3doaXRlJyxcbiAgICB0cmFuc3BhcmVudDogJ3doaXRlJyxcbiAgICB3aGl0ZTogJ2RhcmtHcmF5JyxcbiAgfTtcblxuICBjb25zdCBjbGFzc2VzID0gY2xhc3NuYW1lcyhzdHlsZXMuYnV0dG9uLCB7XG4gICAgW3N0eWxlcy5zbV06IHNpemUgPT09ICdzbScsXG4gICAgW3N0eWxlcy5tZF06IHNpemUgPT09ICdtZCcsXG4gICAgW3N0eWxlcy5sZ106IHNpemUgPT09ICdsZycsXG4gICAgW3N0eWxlcy5zb2xpZF06IGNvbG9yICE9PSAndHJhbnNwYXJlbnQnLFxuICAgIFtzdHlsZXNbY29sb3JdXTogIWRpc2FibGVkLFxuICAgIFtzdHlsZXMuZGlzYWJsZWRdOiBkaXNhYmxlZCxcbiAgICBbc3R5bGVzLmVuYWJsZWRdOiAhZGlzYWJsZWQsXG4gICAgW3N0eWxlcy5pbmxpbmVdOiBpbmxpbmUsXG4gICAgW3N0eWxlcy5ibG9ja106ICFpbmxpbmUsXG4gIH0pO1xuXG4gIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0L2J1dHRvbi1oYXMtdHlwZSAqL1xuICByZXR1cm4gKFxuICAgIDxidXR0b25cbiAgICAgIGFyaWEtZXhwYW5kZWQ9e2FjY2Vzc2liaWxpdHlFeHBhbmRlZH1cbiAgICAgIGFyaWEtaGFzcG9wdXA9e2FjY2Vzc2liaWxpdHlIYXNwb3B1cH1cbiAgICAgIGFyaWEtbGFiZWw9e2FjY2Vzc2liaWxpdHlMYWJlbH1cbiAgICAgIGNsYXNzTmFtZT17Y2xhc3Nlc31cbiAgICAgIGRpc2FibGVkPXtkaXNhYmxlZH1cbiAgICAgIG5hbWU9e25hbWV9XG4gICAgICBvbkNsaWNrPXtldmVudCA9PiBvbkNsaWNrICYmIG9uQ2xpY2soeyBldmVudCB9KX1cbiAgICAgIHR5cGU9e3R5cGV9XG4gICAgPlxuICAgICAgPFRleHRcbiAgICAgICAgYWxpZ249XCJjZW50ZXJcIlxuICAgICAgICBib2xkXG4gICAgICAgIGNvbG9yPXtkaXNhYmxlZCA/ICdncmF5JyA6IHRleHRDb2xvcltjb2xvcl19XG4gICAgICAgIG92ZXJmbG93PVwibm9ybWFsXCJcbiAgICAgICAgc2l6ZT17c2l6ZX1cbiAgICAgID5cbiAgICAgICAge3RleHR9XG4gICAgICA8L1RleHQ+XG4gICAgPC9idXR0b24+XG4gICk7XG4gIC8qIGVzbGludC1lbmFibGUgcmVhY3QvYnV0dG9uLWhhcy10eXBlICovXG59XG5cbkJ1dHRvbi5wcm9wVHlwZXMgPSB7XG4gIGFjY2Vzc2liaWxpdHlFeHBhbmRlZDogUHJvcFR5cGVzLmJvb2wsXG4gIGFjY2Vzc2liaWxpdHlIYXNwb3B1cDogUHJvcFR5cGVzLmJvb2wsXG4gIGFjY2Vzc2liaWxpdHlMYWJlbDogUHJvcFR5cGVzLnN0cmluZyxcbiAgY29sb3I6IFByb3BUeXBlcy5vbmVPZihbJ2JsdWUnLCAnZ3JheScsICdyZWQnLCAndHJhbnNwYXJlbnQnLCAnd2hpdGUnXSksXG4gIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgaW5saW5lOiBQcm9wVHlwZXMuYm9vbCxcbiAgbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgb25DbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gIHNpemU6IFByb3BUeXBlcy5vbmVPZihbJ3NtJywgJ21kJywgJ2xnJ10pLFxuICB0ZXh0OiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gIHR5cGU6IFByb3BUeXBlcy5vbmVPZihbJ2J1dHRvbicsICdzdWJtaXQnXSksXG59O1xuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBCb3ggZnJvbSAnLi9Cb3guanMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL0NhcmQuY3NzJztcblxudHlwZSBQcm9wcyA9IHt8XG4gIGFjdGl2ZT86ID9ib29sZWFuLFxuICBjaGlsZHJlbj86IFJlYWN0Lk5vZGUsXG4gIGltYWdlPzogUmVhY3QuTm9kZSxcbiAgb25Nb3VzZUVudGVyPzogKHsgZXZlbnQ6IFN5bnRoZXRpY01vdXNlRXZlbnQ8SFRNTERpdkVsZW1lbnQ+IH0pID0+IHZvaWQsXG4gIG9uTW91c2VMZWF2ZT86ICh7IGV2ZW50OiBTeW50aGV0aWNNb3VzZUV2ZW50PEhUTUxEaXZFbGVtZW50PiB9KSA9PiB2b2lkLFxufH07XG5cbnR5cGUgU3RhdGUgPSB7fFxuICBob3ZlcmVkOiBib29sZWFuLFxufH07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhcmQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8UHJvcHMsIFN0YXRlPiB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgYWN0aXZlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gICAgaW1hZ2U6IFByb3BUeXBlcy5ub2RlLFxuICAgIG9uTW91c2VFbnRlcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25Nb3VzZUxlYXZlOiBQcm9wVHlwZXMuZnVuYyxcbiAgfTtcblxuICBzdGF0ZTogU3RhdGUgPSB7XG4gICAgaG92ZXJlZDogZmFsc2UsXG4gIH07XG5cbiAgaGFuZGxlTW91c2VFbnRlciA9IChldmVudDogU3ludGhldGljTW91c2VFdmVudDxIVE1MRGl2RWxlbWVudD4pID0+IHtcbiAgICBjb25zdCB7IG9uTW91c2VFbnRlciB9ID0gdGhpcy5wcm9wcztcbiAgICB0aGlzLnNldFN0YXRlKFxuICAgICAgeyBob3ZlcmVkOiB0cnVlIH0sXG4gICAgICBvbk1vdXNlRW50ZXIgJiYgKCgpID0+IG9uTW91c2VFbnRlcih7IGV2ZW50IH0pKVxuICAgICk7XG4gIH07XG5cbiAgaGFuZGxlTW91c2VMZWF2ZSA9IChldmVudDogU3ludGhldGljTW91c2VFdmVudDxIVE1MRGl2RWxlbWVudD4pID0+IHtcbiAgICBjb25zdCB7IG9uTW91c2VMZWF2ZSB9ID0gdGhpcy5wcm9wcztcbiAgICB0aGlzLnNldFN0YXRlKFxuICAgICAgeyBob3ZlcmVkOiBmYWxzZSB9LFxuICAgICAgb25Nb3VzZUxlYXZlICYmICgoKSA9PiBvbk1vdXNlTGVhdmUoeyBldmVudCB9KSlcbiAgICApO1xuICB9O1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGFjdGl2ZSwgY2hpbGRyZW4sIGltYWdlIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgaG92ZXJlZCB9ID0gdGhpcy5zdGF0ZTtcblxuICAgIGNvbnN0IGNsYXNzZXMgPSBjbGFzc25hbWVzKHN0eWxlcy5jYXJkLCB7XG4gICAgICAvLyBJZiwgbGlrZSBAY2hyaXNsbG95ZCwgeW91IGNhbid0IHJlbWVtYmVyIEphdmFzY3JpcHQgZXF1YWxpdHkgcnVsZXMsXG4gICAgICAvLyA9PSBudWxsIGNoZWNrcyBmb3IgYG51bGxgIG9yIGB1bmRlZmluZWRgIGFuZCBsZWF2ZXMgb3V0IGBmYWxzZWAuXG4gICAgICBbc3R5bGVzLmhvdmVyXTogYWN0aXZlIHx8IChhY3RpdmUgPT0gbnVsbCAmJiBob3ZlcmVkKSxcbiAgICB9KTtcblxuICAgIHJldHVybiAoXG4gICAgICA8Qm94XG4gICAgICAgIG9uTW91c2VFbnRlcj17dGhpcy5oYW5kbGVNb3VzZUVudGVyfVxuICAgICAgICBvbk1vdXNlTGVhdmU9e3RoaXMuaGFuZGxlTW91c2VMZWF2ZX1cbiAgICAgICAgcG9zaXRpb249XCJyZWxhdGl2ZVwiXG4gICAgICA+XG4gICAgICAgIHtpbWFnZSAmJiA8Qm94IG1hcmdpbkJvdHRvbT17MX0+e2ltYWdlfTwvQm94Pn1cbiAgICAgICAgPEJveD57Y2hpbGRyZW59PC9Cb3g+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjbGFzc2VzfSAvPlxuICAgICAgPC9Cb3g+XG4gICAgKTtcbiAgfVxufVxuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBjb2xvcnMgZnJvbSAnLi9Db2xvcnMuY3NzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9DaGVja2JveC5jc3MnO1xuaW1wb3J0IEJveCBmcm9tICcuL0JveC5qcyc7XG5pbXBvcnQgSWNvbiBmcm9tICcuL0ljb24uanMnO1xuXG50eXBlIFByb3BzID0ge3xcbiAgY2hlY2tlZD86IGJvb2xlYW4sXG4gIGRpc2FibGVkPzogYm9vbGVhbixcbiAgaGFzRXJyb3I/OiBib29sZWFuLFxuICBpZDogc3RyaW5nLFxuICBpbmRldGVybWluYXRlPzogYm9vbGVhbixcbiAgbmFtZT86IHN0cmluZyxcbiAgb25DaGFuZ2U6ICh7IGV2ZW50OiBTeW50aGV0aWNJbnB1dEV2ZW50PD4sIGNoZWNrZWQ6IGJvb2xlYW4gfSkgPT4gdm9pZCxcbiAgb25DbGljaz86ICh7XG4gICAgZXZlbnQ6IFN5bnRoZXRpY0lucHV0RXZlbnQ8SFRNTElucHV0RWxlbWVudD4sXG4gICAgY2hlY2tlZDogYm9vbGVhbixcbiAgfSkgPT4gdm9pZCxcbiAgc2l6ZT86ICdzbScgfCAnbWQnLFxufH07XG5cbnR5cGUgU3RhdGUgPSB7fFxuICBmb2N1c2VkOiBib29sZWFuLFxufH07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENoZWNrYm94IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFByb3BzLCBTdGF0ZT4ge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIGNoZWNrZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBoYXNFcnJvcjogUHJvcFR5cGVzLmJvb2wsXG4gICAgaWQ6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBpbmRldGVybWluYXRlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBuYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICAgIHNpemU6IFByb3BUeXBlcy5vbmVPZihbJ3NtJywgJ21kJ10pLFxuICB9O1xuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgY2hlY2tlZDogZmFsc2UsXG4gICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgIGhhc0Vycm9yOiBmYWxzZSxcbiAgICBpbmRldGVybWluYXRlOiBmYWxzZSxcbiAgICBzaXplOiAnbWQnLFxuICB9O1xuXG4gIHN0YXRlID0ge1xuICAgIGZvY3VzZWQ6IGZhbHNlLFxuICB9O1xuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGlmICh0aGlzLnByb3BzLmluZGV0ZXJtaW5hdGUpIHtcbiAgICAgIHRoaXMuc2V0SW5kZXRlcm1pbmF0ZSghIXRoaXMucHJvcHMuaW5kZXRlcm1pbmF0ZSk7XG4gICAgfVxuICB9XG5cbiAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZpb3VzUHJvcHM6IFByb3BzKSB7XG4gICAgaWYgKHByZXZpb3VzUHJvcHMuaW5kZXRlcm1pbmF0ZSAhPT0gdGhpcy5wcm9wcy5pbmRldGVybWluYXRlKSB7XG4gICAgICB0aGlzLnNldEluZGV0ZXJtaW5hdGUoISF0aGlzLnByb3BzLmluZGV0ZXJtaW5hdGUpO1xuICAgIH1cbiAgfVxuXG4gIHNldEluZGV0ZXJtaW5hdGUoaW5kZXRlcm1pbmF0ZTogYm9vbGVhbikge1xuICAgIGlmICh0aGlzLmlucHV0KSB7XG4gICAgICB0aGlzLmlucHV0LmluZGV0ZXJtaW5hdGUgPSBpbmRldGVybWluYXRlO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZUNoYW5nZSA9IChldmVudDogU3ludGhldGljSW5wdXRFdmVudDw+KSA9PiB7XG4gICAgY29uc3QgeyBjaGVja2VkIH0gPSBldmVudC50YXJnZXQ7XG4gICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh7IGV2ZW50LCBjaGVja2VkIH0pO1xuICB9O1xuXG4gIGhhbmRsZUNsaWNrID0gKGV2ZW50OiBTeW50aGV0aWNJbnB1dEV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XG4gICAgY29uc3QgeyBvbkNsaWNrIH0gPSB0aGlzLnByb3BzO1xuICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICBjb25zdCB7IGNoZWNrZWQgfSA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICBvbkNsaWNrKHsgZXZlbnQsIGNoZWNrZWQgfSk7XG4gICAgfVxuICB9O1xuXG4gIGhhbmRsZUJsdXIgPSAoKSA9PiB0aGlzLnNldFN0YXRlKHsgZm9jdXNlZDogZmFsc2UgfSk7XG5cbiAgaGFuZGxlRm9jdXMgPSAoKSA9PiB0aGlzLnNldFN0YXRlKHsgZm9jdXNlZDogdHJ1ZSB9KTtcblxuICBpbnB1dDogP0hUTUxJbnB1dEVsZW1lbnQ7XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNoZWNrZWQsXG4gICAgICBkaXNhYmxlZCxcbiAgICAgIGhhc0Vycm9yLFxuICAgICAgaWQsXG4gICAgICBpbmRldGVybWluYXRlLFxuICAgICAgbmFtZSxcbiAgICAgIHNpemUsXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBsZXQgYm9yZGVyU3R5bGUgPSBzdHlsZXMuYm9yZGVyO1xuICAgIGlmICghZGlzYWJsZWQgJiYgKGNoZWNrZWQgfHwgaW5kZXRlcm1pbmF0ZSkpIHtcbiAgICAgIGJvcmRlclN0eWxlID0gc3R5bGVzLmJvcmRlckRhcms7XG4gICAgfSBlbHNlIGlmIChoYXNFcnJvcikge1xuICAgICAgYm9yZGVyU3R5bGUgPSBzdHlsZXMuYm9yZGVyRXJyb3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxCb3ggcG9zaXRpb249XCJyZWxhdGl2ZVwiPlxuICAgICAgICA8aW5wdXRcbiAgICAgICAgICBjaGVja2VkPXtjaGVja2VkfVxuICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NuYW1lcyhzdHlsZXMuaW5wdXQsIHtcbiAgICAgICAgICAgIFtzdHlsZXMuaW5wdXRFbmFibGVkXTogIWRpc2FibGVkLFxuICAgICAgICAgICAgW3N0eWxlcy5pbmRldGVybWluYXRlXTogaW5kZXRlcm1pbmF0ZSxcbiAgICAgICAgICAgIFtzdHlsZXMuaW5wdXRTbV06IHNpemUgPT09ICdzbScsXG4gICAgICAgICAgICBbc3R5bGVzLmlucHV0TWRdOiBzaXplID09PSAnbWQnLFxuICAgICAgICAgIH0pfVxuICAgICAgICAgIGRpc2FibGVkPXtkaXNhYmxlZH1cbiAgICAgICAgICBpZD17aWR9XG4gICAgICAgICAgbmFtZT17bmFtZX1cbiAgICAgICAgICBvbkJsdXI9e3RoaXMuaGFuZGxlQmx1cn1cbiAgICAgICAgICBvbkNoYW5nZT17dGhpcy5oYW5kbGVDaGFuZ2V9XG4gICAgICAgICAgb25DbGljaz17dGhpcy5oYW5kbGVDbGlja31cbiAgICAgICAgICBvbkZvY3VzPXt0aGlzLmhhbmRsZUZvY3VzfVxuICAgICAgICAgIHJlZj17ZWwgPT4ge1xuICAgICAgICAgICAgdGhpcy5pbnB1dCA9IGVsO1xuICAgICAgICAgIH19XG4gICAgICAgICAgdHlwZT1cImNoZWNrYm94XCJcbiAgICAgICAgLz5cbiAgICAgICAgPGRpdlxuICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NuYW1lcyhcbiAgICAgICAgICAgIGJvcmRlclN0eWxlLFxuICAgICAgICAgICAgc3R5bGVzLmNoZWNrLFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgICAgICAgICBkaXNhYmxlZFxuICAgICAgICAgICAgICA/IGNoZWNrZWQgfHwgaW5kZXRlcm1pbmF0ZVxuICAgICAgICAgICAgICAgID8gY29sb3JzLmdyYXlCZ1xuICAgICAgICAgICAgICAgIDogY29sb3JzLmxpZ2h0R3JheUJnXG4gICAgICAgICAgICAgIDogY2hlY2tlZCB8fCBpbmRldGVybWluYXRlXG4gICAgICAgICAgICAgICAgPyBjb2xvcnMuZGFya0dyYXlCZ1xuICAgICAgICAgICAgICAgIDogY29sb3JzLndoaXRlQmcsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIFtzdHlsZXMuY2hlY2tFbmFibGVkXTogIWRpc2FibGVkLFxuICAgICAgICAgICAgICBbc3R5bGVzLmNoZWNrRm9jdXNlZF06IHRoaXMuc3RhdGUuZm9jdXNlZCxcbiAgICAgICAgICAgICAgW3N0eWxlcy5jaGVja01kXTogc2l6ZSA9PT0gJ21kJyxcbiAgICAgICAgICAgICAgW3N0eWxlcy5jaGVja1NtXTogc2l6ZSA9PT0gJ3NtJyxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApfVxuICAgICAgICA+XG4gICAgICAgICAgeyhjaGVja2VkIHx8IGluZGV0ZXJtaW5hdGUpICYmIChcbiAgICAgICAgICAgIDxJY29uXG4gICAgICAgICAgICAgIGFjY2Vzc2liaWxpdHlMYWJlbD1cIlwiXG4gICAgICAgICAgICAgIGNvbG9yPVwid2hpdGVcIlxuICAgICAgICAgICAgICBpY29uPXtpbmRldGVybWluYXRlID8gJ2Rhc2gnIDogJ2NoZWNrJ31cbiAgICAgICAgICAgICAgc2l6ZT17c2l6ZSA9PT0gJ3NtJyA/IDggOiAxMn1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgKX1cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L0JveD5cbiAgICApO1xuICB9XG59XG4iLCIvLyBAZmxvd1xuLypcbiAgIyBDb2xsZWN0aW9uXG5cbiAgQ29sbGVjdGlvbiBpcyBjb21wb25lbnQgdGhhdCBjYW4gYWJzb2x1dGVseSBwb3NpdGlvbiBhbmQgdmlydHVhbGl6ZSBpdGVtcy4gSXQncyBtZWFudCB0byBiZSBhbiBleHRlcmVtbHkgc2ltcGxlIHdvcmtob3JzZSB0byByZS1pbXBsZW1lbnQgY3VzdG9tIGxheW91dHMuIEl0J3Mgbm90IHBlcmZlY3QgZm9yIGFsbCBzaXR1YXRpb25zIGJ1dCBpdCBkb2VzIGhhdmUgYSBjbG9zZWQgQVBJIGFuZCBpcyBwcmV0dHkgcGVyZm9ybWFudC5cblxuICAjIyBIb3cgaXQgd29ya3NcblxuICBUaGVyZSBhcmUgdHdvIGNlbnRyYWwgY29uY2VwdHMgdG8gQ29sbGVjdGlvbiAtIHRoZSBjb250ZW50IGxheWVyIGFuZCB0aGUgdmlld3BvcnQgbGF5ZXIuXG5cbiAgQ29udGVudCBsYXllciAgICAgICAgICAgICAgIFZpZXdwb3J0ICAgICAgICAgICAgICAgICAgIENvbXBvc2l0ZSBsYXllclxuXG4gICstLS0tLS0tLS0tLS0tLS0tKyAgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLSsgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0rXG4gIHwgICAgICAgICAgICAgICAgfCAgICAgICAgICB8ICAgICAgICAgICAgICAgIHwgICAgICAgICAgfCAgICAgICAgICAgICAgICB8XG4gIHwgKy0tKyArLS0rICstLSsgfCAgICAgICAgICB8ICAgICAgICAgICAgICAgIHwgICAgICAgICAgfCAgICAgICAgICAgICAgICB8XG4gIHwgfCAgfCB8ICB8IHwgIHwgfCAgICAgICAgICB8ICAgICAgICAgICAgICAgIHwgICAgICAgICAgfCAgICAgICAgICAgICAgICB8XG4gIHwgfCAgfCB8ICB8IHwgIHwgfCAgICAgICAgICB8ICstLS0tLS0tLS0tLS0rIHwgICAgICAgICAgfCArLS0tLS0tLS0tLS0tKyB8XG4gIHwgKy0tKyB8ICB8IHwgIHwgfCAgICAgICAgICB8IHwgICAgICAgICAgICB8IHwgICAgICAgICAgfCB8LS0rIHwgIHwgfCAgfCB8XG4gIHwgICAgICB8ICB8ICstLSsgfCAgICAgICAgICB8IHwgICAgICAgICAgICB8IHwgICAgICAgICAgfCB8ICAgIHwgIHwgKy0tfCB8XG4gIHwgKy0tKyArLS0rICAgICAgfCAgICAgICAgICB8IHwgICAgICAgICAgICB8IHwgICAgICAgICAgfCB8LS0rICstLSsgICAgfCB8XG4gIHwgfCAgfCAgICAgICstLSsgfCArLS0tLS0tPiB8IHwgICAgICAgICAgICB8IHwgKy0tLS0tLT4gfCB8ICB8ICAgICAgKy0tfCB8XG4gIHwgKy0tKyArLS0rIHwgIHwgfCAgICAgICAgICB8IHwgICAgICAgICAgICB8IHwgICAgICAgICAgfCB8LS0rICstLSsgfCAgfCB8XG4gIHwgICAgICB8ICB8IHwgIHwgfCAgICAgICAgICB8IHwgICAgICAgICAgICB8IHwgICAgICAgICAgfCB8ICAgIHwgIHwgfCAgfCB8XG4gIHwgKy0tKyB8ICB8ICstLSsgfCAgICAgICAgICB8IHwgICAgICAgICAgICB8IHwgICAgICAgICAgfCB8LS0rIHwgIHwgKy0tfCB8XG4gIHwgfCAgfCB8ICB8ICAgICAgfCAgICAgICAgICB8IHwgICAgICAgICAgICB8IHwgICAgICAgICAgfCB8ICB8IHwgIHwgICAgfCB8XG4gIHwgfCAgfCB8ICB8ICstLSsgfCAgICAgICAgICB8ICstLS0tLS0tLS0tLS0rIHwgICAgICAgICAgfCArLS0tLS0tLS0tLS0tKyB8XG4gIHwgfCAgfCB8ICB8IHwgIHwgfCAgICAgICAgICB8ICAgICAgICAgICAgICAgIHwgICAgICAgICAgfCAgICAgICAgICAgICAgICB8XG4gIHwgKy0tKyArLS0rICstLSsgfCAgICAgICAgICB8ICAgICAgICAgICAgICAgIHwgICAgICAgICAgfCAgICAgICAgICAgICAgICB8XG4gIHwgICAgICAgICAgICAgICAgfCAgICAgICAgICB8ICAgICAgICAgICAgICAgIHwgICAgICAgICAgfCAgICAgICAgICAgICAgICB8XG4gICstLS0tLS0tLS0tLS0tLS0tKyAgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLSsgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0rXG5cbiAgWW91IHBvc2l0aW9uIHlvdXIgaXRlbXMgaW4gdGhlIHZpcnR1YWwgY29udGVudCBsYXllciwgdGhlbiB5b3UgZGVmaW5lIHRoZSB2aWV3cG9ydCBsYXllciAoYnkgZGVmYXVsdCB0aGlzIGlzIHRoZSBmdWxsIHNpemUgb2YgdGhlIGNvbnRlbnQgbGF5ZXIpLiBDb2xsZWN0aW9uIHRoZW4gdGFrZXMgdGhvc2UgaXRlbXMsIGFuZCB0aGUgdmlld3BvcnQgcmVuZGVyaW5nIHRoZSBjb250ZW50IGxheWVyIHdpdGggb25seSB0aGUgaXRlbXMgdGhhdCBmaXQgaW5zaWRlIHRoZSB2aWV3cG9ydC5cblxuICAjIyBBc3N1bXB0aW9uc1xuXG4gIDEuIFlvdXIgbGF5b3V0IGlzIHByZS1jYWxjdWxhdGVkLiBDb2xsZWN0aW9uIGV4cGVjdHMgbGF5b3V0IHRvIGJlIHBhc3NlZCBpbiBhcyBhIHByb3BlcnR5LiBJZiB5b3VyIGxheW91dCBpc24ndCByZWFkeSAoaS5lLiBzb21ldGhpbmcgbmVlZHMgdG8gYmUgbWVhc3VyZWQpIHRoZSBjYWxsZXIgbmVlZHMgdG8gZmlndXJlIHRoYXQgb3V0LlxuICAyLiBQYXNzZWQgaW4gSXRlbSBhcmUgc29tZXdoYXQgcHVyZSAtIHRoZXkgY2FuIGJlIG1vdW50ZWQgYW5kIHVubW91bnRlZCBhdCBhbnl0aW1lIHNvIEl0ZW0ncyBsaWZlY3ljbGUgbWV0aG9kcyBuZWVkIHRvIGFjY291bnQgZm9yIHRoYXQuXG4gIDMuIFBhc3NlZCBpbiBJdGVtcyBhcmUgYm91bmQgdG8gdGhlaXIgZGF0YS1zb3VyY2Ugc2VwZXJhdGVseS4gQWxsIHRoZXkgcmVjZWl2ZSBpcyBhbiBpbmRleCwgc28gdGhleSBuZWVkIHRvIGhhdmUgYW55IGV4dGVybmFsIGRhdGEgc291cmNlcyBpbiBzY29wZS5cbiAgNC4gVGhlIHZpZXdwb3J0IGNhbiBiZSBhbnkgc2l6ZS4gTW9zdCB3aW5kb3dpbmcvcmVjeWNsaW5nIHNvbHV0aW9ucyBpbXBsZW1lbnQgc29tZSBzb3J0IG9mIG92ZXJzY2FubmluZywgaG93ZXZlciBDb2xsZWN0aW9uIGxlYXZlcyB0aGlzIHVwIHRoZSB0aGUgcGFyZW50LlxuXG4qL1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBsYXlvdXRTdHlsZXMgZnJvbSAnLi9MYXlvdXQuY3NzJztcblxudHlwZSBQcm9wcyA9IHt8XG4gIEl0ZW06ICh7IGlkeDogbnVtYmVyIH0pID0+IFJlYWN0Lk5vZGUsXG4gIGxheW91dDogQXJyYXk8e3xcbiAgICB0b3A6IG51bWJlcixcbiAgICBsZWZ0OiBudW1iZXIsXG4gICAgd2lkdGg6IG51bWJlcixcbiAgICBoZWlnaHQ6IG51bWJlcixcbiAgfH0+LFxuICB2aWV3cG9ydFRvcD86IG51bWJlcixcbiAgdmlld3BvcnRMZWZ0PzogbnVtYmVyLFxuICB2aWV3cG9ydFdpZHRoPzogbnVtYmVyLFxuICB2aWV3cG9ydEhlaWdodD86IG51bWJlcixcbnx9O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb2xsZWN0aW9uIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudDxQcm9wcywgdm9pZD4ge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9mb3JiaWQtcHJvcC10eXBlc1xuICAgIEl0ZW06IFByb3BUeXBlcy5hbnksXG4gICAgbGF5b3V0OiBQcm9wVHlwZXMuYXJyYXlPZihcbiAgICAgIFByb3BUeXBlcy5leGFjdCh7XG4gICAgICAgIHRvcDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICAgICAgICBsZWZ0OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gICAgICAgIHdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gICAgICAgIGhlaWdodDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICAgICAgfSkuaXNSZXF1aXJlZFxuICAgICksXG4gICAgdmlld3BvcnRIZWlnaHQ6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgdmlld3BvcnRMZWZ0OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIHZpZXdwb3J0VG9wOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIHZpZXdwb3J0V2lkdGg6IFByb3BUeXBlcy5udW1iZXIsXG4gIH07XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICBsYXlvdXQ6IFtdLFxuICAgIHZpZXdwb3J0TGVmdDogMCxcbiAgICB2aWV3cG9ydFRvcDogMCxcbiAgfTtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBJdGVtLCBsYXlvdXQsIHZpZXdwb3J0VG9wID0gMCwgdmlld3BvcnRMZWZ0ID0gMCB9ID0gdGhpcy5wcm9wcztcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgZnVsbCBkaW1lbnNpb25zIG9mIHRoZSBpdGVtIGxheWVyXG4gICAgY29uc3Qgd2lkdGggPSBNYXRoLm1heCguLi5sYXlvdXQubWFwKGl0ZW0gPT4gaXRlbS5sZWZ0ICsgaXRlbS53aWR0aCkpO1xuICAgIGNvbnN0IGhlaWdodCA9IE1hdGgubWF4KC4uLmxheW91dC5tYXAoaXRlbSA9PiBpdGVtLnRvcCArIGl0ZW0uaGVpZ2h0KSk7XG5cbiAgICAvLyBEZWZhdWx0IHRoZSB2aWV3cG9ydCB0byBiZWluZyB0aGUgZnVsbCB3aWR0aCBvZiB0aGUgY29udGVudCBsYXllclxuICAgIGNvbnN0IHsgdmlld3BvcnRXaWR0aCA9IHdpZHRoLCB2aWV3cG9ydEhlaWdodCA9IGhlaWdodCB9ID0gdGhpcy5wcm9wcztcblxuICAgIC8vIENhbGN1bGF0ZXMgd2hpY2ggaXRlbXMgZnJvbSB0aGUgaXRlbSBsYXllciB0byByZW5kZXIgaW4gdGhlIHZpZXdwb3J0XG4gICAgLy8gbGF5ZXIuXG4gICAgY29uc3QgaXRlbXMgPSBsYXlvdXQucmVkdWNlKChhY2MsIHBvc2l0aW9uLCBpZHgpID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgcG9zaXRpb24udG9wICsgcG9zaXRpb24uaGVpZ2h0ID4gdmlld3BvcnRUb3AgJiZcbiAgICAgICAgcG9zaXRpb24udG9wIDwgdmlld3BvcnRIZWlnaHQgKyB2aWV3cG9ydFRvcCAmJlxuICAgICAgICBwb3NpdGlvbi5sZWZ0IDwgdmlld3BvcnRXaWR0aCArIHZpZXdwb3J0TGVmdCAmJlxuICAgICAgICBwb3NpdGlvbi5sZWZ0ICsgcG9zaXRpb24ud2lkdGggPiB2aWV3cG9ydExlZnRcbiAgICAgICkge1xuICAgICAgICBhY2MucHVzaCh7IGlkeCwgLi4ucG9zaXRpb24gfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT17bGF5b3V0U3R5bGVzLnJlbGF0aXZlfSBzdHlsZT17eyB3aWR0aCwgaGVpZ2h0IH19PlxuICAgICAgICB7aXRlbXMubWFwKCh7IGlkeCwgLi4uc3R5bGUgfSkgPT4gKFxuICAgICAgICAgIDxkaXYga2V5PXtpZHh9IGNsYXNzTmFtZT17bGF5b3V0U3R5bGVzLmFic29sdXRlfSBzdHlsZT17c3R5bGV9PlxuICAgICAgICAgICAgPEl0ZW0gaWR4PXtpZHh9IC8+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICkpfVxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgQ29sbGVjdGlvbiBmcm9tICcuL0NvbGxlY3Rpb24uanMnO1xuXG50eXBlIENvbHVtbiA9IDIgfCAzIHwgNDtcblxuLypcblxuVGhpcyBmdW5jdGlvbiBqdXN0IGltcGxlbWVudHMgdGhlIGRlc2lnbiBjb25zdHJhaW50cyBmb3IgYXN5bWV0cmljYWwgY29sdW1ucyBpblxuYSB2ZXJ5IHNpbXBsZSB3YXkuIEl0J3Mgbm90IHBlcmZlY3QsIGJ1dCBpdCdzIHZlcnkgcHJlZGljdGlibGUuIElmIHlvdSBkb1xuYW55dGhpbmcsIGltcHJvdmUgaXQgc28gdGhhdCBpdCB0YWtlcyB0aGVzZSBjb25zdHJhaW50cyBhbmQgZ2VuZXJhdGVzIHRoZW1cbmZvciBuID4gNC5cblxuMSArIG4gY29sdW1uczpcbiAgZmlyc3QgY29sdW1uIGlzIDUwLzUwXG4gIGNhbid0IGhhdmUgMyBjb2x1bW5zIGluIGEgcm93IGJlIDUwLzUwXG5cbiovXG5jb25zdCBVUCA9IFswLjc1LCAwLjI1XTtcbmNvbnN0IERPV04gPSBbMC4yNSwgMC43NV07XG5jb25zdCBNSUQgPSBbMC41LCAwLjVdO1xuY29uc3QgY29sdW1uTGF5b3V0ID0gKG51bU9mQ29sdW1uczogMSB8IENvbHVtbikgPT4ge1xuICBzd2l0Y2ggKG51bU9mQ29sdW1ucykge1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBbW01JRF0sIFtVUF0sIFtET1dOXV07XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIFtbVVAsIE1JRF0sIFtET1dOLCBNSURdLCBbTUlELCBVUF0sIFtNSUQsIERPV05dXTtcbiAgICBjYXNlIDQ6XG4gICAgICByZXR1cm4gW1xuICAgICAgICBbTUlELCBVUCwgTUlELCBNSURdLFxuICAgICAgICBbTUlELCBET1dOLCBNSUQsIE1JRF0sXG4gICAgICAgIFtNSUQsIE1JRCwgVVAsIE1JRF0sXG4gICAgICAgIFtNSUQsIE1JRCwgRE9XTiwgTUlEXSxcbiAgICAgICAgW01JRCwgVVAsIE1JRCwgRE9XTl0sXG4gICAgICAgIFtNSUQsIERPV04sIE1JRCwgVVBdLFxuICAgICAgXTtcbiAgICBjYXNlIDM6XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBbXG4gICAgICAgIFtNSUQsIFVQLCBNSURdLFxuICAgICAgICBbTUlELCBET1dOLCBNSURdLFxuICAgICAgICBbTUlELCBNSUQsIFVQXSxcbiAgICAgICAgW01JRCwgTUlELCBET1dOXSxcbiAgICAgIF07XG4gIH1cbn07XG5cbmNvbnN0IHBhZGRpbmdBbGwgPSAoZ3V0dGVyLCBwb3NpdGlvbnMpID0+XG4gIHBvc2l0aW9ucy5tYXAoKHsgdG9wLCBsZWZ0LCB3aWR0aCwgaGVpZ2h0IH0pID0+ICh7XG4gICAgdG9wLFxuICAgIGxlZnQsXG4gICAgd2lkdGg6IHdpZHRoIC0gZ3V0dGVyLFxuICAgIGhlaWdodDogaGVpZ2h0IC0gZ3V0dGVyLFxuICB9KSk7XG5cbmNvbnN0IG1pbmRleCA9IGFyciA9PlxuICBhcnIucmVkdWNlKChtaW5JbmRleCwgaXRlbSwgaSkgPT4gKGl0ZW0gPCBhcnJbbWluSW5kZXhdID8gaSA6IG1pbkluZGV4KSwgMCk7XG5cbmNvbnN0IGNvbHVtbnNGb3JDb2xsYWdlV2l0aENvdmVyID0gKG51bU9mQ29sdW1uczogQ29sdW1uKSA9PlxuICBudW1PZkNvbHVtbnMgPT09IDQgPyAyIDogMTtcblxuZnVuY3Rpb24gZ2V0Q29sbGFnZUxheW91dCh7XG4gIGd1dHRlcixcbiAgY292ZXIsXG4gIGNvbHVtbnM6IG51bUNvbHMsXG4gIGhlaWdodDogaCxcbiAgd2lkdGg6IHcsXG4gIGxheW91dEtleSxcbn06IHtcbiAgZ3V0dGVyOiBudW1iZXIsXG4gIGNvdmVyOiBib29sZWFuLFxuICBjb2x1bW5zOiBDb2x1bW4sXG4gIGhlaWdodDogbnVtYmVyLFxuICB3aWR0aDogbnVtYmVyLFxuICBsYXlvdXRLZXk6IG51bWJlcixcbn0pIHtcbiAgbGV0IHBvc2l0aW9ucyA9IFtdO1xuICBjb25zdCB3aWR0aCA9IHcgKyBndXR0ZXI7XG4gIGNvbnN0IGhlaWdodCA9IGggKyBndXR0ZXI7XG5cbiAgLy8gSWYgdGhlcmUncyBhIGNvdmVyIGltYWdlLCB3ZSdsbCBhZGQgdGhhdCBsYXRlci4gSXQgc2hvdWxkIGJlIGEgbGl0dGxlXG4gIC8vIGxlc3MgdGhhbiBoYWxmIHRoZSB3aWR0aCBvZiB0aGUgY29sbGFnZS4gV2UgZG8gdGhpcyBub3cgKGFuZCBub3QgbGF0ZXJcbiAgLy8gd2hlbiB3ZSBhZGQgdGhlIGNvdmVyIGltYWdlKSBiZWNhdXNlIG9mIGBjb2x1bW5MYXlvdXRgJ3MgY29uc3RyYWludHNcbiAgLy8gbmVlZGluZyB0aGUgZXhhY3QgbnVtYmVyIG9mIGNvbHVtbnMgdGhhdCBhcmUgZGlzcGxheWVkLlxuICBjb25zdCBncmlkQ29scyA9IGNvdmVyID8gY29sdW1uc0ZvckNvbGxhZ2VXaXRoQ292ZXIobnVtQ29scykgOiBudW1Db2xzO1xuXG4gIC8vIFNlbGVjdHMgdGhlIGxheW91dCB0aGF0IHdlJ3JlIGdvaW5nIHRvIHVzZSBmb3IgdGhlIGdyaWRcbiAgY29uc3QgY29sdW1ucyA9IGNvbHVtbkxheW91dChncmlkQ29scyk7XG4gIGNvbnN0IGxheW91dElkeCA9IGxheW91dEtleSAlIGNvbHVtbnMubGVuZ3RoO1xuICBjb25zdCBsYXlvdXQgPSBjb2x1bW5zW2xheW91dElkeF07XG5cbiAgLy8gVGhpcyBkb2VzIGEgcmVhbGx5IHNpbXBsZSB2ZXJzaW9uIG9mIG91ciBtYXNvbnJ5IGxheW91dC4gV2h5IHJlcGxpY2F0ZVxuICAvLyB0aGF0IGhlcmU/IGEuKSBmZXdlciBkZXBlbmRlbmNpZXMgYW5kIGIuKSB3ZSBuZWVkIHRoZSBhbGdvcml0aG0gdG9cbiAgLy8gcm91Z2hseSBwcmVzZXJ2ZSB0aGUgb3JkZXIgb2YgdGhlIGNvbGxhZ2VzIGZyb20gd2hlbiB0aGV5IHdlcmUgb3JkZXJlZFxuICAvLyBieSBNYXNvbnJ5LlxuICBjb25zdCBjb2xIZWlnaHRzID0gbmV3IEFycmF5KGdyaWRDb2xzKS5maWxsKDApO1xuICBjb25zdCBjb2xDb3VudHMgPSBuZXcgQXJyYXkoZ3JpZENvbHMpLmZpbGwoMCk7XG5cbiAgLy8gV2UgaXRlcmF0ZSBvdmVyIGV2ZXJ5IHBvc2l0aW9uIHRoYXQgd2UgdGhpbmsgd2UgY291bGQgX3BvdGVudGlhbGx5XyBoYXZlXG4gIC8vIHNvIHRoYXQgd2UgY2FuIGZpbGwgdGhlbSB3aXRoIGVtcHR5IHNlY3Rpb25zIGlmIG5lZWQgYmUuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMiAqIGdyaWRDb2xzOyBpICs9IDEpIHtcbiAgICBjb25zdCBjb2wgPSBtaW5kZXgoY29sSGVpZ2h0cyk7XG4gICAgY29uc3QgY29sSWR4ID0gY29sQ291bnRzW2NvbF07XG4gICAgY29uc3QgaXRlbUhlaWdodCA9IGxheW91dFtjb2xdW2NvbElkeF0gKiBoZWlnaHQ7XG5cbiAgICBwb3NpdGlvbnMucHVzaCh7XG4gICAgICB0b3A6IGNvbEhlaWdodHNbY29sXSxcbiAgICAgIGxlZnQ6IGNvbCAqICh3aWR0aCAvIG51bUNvbHMpLFxuICAgICAgd2lkdGg6IHdpZHRoIC8gbnVtQ29scyxcbiAgICAgIGhlaWdodDogaXRlbUhlaWdodCxcbiAgICB9KTtcblxuICAgIGNvbEhlaWdodHNbY29sXSArPSBpdGVtSGVpZ2h0O1xuICAgIGNvbENvdW50c1tjb2xdICs9IDE7XG4gIH1cblxuICAvLyBJZiB3ZSBoYXZlIGEgY292ZXIgaW1hZ2UsIGZpZ3VyZSBvdXQgaG93IGJpZyBpdCBpcywgdGhlbiBtb3ZlIGFsbCB0aGVcbiAgLy8gZXhpc3RpbmcgY29sdW1ucyBvdmVyLlxuICBpZiAoY292ZXIpIHtcbiAgICBjb25zdCBjb3ZlckltYWdlV2lkdGggPSBNYXRoLmNlaWwobnVtQ29scyAvIDIpICogKHdpZHRoIC8gbnVtQ29scyk7XG4gICAgcG9zaXRpb25zID0gcG9zaXRpb25zLm1hcChwb3NpdGlvbiA9PiAoe1xuICAgICAgLi4ucG9zaXRpb24sXG4gICAgICBsZWZ0OiBjb3ZlckltYWdlV2lkdGggKyBwb3NpdGlvbi5sZWZ0LFxuICAgIH0pKTtcbiAgICBwb3NpdGlvbnMudW5zaGlmdCh7IHRvcDogMCwgbGVmdDogMCwgd2lkdGg6IGNvdmVySW1hZ2VXaWR0aCwgaGVpZ2h0IH0pO1xuICB9XG5cbiAgLy8gVGhpcyBhZGRzIHRoZSBzcGFjZSBiZXR3ZWVuIGFueSBpdGVtcyB0aGF0IHdlIGhhdmUuIEl0J3MgbmljZSB0byBkb1xuICAvLyB0aGlzIGFzIGEgc2VwYXJhdGUgcGFzcyBhZnRlciBldmVyeXRoaW5nIGVsc2UsIGJlY2F1c2UgdGhlIG1hdGggZWFybGllclxuICAvLyBiZWNvbWVzIGVhc2llciBhbmQgaXQncyBsZXNzIGJyaXR0bGUgdG8gY2hhbmdlLlxuICBpZiAoZ3V0dGVyKSB7XG4gICAgcG9zaXRpb25zID0gcGFkZGluZ0FsbChndXR0ZXIsIHBvc2l0aW9ucyk7XG4gIH1cblxuICByZXR1cm4gcG9zaXRpb25zO1xufVxuXG50eXBlIFByb3BzID0ge3xcbiAgY29sdW1uczogQ29sdW1uLFxuICBjb3Zlcj86IGJvb2xlYW4sXG4gIGd1dHRlcj86IG51bWJlcixcbiAgaGVpZ2h0OiBudW1iZXIsXG4gIGxheW91dEtleT86IG51bWJlcixcbiAgcmVuZGVySW1hZ2U6ICh7fFxuICAgIHdpZHRoOiBudW1iZXIsXG4gICAgaGVpZ2h0OiBudW1iZXIsXG4gICAgaW5kZXg6IG51bWJlcixcbiAgfH0pID0+IFJlYWN0Lk5vZGUsXG4gIHdpZHRoOiBudW1iZXIsXG58fTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ29sbGFnZShwcm9wczogUHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIGNvbHVtbnMsXG4gICAgY292ZXIsXG4gICAgZ3V0dGVyLFxuICAgIGhlaWdodCxcbiAgICBsYXlvdXRLZXksXG4gICAgcmVuZGVySW1hZ2UsXG4gICAgd2lkdGgsXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgcG9zaXRpb25zID0gZ2V0Q29sbGFnZUxheW91dCh7XG4gICAgY29sdW1ucyxcbiAgICBjb3ZlcjogISFjb3ZlcixcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgZ3V0dGVyOiBndXR0ZXIgfHwgMCxcbiAgICBsYXlvdXRLZXk6IGxheW91dEtleSB8fCAwLFxuICB9KTtcbiAgcmV0dXJuIChcbiAgICA8Q29sbGVjdGlvblxuICAgICAgSXRlbT17KHsgaWR4OiBpbmRleCB9KSA9PlxuICAgICAgICByZW5kZXJJbWFnZSh7XG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgd2lkdGg6IHBvc2l0aW9uc1tpbmRleF0ud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBwb3NpdGlvbnNbaW5kZXhdLmhlaWdodCxcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIGxheW91dD17cG9zaXRpb25zfVxuICAgIC8+XG4gICk7XG59XG5cbkNvbGxhZ2UucHJvcFR5cGVzID0ge1xuICBjb2x1bW5zOiBQcm9wVHlwZXMub25lT2YoWzIsIDMsIDRdKS5pc1JlcXVpcmVkLFxuICBjb3ZlcjogUHJvcFR5cGVzLmJvb2wsXG4gIGd1dHRlcjogUHJvcFR5cGVzLm51bWJlcixcbiAgaGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIGxheW91dEtleTogUHJvcFR5cGVzLm51bWJlcixcbiAgcmVuZGVySW1hZ2U6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG59O1xuIiwiLyogQGZsb3cgKi9cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9Db2x1bW5Db2x1bW4uY3NzJztcblxudHlwZSBEZXByZWNhdGVkQ29sdW1ucyA9IDEgfCAyIHwgMyB8IDQgfCA1IHwgNiB8IDcgfCA4IHwgOSB8IDEwIHwgMTEgfCAxMjtcbnR5cGUgQ29sdW1ucyA9IDAgfCAxIHwgMiB8IDMgfCA0IHwgNSB8IDYgfCA3IHwgOCB8IDkgfCAxMCB8IDExIHwgMTI7XG5cbnR5cGUgQ29sdW1uUHJvcHMgPVxuICB8IHt8XG4gICAgICBjaGlsZHJlbj86IFJlYWN0Lk5vZGUsXG4gICAgICBzcGFuOiBDb2x1bW5zLFxuICAgICAgc21TcGFuPzogQ29sdW1ucyxcbiAgICAgIG1kU3Bhbj86IENvbHVtbnMsXG4gICAgICBsZ1NwYW4/OiBDb2x1bW5zLFxuICAgIHx9XG4gIHwge3xcbiAgICAgIGNoaWxkcmVuPzogUmVhY3QuTm9kZSxcbiAgICAgIHhzPzogRGVwcmVjYXRlZENvbHVtbnMsXG4gICAgICBzbT86IERlcHJlY2F0ZWRDb2x1bW5zLFxuICAgICAgbWQ/OiBEZXByZWNhdGVkQ29sdW1ucyxcbiAgICAgIGxnPzogRGVwcmVjYXRlZENvbHVtbnMsXG4gICAgfH07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENvbHVtbihwcm9wczogQ29sdW1uUHJvcHMpIHtcbiAgY29uc3QgeyBjaGlsZHJlbiB9ID0gcHJvcHM7XG4gIGNvbnN0IGNzID0gY2xhc3NuYW1lcyhcbiAgICAocHJvcHMueHMgIT09IHVuZGVmaW5lZCB8fFxuICAgICAgcHJvcHMuc20gIT09IHVuZGVmaW5lZCB8fFxuICAgICAgcHJvcHMubWQgIT09IHVuZGVmaW5lZCB8fFxuICAgICAgcHJvcHMubGcgIT09IHVuZGVmaW5lZCkgJiZcbiAgICAgIHN0eWxlcy5kZXByZWNhdGVkQ29sdW1uLFxuICAgIHByb3BzLnhzICYmIHN0eWxlc1tgeHNDb2wke3Byb3BzLnhzfWBdLFxuICAgIHByb3BzLnNtICYmIHN0eWxlc1tgc21Db2wke3Byb3BzLnNtfWBdLFxuICAgIHByb3BzLm1kICYmIHN0eWxlc1tgbWRDb2wke3Byb3BzLm1kfWBdLFxuICAgIHByb3BzLmxnICYmIHN0eWxlc1tgbGdDb2wke3Byb3BzLmxnfWBdLFxuICAgIHByb3BzLnNwYW4gIT0gbnVsbCAmJiBzdHlsZXNbYHhzQ29sJHtwcm9wcy5zcGFufWBdLFxuICAgIHByb3BzLnNtU3BhbiAhPSBudWxsICYmIHN0eWxlc1tgc21Db2wke3Byb3BzLnNtU3Bhbn1gXSxcbiAgICBwcm9wcy5tZFNwYW4gIT0gbnVsbCAmJiBzdHlsZXNbYG1kQ29sJHtwcm9wcy5tZFNwYW59YF0sXG4gICAgcHJvcHMubGdTcGFuICE9IG51bGwgJiYgc3R5bGVzW2BsZ0NvbCR7cHJvcHMubGdTcGFufWBdXG4gICk7XG4gIHJldHVybiA8ZGl2IGNsYXNzTmFtZT17Y3N9PntjaGlsZHJlbn08L2Rpdj47XG59XG5cbkNvbHVtbi5wcm9wVHlwZXMgPSB7XG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgeHM6IFByb3BUeXBlcy5udW1iZXIsXG4gIHNtOiBQcm9wVHlwZXMubnVtYmVyLFxuICBtZDogUHJvcFR5cGVzLm51bWJlcixcbiAgbGc6IFByb3BUeXBlcy5udW1iZXIsXG4gIHNwYW46IFByb3BUeXBlcy5udW1iZXIsXG4gIHNtU3BhbjogUHJvcFR5cGVzLm51bWJlcixcbiAgbWRTcGFuOiBQcm9wVHlwZXMubnVtYmVyLFxuICBsZ1NwYW46IFByb3BUeXBlcy5udW1iZXIsXG59O1xuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgQm94IGZyb20gJy4vQm94LmpzJztcblxudHlwZSBQcm9wcyA9IHt8XG4gIGNoaWxkcmVuPzogUmVhY3QuTm9kZSxcbnx9O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDb250YWluZXIocHJvcHM6IFByb3BzKSB7XG4gIGNvbnN0IHsgY2hpbGRyZW4gfSA9IHByb3BzO1xuICByZXR1cm4gKFxuICAgIDxCb3gganVzdGlmeUNvbnRlbnQ9XCJjZW50ZXJcIiBkaXNwbGF5PVwiZmxleFwiPlxuICAgICAgPEJveCBtYXhXaWR0aD17ODAwfSB3aWR0aD1cIjEwMCVcIj5cbiAgICAgICAge2NoaWxkcmVufVxuICAgICAgPC9Cb3g+XG4gICAgPC9Cb3g+XG4gICk7XG59XG5cbkNvbnRhaW5lci5wcm9wVHlwZXMgPSB7XG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbn07XG4iLCIvLyBAZmxvd1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL0RpdmlkZXIuY3NzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRGl2aWRlcigpIHtcbiAgcmV0dXJuIDxociBjbGFzc05hbWU9e3N0eWxlcy5kaXZpZGVyfSAvPjtcbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG50eXBlIFByb3BzID0ge1xuICBkaXJlY3Rpb24/OiA/J3VwJyB8ICdyaWdodCcgfCAnZG93bicgfCAnbGVmdCcsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDYXJldChwcm9wczogUHJvcHMpIHtcbiAgY29uc3QgeyBkaXJlY3Rpb24gfSA9IHByb3BzO1xuICBsZXQgcGF0aDtcbiAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICBjYXNlICd1cCc6XG4gICAgICBwYXRoID0gJ00wIDAgTDEyIDEyIEwyNCAwJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgIHBhdGggPSAnTTI0IDAgTDEyIDEyIEwyNCAyNCc7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdkb3duJzpcbiAgICAgIHBhdGggPSAnTTAgMjQgTDEyIDEyIEwyNCAyNCc7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdsZWZ0JzpcbiAgICAgIHBhdGggPSAnTTAgMCBMMTIgMTIgTDAgMjQnO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPHN2ZyB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIj5cbiAgICAgIDxwYXRoIGQ9e3BhdGh9IC8+XG4gICAgPC9zdmc+XG4gICk7XG59XG5cbkNhcmV0LnByb3BUeXBlcyA9IHtcbiAgZGlyZWN0aW9uOiBQcm9wVHlwZXMub25lT2YoWyd1cCcsICdyaWdodCcsICdkb3duJywgJ2xlZnQnXSksXG59O1xuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBDYXJldCBmcm9tICcuL0NhcmV0LmpzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9Db250ZW50cy5jc3MnO1xuaW1wb3J0IGNvbG9ycyBmcm9tICcuL0NvbG9ycy5jc3MnO1xuXG4vKiBOZWVkZWQgdW50aWwgdGhpcyBGbG93IGlzc3VlIGlzIGZpeGVkOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMzgwICovXG4vKiBlc2xpbnQgcXVvdGUtcHJvcHM6IDAgKi9cbmNvbnN0IFNQQUNFU19JTkRFWF9NQVAgPSB7XG4gICcwJzogJ3VwJyxcbiAgJzEnOiAncmlnaHQnLFxuICAnMic6ICdkb3duJyxcbiAgJzMnOiAnbGVmdCcsXG59O1xuXG5jb25zdCBESVJfSU5ERVhfTUFQID0ge1xuICB1cDogMCxcbiAgcmlnaHQ6IDEsXG4gIGRvd246IDIsXG4gIGxlZnQ6IDMsXG59O1xuXG5jb25zdCBNQVJHSU4gPSAyNDtcbmV4cG9ydCBjb25zdCBDQVJFVF9IRUlHSFQgPSAyNDtcbmNvbnN0IENBUkVUX09GRlNFVF9GUk9NX1NJREUgPSAyNDtcbmV4cG9ydCBjb25zdCBCT1JERVJfUkFESVVTID0gODtcblxudHlwZSBNYWluRGlyID0gPygndXAnIHwgJ3JpZ2h0JyB8ICdkb3duJyB8ICdsZWZ0Jyk7XG50eXBlIFN1YkRpciA9ICd1cCcgfCAncmlnaHQnIHwgJ2Rvd24nIHwgJ2xlZnQnIHwgJ21pZGRsZSc7XG5cbnR5cGUgQ2xpZW50UmVjdCA9IHtcbiAgYm90dG9tOiBudW1iZXIsXG4gIGhlaWdodDogbnVtYmVyLFxuICBsZWZ0OiBudW1iZXIsXG4gIHJpZ2h0OiBudW1iZXIsXG4gIHRvcDogbnVtYmVyLFxuICB3aWR0aDogbnVtYmVyLFxufTtcblxudHlwZSBXaW5kb3cgPSB7XG4gIGhlaWdodDogbnVtYmVyLFxuICB3aWR0aDogbnVtYmVyLFxuICBzY3JvbGxZOiBudW1iZXIsXG4gIHNjcm9sbFg6IG51bWJlcixcbn07XG5cbnR5cGUgRmx5b3V0ID0geyBoZWlnaHQ6IG51bWJlciwgd2lkdGg6IG51bWJlciB9O1xuXG50eXBlIFNoaWZ0ID0geyB4OiBudW1iZXIsIHk6IG51bWJlciB9O1xuXG50eXBlIEVkZ2VTaGlmdCA9IHsgY2FyZXQ6IFNoaWZ0LCBmbHlvdXQ6IFNoaWZ0IH07XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBiZ0NvbG9yOiAnYmx1ZScgfCAnZGFya0dyYXknIHwgJ29yYW5nZScgfCAnd2hpdGUnLFxuICBjaGlsZHJlbj86IFJlYWN0Lk5vZGUsXG4gIGlkZWFsRGlyZWN0aW9uPzogJ3VwJyB8ICdyaWdodCcgfCAnZG93bicgfCAnbGVmdCcsXG4gIG9uS2V5RG93bjogKGV2ZW50OiB7IGtleUNvZGU6IG51bWJlciB9KSA9PiB2b2lkLFxuICBvblJlc2l6ZTogKCkgPT4gdm9pZCxcbiAgcG9zaXRpb25SZWxhdGl2ZVRvQW5jaG9yPzogYm9vbGVhbixcbiAgcmVsYXRpdmVPZmZzZXQ6IHtcbiAgICB4OiBudW1iZXIsXG4gICAgeTogbnVtYmVyLFxuICB9LFxuICBzaG91bGRGb2N1cz86IGJvb2xlYW4sXG4gIHRyaWdnZXJSZWN0OiBDbGllbnRSZWN0LFxuICB3aWR0aDogbnVtYmVyLFxufH07XG5cbnR5cGUgU3RhdGUgPSB7XG4gIGZseW91dE9mZnNldDoge1xuICAgIHRvcDogP251bWJlcixcbiAgICBsZWZ0OiA/bnVtYmVyLFxuICB9LFxuICBjYXJldE9mZnNldDoge1xuICAgIHRvcDogP251bWJlcixcbiAgICByaWdodDogP251bWJlcixcbiAgICBib3R0b206ID9udW1iZXIsXG4gICAgbGVmdDogP251bWJlcixcbiAgfSxcbiAgbWFpbkRpcjogP01haW5EaXIsXG59O1xuXG4vKipcbiAqIERldGVybWluZXMgdGhlIG1haW4gZGlyZWN0aW9uIHRoZSBmbHlvdXQgb3BlbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE1haW5EaXIoXG4gIGZseW91dFNpemU6IEZseW91dCxcbiAgaWRlYWxEaXJlY3Rpb246IE1haW5EaXIsXG4gIHRyaWdnZXJSZWN0OiBDbGllbnRSZWN0LFxuICB3aW5kb3dTaXplOiBXaW5kb3dcbikge1xuICAvLyBDYWxjdWxhdGVzIHRoZSBhdmFpbGFibGUgc3BhY2UgaWYgd2Ugd2VyZSB0byBwbGFjZSB0aGUgZmx5b3V0IGluIHRoZSA0IG1haW4gZGlyZWN0aW9uc1xuICAvLyB0byBkZXRlcm1pbmUgd2hpY2ggJ3F1YWRyYW50JyB0byBwb3NpdGlvbiB0aGUgZmx5b3V0IGluc2lkZSBvZlxuICBsZXQgdXAgPSB0cmlnZ2VyUmVjdC50b3AgLSBmbHlvdXRTaXplLmhlaWdodCAtIENBUkVUX0hFSUdIVDtcbiAgbGV0IHJpZ2h0ID1cbiAgICB3aW5kb3dTaXplLndpZHRoIC0gZmx5b3V0U2l6ZS53aWR0aCAtIENBUkVUX0hFSUdIVCAtIHRyaWdnZXJSZWN0LnJpZ2h0O1xuICBsZXQgZG93biA9XG4gICAgd2luZG93U2l6ZS5oZWlnaHQgLSBmbHlvdXRTaXplLmhlaWdodCAtIENBUkVUX0hFSUdIVCAtIHRyaWdnZXJSZWN0LmJvdHRvbTtcbiAgbGV0IGxlZnQgPSB0cmlnZ2VyUmVjdC5sZWZ0IC0gZmx5b3V0U2l6ZS53aWR0aCAtIENBUkVUX0hFSUdIVDtcblxuICAvLyBvdmVycmlkZXMgYXZhaWxhYmxlIHNwYWNlIHdoZW4gdGhlIHRyaWdnZXIgaXMgY2xvc2UgdG8gdGhlIGVkZ2Ugb2YgdGhlIHNjcmVlblxuICAvLyB0cmlnZ2VyIGlzIHRvbyBjbG9zZSB0byB0b3AvYm90dG9tIG9mIHNjcmVlbiBmb3IgbGVmdCAmIHJpZ2h0IGZseW91dHNcbiAgaWYgKFxuICAgIHRyaWdnZXJSZWN0LnRvcCA8IEJPUkRFUl9SQURJVVMgfHxcbiAgICB3aW5kb3dTaXplLmhlaWdodCAtIHRyaWdnZXJSZWN0LmJvdHRvbSA8IEJPUkRFUl9SQURJVVNcbiAgKSB7XG4gICAgbGVmdCA9IDA7XG4gICAgcmlnaHQgPSAwO1xuICB9XG5cbiAgLy8gdHJpZ2dlciBpcyB0b28gY2xvc2UgdG8gdGhlIGxlZnQvcmlnaHQgb2Ygc2NyZWVuIGZvciB1cCAmIGRvd24gZmx5b3V0c1xuICBpZiAoXG4gICAgdHJpZ2dlclJlY3QubGVmdCA8IEJPUkRFUl9SQURJVVMgfHxcbiAgICB3aW5kb3dTaXplLndpZHRoIC0gdHJpZ2dlclJlY3QucmlnaHQgPCBCT1JERVJfUkFESVVTXG4gICkge1xuICAgIHVwID0gMDtcbiAgICBkb3duID0gMDtcbiAgfVxuXG4gIGNvbnN0IHNwYWNlcyA9IFt1cCwgcmlnaHQsIGRvd24sIGxlZnRdO1xuXG4gIC8vIElkZW50aWZ5IGJlc3QgZGlyZWN0aW9uIG9mIGF2YWlsYWJsZSBzcGFjZXNcbiAgY29uc3QgbWF4ID0gTWF0aC5tYXgoLi4uc3BhY2VzKTtcblxuICAvLyBDaG9zZSB0aGUgbWFpbiBkaXJlY3Rpb24gZm9yIHRoZSBmbHlvdXQgYmFzZWQgb24gYXZhaWxhYmxlIHNwYWNlcyAmIHVzZXIgcHJlZmVyZW5jZVxuICBsZXQgbWFpbkRpcjtcbiAgaWYgKGlkZWFsRGlyZWN0aW9uICYmIHNwYWNlc1tESVJfSU5ERVhfTUFQW2lkZWFsRGlyZWN0aW9uXV0gPiAwKSB7XG4gICAgLy8gdXNlciBwcmVmXG4gICAgbWFpbkRpciA9IGlkZWFsRGlyZWN0aW9uO1xuICB9IGVsc2Uge1xuICAgIC8vIElmIG5vIGRpcmVjdGlvbiBwcmVmLCBjaG9zZSB0aGUgZGlyZWN0aW9uIGluIHdoaWNoIHRoZXJlIGlzIHRoZSBtb3N0IHNwYWNlIGF2YWlsYWJsZVxuICAgIG1haW5EaXIgPSBTUEFDRVNfSU5ERVhfTUFQW3NwYWNlcy5pbmRleE9mKG1heCldO1xuICB9XG4gIHJldHVybiBtYWluRGlyO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgdGhlIHN1YiBkaXJlY3Rpb24gb2YgaG93IHRoZSBmbHlvdXQgaXMgcG9zaXRpb25lZCB3aXRoaW4gdGhlIG1haW4gZGlyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTdWJEaXIoXG4gIGZseW91dFNpemU6IEZseW91dCxcbiAgbWFpbkRpcjogTWFpbkRpcixcbiAgdHJpZ2dlclJlY3Q6IENsaWVudFJlY3QsXG4gIHdpbmRvd1NpemU6IFdpbmRvd1xuKSB7XG4gIC8vIE5vdyB0aGF0IHdlIGhhdmUgdGhlIG1haW4gZGlyZWN0aW9uLCBjaG9zZSBmcm9tIDMgY2FyZXQgcGxhY2VtZW50cyBmb3IgdGhhdCBkaXJlY3Rpb25cbiAgbGV0IG9mZnNldDtcbiAgbGV0IHRyaWdnZXJNaWQ7XG4gIGxldCB3aW5kb3dTcGFjZUF2YWlsYWJsZTtcblxuICBpZiAobWFpbkRpciA9PT0gJ3JpZ2h0JyB8fCBtYWluRGlyID09PSAnbGVmdCcpIHtcbiAgICBvZmZzZXQgPSBmbHlvdXRTaXplLmhlaWdodCAvIDI7XG4gICAgdHJpZ2dlck1pZCA9IHRyaWdnZXJSZWN0LnRvcCArICh0cmlnZ2VyUmVjdC5ib3R0b20gLSB0cmlnZ2VyUmVjdC50b3ApIC8gMjtcbiAgICB3aW5kb3dTcGFjZUF2YWlsYWJsZSA9IHdpbmRvd1NpemUuaGVpZ2h0O1xuICB9IGVsc2Uge1xuICAgIC8vIChtYWluRGlyID09PSAndXAnIHx8IG1haW5EaXIgPT09ICdkb3duJylcbiAgICBvZmZzZXQgPSBmbHlvdXRTaXplLndpZHRoIC8gMjtcbiAgICB0cmlnZ2VyTWlkID0gdHJpZ2dlclJlY3QubGVmdCArICh0cmlnZ2VyUmVjdC5yaWdodCAtIHRyaWdnZXJSZWN0LmxlZnQpIC8gMjtcbiAgICB3aW5kb3dTcGFjZUF2YWlsYWJsZSA9IHdpbmRvd1NpemUud2lkdGg7XG4gIH1cblxuICBjb25zdCBhYm92ZU9yTGVmdCA9IHRyaWdnZXJNaWQgLSBvZmZzZXQgLSBNQVJHSU47XG4gIGNvbnN0IGJlbG93T3JSaWdodCA9IHdpbmRvd1NwYWNlQXZhaWxhYmxlIC0gdHJpZ2dlck1pZCAtIG9mZnNldCAtIE1BUkdJTjtcbiAgbGV0IHN1YkRpcjtcbiAgaWYgKGFib3ZlT3JMZWZ0ID4gMCAmJiBiZWxvd09yUmlnaHQgPiAwKSB7XG4gICAgLy8gY2FyZXQgc2hvdWxkIGdvIGluIG1pZGRsZSBiL2MgaXQgY2FuXG4gICAgc3ViRGlyID0gJ21pZGRsZSc7XG4gIH0gZWxzZSBpZiAoYmVsb3dPclJpZ2h0ID4gMCkge1xuICAgIC8vIGNhcmV0IHNob3VsZCBnbyBhdCB0b3AgZm9yIGxlZnQvcmlnaHQgYW5kIGxlZnQgZm9yIHVwL2Rvd25cbiAgICBzdWJEaXIgPSBtYWluRGlyID09PSAnbGVmdCcgfHwgbWFpbkRpciA9PT0gJ3JpZ2h0JyA/ICd1cCcgOiAnbGVmdCc7XG4gIH0gZWxzZSB7XG4gICAgLy8gY2FyZXQgc2hvdWxkIGdvIGF0IGJvdHRvbSBmb3IgbGVmdC9yaWdodCBhbmQgcmlnaHQgZm9yIHVwL2Rvd25cbiAgICBzdWJEaXIgPSBtYWluRGlyID09PSAnbGVmdCcgfHwgbWFpbkRpciA9PT0gJ3JpZ2h0JyA/ICdkb3duJyA6ICdyaWdodCc7XG4gIH1cbiAgcmV0dXJuIHN1YkRpcjtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBhbW91bnQgdGhlIGZseW91dCAmIGNhcmV0IG5lZWQgdG8gc2hpZnQgb3ZlciB0byBhbGlnbiB3aXRoIGRlc2lnbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGNFZGdlU2hpZnRzKFxuICBzdWJEaXI6IFN1YkRpcixcbiAgdHJpZ2dlclJlY3Q6IENsaWVudFJlY3QsXG4gIHdpbmRvd1NpemU6IFdpbmRvd1xuKSB7XG4gIC8vIFRhcmdldCB2YWx1ZXMgZm9yIGZseW91dCBhbmQgY2FyZXQgc2hpZnRzXG4gIGxldCBmbHlvdXRWZXJ0aWNhbFNoaWZ0ID1cbiAgICBDQVJFVF9PRkZTRVRfRlJPTV9TSURFIC0gKHRyaWdnZXJSZWN0LmhlaWdodCAtIENBUkVUX0hFSUdIVCkgLyAyO1xuICBsZXQgZmx5b3V0SG9yaXpvbnRhbFNoaWZ0ID1cbiAgICBDQVJFVF9PRkZTRVRfRlJPTV9TSURFIC0gKHRyaWdnZXJSZWN0LndpZHRoIC0gQ0FSRVRfSEVJR0hUKSAvIDI7XG4gIGxldCBjYXJldFZlcnRpY2FsU2hpZnQgPSBDQVJFVF9IRUlHSFQ7XG4gIGxldCBjYXJldEhvcml6b250YWxTaGlmdCA9IENBUkVUX0hFSUdIVDtcblxuICAvLyBDb3ZlcnMgZWRnZSBjYXNlIHdoZXJlIHRyaWdnZXIgaXMgaW4gYSBjb3JuZXIgYW5kIHdlIG5lZWQgdG8gYWRqdXN0IHRoZSBvZmZzZXQgb2YgdGhlIGNhcmV0XG4gIC8vIHRvIHNvbWV0aGluZyBzbWFsbGVyIHRoYW4gbm9ybWFsIGluIG9yZGVyXG4gIGNvbnN0IGlzQ2xvc2VWZXJ0aWNhbGx5ID1cbiAgICB0cmlnZ2VyUmVjdC50b3AgLSBmbHlvdXRWZXJ0aWNhbFNoaWZ0IDwgMCB8fFxuICAgIHRyaWdnZXJSZWN0LmJvdHRvbSArIGZseW91dFZlcnRpY2FsU2hpZnQgPiB3aW5kb3dTaXplLmhlaWdodDtcbiAgY29uc3QgaXNDbG9zZUhvcml6b250YWxseSA9XG4gICAgdHJpZ2dlclJlY3QubGVmdCAtIGZseW91dEhvcml6b250YWxTaGlmdCA8IDAgfHxcbiAgICB0cmlnZ2VyUmVjdC5yaWdodCArIGZseW91dEhvcml6b250YWxTaGlmdCA+IHdpbmRvd1NpemUud2lkdGg7XG4gIGlmIChpc0Nsb3NlVmVydGljYWxseSkge1xuICAgIGZseW91dFZlcnRpY2FsU2hpZnQgPVxuICAgICAgQk9SREVSX1JBRElVUyAtICh0cmlnZ2VyUmVjdC5oZWlnaHQgLSBDQVJFVF9IRUlHSFQpIC8gMjtcbiAgICBjYXJldFZlcnRpY2FsU2hpZnQgPSBCT1JERVJfUkFESVVTO1xuICB9XG4gIGlmIChpc0Nsb3NlSG9yaXpvbnRhbGx5KSB7XG4gICAgZmx5b3V0SG9yaXpvbnRhbFNoaWZ0ID1cbiAgICAgIEJPUkRFUl9SQURJVVMgLSAodHJpZ2dlclJlY3Qud2lkdGggLSBDQVJFVF9IRUlHSFQpIC8gMjtcbiAgICBjYXJldEhvcml6b250YWxTaGlmdCA9IEJPUkRFUl9SQURJVVM7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGZseW91dDoge1xuICAgICAgeDogZmx5b3V0SG9yaXpvbnRhbFNoaWZ0LFxuICAgICAgeTogZmx5b3V0VmVydGljYWxTaGlmdCxcbiAgICB9LFxuICAgIGNhcmV0OiB7XG4gICAgICB4OiBjYXJldEhvcml6b250YWxTaGlmdCxcbiAgICAgIHk6IGNhcmV0VmVydGljYWxTaGlmdCxcbiAgICB9LFxuICB9O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgZmx5b3V0IGFuZCBjYXJldCBvZmZzZXRzIGZvciBzdHlsaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGp1c3RPZmZzZXRzKFxuICBiYXNlOiB7IHRvcDogbnVtYmVyLCBsZWZ0OiBudW1iZXIgfSxcbiAgZWRnZVNoaWZ0OiBFZGdlU2hpZnQsXG4gIGZseW91dFNpemU6IEZseW91dCxcbiAgbWFpbkRpcjogTWFpbkRpcixcbiAgc3ViRGlyOiBTdWJEaXIsXG4gIHRyaWdnZXJSZWN0OiBDbGllbnRSZWN0XG4pIHtcbiAgbGV0IGZseW91dExlZnQgPSBiYXNlLmxlZnQ7XG4gIGxldCBmbHlvdXRUb3AgPSBiYXNlLnRvcDtcblxuICBsZXQgY2FyZXRUb3AgPSBtYWluRGlyID09PSAnZG93bicgPyAtQ0FSRVRfSEVJR0hUIDogbnVsbDtcbiAgbGV0IGNhcmV0UmlnaHQgPSBtYWluRGlyID09PSAnbGVmdCcgPyAtQ0FSRVRfSEVJR0hUIDogbnVsbDtcbiAgbGV0IGNhcmV0Qm90dG9tID0gbnVsbDtcbiAgbGV0IGNhcmV0TGVmdCA9IG1haW5EaXIgPT09ICdyaWdodCcgPyAtQ0FSRVRfSEVJR0hUIDogbnVsbDtcblxuICBpZiAoc3ViRGlyID09PSAndXAnKSB7XG4gICAgZmx5b3V0VG9wID0gYmFzZS50b3AgLSBlZGdlU2hpZnQuZmx5b3V0Lnk7XG4gICAgY2FyZXRUb3AgPSBlZGdlU2hpZnQuY2FyZXQueTtcbiAgfSBlbHNlIGlmIChzdWJEaXIgPT09ICdkb3duJykge1xuICAgIGZseW91dFRvcCA9XG4gICAgICBiYXNlLnRvcCAtIGZseW91dFNpemUuaGVpZ2h0ICsgdHJpZ2dlclJlY3QuaGVpZ2h0ICsgZWRnZVNoaWZ0LmZseW91dC55O1xuICAgIGNhcmV0Qm90dG9tID0gZWRnZVNoaWZ0LmNhcmV0Lnk7XG4gIH0gZWxzZSBpZiAoc3ViRGlyID09PSAnbGVmdCcpIHtcbiAgICBmbHlvdXRMZWZ0ID0gYmFzZS5sZWZ0IC0gZWRnZVNoaWZ0LmZseW91dC54O1xuICAgIGNhcmV0TGVmdCA9IGVkZ2VTaGlmdC5jYXJldC54O1xuICB9IGVsc2UgaWYgKHN1YkRpciA9PT0gJ3JpZ2h0Jykge1xuICAgIGZseW91dExlZnQgPVxuICAgICAgYmFzZS5sZWZ0IC0gZmx5b3V0U2l6ZS53aWR0aCArIHRyaWdnZXJSZWN0LndpZHRoICsgZWRnZVNoaWZ0LmZseW91dC54O1xuICAgIGNhcmV0UmlnaHQgPSBlZGdlU2hpZnQuY2FyZXQueDtcbiAgfSBlbHNlIGlmIChzdWJEaXIgPT09ICdtaWRkbGUnKSB7XG4gICAgaWYgKG1haW5EaXIgPT09ICdsZWZ0JyB8fCBtYWluRGlyID09PSAncmlnaHQnKSB7XG4gICAgICBjb25zdCB0cmlnZ2VyTWlkID0gZmx5b3V0VG9wICsgdHJpZ2dlclJlY3QuaGVpZ2h0IC8gMjtcbiAgICAgIGZseW91dFRvcCA9IHRyaWdnZXJNaWQgLSBmbHlvdXRTaXplLmhlaWdodCAvIDI7XG4gICAgICBjYXJldFRvcCA9IChmbHlvdXRTaXplLmhlaWdodCAtIENBUkVUX0hFSUdIVCkgLyAyO1xuICAgIH1cbiAgICBpZiAobWFpbkRpciA9PT0gJ3VwJyB8fCBtYWluRGlyID09PSAnZG93bicpIHtcbiAgICAgIGNvbnN0IHRyaWdnZXJNaWQgPSBmbHlvdXRMZWZ0ICsgdHJpZ2dlclJlY3Qud2lkdGggLyAyO1xuICAgICAgZmx5b3V0TGVmdCA9IHRyaWdnZXJNaWQgLSBmbHlvdXRTaXplLndpZHRoIC8gMjtcbiAgICAgIGNhcmV0TGVmdCA9IChmbHlvdXRTaXplLndpZHRoIC0gQ0FSRVRfSEVJR0hUKSAvIDI7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBmbHlvdXRPZmZzZXQ6IHtcbiAgICAgIHRvcDogZmx5b3V0VG9wLFxuICAgICAgbGVmdDogZmx5b3V0TGVmdCxcbiAgICB9LFxuICAgIGNhcmV0T2Zmc2V0OiB7XG4gICAgICB0b3A6IGNhcmV0VG9wLFxuICAgICAgcmlnaHQ6IGNhcmV0UmlnaHQsXG4gICAgICBib3R0b206IGNhcmV0Qm90dG9tLFxuICAgICAgbGVmdDogY2FyZXRMZWZ0LFxuICAgIH0sXG4gIH07XG59XG5cbi8qIENhbGN1bGF0ZXMgYmFzZWxpbmUgdG9wIGFuZCBsZWZ0IG9mZnNldCBmb3IgZmx5b3V0ICovXG5leHBvcnQgZnVuY3Rpb24gYmFzZU9mZnNldHMoXG4gIHJlbGF0aXZlT2Zmc2V0OiB7IHg6IG51bWJlciwgeTogbnVtYmVyIH0sXG4gIGZseW91dFNpemU6IEZseW91dCxcbiAgbWFpbkRpcjogTWFpbkRpcixcbiAgdHJpZ2dlclJlY3Q6IENsaWVudFJlY3QsXG4gIHdpbmRvd1NpemU6IFdpbmRvd1xuKSB7XG4gIGNvbnN0IEhBTEZfQ0FSRVQgPSBDQVJFVF9IRUlHSFQgLyAyO1xuICAvLyBUT1AgT0ZGU0VUXG4gIGxldCB0b3A7XG4gIGlmIChtYWluRGlyID09PSAnZG93bicpIHtcbiAgICB0b3AgPSB3aW5kb3dTaXplLnNjcm9sbFkgKyB0cmlnZ2VyUmVjdC5ib3R0b20gKyBIQUxGX0NBUkVUO1xuICB9IGVsc2UgaWYgKG1haW5EaXIgPT09ICd1cCcpIHtcbiAgICB0b3AgPVxuICAgICAgd2luZG93U2l6ZS5zY3JvbGxZICsgKHRyaWdnZXJSZWN0LnRvcCAtIGZseW91dFNpemUuaGVpZ2h0IC0gSEFMRl9DQVJFVCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbGVmdCBhbmQgcmlnaHRcbiAgICB0b3AgPSB3aW5kb3dTaXplLnNjcm9sbFkgKyB0cmlnZ2VyUmVjdC50b3A7XG4gIH1cblxuICAvLyBMRUZUIE9GRlNFVFxuICBsZXQgbGVmdDtcbiAgaWYgKG1haW5EaXIgPT09ICdsZWZ0Jykge1xuICAgIGxlZnQgPVxuICAgICAgd2luZG93U2l6ZS5zY3JvbGxYICsgKHRyaWdnZXJSZWN0LmxlZnQgLSBmbHlvdXRTaXplLndpZHRoIC0gSEFMRl9DQVJFVCk7XG4gIH0gZWxzZSBpZiAobWFpbkRpciA9PT0gJ3JpZ2h0Jykge1xuICAgIGxlZnQgPSB3aW5kb3dTaXplLnNjcm9sbFggKyB0cmlnZ2VyUmVjdC5yaWdodCArIEhBTEZfQ0FSRVQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gZG93biBhbmQgdXBcbiAgICBsZWZ0ID0gd2luZG93U2l6ZS5zY3JvbGxYICsgdHJpZ2dlclJlY3QubGVmdDtcbiAgfVxuXG4gIC8vIEFkanVzdHMgZm9yIHRoZSByZWxhdGl2ZSBwYXJlbnQgY29udGFpbmVyXG4gIHRvcCAtPSByZWxhdGl2ZU9mZnNldC55O1xuICBsZWZ0IC09IHJlbGF0aXZlT2Zmc2V0Lng7XG4gIHJldHVybiB7IHRvcCwgbGVmdCB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb250ZW50cyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxQcm9wcywgU3RhdGU+IHtcbiAgc3RhdGU6IFN0YXRlID0ge1xuICAgIGZseW91dE9mZnNldDoge1xuICAgICAgdG9wOiB1bmRlZmluZWQsXG4gICAgICByaWdodDogdW5kZWZpbmVkLFxuICAgICAgYm90dG9tOiB1bmRlZmluZWQsXG4gICAgICBsZWZ0OiB1bmRlZmluZWQsXG4gICAgfSxcbiAgICBjYXJldE9mZnNldDoge1xuICAgICAgdG9wOiB1bmRlZmluZWQsXG4gICAgICByaWdodDogdW5kZWZpbmVkLFxuICAgICAgYm90dG9tOiB1bmRlZmluZWQsXG4gICAgICBsZWZ0OiB1bmRlZmluZWQsXG4gICAgfSxcbiAgICBtYWluRGlyOiBudWxsLFxuICB9O1xuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMuc2V0Rmx5b3V0UG9zaXRpb24odGhpcy5wcm9wcyk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5wcm9wcy5zaG91bGRGb2N1cyAmJiB0aGlzLmZseW91dCkge1xuICAgICAgICB0aGlzLmZseW91dC5mb2N1cygpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnByb3BzLm9uUmVzaXplKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMucHJvcHMub25LZXlEb3duKTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzOiBQcm9wcykge1xuICAgIHRoaXMuc2V0Rmx5b3V0UG9zaXRpb24obmV4dFByb3BzKTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnByb3BzLm9uUmVzaXplKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMucHJvcHMub25LZXlEb3duKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRoZSBtYWluIGRpcmVjaXRvbiwgc3ViIGRpcmVjdGlvbiwgYW5kIGNvcnJlc3BvbmRpbmcgb2Zmc2V0cyBuZWVkZWRcbiAgICogdG8gY29ycmVjdGx5IHBvc2l0aW9uIHRoZSBvZmZzZXRcbiAgICovXG4gIHNldEZseW91dFBvc2l0aW9uID0gKHByb3BzOiBQcm9wcykgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlbGF0aXZlT2Zmc2V0LFxuICAgICAgaWRlYWxEaXJlY3Rpb24sXG4gICAgICBwb3NpdGlvblJlbGF0aXZlVG9BbmNob3IsXG4gICAgICB0cmlnZ2VyUmVjdCxcbiAgICAgIHdpZHRoLFxuICAgIH0gPSBwcm9wcztcblxuICAgIC8vIFNjcm9sbCBub3QgbmVlZGVkIGZvciByZWxhdGl2ZSBlbGVtZW50c1xuICAgIC8vIFdlIGNhbid0IHVzZSB3aW5kb3cuc2Nyb2xsWCAvIHdpbmRvdy5zY3JvbGxZIHNpbmNlIGl0J3Mgbm90IHN1cHBvcnRlZCBieSBJRTExXG4gICAgY29uc3Qgc2Nyb2xsWCA9IHBvc2l0aW9uUmVsYXRpdmVUb0FuY2hvclxuICAgICAgPyAwXG4gICAgICA6IHdpbmRvdy5wYWdlWE9mZnNldCB8fFxuICAgICAgICAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0KSB8fFxuICAgICAgICAwO1xuICAgIGNvbnN0IHNjcm9sbFkgPSBwb3NpdGlvblJlbGF0aXZlVG9BbmNob3JcbiAgICAgID8gMFxuICAgICAgOiB3aW5kb3cucGFnZVlPZmZzZXQgfHxcbiAgICAgICAgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wKSB8fFxuICAgICAgICAwO1xuXG4gICAgY29uc3Qgd2luZG93U2l6ZSA9IHtcbiAgICAgIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0LFxuICAgICAgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoLFxuICAgICAgc2Nyb2xsWCxcbiAgICAgIHNjcm9sbFksXG4gICAgfTtcblxuICAgIGNvbnN0IGZseW91dFNpemUgPSB7XG4gICAgICBoZWlnaHQ6IHRoaXMuZmx5b3V0ID8gdGhpcy5mbHlvdXQuY2xpZW50SGVpZ2h0IDogMCxcbiAgICAgIHdpZHRoLFxuICAgIH07XG5cbiAgICAvLyBGaXJzdCBjaG9vc2Ugb25lIG9mIDQgbWFpbiBkaXJlY3Rpb25cbiAgICBjb25zdCBtYWluRGlyID0gZ2V0TWFpbkRpcihcbiAgICAgIGZseW91dFNpemUsXG4gICAgICBpZGVhbERpcmVjdGlvbixcbiAgICAgIHRyaWdnZXJSZWN0LFxuICAgICAgd2luZG93U2l6ZVxuICAgICk7XG5cbiAgICAvLyBOb3cgdGhhdCB3ZSBoYXZlIHRoZSBtYWluIGRpcmVjdGlvbiwgY2hvc2UgZnJvbSAzIGNhcmV0IHBsYWNlbWVudHMgZm9yIHRoYXQgZGlyZWN0aW9uXG4gICAgY29uc3Qgc3ViRGlyID0gZ2V0U3ViRGlyKGZseW91dFNpemUsIG1haW5EaXIsIHRyaWdnZXJSZWN0LCB3aW5kb3dTaXplKTtcblxuICAgIC8vIEdldHMgdGhlIGJhc2Ugb2Zmc2V0IHRoYXQgcG9zaXRpb25zIHRoZSBmbHlvdXQgYmFzZWQgb24gdGhlIG1haW4gZGlyZWN0aW9uIG9ubHlcbiAgICBjb25zdCBiYXNlID0gYmFzZU9mZnNldHMoXG4gICAgICByZWxhdGl2ZU9mZnNldCxcbiAgICAgIGZseW91dFNpemUsXG4gICAgICBtYWluRGlyLFxuICAgICAgdHJpZ2dlclJlY3QsXG4gICAgICB3aW5kb3dTaXplXG4gICAgKTtcblxuICAgIC8vIEdldHMgdGhlIGVkZ2Ugc2hpZnRzIGZvciB0aGUgZmx5b3V0XG4gICAgY29uc3QgZWRnZVNoaWZ0cyA9IGNhbGNFZGdlU2hpZnRzKHN1YkRpciwgdHJpZ2dlclJlY3QsIHdpbmRvd1NpemUpO1xuXG4gICAgLy8gQWRqdXN0cyBmb3IgdGhlIHN1YmRpcmVjdGlvbiBvZiB0aGUgY2FyZXRcbiAgICBjb25zdCB7IGZseW91dE9mZnNldCwgY2FyZXRPZmZzZXQgfSA9IGFkanVzdE9mZnNldHMoXG4gICAgICBiYXNlLFxuICAgICAgZWRnZVNoaWZ0cyxcbiAgICAgIGZseW91dFNpemUsXG4gICAgICBtYWluRGlyLFxuICAgICAgc3ViRGlyLFxuICAgICAgdHJpZ2dlclJlY3RcbiAgICApO1xuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBjYXJldE9mZnNldCxcbiAgICAgIGZseW91dE9mZnNldCxcbiAgICAgIG1haW5EaXIsXG4gICAgfSk7XG4gIH07XG5cbiAgZmx5b3V0OiA/SFRNTEVsZW1lbnQ7XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgYmdDb2xvciwgY2hpbGRyZW4sIHdpZHRoIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgLy8gTmVlZGVkIHRvIHByZXZlbnQgVUkgdGhyYXNoaW5nXG4gICAgY29uc3QgdmlzaWJpbGl0eSA9IHRoaXMuc3RhdGUubWFpbkRpciA9PT0gbnVsbCA/ICdoaWRkZW4nIDogJ3Zpc2libGUnO1xuICAgIGNvbnN0IGJhY2tncm91bmQgPSBgJHtiZ0NvbG9yfUJnYDtcbiAgICBjb25zdCBzdHJva2UgPSBiZ0NvbG9yID09PSAnd2hpdGUnID8gJyNlZmVmZWYnIDogbnVsbDtcbiAgICBjb25zdCBib3JkZXJDb2xvciA9IGJnQ29sb3IgPT09ICd3aGl0ZScgPyAnbGlnaHRHcmF5JyA6IGJnQ29sb3I7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdlxuICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy5jb250YWluZXJ9XG4gICAgICAgIHN0eWxlPXt7IHN0cm9rZSwgdmlzaWJpbGl0eSwgLi4udGhpcy5zdGF0ZS5mbHlvdXRPZmZzZXQgfX1cbiAgICAgID5cbiAgICAgICAgPGRpdlxuICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NuYW1lcyhcbiAgICAgICAgICAgIGNvbG9yc1tiYWNrZ3JvdW5kXSxcbiAgICAgICAgICAgIGNvbG9yc1tib3JkZXJDb2xvcl0sXG4gICAgICAgICAgICBzdHlsZXMuZGltZW5zaW9ucyxcbiAgICAgICAgICAgIHN0eWxlcy5jb250ZW50c1xuICAgICAgICAgICl9XG4gICAgICAgICAgcmVmPXtjID0+IHtcbiAgICAgICAgICAgIHRoaXMuZmx5b3V0ID0gYztcbiAgICAgICAgICB9fVxuICAgICAgICAgIHRhYkluZGV4PXstMX1cbiAgICAgICAgPlxuICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NuYW1lcyhzdHlsZXMuZGltZW5zaW9ucywgc3R5bGVzLmlubmVyQ29udGVudHMpfVxuICAgICAgICAgICAgc3R5bGU9e3sgd2lkdGggfX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdlxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc25hbWVzKGNvbG9yc1tiZ0NvbG9yXSwgc3R5bGVzLmNhcmV0KX1cbiAgICAgICAgICAgIHN0eWxlPXt7IC4uLnRoaXMuc3RhdGUuY2FyZXRPZmZzZXQgfX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8Q2FyZXQgZGlyZWN0aW9uPXt0aGlzLnN0YXRlLm1haW5EaXJ9IC8+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuXG4vKiBlc2xpbnQgcmVhY3Qvbm8tdW51c2VkLXByb3AtdHlwZXM6IDAgKi9cbkNvbnRlbnRzLnByb3BUeXBlcyA9IHtcbiAgYmdDb2xvcjogUHJvcFR5cGVzLm9uZU9mKFsnYmx1ZScsICdkYXJrR3JheScsICdvcmFuZ2UnLCAnd2hpdGUnXSksXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgaWRlYWxEaXJlY3Rpb246IFByb3BUeXBlcy5vbmVPZihbJ3VwJywgJ3JpZ2h0JywgJ2Rvd24nLCAnbGVmdCddKSxcbiAgb25LZXlEb3duOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBvblJlc2l6ZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgcmVsYXRpdmVPZmZzZXQ6IFByb3BUeXBlcy5leGFjdCh7IHg6IFByb3BUeXBlcy5udW1iZXIsIHk6IFByb3BUeXBlcy5udW1iZXIgfSksXG4gIHBvc2l0aW9uUmVsYXRpdmVUb0FuY2hvcjogUHJvcFR5cGVzLmJvb2wsXG4gIHNob3VsZEZvY3VzOiBQcm9wVHlwZXMuYm9vbCxcbiAgdHJpZ2dlclJlY3Q6IFByb3BUeXBlcy5leGFjdCh7XG4gICAgYm90dG9tOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIGhlaWdodDogUHJvcFR5cGVzLm51bWJlcixcbiAgICBsZWZ0OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIHJpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIHRvcDogUHJvcFR5cGVzLm51bWJlcixcbiAgICB3aWR0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgfSksXG4gIHdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLFxufTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBmaW5kRE9NTm9kZSB9IGZyb20gJ3JlYWN0LWRvbSc7XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBjaGlsZHJlbj86IFJlYWN0Lk5vZGUsXG4gIG9uQ2xpY2s/OiAoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHZvaWQsXG58fTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT3V0c2lkZUV2ZW50QmVoYXZpb3IgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8UHJvcHM+IHtcbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmhhbmRsZUNsaWNrRXZlbnQsIHtcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgfSk7XG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlQ2xpY2tFdmVudCwge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICB9KTtcbiAgfVxuXG4gIGhhbmRsZUNsaWNrRXZlbnQgPSAoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tZmluZC1kb20tbm9kZVxuICAgIGNvbnN0IGVsID0gZmluZERPTU5vZGUodGhpcyk7XG4gICAgaWYgKFxuICAgICAgIXRoaXMucHJvcHMub25DbGljayB8fFxuICAgICAgIWVsIHx8XG4gICAgICAoZXZlbnQudGFyZ2V0IGluc3RhbmNlb2YgTm9kZSAmJiBlbC5jb250YWlucyhldmVudC50YXJnZXQpKVxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnByb3BzLm9uQ2xpY2soZXZlbnQpO1xuICB9O1xuXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgfVxufVxuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgQ29udGVudHMgZnJvbSAnLi9Db250ZW50cy5qcyc7XG5pbXBvcnQgT3V0c2lkZUV2ZW50QmVoYXZpb3IgZnJvbSAnLi9iZWhhdmlvcnMvT3V0c2lkZUV2ZW50QmVoYXZpb3IuanMnO1xuXG50eXBlIFByb3BzID0ge3xcbiAgYW5jaG9yOiA/SFRNTEVsZW1lbnQsXG4gIGJnQ29sb3I6ICdibHVlJyB8ICdkYXJrR3JheScgfCAnb3JhbmdlJyB8ICd3aGl0ZScsXG4gIGNoaWxkcmVuPzogUmVhY3QuTm9kZSxcbiAgaWRlYWxEaXJlY3Rpb24/OiAndXAnIHwgJ3JpZ2h0JyB8ICdkb3duJyB8ICdsZWZ0JyxcbiAgb25EaXNtaXNzOiAoKSA9PiB2b2lkLFxuICBwb3NpdGlvblJlbGF0aXZlVG9BbmNob3I6IGJvb2xlYW4sXG4gIHNob3VsZEZvY3VzPzogYm9vbGVhbixcbiAgc2l6ZT86ICd4cycgfCAnc20nIHwgJ21kJyB8ICdsZycgfCAneGwnIHwgbnVtYmVyLFxufH07XG5cbmNvbnN0IFNJWkVfV0lEVEhfTUFQID0ge1xuICB4czogMTg1LFxuICBzbTogMjMwLFxuICBtZDogMjg0LFxuICBsZzogMzIwLFxuICB4bDogMzc1LFxufTtcblxuY29uc3QgRVNDQVBFX0tFWV9DT0RFID0gMjc7XG5cbnR5cGUgQ2xpZW50UmVjdCA9IHtcbiAgYm90dG9tOiBudW1iZXIsXG4gIGhlaWdodDogbnVtYmVyLFxuICBsZWZ0OiBudW1iZXIsXG4gIHJpZ2h0OiBudW1iZXIsXG4gIHRvcDogbnVtYmVyLFxuICB3aWR0aDogbnVtYmVyLFxufTtcblxudHlwZSBTdGF0ZSA9IHtcbiAgcmVsYXRpdmVPZmZzZXQ6IHtcbiAgICB4OiBudW1iZXIsXG4gICAgeTogbnVtYmVyLFxuICB9LFxuICB0cmlnZ2VyQm91bmRpbmdSZWN0OiBDbGllbnRSZWN0LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29udHJvbGxlciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxQcm9wcywgU3RhdGU+IHtcbiAgc3RhdGU6IFN0YXRlID0ge1xuICAgIHJlbGF0aXZlT2Zmc2V0OiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICB9LFxuICAgIHRyaWdnZXJCb3VuZGluZ1JlY3Q6IHtcbiAgICAgIGJvdHRvbTogMCxcbiAgICAgIGhlaWdodDogMCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICByaWdodDogMCxcbiAgICAgIHRvcDogMCxcbiAgICAgIHdpZHRoOiAwLFxuICAgIH0sXG4gIH07XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy51cGRhdGVUcmlnZ2VyUmVjdCh0aGlzLnByb3BzKTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzOiBQcm9wcykge1xuICAgIHRoaXMudXBkYXRlVHJpZ2dlclJlY3QobmV4dFByb3BzKTtcbiAgfVxuXG4gIGhhbmRsZUtleURvd24gPSAoZXZlbnQ6IHsga2V5Q29kZTogbnVtYmVyIH0pID0+IHtcbiAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gRVNDQVBFX0tFWV9DT0RFKSB7XG4gICAgICB0aGlzLnByb3BzLm9uRGlzbWlzcygpO1xuICAgIH1cbiAgfTtcblxuICBoYW5kbGVQYWdlQ2xpY2sgPSAoZXZlbnQ6IEV2ZW50KSA9PiB7XG4gICAgaWYgKFxuICAgICAgZXZlbnQudGFyZ2V0IGluc3RhbmNlb2YgTm9kZSAmJlxuICAgICAgdGhpcy5wcm9wcy5hbmNob3IgJiZcbiAgICAgICF0aGlzLnByb3BzLmFuY2hvci5jb250YWlucyhldmVudC50YXJnZXQpXG4gICAgKSB7XG4gICAgICB0aGlzLnByb3BzLm9uRGlzbWlzcygpO1xuICAgIH1cbiAgfTtcblxuICBoYW5kbGVSZXNpemUgPSAoKSA9PiB7XG4gICAgdGhpcy51cGRhdGVUcmlnZ2VyUmVjdCh0aGlzLnByb3BzKTtcbiAgfTtcblxuICB1cGRhdGVUcmlnZ2VyUmVjdCA9IChwcm9wczogUHJvcHMpID0+IHtcbiAgICBjb25zdCB7IGFuY2hvciwgcG9zaXRpb25SZWxhdGl2ZVRvQW5jaG9yIH0gPSBwcm9wcztcbiAgICBsZXQgdHJpZ2dlckJvdW5kaW5nUmVjdDtcbiAgICBsZXQgcmVsYXRpdmVPZmZzZXQ7XG4gICAgaWYgKGFuY2hvcikge1xuICAgICAgdHJpZ2dlckJvdW5kaW5nUmVjdCA9IGFuY2hvci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgLy8gTmVlZGVkIGZvciBjb3JyZWN0IHBvc2l0aW9uaW5nIHdpdGhpbiBDb250ZW50cy5qc1xuICAgICAgcmVsYXRpdmVPZmZzZXQgPSB7XG4gICAgICAgIHg6IHBvc2l0aW9uUmVsYXRpdmVUb0FuY2hvclxuICAgICAgICAgID8gdHJpZ2dlckJvdW5kaW5nUmVjdC5sZWZ0IC0gYW5jaG9yLm9mZnNldExlZnRcbiAgICAgICAgICA6IDAsXG4gICAgICAgIHk6IHBvc2l0aW9uUmVsYXRpdmVUb0FuY2hvclxuICAgICAgICAgID8gdHJpZ2dlckJvdW5kaW5nUmVjdC50b3AgLSBhbmNob3Iub2Zmc2V0VG9wXG4gICAgICAgICAgOiAwLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLnNldFN0YXRlKHsgcmVsYXRpdmVPZmZzZXQsIHRyaWdnZXJCb3VuZGluZ1JlY3QgfSk7XG4gIH07XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGFuY2hvcixcbiAgICAgIGJnQ29sb3IsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGlkZWFsRGlyZWN0aW9uLFxuICAgICAgcG9zaXRpb25SZWxhdGl2ZVRvQW5jaG9yLFxuICAgICAgc2hvdWxkRm9jdXMsXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKCFhbmNob3IpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzaXplID0gdGhpcy5wcm9wcy5zaXplID8gdGhpcy5wcm9wcy5zaXplIDogJ3NtJztcbiAgICBjb25zdCB3aWR0aCA9IHR5cGVvZiBzaXplID09PSAnc3RyaW5nJyA/IFNJWkVfV0lEVEhfTUFQW3NpemVdIDogc2l6ZTtcbiAgICByZXR1cm4gKFxuICAgICAgPE91dHNpZGVFdmVudEJlaGF2aW9yIG9uQ2xpY2s9e3RoaXMuaGFuZGxlUGFnZUNsaWNrfT5cbiAgICAgICAgPENvbnRlbnRzXG4gICAgICAgICAgYmdDb2xvcj17YmdDb2xvcn1cbiAgICAgICAgICBpZGVhbERpcmVjdGlvbj17aWRlYWxEaXJlY3Rpb259XG4gICAgICAgICAgb25LZXlEb3duPXt0aGlzLmhhbmRsZUtleURvd259XG4gICAgICAgICAgb25SZXNpemU9e3RoaXMuaGFuZGxlUmVzaXplfVxuICAgICAgICAgIHBvc2l0aW9uUmVsYXRpdmVUb0FuY2hvcj17cG9zaXRpb25SZWxhdGl2ZVRvQW5jaG9yfVxuICAgICAgICAgIHJlbGF0aXZlT2Zmc2V0PXt0aGlzLnN0YXRlLnJlbGF0aXZlT2Zmc2V0fVxuICAgICAgICAgIHNob3VsZEZvY3VzPXtzaG91bGRGb2N1c31cbiAgICAgICAgICB0cmlnZ2VyUmVjdD17dGhpcy5zdGF0ZS50cmlnZ2VyQm91bmRpbmdSZWN0fVxuICAgICAgICAgIHdpZHRoPXt3aWR0aH1cbiAgICAgICAgPlxuICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgPC9Db250ZW50cz5cbiAgICAgIDwvT3V0c2lkZUV2ZW50QmVoYXZpb3I+XG4gICAgKTtcbiAgfVxufVxuXG5Db250cm9sbGVyLnByb3BUeXBlcyA9IHtcbiAgYW5jaG9yOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGNvbnRhaW5zOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3Q6IFByb3BUeXBlcy5mdW5jLFxuICB9KSxcbiAgYmdDb2xvcjogUHJvcFR5cGVzLm9uZU9mKFsnYmx1ZScsICdkYXJrR3JheScsICdvcmFuZ2UnLCAnd2hpdGUnXSksXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgaWRlYWxEaXJlY3Rpb246IFByb3BUeXBlcy5vbmVPZihbJ3VwJywgJ3JpZ2h0JywgJ2Rvd24nLCAnbGVmdCddKSxcbiAgb25EaXNtaXNzOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBwb3NpdGlvblJlbGF0aXZlVG9BbmNob3I6IFByb3BUeXBlcy5ib29sLFxuICBzaG91bGRGb2N1czogUHJvcFR5cGVzLmJvb2wsXG4gIHNpemU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xuICAgIFByb3BUeXBlcy5udW1iZXIsXG4gICAgUHJvcFR5cGVzLm9uZU9mKFsneHMnLCAnc20nLCAnbWQnLCAnbGcnLCAneGwnXSksIC8vIGRlZmF1bHQ6IHNtXG4gIF0pLFxufTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IENvbnRyb2xsZXIgZnJvbSAnLi9Db250cm9sbGVyLmpzJztcblxudHlwZSBQcm9wcyA9IHt8XG4gIGFuY2hvcjogP0hUTUxFbGVtZW50LFxuICBjaGlsZHJlbj86IFJlYWN0Lk5vZGUsXG4gIGlkZWFsRGlyZWN0aW9uPzogJ3VwJyB8ICdyaWdodCcgfCAnZG93bicgfCAnbGVmdCcsXG4gIG9uRGlzbWlzczogKCkgPT4gdm9pZCxcbiAgcG9zaXRpb25SZWxhdGl2ZVRvQW5jaG9yPzogYm9vbGVhbixcbiAgY29sb3I/OiAnYmx1ZScgfCAnb3JhbmdlJyB8ICd3aGl0ZScgfCAnZGFya0dyYXknLFxuICBzaG91bGRGb2N1cz86IGJvb2xlYW4sXG4gIHNpemU/OiAneHMnIHwgJ3NtJyB8ICdtZCcgfCAnbGcnIHwgJ3hsJyB8IG51bWJlcixcbnx9O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGbHlvdXQocHJvcHM6IFByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBhbmNob3IsXG4gICAgY2hpbGRyZW4sXG4gICAgaWRlYWxEaXJlY3Rpb24sXG4gICAgb25EaXNtaXNzLFxuICAgIHBvc2l0aW9uUmVsYXRpdmVUb0FuY2hvciA9IHRydWUsXG4gICAgY29sb3IgPSAnd2hpdGUnLFxuICAgIHNob3VsZEZvY3VzID0gdHJ1ZSxcbiAgICBzaXplLFxuICB9ID0gcHJvcHM7XG5cbiAgaWYgKCFhbmNob3IpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPENvbnRyb2xsZXJcbiAgICAgIGFuY2hvcj17YW5jaG9yfVxuICAgICAgYmdDb2xvcj17Y29sb3J9XG4gICAgICBpZGVhbERpcmVjdGlvbj17aWRlYWxEaXJlY3Rpb259XG4gICAgICBvbkRpc21pc3M9e29uRGlzbWlzc31cbiAgICAgIHBvc2l0aW9uUmVsYXRpdmVUb0FuY2hvcj17cG9zaXRpb25SZWxhdGl2ZVRvQW5jaG9yfVxuICAgICAgc2hvdWxkRm9jdXM9e3Nob3VsZEZvY3VzfVxuICAgICAgc2l6ZT17c2l6ZX1cbiAgICA+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9Db250cm9sbGVyPlxuICApO1xufVxuXG5GbHlvdXQucHJvcFR5cGVzID0ge1xuICBhbmNob3I6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgY29udGFpbnM6IFByb3BUeXBlcy5mdW5jLFxuICAgIGdldEJvdW5kaW5nQ2xpZW50UmVjdDogUHJvcFR5cGVzLmZ1bmMsXG4gIH0pLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gIGlkZWFsRGlyZWN0aW9uOiBQcm9wVHlwZXMub25lT2YoWyd1cCcsICdyaWdodCcsICdkb3duJywgJ2xlZnQnXSksXG4gIG9uRGlzbWlzczogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgcG9zaXRpb25SZWxhdGl2ZVRvQW5jaG9yOiBQcm9wVHlwZXMuYm9vbCxcbiAgY29sb3I6IFByb3BUeXBlcy5vbmVPZihbJ2JsdWUnLCAnb3JhbmdlJywgJ3doaXRlJywgJ2RhcmtHcmF5J10pLFxuICBzaXplOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcbiAgICBQcm9wVHlwZXMubnVtYmVyLFxuICAgIFByb3BUeXBlcy5vbmVPZihbJ3hzJywgJ3NtJywgJ21kJywgJ2xnJywgJ3hsJ10pLCAvLyBkZWZhdWx0OiBzbVxuICBdKSxcbn07XG4iLCIvLyBAZmxvd1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9Hcm91cEF2YXRhci5jc3MnO1xuaW1wb3J0IEJveCBmcm9tICcuL0JveC5qcyc7XG5pbXBvcnQgSW1hZ2UgZnJvbSAnLi9JbWFnZS5qcyc7XG5pbXBvcnQgdHlwb2dyYXBoeSBmcm9tICcuL1R5cG9ncmFwaHkuY3NzJztcblxuZnVuY3Rpb24gemlwKGEsIGIpIHtcbiAgcmV0dXJuIGEubWFwKChpdGVtLCBpZHgpID0+IFtpdGVtLCBiW2lkeF1dKTtcbn1cblxuY29uc3QgQk9SREVSX1dJRFRIID0gMjtcblxuY29uc3QgQVZBVEFSX1NJWkVTID0ge1xuICBzbTogMjQsXG4gIG1kOiA0MCxcbiAgbGc6IDcyLFxufTtcblxudHlwZSBQcm9wcyA9IHt8XG4gIGNvbGxhYm9yYXRvcnM6IEFycmF5PHt8XG4gICAgbmFtZTogc3RyaW5nLFxuICAgIHNyYz86IHN0cmluZyxcbiAgfH0+LFxuICBvdXRsaW5lPzogYm9vbGVhbixcbiAgc2l6ZT86ICdzbScgfCAnbWQnIHwgJ2xnJyxcbnx9O1xuXG5jb25zdCBhdmF0YXJMYXlvdXQgPSAobiwgc2l6ZSkgPT4ge1xuICBzd2l0Y2ggKG4pIHtcbiAgICBjYXNlIDA6XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgeyB0b3A6IDAsIGxlZnQ6IDAsIHdpZHRoOiBzaXplLCBoZWlnaHQ6IHNpemUsIHRleHRMYXlvdXQ6ICdjZW50ZXInIH0sXG4gICAgICBdO1xuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICB3aWR0aDogYGNhbGMoNTAlIC0gJHtCT1JERVJfV0lEVEggLyAyfXB4KWAsXG4gICAgICAgICAgaGVpZ2h0OiBzaXplLFxuICAgICAgICAgIHRleHRMYXlvdXQ6ICdjZW50ZXInLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgIGxlZnQ6IGBjYWxjKDUwJSArICR7Qk9SREVSX1dJRFRIIC8gMn1weClgLFxuICAgICAgICAgIHdpZHRoOiBgY2FsYyg1MCUgLSAke0JPUkRFUl9XSURUSCAvIDJ9cHgpYCxcbiAgICAgICAgICBoZWlnaHQ6IHNpemUsXG4gICAgICAgICAgdGV4dExheW91dDogJ2NlbnRlcicsXG4gICAgICAgIH0sXG4gICAgICBdO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gW1xuICAgICAgICB7XG4gICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgd2lkdGg6IGBjYWxjKDUwJSAtICR7Qk9SREVSX1dJRFRIIC8gMn1weClgLFxuICAgICAgICAgIGhlaWdodDogc2l6ZSxcbiAgICAgICAgICB0ZXh0TGF5b3V0OiAnY2VudGVyJyxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICBsZWZ0OiBgY2FsYyg1MCUgKyAke0JPUkRFUl9XSURUSCAvIDJ9cHgpYCxcbiAgICAgICAgICB3aWR0aDogJ2NhbGMoNTAlKScsXG4gICAgICAgICAgaGVpZ2h0OiBgY2FsYyg1MCUgLSAke0JPUkRFUl9XSURUSCAvIDJ9cHgpYCxcbiAgICAgICAgICB0ZXh0TGF5b3V0OiAndG9wTGVmdCcsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICB0b3A6IGBjYWxjKDUwJSArICR7Qk9SREVSX1dJRFRIIC8gMn1weClgLFxuICAgICAgICAgIGxlZnQ6IGBjYWxjKDUwJSArICR7Qk9SREVSX1dJRFRIIC8gMn1weClgLFxuICAgICAgICAgIHdpZHRoOiAnY2FsYyg1MCUpJyxcbiAgICAgICAgICBoZWlnaHQ6IGBjYWxjKDUwJSAtICR7Qk9SREVSX1dJRFRIIC8gMn1weClgLFxuICAgICAgICAgIHRleHRMYXlvdXQ6ICdib3R0b21MZWZ0JyxcbiAgICAgICAgfSxcbiAgICAgIF07XG4gIH1cbn07XG5cbmNvbnN0IGRlZ1RvUmFkID0gZGVnID0+IGRlZyAqIChNYXRoLlBJIC8gMTgwKTtcblxuY29uc3QgRGVmYXVsdEF2YXRhciA9IChwcm9wczoge3xcbiAgc2l6ZTogc3RyaW5nIHwgbnVtYmVyLFxuICBuYW1lOiBzdHJpbmcsXG4gIHRleHRMYXlvdXQ6ICdjZW50ZXInIHwgJ3RvcExlZnQnIHwgJ2JvdHRvbUxlZnQnLFxufH0pID0+IHtcbiAgY29uc3QgeyBzaXplLCBuYW1lLCB0ZXh0TGF5b3V0IH0gPSBwcm9wcztcblxuICBjb25zdCBxdWFydGVyUGFkZGluZyA9IGBjYWxjKCR7TWF0aC5zaW4oZGVnVG9SYWQoNDUpKX0gKiAoJHtzaXplfSkgLyAyKWA7XG5cbiAgY29uc3QgaW5pdGlhbCA9IChcbiAgICA8c3ZnXG4gICAgICB3aWR0aD1cIjEwMCVcIlxuICAgICAgdmlld0JveD1cIi01MCAtNTAgMTAwIDEwMFwiXG4gICAgICB2ZXJzaW9uPVwiMS4xXCJcbiAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW89XCJ4TWlkWU1pZCBtZWV0XCJcbiAgICAgIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICAgID5cbiAgICAgIDx0aXRsZT57bmFtZX08L3RpdGxlPlxuICAgICAgPHRleHRcbiAgICAgICAgZm9udFNpemU9XCI1MHB4XCJcbiAgICAgICAgZmlsbD1cIiNmZmZcIlxuICAgICAgICBkb21pbmFudEJhc2VsaW5lPVwiY2VudHJhbFwiXG4gICAgICAgIHRleHRBbmNob3I9XCJtaWRkbGVcIlxuICAgICAgICBjbGFzc05hbWU9e1tcbiAgICAgICAgICB0eXBvZ3JhcGh5LmFudGlhbGlhc2VkLFxuICAgICAgICAgIHR5cG9ncmFwaHkuc2Fuc1NlcmlmLFxuICAgICAgICAgIHR5cG9ncmFwaHkubGVhZGluZ1NtYWxsLFxuICAgICAgICAgIHR5cG9ncmFwaHkuZm9udFdlaWdodEJvbGQsXG4gICAgICAgIF0uam9pbignICcpfVxuICAgICAgPlxuICAgICAgICB7bmFtZSA/IFsuLi5uYW1lXVswXS50b1VwcGVyQ2FzZSgpIDogJyd9XG4gICAgICA8L3RleHQ+XG4gICAgPC9zdmc+XG4gICk7XG4gIHN3aXRjaCAodGV4dExheW91dCkge1xuICAgIGNhc2UgJ2JvdHRvbUxlZnQnOlxuICAgICAgcmV0dXJuIChcbiAgICAgICAgPEJveFxuICAgICAgICAgIGFyaWEtbGFiZWw9e25hbWV9XG4gICAgICAgICAgY29sb3I9XCJncmF5XCJcbiAgICAgICAgICBoZWlnaHQ9XCIxMDAlXCJcbiAgICAgICAgICBkaXNwbGF5PVwiZmxleFwiXG4gICAgICAgICAgYWxpZ25JdGVtcz1cImVuZFwiXG4gICAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbmxpbmVTdHlsZT17e1xuICAgICAgICAgICAgX19zdHlsZToge1xuICAgICAgICAgICAgICBwYWRkaW5nQm90dG9tOiBxdWFydGVyUGFkZGluZyxcbiAgICAgICAgICAgICAgcGFkZGluZ1JpZ2h0OiBxdWFydGVyUGFkZGluZyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfX1cbiAgICAgICAgPlxuICAgICAgICAgIHtpbml0aWFsfVxuICAgICAgICA8L0JveD5cbiAgICAgICk7XG4gICAgY2FzZSAndG9wTGVmdCc6XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8Qm94XG4gICAgICAgICAgYXJpYS1sYWJlbD17bmFtZX1cbiAgICAgICAgICBjb2xvcj1cImdyYXlcIlxuICAgICAgICAgIGhlaWdodD1cIjEwMCVcIlxuICAgICAgICAgIGRpc3BsYXk9XCJmbGV4XCJcbiAgICAgICAgICBhbGlnbkl0ZW1zPVwic3RhcnRcIlxuICAgICAgICAgIGRhbmdlcm91c2x5U2V0SW5saW5lU3R5bGU9e3tcbiAgICAgICAgICAgIF9fc3R5bGU6IHtcbiAgICAgICAgICAgICAgcGFkZGluZ1RvcDogcXVhcnRlclBhZGRpbmcsXG4gICAgICAgICAgICAgIHBhZGRpbmdSaWdodDogcXVhcnRlclBhZGRpbmcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH19XG4gICAgICAgID5cbiAgICAgICAgICB7aW5pdGlhbH1cbiAgICAgICAgPC9Cb3g+XG4gICAgICApO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8Qm94XG4gICAgICAgICAgYXJpYS1sYWJlbD17bmFtZX1cbiAgICAgICAgICBjb2xvcj1cImdyYXlcIlxuICAgICAgICAgIGhlaWdodD1cIjEwMCVcIlxuICAgICAgICAgIGRpc3BsYXk9XCJmbGV4XCJcbiAgICAgICAgICBhbGlnbkl0ZW1zPVwiY2VudGVyXCJcbiAgICAgICAgICBqdXN0aWZ5Q29udGVudD1cImNlbnRlclwiXG4gICAgICAgID5cbiAgICAgICAgICB7aW5pdGlhbH1cbiAgICAgICAgPC9Cb3g+XG4gICAgICApO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBHcm91cEF2YXRhcihwcm9wczogUHJvcHMpIHtcbiAgY29uc3QgeyBjb2xsYWJvcmF0b3JzLCBvdXRsaW5lLCBzaXplIH0gPSBwcm9wcztcbiAgY29uc3QgYXZhdGFyV2lkdGggPSBzaXplID8gQVZBVEFSX1NJWkVTW3NpemVdIDogJzEwMCUnO1xuICBjb25zdCBhdmF0YXJIZWlnaHQgPSBzaXplID8gQVZBVEFSX1NJWkVTW3NpemVdIDogJyc7XG4gIGNvbnN0IHBvc2l0aW9ucyA9IGF2YXRhckxheW91dChjb2xsYWJvcmF0b3JzLmxlbmd0aCwgYXZhdGFyV2lkdGgpO1xuICByZXR1cm4gKFxuICAgIDxCb3hcbiAgICAgIGNvbG9yPVwid2hpdGVcIlxuICAgICAgb3ZlcmZsb3c9XCJoaWRkZW5cIlxuICAgICAgc2hhcGU9XCJjaXJjbGVcIlxuICAgICAgd2lkdGg9e2F2YXRhcldpZHRofVxuICAgICAgaGVpZ2h0PXthdmF0YXJIZWlnaHR9XG4gICAgICBwb3NpdGlvbj1cInJlbGF0aXZlXCJcbiAgICAgIGRhbmdlcm91c2x5U2V0SW5saW5lU3R5bGU9e3tcbiAgICAgICAgX19zdHlsZToge1xuICAgICAgICAgIC4uLihvdXRsaW5lID8geyBib3hTaGFkb3c6ICcwIDAgMCAycHggI2ZmZicgfSA6IHt9KSxcbiAgICAgICAgICAvLyB3aWxsQ2hhbmdlOiB0cmFuc2Zvcm0gZml4ZXMgYSBzdHJhbmdlIGJlaGF2aW9yIHdoZXJlIHRoZSBib3JkZXIgb2YgdGhlIGNoaWxkcmVuXG4gICAgICAgICAgLy8gYXJlIG5vdCBwcm9wZXJseSB0cmltbWVkIGV2ZW4gdGhvdWdoIG92ZXJmbG93OiBoaWRkZW4gaXMgc2V0XG4gICAgICAgICAgd2lsbENoYW5nZTogJ3RyYW5zZm9ybScsXG4gICAgICAgIH0sXG4gICAgICB9fVxuICAgID5cbiAgICAgIDxCb3ggZGFuZ2Vyb3VzbHlTZXRJbmxpbmVTdHlsZT17eyBfX3N0eWxlOiB7IHBhZGRpbmdCb3R0b206ICcxMDAlJyB9IH19IC8+XG4gICAgICB7emlwKHBvc2l0aW9ucywgY29sbGFib3JhdG9ycykubWFwKFxuICAgICAgICAoW3Bvc2l0aW9uLCBjb2xsYWJvcmF0b3IgPSB7IG5hbWU6ICcnLCBzcmM6IHVuZGVmaW5lZCB9XSwgaWR4KSA9PiB7XG4gICAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCB0b3AsIGxlZnQsIHRleHRMYXlvdXQgfSA9IHBvc2l0aW9uO1xuICAgICAgICAgIGNvbnN0IHsgbmFtZSwgc3JjIH0gPSBjb2xsYWJvcmF0b3I7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxCb3hcbiAgICAgICAgICAgICAga2V5PXtpZHh9XG4gICAgICAgICAgICAgIHBvc2l0aW9uPVwiYWJzb2x1dGVcIlxuICAgICAgICAgICAgICB3aWR0aD17d2lkdGh9XG4gICAgICAgICAgICAgIGhlaWdodD17aGVpZ2h0fVxuICAgICAgICAgICAgICBkYW5nZXJvdXNseVNldElubGluZVN0eWxlPXt7IF9fc3R5bGU6IHsgdG9wLCBsZWZ0IH0gfX1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAge3NyYyA/IChcbiAgICAgICAgICAgICAgICA8SW1hZ2VcbiAgICAgICAgICAgICAgICAgIGFsdD17bmFtZX1cbiAgICAgICAgICAgICAgICAgIGNvbG9yPVwiI0VGRUZFRlwiXG4gICAgICAgICAgICAgICAgICBzcmM9e3NyY31cbiAgICAgICAgICAgICAgICAgIG5hdHVyYWxXaWR0aD17MX1cbiAgICAgICAgICAgICAgICAgIG5hdHVyYWxIZWlnaHQ9ezF9XG4gICAgICAgICAgICAgICAgICBmaXQ9XCJjb3ZlclwiXG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgKSA6IChcbiAgICAgICAgICAgICAgICA8RGVmYXVsdEF2YXRhclxuICAgICAgICAgICAgICAgICAgbmFtZT17bmFtZX1cbiAgICAgICAgICAgICAgICAgIHRleHRMYXlvdXQ9e3RleHRMYXlvdXR9XG4gICAgICAgICAgICAgICAgICBzaXplPXtoZWlnaHR9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy53YXNofSAvPlxuICAgICAgICAgICAgPC9Cb3g+XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgKX1cbiAgICA8L0JveD5cbiAgKTtcbn1cblxuR3JvdXBBdmF0YXIucHJvcFR5cGVzID0ge1xuICBjb2xsYWJvcmF0b3JzOiBQcm9wVHlwZXMuYXJyYXlPZihcbiAgICBQcm9wVHlwZXMuZXhhY3Qoe1xuICAgICAgbmFtZTogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgICAgc3JjOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIH0pXG4gICkuaXNSZXF1aXJlZCxcbiAgb3V0bGluZTogUHJvcFR5cGVzLmJvb2wsXG4gIHNpemU6IFByb3BUeXBlcy5vbmVPZihbJ3NtJywgJ21kJywgJ2xnJ10pLFxufTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGN4IGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IGNvbG9ycyBmcm9tICcuL0NvbG9ycy5jc3MnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL0hlYWRpbmcuY3NzJztcbmltcG9ydCB0eXBvZ3JhcGh5IGZyb20gJy4vVHlwb2dyYXBoeS5jc3MnO1xuXG50eXBlIFByb3BzID0ge3xcbiAgYWNjZXNzaWJpbGl0eUxldmVsPzogMSB8IDIgfCAzIHwgNCB8IDUgfCA2LFxuICBjaGlsZHJlbj86IFJlYWN0Lk5vZGUsXG4gIGNvbG9yPzpcbiAgICB8ICdibHVlJ1xuICAgIHwgJ2RhcmtHcmF5J1xuICAgIHwgJ2VnZ3BsYW50J1xuICAgIHwgJ2dyYXknXG4gICAgfCAnZ3JlZW4nXG4gICAgfCAnbGlnaHRHcmF5J1xuICAgIHwgJ21hcm9vbidcbiAgICB8ICdtaWRuaWdodCdcbiAgICB8ICduYXZ5J1xuICAgIHwgJ29saXZlJ1xuICAgIHwgJ29yYW5nZSdcbiAgICB8ICdvcmNoaWQnXG4gICAgfCAncGluZSdcbiAgICB8ICdwdXJwbGUnXG4gICAgfCAncmVkJ1xuICAgIHwgJ3dhdGVybWVsb24nXG4gICAgfCAnd2hpdGUnLFxuICBpZD86IHN0cmluZyxcbiAgbGdTaXplPzogJ3hzJyB8ICdzbScgfCAnbWQnIHwgJ2xnJyB8ICd4bCcsXG4gIG1kU2l6ZT86ICd4cycgfCAnc20nIHwgJ21kJyB8ICdsZycgfCAneGwnLFxuICBvdmVyZmxvdz86ICdub3JtYWwnIHwgJ2JyZWFrV29yZCcsXG4gIHNpemU/OiAneHMnIHwgJ3NtJyB8ICdtZCcgfCAnbGcnIHwgJ3hsJyxcbiAgc21TaXplPzogJ3hzJyB8ICdzbScgfCAnbWQnIHwgJ2xnJyB8ICd4bCcsXG4gIHRydW5jYXRlPzogYm9vbGVhbixcbnx9O1xuXG5jb25zdCBkZWZhdWx0SGVhZGluZ0xldmVscyA9IHtcbiAgeHM6IDUsXG4gIHNtOiA0LFxuICBtZDogMyxcbiAgbGc6IDIsXG4gIHhsOiAxLFxufTtcblxuY29uc3QgU0laRV9TQ0FMRTogeyBbc2l6ZTogP3N0cmluZ106IG51bWJlciB9ID0ge1xuICB4czogMSxcbiAgc206IDIsXG4gIG1kOiAzLFxuICBsZzogNCxcbiAgeGw6IDUsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBIZWFkaW5nKHByb3BzOiBQcm9wcykge1xuICBjb25zdCB7XG4gICAgYWNjZXNzaWJpbGl0eUxldmVsLFxuICAgIGNoaWxkcmVuLFxuICAgIGNvbG9yID0gJ2RhcmtHcmF5JyxcbiAgICBpZCA9IG51bGwsXG4gICAgbGdTaXplLFxuICAgIG1kU2l6ZSxcbiAgICBvdmVyZmxvdyA9ICdicmVha1dvcmQnLFxuICAgIHNpemUgPSAnbWQnLFxuICAgIHNtU2l6ZSxcbiAgICB0cnVuY2F0ZSA9IGZhbHNlLFxuICB9ID0gcHJvcHM7XG5cbiAgY29uc3QgY3MgPSBjeChcbiAgICBzdHlsZXMuSGVhZGluZyxcbiAgICBzdHlsZXNbYGZvbnRTaXplJHtTSVpFX1NDQUxFW3NpemVdfWBdLFxuICAgIHNtU2l6ZSAmJiBzdHlsZXNbYHNtRm9udFNpemUke1NJWkVfU0NBTEVbc21TaXplXX1gXSxcbiAgICBtZFNpemUgJiYgc3R5bGVzW2BtZEZvbnRTaXplJHtTSVpFX1NDQUxFW21kU2l6ZV19YF0sXG4gICAgbGdTaXplICYmIHN0eWxlc1tgbGdGb250U2l6ZSR7U0laRV9TQ0FMRVtsZ1NpemVdfWBdLFxuICAgIGNvbG9yc1tjb2xvcl0sXG4gICAgb3ZlcmZsb3cgPT09ICdicmVha1dvcmQnICYmIHR5cG9ncmFwaHkuYnJlYWtXb3JkLFxuICAgIHRydW5jYXRlICYmIHR5cG9ncmFwaHkudHJ1bmNhdGVcbiAgKTtcblxuICBjb25zdCBoZWFkaW5nTGV2ZWwgPSBhY2Nlc3NpYmlsaXR5TGV2ZWwgfHwgZGVmYXVsdEhlYWRpbmdMZXZlbHNbc2l6ZV07XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIGBoJHtoZWFkaW5nTGV2ZWx9YCxcbiAgICB7XG4gICAgICBjbGFzc05hbWU6IGNzLFxuICAgICAgaWQsXG4gICAgICAuLi4odHJ1bmNhdGUgJiYgdHlwZW9mIGNoaWxkcmVuID09PSAnc3RyaW5nJ1xuICAgICAgICA/IHsgdGl0bGU6IGNoaWxkcmVuIH1cbiAgICAgICAgOiBudWxsKSxcbiAgICB9LFxuICAgIGNoaWxkcmVuXG4gICk7XG59XG5cbkhlYWRpbmcucHJvcFR5cGVzID0ge1xuICBhY2Nlc3NpYmlsaXR5TGV2ZWw6IFByb3BUeXBlcy5vbmVPZihbMSwgMiwgMywgNCwgNSwgNl0pLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gIGNvbG9yOiBQcm9wVHlwZXMub25lT2YoW1xuICAgICdibHVlJyxcbiAgICAnZGFya0dyYXknLFxuICAgICdlZ2dwbGFudCcsXG4gICAgJ2dyYXknLFxuICAgICdncmVlbicsXG4gICAgJ2xpZ2h0R3JheScsXG4gICAgJ21hcm9vbicsXG4gICAgJ21pZG5pZ2h0JyxcbiAgICAnbmF2eScsXG4gICAgJ29saXZlJyxcbiAgICAnb3JhbmdlJyxcbiAgICAnb3JjaGlkJyxcbiAgICAncGluZScsXG4gICAgJ3B1cnBsZScsXG4gICAgJ3JlZCcsXG4gICAgJ3dhdGVybWVsb24nLFxuICAgICd3aGl0ZScsXG4gIF0pLFxuICBpZDogUHJvcFR5cGVzLnN0cmluZyxcbiAgb3ZlcmZsb3c6IFByb3BUeXBlcy5vbmVPZihbJ25vcm1hbCcsICdicmVha1dvcmQnXSksXG4gIHNpemU6IFByb3BUeXBlcy5vbmVPZihbJ3hzJywgJ3NtJywgJ21kJywgJ2xnJywgJ3hsJ10pLFxuICBzbVNpemU6IFByb3BUeXBlcy5vbmVPZihbJ3hzJywgJ3NtJywgJ21kJywgJ2xnJywgJ3hsJ10pLFxuICBtZFNpemU6IFByb3BUeXBlcy5vbmVPZihbJ3hzJywgJ3NtJywgJ21kJywgJ2xnJywgJ3hsJ10pLFxuICBsZ1NpemU6IFByb3BUeXBlcy5vbmVPZihbJ3hzJywgJ3NtJywgJ21kJywgJ2xnJywgJ3hsJ10pLFxuICB0cnVuY2F0ZTogUHJvcFR5cGVzLmJvb2wsXG59O1xuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBCb3ggZnJvbSAnLi9Cb3guanMnO1xuaW1wb3J0IEljb24gZnJvbSAnLi9JY29uLmpzJztcbmltcG9ydCBpY29ucyBmcm9tICcuL2ljb25zL2luZGV4LmpzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9Qb2cuY3NzJztcblxuY29uc3QgU0laRV9OQU1FX1RPX1BJWEVMID0ge1xuICB4czogMjQsXG4gIHNtOiAzMixcbiAgbWQ6IDQwLFxuICBsZzogNDgsXG4gIHhsOiA1Nixcbn07XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBhY3RpdmU/OiBib29sZWFuLFxuICBiZ0NvbG9yPzogJ3RyYW5zcGFyZW50JyB8ICdncmF5JyB8ICdsaWdodEdyYXknIHwgJ3doaXRlJyxcbiAgZm9jdXNlZD86IGJvb2xlYW4sXG4gIGhvdmVyZWQ/OiBib29sZWFuLFxuICBpY29uQ29sb3I/OiAnZ3JheScgfCAnZGFya0dyYXknIHwgJ3JlZCcgfCAnYmx1ZScgfCAnd2hpdGUnLFxuICBpY29uOiAkS2V5czx0eXBlb2YgaWNvbnM+LFxuICBzaXplPzogJEtleXM8dHlwZW9mIFNJWkVfTkFNRV9UT19QSVhFTD4sXG58fTtcblxuY29uc3QgZGVmYXVsdEljb25CdXR0b25JY29uQ29sb3JzID0ge1xuICB0cmFuc3BhcmVudDogJ2dyYXknLFxuICBncmF5OiAnd2hpdGUnLFxuICBsaWdodEdyYXk6ICdncmF5JyxcbiAgd2hpdGU6ICdncmF5Jyxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFBvZyhwcm9wczogUHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIGFjdGl2ZSA9IGZhbHNlLFxuICAgIGJnQ29sb3IgPSAndHJhbnNwYXJlbnQnLFxuICAgIGZvY3VzZWQgPSBmYWxzZSxcbiAgICBob3ZlcmVkID0gZmFsc2UsXG4gICAgaWNvbkNvbG9yID0gZGVmYXVsdEljb25CdXR0b25JY29uQ29sb3JzW2JnQ29sb3JdLFxuICAgIGljb24sXG4gICAgc2l6ZSA9ICdtZCcsXG4gIH0gPSBwcm9wcztcblxuICBjb25zdCBpY29uU2l6ZSA9IFNJWkVfTkFNRV9UT19QSVhFTFtzaXplXSAvIDI7XG5cbiAgY29uc3QgaW5saW5lU3R5bGUgPSB7XG4gICAgaGVpZ2h0OiBTSVpFX05BTUVfVE9fUElYRUxbc2l6ZV0sXG4gICAgd2lkdGg6IFNJWkVfTkFNRV9UT19QSVhFTFtzaXplXSxcbiAgfTtcblxuICBjb25zdCBjbGFzc2VzID0gY2xhc3NuYW1lcyhzdHlsZXMucG9nLCBzdHlsZXNbYmdDb2xvcl0sIHtcbiAgICBbc3R5bGVzLmFjdGl2ZV06IGFjdGl2ZSxcbiAgICBbc3R5bGVzLmZvY3VzZWRdOiBmb2N1c2VkLFxuICAgIFtzdHlsZXMuaG92ZXJlZF06IGhvdmVyZWQgJiYgIWZvY3VzZWQgJiYgIWFjdGl2ZSxcbiAgfSk7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT17Y2xhc3Nlc30gc3R5bGU9e2lubGluZVN0eWxlfT5cbiAgICAgIDxCb3ggc2hhcGU9XCJjaXJjbGVcIj5cbiAgICAgICAgey8qXG4gICAgICAgICAgV2UncmUgZXhwbGljaXRseSBzZXR0aW5nIGFuIGVtcHR5IHN0cmluZyBhcyBhIGxhYmVsIG9uIHRoZSBJY29uIHNpbmNlIHdlXG4gICAgICAgICAgYWxyZWFkeSBoYXZlIGFuIGFyaWEtbGFiZWwgb24gdGhlIGJ1dHRvbiBjb250YWluZXIuXG4gICAgICAgICAgVGhpcyBpcyBzaW1pbGFyIHRvIGhhdmluZyBlbXB0eSBgYWx0YCBhdHRyaWJ1dGVzOlxuICAgICAgICAgIGh0dHBzOi8vZGF2aWR3YWxzaC5uYW1lL2FjY2Vzc2liaWxpdHktdGlwLWVtcHR5LWFsdC1hdHRyaWJ1dGVzXG4gICAgICAgICovfVxuICAgICAgICA8SWNvblxuICAgICAgICAgIGNvbG9yPXtpY29uQ29sb3J9XG4gICAgICAgICAgaWNvbj17aWNvbn1cbiAgICAgICAgICBzaXplPXtpY29uU2l6ZX1cbiAgICAgICAgICBhY2Nlc3NpYmlsaXR5TGFiZWw9XCJcIlxuICAgICAgICAvPlxuICAgICAgPC9Cb3g+XG4gICAgPC9kaXY+XG4gICk7XG59XG5cblBvZy5wcm9wVHlwZXMgPSB7XG4gIGFjdGl2ZTogUHJvcFR5cGVzLmJvb2wsXG4gIGJnQ29sb3I6IFByb3BUeXBlcy5vbmVPZihbJ3RyYW5zcGFyZW50JywgJ2dyYXknLCAnbGlnaHRHcmF5JywgJ3doaXRlJ10pLFxuICBmb2N1c2VkOiBQcm9wVHlwZXMuYm9vbCxcbiAgaG92ZXJlZDogUHJvcFR5cGVzLmJvb2wsXG4gIGljb25Db2xvcjogUHJvcFR5cGVzLm9uZU9mKFsnZ3JheScsICdkYXJrR3JheScsICdyZWQnLCAnYmx1ZScsICd3aGl0ZSddKSxcbiAgaWNvbjogUHJvcFR5cGVzLm9uZU9mKE9iamVjdC5rZXlzKGljb25zKSkuaXNSZXF1aXJlZCxcbiAgc2l6ZTogUHJvcFR5cGVzLm9uZU9mKE9iamVjdC5rZXlzKFNJWkVfTkFNRV9UT19QSVhFTCkpLFxufTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL0ljb25CdXR0b24uY3NzJztcbmltcG9ydCBpY29ucyBmcm9tICcuL2ljb25zL2luZGV4LmpzJztcbmltcG9ydCBQb2cgZnJvbSAnLi9Qb2cuanMnO1xuXG50eXBlIFByb3BzID0ge3xcbiAgYWNjZXNzaWJpbGl0eUV4cGFuZGVkPzogYm9vbGVhbixcbiAgYWNjZXNzaWJpbGl0eUhhc3BvcHVwPzogYm9vbGVhbixcbiAgYWNjZXNzaWJpbGl0eUxhYmVsOiBzdHJpbmcsXG4gIGJnQ29sb3I/OiAndHJhbnNwYXJlbnQnIHwgJ2dyYXknIHwgJ2xpZ2h0R3JheScgfCAnd2hpdGUnLFxuICBpY29uQ29sb3I/OiAnZ3JheScgfCAnZGFya0dyYXknIHwgJ3JlZCcgfCAnYmx1ZScgfCAnd2hpdGUnLFxuICBpY29uOiAkS2V5czx0eXBlb2YgaWNvbnM+LFxuICBvbkNsaWNrPzogKHsgZXZlbnQ6IFN5bnRoZXRpY01vdXNlRXZlbnQ8PiB9KSA9PiB2b2lkLFxuICBzaXplPzogJ3hzJyB8ICdzbScgfCAnbWQnIHwgJ2xnJyB8ICd4bCcsXG58fTtcblxudHlwZSBTdGF0ZSA9IHt8XG4gIGFjdGl2ZTogYm9vbGVhbixcbiAgZm9jdXNlZDogYm9vbGVhbixcbiAgaG92ZXJlZDogYm9vbGVhbixcbnx9O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJY29uQnV0dG9uIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFByb3BzLCBTdGF0ZT4ge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIGFjY2Vzc2liaWxpdHlFeHBhbmRlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgYWNjZXNzaWJpbGl0eUhhc3BvcHVwOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBhY2Nlc3NpYmlsaXR5TGFiZWw6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBiZ0NvbG9yOiBQcm9wVHlwZXMub25lT2YoWyd0cmFuc3BhcmVudCcsICdncmF5JywgJ2xpZ2h0R3JheScsICd3aGl0ZSddKSxcbiAgICBpY29uOiBQcm9wVHlwZXMub25lT2YoT2JqZWN0LmtleXMoaWNvbnMpKS5pc1JlcXVpcmVkLFxuICAgIGljb25Db2xvcjogUHJvcFR5cGVzLm9uZU9mKFsnZ3JheScsICdkYXJrR3JheScsICdyZWQnLCAnYmx1ZScsICd3aGl0ZSddKSxcbiAgICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBzaXplOiBQcm9wVHlwZXMub25lT2YoWyd4cycsICdzbScsICdtZCcsICdsZycsICd4bCddKSxcbiAgfTtcblxuICBzdGF0ZTogU3RhdGUgPSB7XG4gICAgYWN0aXZlOiBmYWxzZSxcbiAgICBmb2N1c2VkOiBmYWxzZSxcbiAgICBob3ZlcmVkOiBmYWxzZSxcbiAgfTtcblxuICBoYW5kbGVCbHVyID0gKCkgPT4gdGhpcy5zZXRTdGF0ZSh7IGZvY3VzZWQ6IGZhbHNlIH0pO1xuXG4gIGhhbmRsZUZvY3VzID0gKCkgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoeyBmb2N1c2VkOiB0cnVlIH0pO1xuICB9O1xuXG4gIGhhbmRsZU1vdXNlRG93biA9ICgpID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHsgYWN0aXZlOiB0cnVlIH0pO1xuICB9O1xuXG4gIGhhbmRsZU1vdXNlRW50ZXIgPSAoKSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGhvdmVyZWQ6IHRydWUgfSk7XG4gIH07XG5cbiAgaGFuZGxlTW91c2VMZWF2ZSA9ICgpID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgICBob3ZlcmVkOiBmYWxzZSxcbiAgICB9KTtcbiAgfTtcblxuICBoYW5kbGVNb3VzZVVwID0gKCkgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoeyBhY3RpdmU6IGZhbHNlIH0pO1xuICB9O1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBhY2Nlc3NpYmlsaXR5RXhwYW5kZWQsXG4gICAgICBhY2Nlc3NpYmlsaXR5SGFzcG9wdXAsXG4gICAgICBhY2Nlc3NpYmlsaXR5TGFiZWwsXG4gICAgICBiZ0NvbG9yLFxuICAgICAgaWNvbkNvbG9yLFxuICAgICAgaWNvbixcbiAgICAgIHNpemUsXG4gICAgICBvbkNsaWNrLFxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgY29uc3QgeyBhY3RpdmUsIGZvY3VzZWQsIGhvdmVyZWQgfSA9IHRoaXMuc3RhdGU7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGJ1dHRvblxuICAgICAgICBhcmlhLWV4cGFuZGVkPXthY2Nlc3NpYmlsaXR5RXhwYW5kZWR9XG4gICAgICAgIGFyaWEtaGFzcG9wdXA9e2FjY2Vzc2liaWxpdHlIYXNwb3B1cH1cbiAgICAgICAgYXJpYS1sYWJlbD17YWNjZXNzaWJpbGl0eUxhYmVsfVxuICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy5idXR0b259XG4gICAgICAgIG9uQmx1cj17dGhpcy5oYW5kbGVCbHVyfVxuICAgICAgICBvbkNsaWNrPXtldmVudCA9PiBvbkNsaWNrICYmIG9uQ2xpY2soeyBldmVudCB9KX1cbiAgICAgICAgb25Gb2N1cz17dGhpcy5oYW5kbGVGb2N1c31cbiAgICAgICAgb25Nb3VzZURvd249e3RoaXMuaGFuZGxlTW91c2VEb3dufVxuICAgICAgICBvbk1vdXNlRW50ZXI9e3RoaXMuaGFuZGxlTW91c2VFbnRlcn1cbiAgICAgICAgb25Nb3VzZUxlYXZlPXt0aGlzLmhhbmRsZU1vdXNlTGVhdmV9XG4gICAgICAgIG9uTW91c2VVcD17dGhpcy5oYW5kbGVNb3VzZVVwfVxuICAgICAgICB0aXRsZT17YWNjZXNzaWJpbGl0eUxhYmVsfVxuICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgID5cbiAgICAgICAgPFBvZ1xuICAgICAgICAgIGFjdGl2ZT17YWN0aXZlfVxuICAgICAgICAgIGJnQ29sb3I9e2JnQ29sb3J9XG4gICAgICAgICAgZm9jdXNlZD17Zm9jdXNlZH1cbiAgICAgICAgICBob3ZlcmVkPXtob3ZlcmVkfVxuICAgICAgICAgIGljb25Db2xvcj17aWNvbkNvbG9yfVxuICAgICAgICAgIGljb249e2ljb259XG4gICAgICAgICAgc2l6ZT17c2l6ZX1cbiAgICAgICAgLz5cbiAgICAgIDwvYnV0dG9uPlxuICAgICk7XG4gIH1cbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL0xhYmVsLmNzcyc7XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBjaGlsZHJlbj86IFJlYWN0Lk5vZGUsXG4gIGh0bWxGb3I6IHN0cmluZyxcbnx9O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBMYWJlbChwcm9wczogUHJvcHMpIHtcbiAgY29uc3QgeyBjaGlsZHJlbiwgaHRtbEZvciB9ID0gcHJvcHM7XG5cbiAgcmV0dXJuIChcbiAgICA8bGFiZWwgY2xhc3NOYW1lPXtzdHlsZXMubGFiZWx9IGh0bWxGb3I9e2h0bWxGb3J9PlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvbGFiZWw+XG4gICk7XG59XG5cbkxhYmVsLnByb3BUeXBlcyA9IHtcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICBodG1sRm9yOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG59O1xuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNyZWF0ZVBvcnRhbCB9IGZyb20gJ3JlYWN0LWRvbSc7XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBjaGlsZHJlbj86IFJlYWN0Lk5vZGUsXG58fTtcbnR5cGUgU3RhdGUgPSB7fFxuICBtb3VudGVkOiBib29sZWFuLFxufH07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExheWVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFByb3BzLCBTdGF0ZT4ge1xuICBzdGF0ZSA9IHtcbiAgICBtb3VudGVkOiBmYWxzZSxcbiAgfTtcblxuICBjb25zdHJ1Y3Rvcihwcm9wczogUHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCkge1xuICAgICAgdGhpcy5lbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAnVXNpbmcgTGF5ZXIgd2l0aG91dCBkb2N1bWVudCBwcmVzZW50LiBDaGlsZHJlbiB3aWxsIG5vdCBiZSByZW5kZXJlZC4nXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmJvZHkpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5lbCk7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgbW91bnRlZDogdHJ1ZSB9KTtcbiAgICB9XG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBpZiAoZG9jdW1lbnQuYm9keSkge1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGlzLmVsKTtcbiAgICB9XG4gIH1cblxuICBlbDogSFRNTERpdkVsZW1lbnQ7XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IHRoaXMucHJvcHM7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUubW91bnRlZCAmJiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIHRoaXMuZWwpO1xuICB9XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBNYXNrIGZyb20gJy4vTWFzay5qcyc7XG5cbi8qXG4gIE11Y2ggb2YgdGhlIG1hdGggYW5kIHVuZGVyc3RhbmRpbmcgYWJvdXQgdGhpcyBjb21wb25lbnQgY29tZXMgZnJvbSBAdmplYXV4J3NcbiAgZXhjZWxsZW50IGJsb2cgcG9zdCBvbiBpbWFnZSByZXNpemluZy5cblxuICBodHRwOi8vYmxvZy52amV1eC5jb20vMjAxMy9pbWFnZS9jc3MtY29udGFpbmVyLWFuZC1jb3Zlci5odG1sXG5cbiAgSSBoaWdobHkgcmVjb21tZW5kIHlvdSByZWFkIHRoYXQgZmlyc3QgYmVmb3JlIGNvbnRpbnVpbmcgb24gcmVhZGluZy5cbiovXG5cbmNvbnN0IGFzcGVjdFJhdGlvID0gKHdpZHRoLCBoZWlnaHQpID0+IHdpZHRoIC8gaGVpZ2h0O1xuXG50eXBlIFByb3BzID0ge3xcbiAgY2hpbGRyZW4/OiBSZWFjdC5Ob2RlLFxuICBjb250ZW50QXNwZWN0UmF0aW86IG51bWJlcixcbiAgaGVpZ2h0OiBudW1iZXIsXG4gIHdpZHRoOiBudW1iZXIsXG58fTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTGV0dGVyYm94KHtcbiAgY2hpbGRyZW4sXG4gIGNvbnRlbnRBc3BlY3RSYXRpbyxcbiAgaGVpZ2h0LFxuICB3aWR0aCxcbn06IFByb3BzKSB7XG4gIGNvbnN0IHZpZXdwb3J0QXNwZWN0UmF0aW8gPSBhc3BlY3RSYXRpbyh3aWR0aCwgaGVpZ2h0KTtcblxuICBsZXQgY29udGVudEhlaWdodDtcbiAgbGV0IGNvbnRlbnRXaWR0aDtcblxuICBpZiAoY29udGVudEFzcGVjdFJhdGlvIDwgdmlld3BvcnRBc3BlY3RSYXRpbykge1xuICAgIGNvbnRlbnRXaWR0aCA9IHdpZHRoO1xuICAgIGNvbnRlbnRIZWlnaHQgPSB3aWR0aCAvIGNvbnRlbnRBc3BlY3RSYXRpbztcbiAgfSBlbHNlIHtcbiAgICBjb250ZW50V2lkdGggPSBoZWlnaHQgKiBjb250ZW50QXNwZWN0UmF0aW87XG4gICAgY29udGVudEhlaWdodCA9IGhlaWdodDtcbiAgfVxuXG4gIGNvbnN0IG9mZnNldFRvcCA9IChjb250ZW50SGVpZ2h0IC0gaGVpZ2h0KSAvIC0yO1xuICBjb25zdCBvZmZzZXRMZWZ0ID0gKGNvbnRlbnRXaWR0aCAtIHdpZHRoKSAvIC0yO1xuXG4gIHJldHVybiAoXG4gICAgPE1hc2sgd2lkdGg9e3dpZHRofSBoZWlnaHQ9e2hlaWdodH0+XG4gICAgICA8ZGl2IHN0eWxlPXt7IG1hcmdpblRvcDogb2Zmc2V0VG9wLCBtYXJnaW5MZWZ0OiBvZmZzZXRMZWZ0IH19PlxuICAgICAgICA8TWFzayB3aWR0aD17Y29udGVudFdpZHRofSBoZWlnaHQ9e2NvbnRlbnRIZWlnaHR9PlxuICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgPC9NYXNrPlxuICAgICAgPC9kaXY+XG4gICAgPC9NYXNrPlxuICApO1xufVxuXG5MZXR0ZXJib3gucHJvcFR5cGVzID0ge1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gIGNvbnRlbnRBc3BlY3RSYXRpbzogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICBoZWlnaHQ6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgd2lkdGg6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbn07XG4iLCIvLyBAZmxvd1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjeCBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9MaW5rLmNzcyc7XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBjaGlsZHJlbj86IFJlYWN0Lk5vZGUsXG4gIGhyZWY6IHN0cmluZyxcbiAgaW5saW5lPzogYm9vbGVhbixcbiAgb25DbGljaz86ICh7IGV2ZW50OiBTeW50aGV0aWNNb3VzZUV2ZW50PD4gfSkgPT4gdm9pZCxcbiAgdGFyZ2V0PzogbnVsbCB8ICdzZWxmJyB8ICdibGFuaycsXG58fTtcblxudHlwZSBTdGF0ZSA9IHt8XG4gIGVuYWJsZUZvY3VzU3R5bGVzOiBib29sZWFuLFxufH07XG5cbmNvbnN0IFRBQl9LRVlfQ09ERSA9IDk7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpbmsgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8UHJvcHMsIFN0YXRlPiB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLmlzUmVxdWlyZWQsXG4gICAgaHJlZjogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIGlubGluZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgb25DbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gICAgdGFyZ2V0OiBQcm9wVHlwZXMub25lT2YoW251bGwsICdzZWxmJywgJ2JsYW5rJ10pLFxuICB9O1xuXG4gIHN0YXRlOiBTdGF0ZSA9IHtcbiAgICBlbmFibGVGb2N1c1N0eWxlczogdHJ1ZSxcbiAgfTtcblxuICBoYW5kbGVDbGljayA9IChldmVudDogU3ludGhldGljTW91c2VFdmVudDw+KSA9PiB7XG4gICAgY29uc3QgeyBocmVmLCBvbkNsaWNrIH0gPSB0aGlzLnByb3BzO1xuICAgIGlmIChvbkNsaWNrICYmIGhyZWYpIHtcbiAgICAgIG9uQ2xpY2soeyBldmVudCB9KTtcbiAgICB9XG4gIH07XG5cbiAgaGFuZGxlTW91c2VEb3duID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgaHJlZiwgdGFyZ2V0IH0gPSB0aGlzLnByb3BzO1xuICAgIGlmICh0YXJnZXQgPT09ICdibGFuaycgJiYgaHJlZikge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGVuYWJsZUZvY3VzU3R5bGVzOiBmYWxzZSB9KTtcbiAgICB9XG4gIH07XG5cbiAgaGFuZGxlS2V5VXAgPSAoZXZlbnQ6IFN5bnRoZXRpY0tleWJvYXJkRXZlbnQ8PikgPT4ge1xuICAgIGNvbnN0IHsgaHJlZiwgdGFyZ2V0IH0gPSB0aGlzLnByb3BzO1xuICAgIGlmICh0YXJnZXQgPT09ICdibGFuaycgJiYgZXZlbnQua2V5Q29kZSA9PT0gVEFCX0tFWV9DT0RFICYmIGhyZWYpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBlbmFibGVGb2N1c1N0eWxlczogdHJ1ZSB9KTtcbiAgICB9XG4gIH07XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgY2hpbGRyZW4sIGlubGluZSA9IGZhbHNlLCB0YXJnZXQgPSBudWxsLCBocmVmIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHJlbCA9IHRhcmdldCA9PT0gJ2JsYW5rJyA/ICdub29wZW5lciBub3JlZmVycmVyJyA6IG51bGw7XG4gICAgY29uc3QgbGlua1RhcmdldCA9IHRhcmdldCA/IGBfJHt0YXJnZXR9YCA6IG51bGw7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGFcbiAgICAgICAgY2xhc3NOYW1lPXtjeChcbiAgICAgICAgICBzdHlsZXMubGluayxcbiAgICAgICAgICB0aGlzLnN0YXRlLmVuYWJsZUZvY3VzU3R5bGVzID8gc3R5bGVzLmFjY2Vzc2libGVGb2N1c1N0eWxlIDogJycsXG4gICAgICAgICAgaW5saW5lID8gJycgOiBzdHlsZXMuYmxvY2tcbiAgICAgICAgKX1cbiAgICAgICAgaHJlZj17aHJlZn1cbiAgICAgICAgb25Nb3VzZURvd249e3RoaXMuaGFuZGxlTW91c2VEb3dufVxuICAgICAgICBvbktleVVwPXt0aGlzLmhhbmRsZUtleVVwfVxuICAgICAgICBvbkNsaWNrPXt0aGlzLmhhbmRsZUNsaWNrfVxuICAgICAgICByZWw9e3JlbH1cbiAgICAgICAgdGFyZ2V0PXtsaW5rVGFyZ2V0fVxuICAgICAgPlxuICAgICAgICB7Y2hpbGRyZW59XG4gICAgICA8L2E+XG4gICAgKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBkZWJvdW5jZSBwcmV2ZW50cyBhIHBhcnRpY3VsYXIgZnVuY3Rpb24gZnJvbSBiZWluZyBjYWxsZWQgdW50aWwgYWZ0ZXIgYSBnaXZlblxuICogY29vbGRvd24gcGVyaW9kIChkZWZhdWx0IDEwMG1zKS4gRXZlcnkgdGltZSB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkLCBpdCByZXNldHNcbiAqIHRoZSBjb29sZG93bi5cbiAqL1xuXG4vLyBAZmxvd1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGVib3VuY2UoXG4gIGZuOiAoLi4uYXJnczogKikgPT4gdm9pZCxcbiAgdGhyZXNoaG9sZDogbnVtYmVyID0gMTAwXG4pIHtcbiAgbGV0IGRlZmVyVGltZXI6IFRpbWVvdXRJRCB8IG51bGwgPSBudWxsO1xuXG4gIGNvbnN0IGRlYm91bmNlZCA9ICguLi5hcmdzOiAqKSA9PiB7XG4gICAgaWYgKGRlZmVyVGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dChkZWZlclRpbWVyKTtcbiAgICB9XG5cbiAgICBkZWZlclRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBkZWZlclRpbWVyID0gbnVsbDtcbiAgICAgIGZuKC4uLmFyZ3MpO1xuICAgIH0sIHRocmVzaGhvbGQpO1xuICB9O1xuXG4gIGRlYm91bmNlZC5jbGVhclRpbWVvdXQgPSAoKSA9PiB7XG4gICAgaWYgKGRlZmVyVGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dChkZWZlclRpbWVyKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGRlYm91bmNlZDtcbn1cbiIsIi8qKlxuICogRmV0Y2hJdGVtcyBpcyBhIGxvZ2ljIGNvbXBvbmVudCB0aGF0IHJlbmRlcnMgbm8gY29udGVudCBpdHNlbGYuIEl0cyBqb2JcbiAqIGlzIHRvIG1hbmFnZSB3aGVuIHRoZSBnaXZlbiBmZXRjaE1vcmUgbWV0aG9kIHNob3VsZCBiZSBjYWxsZWQgYmFzZWQgb25cbiAqIHRoZSBnaXZlbiBzY3JvbGwvc2l6ZSBwcm9wcy5cbiAqXG4gKiBXaGlsZSBubyBlbGVtZW50IGlzIGFjdHVhbGx5IHBhc3NlZCB0byBGZXRjaEl0ZW1zLCBpdCBpcyBpbnRlbmRlZCB0byBiZSB1c2VkXG4gKiBpbiBjb25qdW5jdGlvbiB3aXRoIGEgbGFyZ2Ugc2Nyb2xsIGNvbnRhaW5lciB0aGF0IHVzZXMgYXN5bmMgZmV0Y2hpbmcgdG9cbiAqIGxvYWQgYW5kIHJlbmRlciBhZGRpdGlvbmFsIGRhdGEuIEJhc2VkIG9uIHRoZSBoZWlnaHQgb2YgdGhpcyBjb250YWluZXIgYW5kXG4gKiBpdHMgY3VycmVudCBzY3JvbGwgcG9zaXRpb24sIEZldGNoSXRlbXMgaXMgcmVzcG9uc2libGUgZm9yIHRyaWdnZXJpbmcgZnV0dXJlXG4gKiBmZXRjaCBjYWxscy5cbiAqL1xuXG4vLyBAZmxvd1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxudHlwZSBQcm9wcyA9IHtcbiAgY29udGFpbmVySGVpZ2h0OiBudW1iZXIsXG4gIGlzQXRFbmQ/OiBib29sZWFuLFxuICBpc0ZldGNoaW5nOiBib29sZWFuLFxuICBmZXRjaE1vcmU/OiAoKSA9PiB2b2lkLFxuICBzY3JvbGxIZWlnaHQ6IG51bWJlcixcbiAgc2Nyb2xsVG9wOiBudW1iZXIsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGZXRjaEl0ZW1zIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudDxQcm9wcz4ge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIGNvbnRhaW5lckhlaWdodDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICAgIGlzQXRFbmQ6IFByb3BUeXBlcy5ib29sLFxuICAgIGlzRmV0Y2hpbmc6IFByb3BUeXBlcy5ib29sLmlzUmVxdWlyZWQsXG4gICAgZmV0Y2hNb3JlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBzY3JvbGxIZWlnaHQ6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgICBzY3JvbGxUb3A6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgfTtcblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBzZXRUaW1lb3V0KHRoaXMuY2hlY2spO1xuICB9XG5cbiAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIGNoZWNrID0gKCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRhaW5lckhlaWdodCxcbiAgICAgIGlzQXRFbmQsXG4gICAgICBpc0ZldGNoaW5nLFxuICAgICAgZmV0Y2hNb3JlLFxuICAgICAgc2Nyb2xsSGVpZ2h0LFxuICAgICAgc2Nyb2xsVG9wLFxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgaWYgKGlzQXRFbmQgfHwgaXNGZXRjaGluZyB8fCAhZmV0Y2hNb3JlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNjcm9sbEJ1ZmZlciA9IGNvbnRhaW5lckhlaWdodCAqIDM7XG5cbiAgICBpZiAoc2Nyb2xsVG9wICsgc2Nyb2xsQnVmZmVyID4gc2Nyb2xsSGVpZ2h0KSB7XG4gICAgICBmZXRjaE1vcmUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG4iLCIvKipcbiAqIFNjcm9sbENvbnRhaW5lciBpcyBhIHBhc3MtdGhyb3VnaCBjb21wb25lbnQgdGhhdCBzaW1wbHkgc2V0cyB1cCBhbiBvblNjcm9sbFxuICogaGFuZGxlciBvbiB0aGUgZ2l2ZW4gc2Nyb2xsQ29udGFpbmVyIGVsZW1lbnQgKG9yIHRoZSBlbGVtZW50IHRoYXQgaXNcbiAqIHJldHVybmVkIGFzIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBzY3JvbGxDb250YWluZXIgbWV0aG9kKS4gVGhpcyBhbGxvd3MgZm9yXG4gKiB0aGUgZXZlbnQgbGlzdGVuZXIgc3Vic2NyaXB0aW9uIG9mIHRoZSBzY3JvbGxDb250YWluZXIgdG8gYmUgbWFuYWdlZCBpbnNpZGVcbiAqIHRoZSBSZWFjdCBsaWZlY3ljbGUgd2l0aG91dCBhZGRpbmcgYmxvYXQgdG8gTWFzb25yeSBvciBvdGhlciBvblNjcm9sbFxuICogc3Vic2NyaWJlcnMuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgQ29tcG9uZW50IHJlbmRlcnMgaXRzIGNoaWxkcmVuIHdpdGhvdXQgY3JlYXRpbmcgYW55XG4gKiBhZGRpdGlvbmFsIGNvbnRlbnQuIEFsc28gbm90ZSB0aGF0LCB3aGlsZSB0aGUgY29tcG9uZW50IGlzIGJ1aWx0IHRvIG1hbmFnZVxuICogb25TY3JvbGwgaW5zaWRlIG9mIHRoZSBSZWFjdCBsaWZlY3ljbGUsIGl0IGRvZXNuJ3QgY2hhbmdlIG9uU2Nyb2xsIGV2ZW50c1xuICogb3IgdGhlIEFQSSBhdCBhbGwsIHNvIGl0IGNvdWxkIGVhc2lseSBiZSBhZGFwdGVkIHRvIG90aGVyIGV2ZW50IHR5cGVzLlxuICovXG5cbi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG50eXBlIFByb3BzID0ge3xcbiAgY2hpbGRyZW4/OiBSZWFjdC5Ob2RlLFxuICBvblNjcm9sbDogKGV2ZW50OiBFdmVudCkgPT4gdm9pZCxcbiAgc2Nyb2xsQ29udGFpbmVyOiA/SFRNTEVsZW1lbnQgfCAoKCkgPT4gP0hUTUxFbGVtZW50KSxcbnx9O1xuXG5mdW5jdGlvbiBnZXRTY3JvbGxDb250YWluZXIoc2Nyb2xsQ29udGFpbmVyKSB7XG4gIHJldHVybiB0eXBlb2Ygc2Nyb2xsQ29udGFpbmVyID09PSAnZnVuY3Rpb24nXG4gICAgPyBzY3JvbGxDb250YWluZXIoKVxuICAgIDogc2Nyb2xsQ29udGFpbmVyO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTY3JvbGxDb250YWluZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8UHJvcHM+IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUuaXNSZXF1aXJlZCxcbiAgICBvblNjcm9sbDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBzY3JvbGxDb250YWluZXI6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5vYmplY3QsIFByb3BUeXBlcy5mdW5jXSlcbiAgICAgIC5pc1JlcXVpcmVkLFxuICB9O1xuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGNvbnN0IHNjcm9sbENvbnRhaW5lciA9IGdldFNjcm9sbENvbnRhaW5lcih0aGlzLnByb3BzLnNjcm9sbENvbnRhaW5lcik7XG4gICAgaWYgKHNjcm9sbENvbnRhaW5lcikge1xuICAgICAgdGhpcy51cGRhdGVTY3JvbGxDb250YWluZXIoc2Nyb2xsQ29udGFpbmVyKTtcbiAgICB9XG4gIH1cblxuICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgY29uc3QgbmV4dFNjcm9sbENvbnRhaW5lciA9IGdldFNjcm9sbENvbnRhaW5lcih0aGlzLnByb3BzLnNjcm9sbENvbnRhaW5lcik7XG4gICAgaWYgKG5leHRTY3JvbGxDb250YWluZXIgJiYgbmV4dFNjcm9sbENvbnRhaW5lciAhPT0gdGhpcy5zY3JvbGxDb250YWluZXIpIHtcbiAgICAgIHRoaXMudXBkYXRlU2Nyb2xsQ29udGFpbmVyKG5leHRTY3JvbGxDb250YWluZXIpO1xuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGlmICh0aGlzLnNjcm9sbENvbnRhaW5lcikge1xuICAgICAgdGhpcy5zY3JvbGxDb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5oYW5kbGVTY3JvbGwpO1xuICAgIH1cbiAgfVxuXG4gIGdldFNjcm9sbENvbnRhaW5lclJlZiA9ICgpID0+IHRoaXMuc2Nyb2xsQ29udGFpbmVyO1xuXG4gIGhhbmRsZVNjcm9sbCA9IChldmVudDogRXZlbnQpID0+IHtcbiAgICB0aGlzLnByb3BzLm9uU2Nyb2xsKGV2ZW50KTtcbiAgfTtcblxuICB1cGRhdGVTY3JvbGxDb250YWluZXIoc2Nyb2xsQ29udGFpbmVyOiBIVE1MRWxlbWVudCkge1xuICAgIGlmICh0aGlzLnNjcm9sbENvbnRhaW5lcikge1xuICAgICAgLy8gY2xlYW51cCBleGlzdGluZyBzY3JvbGwgY29udGFpbmVyIGlmIGl0IGV4aXN0c1xuICAgICAgdGhpcy5zY3JvbGxDb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5oYW5kbGVTY3JvbGwpO1xuICAgIH1cbiAgICB0aGlzLnNjcm9sbENvbnRhaW5lciA9IHNjcm9sbENvbnRhaW5lcjtcbiAgICB0aGlzLnNjcm9sbENvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLmhhbmRsZVNjcm9sbCk7XG4gIH1cblxuICBzY3JvbGxDb250YWluZXI6ID9IVE1MRWxlbWVudDtcblxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIFJlYWN0LkNoaWxkcmVuLm9ubHkodGhpcy5wcm9wcy5jaGlsZHJlbik7XG4gIH1cbn1cbiIsIi8qKlxuICogdGhyb3R0bGUgbGltaXRzIHRoZSBudW1iZXIgb2YgdGltZXMgYSBmdW5jdGlvbiBjYW4gYmUgY2FsbGVkIHRvIGFcbiAqIGdpdmVuIHRocmVzaGhvbGQgKDEwMG1zIGJ5IGRlZmF1bHQpLiBUaGUgZnVuY3Rpb24gaXMgYWx3YXlzIGNhbGxlZFxuICogb24gdGhlIGxlYWRpbmcgYW5kIHRyYWlsaW5nIGVkZ2UuXG4gKi9cblxuLy8gQGZsb3dcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRocm90dGxlKFxuICBmbjogKC4uLmFyZ3M6ICopID0+IHZvaWQsXG4gIHRocmVzaGhvbGQ6IG51bWJlciA9IDEwMFxuKSB7XG4gIGxldCBsYXN0OiBudW1iZXIgfCB2b2lkO1xuICBsZXQgZGVmZXJUaW1lcjogVGltZW91dElEIHwgdm9pZDtcbiAgY29uc3QgdGhyb3R0bGVkID0gKC4uLmFyZ3M6ICopID0+IHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGlmIChsYXN0ICE9PSB1bmRlZmluZWQgJiYgbm93IC0gbGFzdCA8IHRocmVzaGhvbGQpIHtcbiAgICAgIGNsZWFyVGltZW91dChkZWZlclRpbWVyKTtcbiAgICAgIGRlZmVyVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgbGFzdCA9IG5vdztcbiAgICAgICAgZm4oLi4uYXJncyk7XG4gICAgICB9LCB0aHJlc2hob2xkIC0gKG5vdyAtIGxhc3QpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdCA9IG5vdztcbiAgICAgIGZuKC4uLmFyZ3MpO1xuICAgIH1cbiAgfTtcblxuICB0aHJvdHRsZWQuY2xlYXJUaW1lb3V0ID0gKCkgPT4ge1xuICAgIGlmIChkZWZlclRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQoZGVmZXJUaW1lcik7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB0aHJvdHRsZWQ7XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHR5cGUgeyBDYWNoZSB9IGZyb20gJy4vQ2FjaGUuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNZWFzdXJlbWVudFN0b3JlPFQsIFY+IGltcGxlbWVudHMgQ2FjaGU8VCwgVj4ge1xuICBtYXA6IFdlYWtNYXA8VCwgVj4gPSBuZXcgV2Vha01hcCgpO1xuXG4gIGdldChrZXk6IFQpOiA/ViB7XG4gICAgcmV0dXJuIHRoaXMubWFwLmdldChrZXkpO1xuICB9XG5cbiAgaGFzKGtleTogVCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLm1hcC5oYXMoa2V5KTtcbiAgfVxuXG4gIHNldChrZXk6IFQsIHZhbHVlOiBWKTogdm9pZCB7XG4gICAgdGhpcy5tYXAuc2V0KGtleSwgdmFsdWUpO1xuICB9XG5cbiAgcmVzZXQoKTogdm9pZCB7XG4gICAgdGhpcy5tYXAgPSBuZXcgV2Vha01hcCgpO1xuICB9XG59XG4iLCIvKipcbiAqIE1lYXN1cmluZyBzY3JvbGwgcG9zaXRpb25zLCBlbGVtZW50IGhlaWdodHMsIGV0YyBpcyBkaWZmZXJlbnQgYmV0d2VlblxuICogZGlmZmVyZW50IGJyb3dzZXJzIGFuZCB0aGUgd2luZG93IG9iamVjdCB2cyBvdGhlciBET00gbm9kZXMuIFRoZXNlXG4gKiB1dGlscyBhYnN0cmFjdCBhd2F5IHRoZXNlIGRpZmZlcmVuY2VzLlxuICovXG5cbi8vIEBmbG93XG5leHBvcnQgZnVuY3Rpb24gZ2V0RWxlbWVudEhlaWdodChlbGVtZW50OiBIVE1MRWxlbWVudCk6IG51bWJlciB7XG4gIHJldHVybiBlbGVtZW50ID09PSB3aW5kb3cgPyB3aW5kb3cuaW5uZXJIZWlnaHQgOiBlbGVtZW50LmNsaWVudEhlaWdodDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbFBvcygpIHtcbiAgaWYgKHdpbmRvdy5zY3JvbGxZICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBNb2Rlcm4gYnJvd3NlclxuICAgIHJldHVybiB3aW5kb3cuc2Nyb2xsWTtcbiAgfVxuICBpZiAoXG4gICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmXG4gICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIC8vIElFIHN1cHBvcnQuXG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3A7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZWxhdGl2ZVNjcm9sbFRvcChlbGVtZW50OiBIVE1MRWxlbWVudCk6IG51bWJlciB7XG4gIHJldHVybiBlbGVtZW50ID09PSB3aW5kb3dcbiAgICA/IGdldFdpbmRvd1Njcm9sbFBvcygpXG4gICAgOiBlbGVtZW50LnNjcm9sbFRvcCAtIGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2Nyb2xsSGVpZ2h0KGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogbnVtYmVyIHtcbiAgcmV0dXJuIGVsZW1lbnQgPT09IHdpbmRvdyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRcbiAgICA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHRcbiAgICA6IGVsZW1lbnQuc2Nyb2xsSGVpZ2h0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2Nyb2xsUG9zKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogbnVtYmVyIHtcbiAgcmV0dXJuIGVsZW1lbnQgPT09IHdpbmRvdyA/IGdldFdpbmRvd1Njcm9sbFBvcygpIDogZWxlbWVudC5zY3JvbGxUb3A7XG59XG4iLCIvLyBAZmxvd1xuZXhwb3J0IGNvbnN0IERlZmF1bHRMYXlvdXRTeW1ib2wgPSBTeW1ib2woJ2RlZmF1bHQnKTtcbmV4cG9ydCBjb25zdCBVbmlmb3JtUm93TGF5b3V0U3ltYm9sID0gU3ltYm9sKCd1bmlmb3JtUm93Jyk7XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHR5cGUgeyBDYWNoZSB9IGZyb20gJy4vQ2FjaGUuanMnO1xuXG5leHBvcnQgdHlwZSBQb3NpdGlvbiA9IHtcbiAgdG9wOiBudW1iZXIsXG4gIGxlZnQ6IG51bWJlcixcbiAgd2lkdGg6IG51bWJlcixcbiAgaGVpZ2h0OiBudW1iZXIsXG59O1xuXG5jb25zdCBtaW5kZXggPSBhcnIgPT4ge1xuICBsZXQgaWR4ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAoYXJyW2ldIDwgYXJyW2lkeF0pIHtcbiAgICAgIGlkeCA9IGk7XG4gICAgfVxuICB9XG4gIHJldHVybiBpZHg7XG59O1xuXG5jb25zdCBvZmZzY3JlZW4gPSAod2lkdGgsIGhlaWdodCA9IEluZmluaXR5KSA9PiAoe1xuICB0b3A6IC05OTk5LFxuICBsZWZ0OiAtOTk5OSxcbiAgd2lkdGgsXG4gIGhlaWdodCxcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCA8VD4oe1xuICBjYWNoZSxcbiAgY29sdW1uV2lkdGggPSAyMzYsXG4gIGd1dHRlciA9IDE0LFxuICBtaW5Db2xzID0gMixcbiAgd2lkdGgsXG59OiB7fFxuICBjb2x1bW5XaWR0aD86IG51bWJlcixcbiAgZ3V0dGVyPzogbnVtYmVyLFxuICBjYWNoZTogQ2FjaGU8VCwgbnVtYmVyPixcbiAgbWluQ29scz86IG51bWJlcixcbiAgd2lkdGg/OiA/bnVtYmVyLFxufH0pID0+IChpdGVtczogQXJyYXk8Kj4pOiBBcnJheTxQb3NpdGlvbj4gPT4ge1xuICBpZiAod2lkdGggPT0gbnVsbCkge1xuICAgIHJldHVybiBpdGVtcy5tYXAoKCkgPT4gb2Zmc2NyZWVuKGNvbHVtbldpZHRoKSk7XG4gIH1cblxuICBjb25zdCBjb2x1bW5XaWR0aEFuZEd1dHRlciA9IGNvbHVtbldpZHRoICsgZ3V0dGVyO1xuICBjb25zdCBjb2x1bW5Db3VudCA9IE1hdGgubWF4KFxuICAgIE1hdGguZmxvb3IoKHdpZHRoICsgZ3V0dGVyKSAvIGNvbHVtbldpZHRoQW5kR3V0dGVyKSxcbiAgICBtaW5Db2xzXG4gICk7XG4gIC8vIHRoZSB0b3RhbCBoZWlnaHQgb2YgZWFjaCBjb2x1bW5cbiAgY29uc3QgaGVpZ2h0cyA9IG5ldyBBcnJheShjb2x1bW5Db3VudCkuZmlsbCgwKTtcbiAgY29uc3QgY2VudGVyT2Zmc2V0ID0gTWF0aC5tYXgoXG4gICAgTWF0aC5mbG9vcigod2lkdGggLSBjb2x1bW5XaWR0aEFuZEd1dHRlciAqIGNvbHVtbkNvdW50ICsgZ3V0dGVyKSAvIDIpLFxuICAgIDBcbiAgKTtcblxuICByZXR1cm4gaXRlbXMucmVkdWNlKChhY2MsIGl0ZW0pID0+IHtcbiAgICBjb25zdCBwb3NpdGlvbnMgPSBhY2M7XG4gICAgLy8gJEZsb3dGaXhNZVxuICAgIGNvbnN0IGhlaWdodCA9IGNhY2hlLmdldChpdGVtKTtcbiAgICBsZXQgcG9zaXRpb247XG5cbiAgICBpZiAoaGVpZ2h0ID09IG51bGwpIHtcbiAgICAgIHBvc2l0aW9uID0gb2Zmc2NyZWVuKGNvbHVtbldpZHRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaGVpZ2h0QW5kR3V0dGVyID0gaGVpZ2h0ICsgZ3V0dGVyO1xuICAgICAgY29uc3QgY29sID0gbWluZGV4KGhlaWdodHMpO1xuICAgICAgY29uc3QgdG9wID0gaGVpZ2h0c1tjb2xdO1xuICAgICAgY29uc3QgbGVmdCA9IGNvbCAqIGNvbHVtbldpZHRoQW5kR3V0dGVyICsgY2VudGVyT2Zmc2V0O1xuXG4gICAgICBoZWlnaHRzW2NvbF0gKz0gaGVpZ2h0QW5kR3V0dGVyO1xuICAgICAgcG9zaXRpb24gPSB7IHRvcCwgbGVmdCwgd2lkdGg6IGNvbHVtbldpZHRoLCBoZWlnaHQgfTtcbiAgICB9XG4gICAgcG9zaXRpb25zLnB1c2gocG9zaXRpb24pO1xuICAgIHJldHVybiBwb3NpdGlvbnM7XG4gIH0sIFtdKTtcbn07XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHR5cGUgeyBDYWNoZSB9IGZyb20gJy4vQ2FjaGUuanMnO1xuXG50eXBlIFBvc2l0aW9uID0geyB0b3A6IG51bWJlciwgbGVmdDogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciB9O1xuXG5jb25zdCBvZmZzY3JlZW4gPSAod2lkdGgsIGhlaWdodCA9IEluZmluaXR5KSA9PiAoe1xuICB0b3A6IC05OTk5LFxuICBsZWZ0OiAtOTk5OSxcbiAgd2lkdGgsXG4gIGhlaWdodCxcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCA8VD4oe1xuICBjYWNoZSxcbiAgY29sdW1uV2lkdGggPSAyMzYsXG4gIGd1dHRlciA9IDE0LFxuICB3aWR0aCxcbiAgbWluQ29scyA9IDMsXG59OiB7fFxuICBjYWNoZTogQ2FjaGU8VCwgbnVtYmVyPixcbiAgY29sdW1uV2lkdGg/OiBudW1iZXIsXG4gIGd1dHRlcj86IG51bWJlcixcbiAgd2lkdGg/OiA/bnVtYmVyLFxuICBtaW5Db2xzPzogbnVtYmVyLFxufH0pID0+IChpdGVtczogQXJyYXk8VD4pOiBBcnJheTxQb3NpdGlvbj4gPT4ge1xuICBpZiAod2lkdGggPT0gbnVsbCkge1xuICAgIHJldHVybiBpdGVtcy5tYXAoKCkgPT4gb2Zmc2NyZWVuKGNvbHVtbldpZHRoKSk7XG4gIH1cblxuICBjb25zdCBjb2x1bW5XaWR0aEFuZEd1dHRlciA9IGNvbHVtbldpZHRoICsgZ3V0dGVyO1xuICBjb25zdCBjb2x1bW5Db3VudCA9IE1hdGgubWF4KFxuICAgIE1hdGguZmxvb3IoKHdpZHRoICsgZ3V0dGVyKSAvIGNvbHVtbldpZHRoQW5kR3V0dGVyKSxcbiAgICBtaW5Db2xzXG4gICk7XG5cbiAgY29uc3QgcG9zaXRpb25zID0gW107XG4gIGNvbnN0IGhlaWdodHMgPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgbGV0IHBvc2l0aW9uO1xuICAgIGNvbnN0IGhlaWdodCA9IGNhY2hlLmdldChpdGVtc1tpXSk7XG5cbiAgICBpZiAoaGVpZ2h0ID09IG51bGwpIHtcbiAgICAgIHBvc2l0aW9uID0gb2Zmc2NyZWVuKGNvbHVtbldpZHRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY29sdW1uID0gaSAlIGNvbHVtbkNvdW50O1xuICAgICAgY29uc3Qgcm93ID0gTWF0aC5mbG9vcihpIC8gY29sdW1uQ291bnQpO1xuXG4gICAgICBpZiAoY29sdW1uID09PSAwIHx8IGhlaWdodCA+IGhlaWdodHNbcm93XSkge1xuICAgICAgICBoZWlnaHRzW3Jvd10gPSBoZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRvcCA9XG4gICAgICAgIHJvdyA+IDBcbiAgICAgICAgICA/IGhlaWdodHMuc2xpY2UoMCwgcm93KS5yZWR1Y2UoKHN1bSwgeSkgPT4gc3VtICsgeSArIGd1dHRlciwgMClcbiAgICAgICAgICA6IDA7XG5cbiAgICAgIHBvc2l0aW9uID0ge1xuICAgICAgICB0b3AsXG4gICAgICAgIGxlZnQ6IGNvbHVtbiAqIGNvbHVtbldpZHRoQW5kR3V0dGVyLFxuICAgICAgICB3aWR0aDogY29sdW1uV2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgIH07XG4gICAgfVxuICAgIHBvc2l0aW9ucy5wdXNoKHBvc2l0aW9uKTtcbiAgfVxuICByZXR1cm4gcG9zaXRpb25zO1xufTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgdHlwZSB7IENhY2hlIH0gZnJvbSAnLi9DYWNoZS5qcyc7XG5cbnR5cGUgUG9zaXRpb24gPSB7IHRvcDogbnVtYmVyLCBsZWZ0OiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyIH07XG5cbmNvbnN0IG1pbmRleCA9IGFyciA9PiB7XG4gIGxldCBpZHggPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGlmIChhcnJbaV0gPCBhcnJbaWR4XSkge1xuICAgICAgaWR4ID0gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGlkeDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IDxUPih7XG4gIGd1dHRlciA9IDAsXG4gIGNhY2hlLFxuICBtaW5Db2xzID0gMixcbiAgaWRlYWxDb2x1bW5XaWR0aCA9IDI0MCxcbiAgd2lkdGgsXG59OiB7fFxuICBndXR0ZXI/OiBudW1iZXIsXG4gIGNhY2hlOiBDYWNoZTxULCBudW1iZXI+LFxuICBtaW5Db2xzPzogbnVtYmVyLFxuICBpZGVhbENvbHVtbldpZHRoPzogbnVtYmVyLFxuICB3aWR0aD86ID9udW1iZXIsXG58fSkgPT4ge1xuICBpZiAod2lkdGggPT0gbnVsbCkge1xuICAgIHJldHVybiAoaXRlbXM6IEFycmF5PG1peGVkPik6IEFycmF5PFBvc2l0aW9uPiA9PlxuICAgICAgaXRlbXMubWFwKCgpID0+ICh7XG4gICAgICAgIHRvcDogSW5maW5pdHksXG4gICAgICAgIGxlZnQ6IEluZmluaXR5LFxuICAgICAgICB3aWR0aDogSW5maW5pdHksXG4gICAgICAgIGhlaWdodDogSW5maW5pdHksXG4gICAgICB9KSk7XG4gIH1cblxuICAvLyBcIlRoaXMgaXMga2luZCBvZiBjcmF6eSFcIiAtIHlvdVxuICAvLyBZZXMsIGluZGVlZC4gVGhlIFwiZ3Vlc3NpbmdcIiBoZXJlIGlzIG1lYW50IHRvIHJlcGxpY2F0ZSB0aGUgcGFzcyB0aGF0IHRoZVxuICAvLyBvcmlnaW5hbCBpbXBsZW1lbnRhdGlvbiB0YWtlcyB3aXRoIENTUy5cbiAgY29uc3QgY29sZ3Vlc3MgPSBNYXRoLmZsb29yKHdpZHRoIC8gaWRlYWxDb2x1bW5XaWR0aCk7XG4gIGNvbnN0IGNvbHVtbkNvdW50ID0gTWF0aC5tYXgoXG4gICAgTWF0aC5mbG9vcigod2lkdGggLSBjb2xndWVzcyAqIGd1dHRlcikgLyBpZGVhbENvbHVtbldpZHRoKSxcbiAgICBtaW5Db2xzXG4gICk7XG4gIGNvbnN0IGNvbHVtbldpZHRoID0gTWF0aC5mbG9vcih3aWR0aCAvIGNvbHVtbkNvdW50KTtcblxuICByZXR1cm4gKGl0ZW1zOiBBcnJheTxUPikgPT4ge1xuICAgIC8vIHRoZSB0b3RhbCBoZWlnaHQgb2YgZWFjaCBjb2x1bW5cbiAgICBjb25zdCBoZWlnaHRzID0gbmV3IEFycmF5KGNvbHVtbkNvdW50KS5maWxsKDApO1xuXG4gICAgcmV0dXJuIGl0ZW1zLnJlZHVjZSgoYWNjLCBpdGVtKSA9PiB7XG4gICAgICBjb25zdCBwb3NpdGlvbnMgPSBhY2M7XG4gICAgICBjb25zdCBoZWlnaHQgPSBjYWNoZS5nZXQoaXRlbSk7XG4gICAgICBsZXQgcG9zaXRpb247XG5cbiAgICAgIGlmIChoZWlnaHQgPT0gbnVsbCkge1xuICAgICAgICBwb3NpdGlvbiA9IHtcbiAgICAgICAgICB0b3A6IEluZmluaXR5LFxuICAgICAgICAgIGxlZnQ6IEluZmluaXR5LFxuICAgICAgICAgIHdpZHRoOiBjb2x1bW5XaWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IEluZmluaXR5LFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY29sID0gbWluZGV4KGhlaWdodHMpO1xuICAgICAgICBjb25zdCB0b3AgPSBoZWlnaHRzW2NvbF07XG4gICAgICAgIGNvbnN0IGxlZnQgPSBjb2wgKiBjb2x1bW5XaWR0aCArIGd1dHRlciAvIDI7XG5cbiAgICAgICAgaGVpZ2h0c1tjb2xdICs9IGhlaWdodDtcbiAgICAgICAgcG9zaXRpb24gPSB7XG4gICAgICAgICAgdG9wLFxuICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgd2lkdGg6IGNvbHVtbldpZHRoIC0gZ3V0dGVyLFxuICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcG9zaXRpb25zLnB1c2gocG9zaXRpb24pO1xuICAgICAgcmV0dXJuIHBvc2l0aW9ucztcbiAgICB9LCBbXSk7XG4gIH07XG59O1xuIiwiLy8gQGZsb3dcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hc29ucnlMYXlvdXQge31cbiIsIi8vIEBmbG93XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBVbmlmb3JtUm93TGF5b3V0IHt9XG4iLCIvLyBAZmxvd1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBkZWJvdW5jZSBmcm9tICcuL2RlYm91bmNlLmpzJztcbmltcG9ydCBGZXRjaEl0ZW1zIGZyb20gJy4vRmV0Y2hJdGVtcy5qcyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vTWFzb25yeS5jc3MnO1xuaW1wb3J0IFNjcm9sbENvbnRhaW5lciBmcm9tICcuL1Njcm9sbENvbnRhaW5lci5qcyc7XG5pbXBvcnQgdGhyb3R0bGUgZnJvbSAnLi90aHJvdHRsZS5qcyc7XG5pbXBvcnQgdHlwZSB7IENhY2hlIH0gZnJvbSAnLi9DYWNoZS5qcyc7XG5pbXBvcnQgTWVhc3VyZW1lbnRTdG9yZSBmcm9tICcuL01lYXN1cmVtZW50U3RvcmUuanMnO1xuaW1wb3J0IHtcbiAgZ2V0RWxlbWVudEhlaWdodCxcbiAgZ2V0UmVsYXRpdmVTY3JvbGxUb3AsXG4gIGdldFNjcm9sbFBvcyxcbn0gZnJvbSAnLi9zY3JvbGxVdGlscy5qcyc7XG5pbXBvcnQge1xuICBEZWZhdWx0TGF5b3V0U3ltYm9sLFxuICBVbmlmb3JtUm93TGF5b3V0U3ltYm9sLFxufSBmcm9tICcuL2xlZ2FjeUxheW91dFN5bWJvbHMuanMnO1xuaW1wb3J0IGRlZmF1bHRMYXlvdXQgZnJvbSAnLi9kZWZhdWx0TGF5b3V0LmpzJztcbmltcG9ydCB1bmlmb3JtUm93TGF5b3V0IGZyb20gJy4vdW5pZm9ybVJvd0xheW91dC5qcyc7XG5pbXBvcnQgZnVsbFdpZHRoTGF5b3V0IGZyb20gJy4vZnVsbFdpZHRoTGF5b3V0LmpzJztcbmltcG9ydCBMZWdhY3lNYXNvbnJ5TGF5b3V0IGZyb20gJy4vbGF5b3V0cy9NYXNvbnJ5TGF5b3V0LmpzJztcbmltcG9ydCBMZWdhY3lVbmlmb3JtUm93TGF5b3V0IGZyb20gJy4vbGF5b3V0cy9Vbmlmb3JtUm93TGF5b3V0LmpzJztcblxudHlwZSBMYXlvdXQgPVxuICB8IHR5cGVvZiBEZWZhdWx0TGF5b3V0U3ltYm9sXG4gIHwgdHlwZW9mIFVuaWZvcm1Sb3dMYXlvdXRTeW1ib2xcbiAgfCBMZWdhY3lNYXNvbnJ5TGF5b3V0XG4gIHwgTGVnYWN5VW5pZm9ybVJvd0xheW91dDtcblxudHlwZSBQcm9wczxUPiA9IHt8XG4gIGNvbHVtbldpZHRoPzogbnVtYmVyLFxuICBjb21wOiBSZWFjdC5Db21wb25lbnRUeXBlPHtcbiAgICBkYXRhOiBULFxuICAgIGl0ZW1JZHg6IG51bWJlcixcbiAgICBpc01lYXN1cmluZzogYm9vbGVhbixcbiAgfT4sXG4gIGZsZXhpYmxlPzogYm9vbGVhbixcbiAgZ3V0dGVyV2lkdGg/OiBudW1iZXIsXG4gIGl0ZW1zOiBBcnJheTxUPixcbiAgbWVhc3VyZW1lbnRTdG9yZTogQ2FjaGU8VCwgKj4sXG4gIG1pbkNvbHM6IG51bWJlcixcbiAgbGF5b3V0PzogTGF5b3V0LFxuICAvLyBTdXBwb3J0IGxlZ2FjeSBsb2FkSXRlbXMgdXNhZ2UuXG4gIC8vIFRPRE86IFNpbXBsaWZ5IG5vbiBmYWxzZXkgZmxvd3R5cGUuXG4gIGxvYWRJdGVtcz86XG4gICAgfCBmYWxzZVxuICAgIHwgKChcbiAgICAgICAgP3tcbiAgICAgICAgICBmcm9tOiBudW1iZXIsXG4gICAgICAgIH1cbiAgICAgICkgPT4gdm9pZCB8IGJvb2xlYW4gfCB7fSksXG4gIHNjcm9sbENvbnRhaW5lcj86ICgpID0+IEhUTUxFbGVtZW50LFxuICB2aXJ0dWFsQm91bmRzVG9wPzogbnVtYmVyLFxuICB2aXJ0dWFsQm91bmRzQm90dG9tPzogbnVtYmVyLFxuICB2aXJ0dWFsaXplPzogYm9vbGVhbixcbnx9O1xuXG50eXBlIFN0YXRlPFQ+ID0ge3xcbiAgaGFzUGVuZGluZ01lYXN1cmVtZW50czogYm9vbGVhbixcbiAgaXNGZXRjaGluZzogYm9vbGVhbixcbiAgaXRlbXM6IEFycmF5PFQ+LFxuICBzY3JvbGxUb3A6IG51bWJlcixcbiAgd2lkdGg6ID9udW1iZXIsXG58fTtcblxuY29uc3QgUkVTSVpFX0RFQk9VTkNFID0gMzAwO1xuLy8gTXVsdGlwbGllZCBhZ2FpbnN0IGNvbnRhaW5lciBoZWlnaHQuXG4vLyBUaGUgYW1vdW50IG9mIGV4dHJhIGJ1ZmZlciBzcGFjZSBmb3IgcG9wdWxhdGluZyB2aXNpYmxlIGl0ZW1zLlxuY29uc3QgVklSVFVBTF9CVUZGRVJfRkFDVE9SID0gMC43O1xuXG5jb25zdCBsYXlvdXROdW1iZXJUb0Nzc0RpbWVuc2lvbiA9IG4gPT4gKG4gIT09IEluZmluaXR5ID8gbiA6IHVuZGVmaW5lZCk7XG5cbi8qKlxuICogTk9URTogVGhpcyBpcyB0byBiZSByZXBsYWNlZCBieSBNYXNvbnJ5SW5maW5pdGVCZXRhIHdoZW4gaXQgaXMgcmVhZHlcbiAqIE5PVEU6IFBsZWFzZSBkbyBub3QgbW9kaWZ5IHRoaXMgb3IgbWFrZSBzdXJlIGNoYW5nZXMgaW4gaGVyZSBhcmUgYWxzb1xuICogICAgICAgcmVwbGljYXRlZCBpbiBNYXNvbnJ5QmV0YS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFzb25yeTxUPiBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxQcm9wczxUPiwgU3RhdGU8VD4+IHtcbiAgc3RhdGljIGNyZWF0ZU1lYXN1cmVtZW50U3RvcmUoKSB7XG4gICAgcmV0dXJuIG5ldyBNZWFzdXJlbWVudFN0b3JlKCk7XG4gIH1cblxuICAvKipcbiAgICogRGVsYXlzIHJlc2l6ZSBoYW5kbGluZyBpbiBjYXNlIHRoZSBzY3JvbGwgY29udGFpbmVyIGlzIHN0aWxsIGJlaW5nIHJlc2l6ZWQuXG4gICAqL1xuICBoYW5kbGVSZXNpemUgPSBkZWJvdW5jZSgoKSA9PiB7XG4gICAgaWYgKHRoaXMuZ3JpZFdyYXBwZXIpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyB3aWR0aDogdGhpcy5ncmlkV3JhcHBlci5jbGllbnRXaWR0aCB9KTtcbiAgICB9XG4gIH0sIFJFU0laRV9ERUJPVU5DRSk7XG5cbiAgdXBkYXRlU2Nyb2xsUG9zaXRpb24gPSB0aHJvdHRsZSgoKSA9PiB7XG4gICAgaWYgKCF0aGlzLnNjcm9sbENvbnRhaW5lcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzY3JvbGxDb250YWluZXIgPSB0aGlzLnNjcm9sbENvbnRhaW5lci5nZXRTY3JvbGxDb250YWluZXJSZWYoKTtcblxuICAgIGlmICghc2Nyb2xsQ29udGFpbmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBzY3JvbGxUb3A6IGdldFNjcm9sbFBvcyhzY3JvbGxDb250YWluZXIpLFxuICAgIH0pO1xuICB9KTtcblxuICBtZWFzdXJlQ29udGFpbmVyQXN5bmMgPSBkZWJvdW5jZSgoKSA9PiB7XG4gICAgdGhpcy5tZWFzdXJlQ29udGFpbmVyKCk7XG4gIH0sIDApO1xuXG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgLyoqXG4gICAgICogVGhlIHByZWZlcnJlZC90YXJnZXQgaXRlbSB3aWR0aC4gSWYgYGZsZXhpYmxlYCBpcyBzZXQsIHRoZSBpdGVtIHdpZHRoIHdpbGxcbiAgICAgKiBncm93IHRvIGZpbGwgY29sdW1uIHNwYWNlLCBhbmQgc2hyaW5rIHRvIGZpdCBpZiBiZWxvdyBtaW4gY29sdW1ucy5cbiAgICAgKi9cbiAgICBjb2x1bW5XaWR0aDogUHJvcFR5cGVzLm51bWJlcixcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb21wb25lbnQgdG8gcmVuZGVyLlxuICAgICAqL1xuICAgIC8qIGVzbGludCByZWFjdC9uby11bnVzZWQtcHJvcC10eXBlczogMCAqL1xuICAgIGNvbXA6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgcHJlZmVycmVkL3RhcmdldCBpdGVtIHdpZHRoLiBJdGVtIHdpZHRoIHdpbGwgZ3JvdyB0byBmaWxsXG4gICAgICogY29sdW1uIHNwYWNlLCBhbmQgc2hyaW5rIHRvIGZpdCBpZiBiZWxvdyBtaW4gY29sdW1ucy5cbiAgICAgKi9cbiAgICBmbGV4aWJsZTogUHJvcFR5cGVzLmJvb2wsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgYW1vdW50IG9mIHNwYWNlIGJldHdlZW4gZWFjaCBpdGVtLlxuICAgICAqL1xuICAgIGd1dHRlcldpZHRoOiBQcm9wVHlwZXMubnVtYmVyLFxuXG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgYWxsIG9iamVjdHMgdG8gZGlzcGxheSBpbiB0aGUgZ3JpZC5cbiAgICAgKi9cbiAgICBpdGVtczogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLnNoYXBlKHt9KSkuaXNSZXF1aXJlZCxcblxuICAgIC8qKlxuICAgICAqIE1lYXN1cmVtZW50IFN0b3JlXG4gICAgICovXG4gICAgbWVhc3VyZW1lbnRTdG9yZTogUHJvcFR5cGVzLmluc3RhbmNlT2YoTWVhc3VyZW1lbnRTdG9yZSksXG5cbiAgICAvKipcbiAgICAgKiBMYXlvdXQgc3lzdGVtIHRvIHVzZSBmb3IgaXRlbXNcbiAgICAgKi9cbiAgICBsYXlvdXQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xuICAgICAgUHJvcFR5cGVzLmluc3RhbmNlT2YoTGVnYWN5TWFzb25yeUxheW91dCksXG4gICAgICBQcm9wVHlwZXMuaW5zdGFuY2VPZihMZWdhY3lVbmlmb3JtUm93TGF5b3V0KSxcbiAgICAgIFByb3BUeXBlcy5zeW1ib2wsXG4gICAgXSksXG5cbiAgICAvKipcbiAgICAgKiBBIGNhbGxiYWNrIHdoaWNoIHRoZSBncmlkIGNhbGxzIHdoZW4gd2UgbmVlZCB0byBsb2FkIG1vcmUgaXRlbXMgYXMgdGhlIHVzZXIgc2Nyb2xscy5cbiAgICAgKiBUaGUgY2FsbGJhY2sgc2hvdWxkIHVwZGF0ZSB0aGUgc3RhdGUgb2YgdGhlIGl0ZW1zLCBhbmQgcGFzcyB0aG9zZSBpbiBhcyBwcm9wc1xuICAgICAqIHRvIHRoaXMgY29tcG9uZW50LlxuICAgICAqL1xuICAgIGxvYWRJdGVtczogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgICAvKipcbiAgICAgKiBNaW5pbXVtIG51bWJlciBvZiBjb2x1bW5zIHRvIGRpc3BsYXkuXG4gICAgICovXG4gICAgbWluQ29sczogUHJvcFR5cGVzLm51bWJlcixcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRoYXQgdGhlIGdyaWQgY2FsbHMgdG8gZ2V0IHRoZSBzY3JvbGwgY29udGFpbmVyLlxuICAgICAqIFRoaXMgaXMgcmVxdWlyZWQgaWYgdGhlIGdyaWQgaXMgZXhwZWN0ZWQgdG8gYmUgc2Nyb2xsYWJsZS5cbiAgICAgKi9cbiAgICBzY3JvbGxDb250YWluZXI6IFByb3BUeXBlcy5mdW5jLFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBvciBub3QgdG8gdXNlIGFjdHVhbCB2aXJ0dWFsaXphdGlvblxuICAgICAqL1xuICAgIHZpcnR1YWxpemU6IFByb3BUeXBlcy5ib29sLFxuICB9O1xuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgY29sdW1uV2lkdGg6IDIzNixcbiAgICBtZWFzdXJlbWVudFN0b3JlOiBuZXcgTWVhc3VyZW1lbnRTdG9yZSgpLFxuICAgIG1pbkNvbHM6IDMsXG4gICAgbGF5b3V0OiBEZWZhdWx0TGF5b3V0U3ltYm9sLFxuICAgIGxvYWRJdGVtczogKCkgPT4ge30sXG4gICAgdmlydHVhbGl6ZTogZmFsc2UsXG4gIH07XG5cbiAgY29uc3RydWN0b3IocHJvcHM6IFByb3BzPFQ+KSB7XG4gICAgc3VwZXIocHJvcHMpO1xuXG4gICAgdGhpcy5jb250YWluZXJIZWlnaHQgPSAwO1xuICAgIHRoaXMuY29udGFpbmVyT2Zmc2V0ID0gMDtcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBoYXNQZW5kaW5nTWVhc3VyZW1lbnRzOiBwcm9wcy5pdGVtcy5zb21lKFxuICAgICAgICBpdGVtID0+ICEhaXRlbSAmJiAhcHJvcHMubWVhc3VyZW1lbnRTdG9yZS5oYXMoaXRlbSlcbiAgICAgICksXG4gICAgICBpc0ZldGNoaW5nOiBmYWxzZSxcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9uby11bnVzZWQtc3RhdGVcbiAgICAgIGl0ZW1zOiBwcm9wcy5pdGVtcyxcbiAgICAgIHNjcm9sbFRvcDogMCxcbiAgICAgIHdpZHRoOiB1bmRlZmluZWQsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGhvb2tzIGFmdGVyIHRoZSBjb21wb25lbnQgbW91bnRzLlxuICAgKi9cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuaGFuZGxlUmVzaXplKTtcblxuICAgIHRoaXMubWVhc3VyZUNvbnRhaW5lcigpO1xuXG4gICAgbGV0IHsgc2Nyb2xsVG9wIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmICh0aGlzLnNjcm9sbENvbnRhaW5lciAhPSBudWxsKSB7XG4gICAgICBjb25zdCBzY3JvbGxDb250YWluZXIgPSB0aGlzLnNjcm9sbENvbnRhaW5lci5nZXRTY3JvbGxDb250YWluZXJSZWYoKTtcbiAgICAgIGlmIChzY3JvbGxDb250YWluZXIpIHtcbiAgICAgICAgc2Nyb2xsVG9wID0gZ2V0U2Nyb2xsUG9zKHNjcm9sbENvbnRhaW5lcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zZXRTdGF0ZShwcmV2U3RhdGUgPT4gKHtcbiAgICAgIHNjcm9sbFRvcCxcbiAgICAgIHdpZHRoOiB0aGlzLmdyaWRXcmFwcGVyID8gdGhpcy5ncmlkV3JhcHBlci5jbGllbnRXaWR0aCA6IHByZXZTdGF0ZS53aWR0aCxcbiAgICB9KSk7XG4gIH1cblxuICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzOiBQcm9wczxUPiwgcHJldlN0YXRlOiBTdGF0ZTxUPikge1xuICAgIGNvbnN0IHsgaXRlbXMsIG1lYXN1cmVtZW50U3RvcmUgfSA9IHRoaXMucHJvcHM7XG5cbiAgICB0aGlzLm1lYXN1cmVDb250YWluZXJBc3luYygpO1xuXG4gICAgaWYgKHByZXZTdGF0ZS53aWR0aCAhPSBudWxsICYmIHRoaXMuc3RhdGUud2lkdGggIT09IHByZXZTdGF0ZS53aWR0aCkge1xuICAgICAgbWVhc3VyZW1lbnRTdG9yZS5yZXNldCgpO1xuICAgIH1cbiAgICAvLyBjYWxjdWxhdGUgd2hldGhlciB3ZSBzdGlsbCBoYXZlIHBlbmRpbmcgbWVhc3VyZW1lbnRzXG4gICAgY29uc3QgaGFzUGVuZGluZ01lYXN1cmVtZW50cyA9IGl0ZW1zLnNvbWUoXG4gICAgICBpdGVtID0+ICEhaXRlbSAmJiAhbWVhc3VyZW1lbnRTdG9yZS5oYXMoaXRlbSlcbiAgICApO1xuICAgIGlmIChcbiAgICAgIGhhc1BlbmRpbmdNZWFzdXJlbWVudHMgfHxcbiAgICAgIGhhc1BlbmRpbmdNZWFzdXJlbWVudHMgIT09IHRoaXMuc3RhdGUuaGFzUGVuZGluZ01lYXN1cmVtZW50cyB8fFxuICAgICAgcHJldlN0YXRlLndpZHRoID09IG51bGxcbiAgICApIHtcbiAgICAgIHRoaXMuaW5zZXJ0QW5pbWF0aW9uRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBoYXNQZW5kaW5nTWVhc3VyZW1lbnRzLFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgbGlzdGVuZXJzIHdoZW4gdW5tb3VudGluZy5cbiAgICovXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGlmICh0aGlzLmluc2VydEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmluc2VydEFuaW1hdGlvbkZyYW1lKTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgYXN5bmMgbWV0aG9kcyBhcmUgY2FuY2VsbGVkLlxuICAgIHRoaXMubWVhc3VyZUNvbnRhaW5lckFzeW5jLmNsZWFyVGltZW91dCgpO1xuICAgIHRoaXMuaGFuZGxlUmVzaXplLmNsZWFyVGltZW91dCgpO1xuICAgIHRoaXMudXBkYXRlU2Nyb2xsUG9zaXRpb24uY2xlYXJUaW1lb3V0KCk7XG5cbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5oYW5kbGVSZXNpemUpO1xuICB9XG5cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhwcm9wczogUHJvcHM8VD4sIHN0YXRlOiBTdGF0ZTxUPikge1xuICAgIGNvbnN0IHsgaXRlbXMsIG1lYXN1cmVtZW50U3RvcmUgfSA9IHByb3BzO1xuICAgIC8vIHdoZW5ldmVyIHdlJ3JlIHJlY2VpdmluZyBuZXcgcHJvcHMsIGRldGVybWluZSB3aGV0aGVyIGFueSBpdGVtcyBuZWVkIHRvIGJlIG1lYXN1cmVkXG4gICAgLy8gVE9ETyAtIHdlIHNob3VsZCB0cmVhdCBpdGVtcyBhcyBpbW11dGFibGVcbiAgICBjb25zdCBoYXNQZW5kaW5nTWVhc3VyZW1lbnRzID0gaXRlbXMuc29tZShcbiAgICAgIGl0ZW0gPT4gIW1lYXN1cmVtZW50U3RvcmUuaGFzKGl0ZW0pXG4gICAgKTtcblxuICAgIC8vIFNoYWxsb3cgY29tcGFyZSBhbGwgaXRlbXMsIGlmIGFueSBjaGFuZ2UgcmVmbG93IHRoZSBncmlkLlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCBvZiBvdXIgY3VycmVudCBwcm9wcyBhbmQgZXZlcnl0aGluZyBtYXRjaGVzLlxuICAgICAgLy8gSWYgd2UgaGl0IHRoaXMgY2FzZSBpdCBtZWFucyB3ZSBuZWVkIHRvIGluc2VydCBuZXcgaXRlbXMuXG4gICAgICBpZiAoc3RhdGUuaXRlbXNbaV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGhhc1BlbmRpbmdNZWFzdXJlbWVudHMsXG4gICAgICAgICAgaXRlbXMsXG4gICAgICAgICAgaXNGZXRjaGluZzogZmFsc2UsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIFJlc2V0IGdyaWQgaXRlbXMgd2hlbjpcbiAgICAgIGlmIChcbiAgICAgICAgLy8gQW4gaXRlbSBvYmplY3QgcmVmIGRvZXMgbm90IG1hdGNoLlxuICAgICAgICBpdGVtc1tpXSAhPT0gc3RhdGUuaXRlbXNbaV0gfHxcbiAgICAgICAgLy8gT3IgbGVzcyBpdGVtcyB0aGFuIHdlIGN1cnJlbnRseSBoYXZlIGFyZSBwYXNzZWQgaW4uXG4gICAgICAgIGl0ZW1zLmxlbmd0aCA8IHN0YXRlLml0ZW1zLmxlbmd0aFxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaGFzUGVuZGluZ01lYXN1cmVtZW50cyxcbiAgICAgICAgICBpdGVtcyxcbiAgICAgICAgICBpc0ZldGNoaW5nOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXNldCBpdGVtcyBpZiBuZXcgaXRlbXMgYXJyYXkgaXMgZW1wdHkuXG4gICAgaWYgKGl0ZW1zLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5pdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBoYXNQZW5kaW5nTWVhc3VyZW1lbnRzLFxuICAgICAgICBpdGVtcyxcbiAgICAgICAgaXNGZXRjaGluZzogZmFsc2UsXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoaGFzUGVuZGluZ01lYXN1cmVtZW50cyAhPT0gc3RhdGUuaGFzUGVuZGluZ01lYXN1cmVtZW50cykge1xuICAgICAgLy8gbWFrZSBzdXJlIHdlIGFsd2F5cyB1cGRhdGUgaGFzUGVuZGluZ01lYXN1cmVtZW50c1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaGFzUGVuZGluZ01lYXN1cmVtZW50cyxcbiAgICAgICAgaXRlbXMsXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIFJldHVybiBudWxsIHRvIGluZGljYXRlIG5vIGNoYW5nZSB0byBzdGF0ZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHNldEdyaWRXcmFwcGVyUmVmID0gKHJlZjogP0hUTUxFbGVtZW50KSA9PiB7XG4gICAgdGhpcy5ncmlkV3JhcHBlciA9IHJlZjtcbiAgfTtcblxuICBzZXRTY3JvbGxDb250YWluZXJSZWYgPSAocmVmOiA/U2Nyb2xsQ29udGFpbmVyKSA9PiB7XG4gICAgdGhpcy5zY3JvbGxDb250YWluZXIgPSByZWY7XG4gIH07XG5cbiAgZmV0Y2hNb3JlID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgbG9hZEl0ZW1zIH0gPSB0aGlzLnByb3BzO1xuICAgIGlmIChsb2FkSXRlbXMgJiYgdHlwZW9mIGxvYWRJdGVtcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5zZXRTdGF0ZShcbiAgICAgICAge1xuICAgICAgICAgIGlzRmV0Y2hpbmc6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgICgpID0+IGxvYWRJdGVtcyh7IGZyb206IHRoaXMucHJvcHMuaXRlbXMubGVuZ3RoIH0pXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICBjb250YWluZXJIZWlnaHQ6IG51bWJlcjtcblxuICBjb250YWluZXJPZmZzZXQ6IG51bWJlcjtcblxuICBncmlkV3JhcHBlcjogP0hUTUxFbGVtZW50O1xuXG4gIGluc2VydEFuaW1hdGlvbkZyYW1lOiBBbmltYXRpb25GcmFtZUlEO1xuXG4gIG1lYXN1cmVUaW1lb3V0OiBUaW1lb3V0SUQ7XG5cbiAgc2Nyb2xsQ29udGFpbmVyOiA/U2Nyb2xsQ29udGFpbmVyO1xuXG4gIG1lYXN1cmVDb250YWluZXIoKSB7XG4gICAgaWYgKHRoaXMuc2Nyb2xsQ29udGFpbmVyICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHsgc2Nyb2xsQ29udGFpbmVyIH0gPSB0aGlzO1xuICAgICAgY29uc3Qgc2Nyb2xsQ29udGFpbmVyUmVmID0gc2Nyb2xsQ29udGFpbmVyLmdldFNjcm9sbENvbnRhaW5lclJlZigpO1xuICAgICAgaWYgKHNjcm9sbENvbnRhaW5lclJlZikge1xuICAgICAgICB0aGlzLmNvbnRhaW5lckhlaWdodCA9IGdldEVsZW1lbnRIZWlnaHQoc2Nyb2xsQ29udGFpbmVyUmVmKTtcbiAgICAgICAgY29uc3QgZWwgPSB0aGlzLmdyaWRXcmFwcGVyO1xuICAgICAgICBpZiAoZWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgIGNvbnN0IHJlbGF0aXZlU2Nyb2xsVG9wID0gZ2V0UmVsYXRpdmVTY3JvbGxUb3Aoc2Nyb2xsQ29udGFpbmVyUmVmKTtcbiAgICAgICAgICB0aGlzLmNvbnRhaW5lck9mZnNldCA9XG4gICAgICAgICAgICBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKyByZWxhdGl2ZVNjcm9sbFRvcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhciBtZWFzdXJlbWVudHMvcG9zaXRpb25zIGFuZCBmb3JjZSBhIHJlZmxvdyBvZiB0aGUgZW50aXJlIGdyaWQuXG4gICAqIE9ubHkgdXNlIHRoaXMgaWYgYWJzb2x1dGVseSBuZWNlc3NhcnkgLSBleDogV2UgbmVlZCB0byByZWZsb3cgaXRlbXMgaWYgdGhlXG4gICAqIG51bWJlciBvZiBjb2x1bW5zIHdlIHdvdWxkIGRpc3BsYXkgc2hvdWxkIGNoYW5nZSBhZnRlciBhIHJlc2l6ZS5cbiAgICovXG4gIHJlZmxvdygpIHtcbiAgICB0aGlzLnByb3BzLm1lYXN1cmVtZW50U3RvcmUucmVzZXQoKTtcbiAgICB0aGlzLm1lYXN1cmVDb250YWluZXIoKTtcbiAgICB0aGlzLmZvcmNlVXBkYXRlKCk7XG4gIH1cblxuICByZW5kZXJNYXNvbnJ5Q29tcG9uZW50ID0gKGl0ZW1EYXRhOiBULCBpZHg6IG51bWJlciwgcG9zaXRpb246ICopID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBjb21wOiBDb21wb25lbnQsXG4gICAgICB2aXJ0dWFsaXplLFxuICAgICAgdmlydHVhbEJvdW5kc1RvcCxcbiAgICAgIHZpcnR1YWxCb3VuZHNCb3R0b20sXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgeyB0b3AsIGxlZnQsIHdpZHRoLCBoZWlnaHQgfSA9IHBvc2l0aW9uO1xuXG4gICAgbGV0IGlzVmlzaWJsZTtcbiAgICBpZiAodGhpcy5wcm9wcy5zY3JvbGxDb250YWluZXIpIHtcbiAgICAgIGNvbnN0IHZpcnR1YWxCdWZmZXIgPSB0aGlzLmNvbnRhaW5lckhlaWdodCAqIFZJUlRVQUxfQlVGRkVSX0ZBQ1RPUjtcbiAgICAgIGNvbnN0IG9mZnNldFNjcm9sbFBvcyA9IHRoaXMuc3RhdGUuc2Nyb2xsVG9wIC0gdGhpcy5jb250YWluZXJPZmZzZXQ7XG4gICAgICBjb25zdCB2aWV3cG9ydFRvcCA9IHZpcnR1YWxCb3VuZHNUb3BcbiAgICAgICAgPyBvZmZzZXRTY3JvbGxQb3MgLSB2aXJ0dWFsQm91bmRzVG9wXG4gICAgICAgIDogb2Zmc2V0U2Nyb2xsUG9zIC0gdmlydHVhbEJ1ZmZlcjtcbiAgICAgIGNvbnN0IHZpZXdwb3J0Qm90dG9tID0gdmlydHVhbEJvdW5kc0JvdHRvbVxuICAgICAgICA/IG9mZnNldFNjcm9sbFBvcyArIHRoaXMuY29udGFpbmVySGVpZ2h0ICsgdmlydHVhbEJvdW5kc0JvdHRvbVxuICAgICAgICA6IG9mZnNldFNjcm9sbFBvcyArIHRoaXMuY29udGFpbmVySGVpZ2h0ICsgdmlydHVhbEJ1ZmZlcjtcblxuICAgICAgaXNWaXNpYmxlID0gIShcbiAgICAgICAgcG9zaXRpb24udG9wICsgcG9zaXRpb24uaGVpZ2h0IDwgdmlld3BvcnRUb3AgfHxcbiAgICAgICAgcG9zaXRpb24udG9wID4gdmlld3BvcnRCb3R0b21cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIG5vIHNjcm9sbCBjb250YWluZXIgaXMgcGFzc2VkIGluLCBpdGVtcyBzaG91bGQgYWx3YXlzIGJlIHZpc2libGVcbiAgICAgIGlzVmlzaWJsZSA9IHRydWU7XG4gICAgfVxuXG4gICAgY29uc3QgaXRlbUNvbXBvbmVudCA9IChcbiAgICAgIDxkaXZcbiAgICAgICAga2V5PXtgaXRlbS0ke2lkeH1gfVxuICAgICAgICBjbGFzc05hbWU9e1tzdHlsZXMuTWFzb25yeV9fSXRlbSwgc3R5bGVzLk1hc29ucnlfX0l0ZW1fX01vdW50ZWRdLmpvaW4oXG4gICAgICAgICAgJyAnXG4gICAgICAgICl9XG4gICAgICAgIGRhdGEtZ3JpZC1pdGVtXG4gICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlWCgke2xlZnR9cHgpIHRyYW5zbGF0ZVkoJHt0b3B9cHgpYCxcbiAgICAgICAgICBXZWJraXRUcmFuc2Zvcm06IGB0cmFuc2xhdGVYKCR7bGVmdH1weCkgdHJhbnNsYXRlWSgke3RvcH1weClgLFxuICAgICAgICAgIHdpZHRoOiBsYXlvdXROdW1iZXJUb0Nzc0RpbWVuc2lvbih3aWR0aCksXG4gICAgICAgICAgaGVpZ2h0OiBsYXlvdXROdW1iZXJUb0Nzc0RpbWVuc2lvbihoZWlnaHQpLFxuICAgICAgICB9fVxuICAgICAgPlxuICAgICAgICA8Q29tcG9uZW50IGRhdGE9e2l0ZW1EYXRhfSBpdGVtSWR4PXtpZHh9IGlzTWVhc3VyaW5nPXtmYWxzZX0gLz5cbiAgICAgIDwvZGl2PlxuICAgICk7XG5cbiAgICByZXR1cm4gdmlydHVhbGl6ZSA/IChpc1Zpc2libGUgJiYgaXRlbUNvbXBvbmVudCkgfHwgbnVsbCA6IGl0ZW1Db21wb25lbnQ7XG4gIH07XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbHVtbldpZHRoLFxuICAgICAgY29tcDogQ29tcG9uZW50LFxuICAgICAgZmxleGlibGUsXG4gICAgICBndXR0ZXJXaWR0aDogZ3V0dGVyLFxuICAgICAgbWVhc3VyZW1lbnRTdG9yZSxcbiAgICAgIGl0ZW1zLFxuICAgICAgbWluQ29scyxcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IGhhc1BlbmRpbmdNZWFzdXJlbWVudHMsIHdpZHRoIH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgbGV0IGxheW91dDtcbiAgICBpZiAoZmxleGlibGUgJiYgd2lkdGggIT09IG51bGwpIHtcbiAgICAgIGxheW91dCA9IGZ1bGxXaWR0aExheW91dCh7XG4gICAgICAgIGd1dHRlcixcbiAgICAgICAgY2FjaGU6IG1lYXN1cmVtZW50U3RvcmUsXG4gICAgICAgIG1pbkNvbHMsXG4gICAgICAgIGlkZWFsQ29sdW1uV2lkdGg6IGNvbHVtbldpZHRoLFxuICAgICAgICB3aWR0aCxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICB0aGlzLnByb3BzLmxheW91dCA9PT0gVW5pZm9ybVJvd0xheW91dFN5bWJvbCB8fFxuICAgICAgdGhpcy5wcm9wcy5sYXlvdXQgaW5zdGFuY2VvZiBMZWdhY3lVbmlmb3JtUm93TGF5b3V0XG4gICAgKSB7XG4gICAgICBsYXlvdXQgPSB1bmlmb3JtUm93TGF5b3V0KHtcbiAgICAgICAgY2FjaGU6IG1lYXN1cmVtZW50U3RvcmUsXG4gICAgICAgIGNvbHVtbldpZHRoLFxuICAgICAgICBndXR0ZXIsXG4gICAgICAgIG1pbkNvbHMsXG4gICAgICAgIHdpZHRoLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxheW91dCA9IGRlZmF1bHRMYXlvdXQoe1xuICAgICAgICBjYWNoZTogbWVhc3VyZW1lbnRTdG9yZSxcbiAgICAgICAgY29sdW1uV2lkdGgsXG4gICAgICAgIGd1dHRlcixcbiAgICAgICAgbWluQ29scyxcbiAgICAgICAgd2lkdGgsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBsZXQgZ3JpZEJvZHk7XG4gICAgaWYgKHdpZHRoID09IG51bGwgJiYgaGFzUGVuZGluZ01lYXN1cmVtZW50cykge1xuICAgICAgLy8gV2hlbiBoeXJkYXRpbmcgZnJvbSBhIHNlcnZlciByZW5kZXIsIHdlIGRvbid0IGhhdmUgdGhlIHdpZHRoIG9mIHRoZSBncmlkXG4gICAgICAvLyBhbmQgdGhlIG1lYXN1cmVtZW50IHN0b3JlIGlzIGVtcHR5XG4gICAgICBncmlkQm9keSA9IChcbiAgICAgICAgPGRpdlxuICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLk1hc29ucnl9XG4gICAgICAgICAgc3R5bGU9e3sgaGVpZ2h0OiAwLCB3aWR0aDogJzEwMCUnIH19XG4gICAgICAgICAgcmVmPXt0aGlzLnNldEdyaWRXcmFwcGVyUmVmfVxuICAgICAgICA+XG4gICAgICAgICAge2l0ZW1zLmZpbHRlcihpdGVtID0+IGl0ZW0pLm1hcCgoaXRlbSwgaSkgPT4gKFxuICAgICAgICAgICAgPGRpdiAvLyBrZWVwIHRoaXMgaW4gc3luYyB3aXRoIHJlbmRlck1hc29ucnlDb21wb25lbnRcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwic3RhdGljXCJcbiAgICAgICAgICAgICAgZGF0YS1ncmlkLWl0ZW1cbiAgICAgICAgICAgICAga2V5PXtpfVxuICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoMHB4KSB0cmFuc2xhdGVZKDBweCknLFxuICAgICAgICAgICAgICAgIFdlYmtpdFRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoMHB4KSB0cmFuc2xhdGVZKDBweCknLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBmbGV4aWJsZVxuICAgICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgIDogbGF5b3V0TnVtYmVyVG9Dc3NEaW1lbnNpb24oY29sdW1uV2lkdGgpLCAvLyB3ZSBjYW4ndCBzZXQgYSB3aWR0aCBmb3Igc2VydmVyIHJlbmRlcmVkIGZsZXhpYmxlIGl0ZW1zXG4gICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgIHJlZj17ZWwgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlbCAmJiAhZmxleGlibGUpIHtcbiAgICAgICAgICAgICAgICAgIC8vIG9ubHkgbWVhc3VyZSBmbGV4aWJsZSBpdGVtcyBvbiBjbGllbnRcbiAgICAgICAgICAgICAgICAgIG1lYXN1cmVtZW50U3RvcmUuc2V0KGl0ZW0sIGVsLmNsaWVudEhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8Q29tcG9uZW50IGRhdGE9e2l0ZW19IGl0ZW1JZHg9e2l9IGlzTWVhc3VyaW5nPXtmYWxzZX0gLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICkpfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICh3aWR0aCA9PSBudWxsKSB7XG4gICAgICAvLyBXaGVuIHRoZSB3aWR0aCBpcyBlbXB0eSAodXN1YWxseSBhZnRlciBhIHJlLW1vdW50KSByZW5kZXIgYW4gZW1wdHlcbiAgICAgIC8vIGRpdiB0byBjb2xsZWN0IHRoZSB3aWR0aCBmb3IgbGF5b3V0XG4gICAgICBncmlkQm9keSA9IDxkaXYgc3R5bGU9e3sgd2lkdGg6ICcxMDAlJyB9fSByZWY9e3RoaXMuc2V0R3JpZFdyYXBwZXJSZWZ9IC8+O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGdWxsIGxheW91dCBpcyBwb3NzaWJsZVxuICAgICAgY29uc3QgaXRlbXNUb1JlbmRlciA9IGl0ZW1zLmZpbHRlcihcbiAgICAgICAgaXRlbSA9PiBpdGVtICYmIG1lYXN1cmVtZW50U3RvcmUuaGFzKGl0ZW0pXG4gICAgICApO1xuICAgICAgY29uc3QgaXRlbXNUb01lYXN1cmUgPSBpdGVtc1xuICAgICAgICAuZmlsdGVyKGl0ZW0gPT4gaXRlbSAmJiAhbWVhc3VyZW1lbnRTdG9yZS5oYXMoaXRlbSkpXG4gICAgICAgIC5zbGljZSgwLCBtaW5Db2xzKTtcblxuICAgICAgY29uc3QgcG9zaXRpb25zID0gbGF5b3V0KGl0ZW1zVG9SZW5kZXIpO1xuICAgICAgY29uc3QgbWVhc3VyaW5nUG9zaXRpb25zID0gbGF5b3V0KGl0ZW1zVG9NZWFzdXJlKTtcbiAgICAgIC8vIE1hdGgubWF4KCkgPT09IC1JbmZpbml0eSB3aGVuIHRoZXJlIGFyZSBubyBwb3NpdGlvbnNcbiAgICAgIGNvbnN0IGhlaWdodCA9IHBvc2l0aW9ucy5sZW5ndGhcbiAgICAgICAgPyBNYXRoLm1heCguLi5wb3NpdGlvbnMubWFwKHBvcyA9PiBwb3MudG9wICsgcG9zLmhlaWdodCkpXG4gICAgICAgIDogMDtcbiAgICAgIGdyaWRCb2R5ID0gKFxuICAgICAgICA8ZGl2IHN0eWxlPXt7IHdpZHRoOiAnMTAwJScgfX0gcmVmPXt0aGlzLnNldEdyaWRXcmFwcGVyUmVmfT5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLk1hc29ucnl9IHN0eWxlPXt7IGhlaWdodCwgd2lkdGggfX0+XG4gICAgICAgICAgICB7aXRlbXNUb1JlbmRlci5tYXAoKGl0ZW0sIGkpID0+XG4gICAgICAgICAgICAgIHRoaXMucmVuZGVyTWFzb25yeUNvbXBvbmVudChpdGVtLCBpLCBwb3NpdGlvbnNbaV0pXG4gICAgICAgICAgICApfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuTWFzb25yeX0gc3R5bGU9e3sgd2lkdGggfX0+XG4gICAgICAgICAgICB7aXRlbXNUb01lYXN1cmUubWFwKChkYXRhLCBpKSA9PiB7XG4gICAgICAgICAgICAgIC8vIGl0ZW1zVG9NZWFzdXJlIGlzIGFsd2F5cyB0aGUgbGVuZ3RoIG9mIG1pbkNvbHMsIHNvIGkgd2lsbCBhbHdheXMgYmUgMC4ubWluQ29scy5sZW5ndGhcbiAgICAgICAgICAgICAgLy8gd2Ugbm9ybWFsaXplIHRoZSBpbmRleCBoZXJlIHJlbGF0aXZlIHRvIHRoZSBpdGVtIGxpc3QgYXMgYSB3aG9sZSBzbyB0aGF0IGl0ZW1JZHggaXMgY29ycmVjdFxuICAgICAgICAgICAgICAvLyBhbmQgc28gdGhhdCBSZWFjdCBkb2VzbnQgcmV1c2UgdGhlIG1lYXN1cmVtZW50IG5vZGVzXG4gICAgICAgICAgICAgIGNvbnN0IG1lYXN1cmVtZW50SW5kZXggPSBpdGVtc1RvUmVuZGVyLmxlbmd0aCArIGk7XG4gICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gbWVhc3VyaW5nUG9zaXRpb25zW2ldO1xuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgIGtleT17YG1lYXN1cmluZy0ke21lYXN1cmVtZW50SW5kZXh9YH1cbiAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6ICdoaWRkZW4nLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiBsYXlvdXROdW1iZXJUb0Nzc0RpbWVuc2lvbihwb3NpdGlvbi50b3ApLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBsYXlvdXROdW1iZXJUb0Nzc0RpbWVuc2lvbihwb3NpdGlvbi5sZWZ0KSxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGxheW91dE51bWJlclRvQ3NzRGltZW5zaW9uKHBvc2l0aW9uLndpZHRoKSxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBsYXlvdXROdW1iZXJUb0Nzc0RpbWVuc2lvbihwb3NpdGlvbi5oZWlnaHQpLFxuICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgIHJlZj17ZWwgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICBtZWFzdXJlbWVudFN0b3JlLnNldChkYXRhLCBlbC5jbGllbnRIZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIDxDb21wb25lbnRcbiAgICAgICAgICAgICAgICAgICAgZGF0YT17ZGF0YX1cbiAgICAgICAgICAgICAgICAgICAgaXRlbUlkeD17bWVhc3VyZW1lbnRJbmRleH1cbiAgICAgICAgICAgICAgICAgICAgaXNNZWFzdXJpbmdcbiAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KX1cbiAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgIHt0aGlzLnNjcm9sbENvbnRhaW5lciAmJiAoXG4gICAgICAgICAgICA8RmV0Y2hJdGVtc1xuICAgICAgICAgICAgICBjb250YWluZXJIZWlnaHQ9e3RoaXMuY29udGFpbmVySGVpZ2h0fVxuICAgICAgICAgICAgICBmZXRjaE1vcmU9e3RoaXMuZmV0Y2hNb3JlfVxuICAgICAgICAgICAgICBpc0ZldGNoaW5nPXtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmlzRmV0Y2hpbmcgfHwgdGhpcy5zdGF0ZS5oYXNQZW5kaW5nTWVhc3VyZW1lbnRzXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc2Nyb2xsSGVpZ2h0PXtoZWlnaHR9XG4gICAgICAgICAgICAgIHNjcm9sbFRvcD17dGhpcy5zdGF0ZS5zY3JvbGxUb3B9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICl9XG4gICAgICAgIDwvZGl2PlxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wcm9wcy5zY3JvbGxDb250YWluZXIgPyAoXG4gICAgICA8U2Nyb2xsQ29udGFpbmVyXG4gICAgICAgIHJlZj17dGhpcy5zZXRTY3JvbGxDb250YWluZXJSZWZ9XG4gICAgICAgIG9uU2Nyb2xsPXt0aGlzLnVwZGF0ZVNjcm9sbFBvc2l0aW9ufVxuICAgICAgICBzY3JvbGxDb250YWluZXI9e3RoaXMucHJvcHMuc2Nyb2xsQ29udGFpbmVyfVxuICAgICAgPlxuICAgICAgICB7Z3JpZEJvZHl9XG4gICAgICA8L1Njcm9sbENvbnRhaW5lcj5cbiAgICApIDogKFxuICAgICAgZ3JpZEJvZHlcbiAgICApO1xuICB9XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBkZWJvdW5jZSBmcm9tICcuL2RlYm91bmNlLmpzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9NYXNvbnJ5LmNzcyc7XG5pbXBvcnQgU2Nyb2xsQ29udGFpbmVyIGZyb20gJy4vU2Nyb2xsQ29udGFpbmVyLmpzJztcbmltcG9ydCB0aHJvdHRsZSBmcm9tICcuL3Rocm90dGxlLmpzJztcbmltcG9ydCB0eXBlIHsgQ2FjaGUgfSBmcm9tICcuL0NhY2hlLmpzJztcbmltcG9ydCBNZWFzdXJlbWVudFN0b3JlIGZyb20gJy4vTWVhc3VyZW1lbnRTdG9yZS5qcyc7XG5pbXBvcnQge1xuICBnZXRFbGVtZW50SGVpZ2h0LFxuICBnZXRSZWxhdGl2ZVNjcm9sbFRvcCxcbiAgZ2V0U2Nyb2xsUG9zLFxufSBmcm9tICcuL3Njcm9sbFV0aWxzLmpzJztcbmltcG9ydCB7XG4gIERlZmF1bHRMYXlvdXRTeW1ib2wsXG4gIFVuaWZvcm1Sb3dMYXlvdXRTeW1ib2wsXG59IGZyb20gJy4vbGVnYWN5TGF5b3V0U3ltYm9scy5qcyc7XG5pbXBvcnQgZGVmYXVsdExheW91dCwgeyB0eXBlIFBvc2l0aW9uIH0gZnJvbSAnLi9kZWZhdWx0TGF5b3V0LmpzJztcbmltcG9ydCB1bmlmb3JtUm93TGF5b3V0IGZyb20gJy4vdW5pZm9ybVJvd0xheW91dC5qcyc7XG5pbXBvcnQgZnVsbFdpZHRoTGF5b3V0IGZyb20gJy4vZnVsbFdpZHRoTGF5b3V0LmpzJztcbmltcG9ydCBMZWdhY3lNYXNvbnJ5TGF5b3V0IGZyb20gJy4vbGF5b3V0cy9NYXNvbnJ5TGF5b3V0LmpzJztcbmltcG9ydCBMZWdhY3lVbmlmb3JtUm93TGF5b3V0IGZyb20gJy4vbGF5b3V0cy9Vbmlmb3JtUm93TGF5b3V0LmpzJztcblxudHlwZSBMYXlvdXQgPVxuICB8IHR5cGVvZiBEZWZhdWx0TGF5b3V0U3ltYm9sXG4gIHwgdHlwZW9mIFVuaWZvcm1Sb3dMYXlvdXRTeW1ib2xcbiAgfCBMZWdhY3lNYXNvbnJ5TGF5b3V0XG4gIHwgTGVnYWN5VW5pZm9ybVJvd0xheW91dDtcblxuZXhwb3J0IHR5cGUgTWVhc3VyZW1lbnRTdGF0ZSA9ICdpZGxlJyB8ICdtZWFzdXJpbmcnO1xuXG5leHBvcnQgdHlwZSBQcm9wczxUPiA9IHt8XG4gIGNvbHVtbldpZHRoPzogbnVtYmVyLFxuICBjb21wOiBSZWFjdC5Db21wb25lbnRUeXBlPHtcbiAgICBkYXRhOiBULFxuICAgIGl0ZW1JZHg6IG51bWJlcixcbiAgICBpc01lYXN1cmluZzogYm9vbGVhbixcbiAgfT4sXG4gIGZsZXhpYmxlPzogYm9vbGVhbixcbiAgZ3V0dGVyV2lkdGg/OiBudW1iZXIsXG4gIGl0ZW1zOiBBcnJheTxUPixcbiAgbWVhc3VyZW1lbnRTdG9yZTogQ2FjaGU8VCwgKj4sXG4gIG1pbkNvbHM6IG51bWJlcixcbiAgLy8gQ29udGVudCBsYXllciBhbmQgVmlld3BvcnQgbGF5ZXIgaXMgYXMgZGVmaW5lZCBpbiBDb2xsZWN0aW9uLlxuICBvblZpcnR1YWxpemF0aW9uV2luZG93VXBkYXRlPzogKFxuICAgIGNvbnRlbnQ6IFBvc2l0aW9uLFxuICAgIHZpZXdwb3J0OiBQb3NpdGlvblxuICApID0+IHZvaWQsXG4gIG9uQXV0b01lYXN1cmluZ1VwZGF0ZT86IChzdGF0ZTogTWVhc3VyZW1lbnRTdGF0ZSkgPT4gdm9pZCxcbiAgbGF5b3V0PzogTGF5b3V0LFxuICAvLyBTdXBwb3J0IGxlZ2FjeSBsb2FkSXRlbXMgdXNhZ2UuXG4gIC8vIFRPRE86IFNpbXBsaWZ5IG5vbiBmYWxzZXkgZmxvd3R5cGUuXG4gIGxvYWRJdGVtcz86XG4gICAgfCBmYWxzZVxuICAgIHwgKChcbiAgICAgICAgP3tcbiAgICAgICAgICBmcm9tOiBudW1iZXIsXG4gICAgICAgIH1cbiAgICAgICkgPT4gdm9pZCB8IGJvb2xlYW4gfCB7fSksXG4gIHNjcm9sbENvbnRhaW5lcj86ICgpID0+IEhUTUxFbGVtZW50LFxuICB2aXJ0dWFsQm91bmRzVG9wPzogbnVtYmVyLFxuICB2aXJ0dWFsQm91bmRzQm90dG9tPzogbnVtYmVyLFxuICB2aXJ0dWFsaXplPzogYm9vbGVhbixcbnx9O1xuXG50eXBlIFN0YXRlPFQ+ID0ge3xcbiAgaGFzUGVuZGluZ01lYXN1cmVtZW50czogYm9vbGVhbixcbiAgaGVpZ2h0OiBudW1iZXIsXG4gIGl0ZW1zOiBBcnJheTxUPixcbiAgaXRlbXNUb01lYXN1cmU6IEFycmF5PFQ+LFxuICBpdGVtc1RvUmVuZGVyOiBBcnJheTxUPixcbiAgbWVhc3VyaW5nUG9zaXRpb25zOiBBcnJheTxQb3NpdGlvbj4sXG4gIHJlbmRlclBvc2l0aW9uczogQXJyYXk8UG9zaXRpb24+LFxuICBzY3JvbGxUb3A6IG51bWJlcixcbiAgd2lkdGg6ID9udW1iZXIsXG58fTtcblxuY29uc3QgUkVTSVpFX0RFQk9VTkNFID0gMzAwO1xuLy8gTXVsdGlwbGllZCBhZ2FpbnN0IGNvbnRhaW5lciBoZWlnaHQuXG4vLyBUaGUgYW1vdW50IG9mIGV4dHJhIGJ1ZmZlciBzcGFjZSBmb3IgcG9wdWxhdGluZyB2aXNpYmxlIGl0ZW1zLlxuY29uc3QgVklSVFVBTF9CVUZGRVJfRkFDVE9SID0gMC43O1xuXG5jb25zdCBsYXlvdXROdW1iZXJUb0Nzc0RpbWVuc2lvbiA9IG4gPT4gKG4gIT09IEluZmluaXR5ID8gbiA6IHVuZGVmaW5lZCk7XG5cbmZ1bmN0aW9uIGxheW91dENsYXNzPFQ+KFxuICB7XG4gICAgY29sdW1uV2lkdGgsXG4gICAgZmxleGlibGUsXG4gICAgZ3V0dGVyV2lkdGg6IGd1dHRlcixcbiAgICBsYXlvdXQsXG4gICAgbWVhc3VyZW1lbnRTdG9yZSxcbiAgICBtaW5Db2xzLFxuICB9OiBQcm9wczxUPixcbiAgeyB3aWR0aCB9OiBTdGF0ZTxUPlxuKSB7XG4gIGlmIChmbGV4aWJsZSAmJiB3aWR0aCAhPT0gbnVsbCkge1xuICAgIHJldHVybiBmdWxsV2lkdGhMYXlvdXQoe1xuICAgICAgZ3V0dGVyLFxuICAgICAgY2FjaGU6IG1lYXN1cmVtZW50U3RvcmUsXG4gICAgICBtaW5Db2xzLFxuICAgICAgaWRlYWxDb2x1bW5XaWR0aDogY29sdW1uV2lkdGgsXG4gICAgICB3aWR0aCxcbiAgICB9KTtcbiAgfVxuICBpZiAoXG4gICAgbGF5b3V0ID09PSBVbmlmb3JtUm93TGF5b3V0U3ltYm9sIHx8XG4gICAgbGF5b3V0IGluc3RhbmNlb2YgTGVnYWN5VW5pZm9ybVJvd0xheW91dFxuICApIHtcbiAgICByZXR1cm4gdW5pZm9ybVJvd0xheW91dCh7XG4gICAgICBjYWNoZTogbWVhc3VyZW1lbnRTdG9yZSxcbiAgICAgIGNvbHVtbldpZHRoLFxuICAgICAgZ3V0dGVyLFxuICAgICAgbWluQ29scyxcbiAgICAgIHdpZHRoLFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBkZWZhdWx0TGF5b3V0KHtcbiAgICBjYWNoZTogbWVhc3VyZW1lbnRTdG9yZSxcbiAgICBjb2x1bW5XaWR0aCxcbiAgICBndXR0ZXIsXG4gICAgbWluQ29scyxcbiAgICB3aWR0aCxcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHN0YXRlc0ZvclJlbmRlcmluZzxUPihwcm9wczogUHJvcHM8VD4sIHN0YXRlOiBTdGF0ZTxUPikge1xuICBjb25zdCB7IG1lYXN1cmVtZW50U3RvcmUsIG1pbkNvbHMgfSA9IHByb3BzO1xuICBjb25zdCB7IGl0ZW1zIH0gPSBzdGF0ZTtcblxuICAvLyBGdWxsIGxheW91dCBpcyBwb3NzaWJsZVxuICAvLyAkRmxvd0lzc3VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy82MTUxXG4gIGNvbnN0IGl0ZW1zVG9SZW5kZXIgPSBpdGVtcy5maWx0ZXIoXG4gICAgaXRlbSA9PiBpdGVtICYmIG1lYXN1cmVtZW50U3RvcmUuaGFzKGl0ZW0pXG4gICk7XG5cbiAgY29uc3QgbGF5b3V0ID0gbGF5b3V0Q2xhc3MocHJvcHMsIHN0YXRlKTtcbiAgY29uc3QgcmVuZGVyUG9zaXRpb25zID0gbGF5b3V0KGl0ZW1zVG9SZW5kZXIpO1xuICAvLyBNYXRoLm1heCgpID09PSAtSW5maW5pdHkgd2hlbiB0aGVyZSBhcmUgbm8gcmVuZGVyUG9zaXRpb25zXG4gIGNvbnN0IGhlaWdodCA9IHJlbmRlclBvc2l0aW9ucy5sZW5ndGhcbiAgICA/IE1hdGgubWF4KC4uLnJlbmRlclBvc2l0aW9ucy5tYXAocG9zID0+IHBvcy50b3AgKyBwb3MuaGVpZ2h0KSlcbiAgICA6IDA7XG5cbiAgLy8gJEZsb3dJc3N1ZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvNjE1MVxuICBjb25zdCBpdGVtc1RvTWVhc3VyZSA9IGl0ZW1zXG4gICAgLmZpbHRlcihpdGVtID0+IGl0ZW0gJiYgIW1lYXN1cmVtZW50U3RvcmUuaGFzKGl0ZW0pKVxuICAgIC5zbGljZSgwLCBtaW5Db2xzKTtcbiAgY29uc3QgbWVhc3VyaW5nUG9zaXRpb25zID0gbGF5b3V0KGl0ZW1zVG9NZWFzdXJlKTtcblxuICByZXR1cm4ge1xuICAgIGhlaWdodCxcbiAgICBpdGVtc1RvUmVuZGVyLFxuICAgIGl0ZW1zVG9NZWFzdXJlLFxuICAgIG1lYXN1cmluZ1Bvc2l0aW9ucyxcbiAgICByZW5kZXJQb3NpdGlvbnMsXG4gIH07XG59XG5cbi8qKlxuICogVGhlIHdpbGwgYmUgdGhlIG5ldyBNYXNvbnJ5QmV0YSB0aGF0IHdpbGwgbm90IGhhdmUgYW55IGZldGNoaW5nIGNvbmNlcm5zLlxuICpcbiAqIEZvciBub3csIGl0IGRpZmZlcnMgd2l0aCBNYXNvbnJ5IG9ubHkgYnkgbm90IGhhdmluZyBhbnkgZmV0Y2hpbmcgbG9naWMuXG4gKlxuICogSXQgaXMgaW4gYmV0YSB1bnRpbCBpdCBjYW4gYmUgYmF0dGxlIHRlc3RlZC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFzb25yeUJldGE8VD4gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8XG4gIFByb3BzPFQ+LFxuICBTdGF0ZTxUPlxuPiB7XG4gIC8qKlxuICAgKiBEZWxheXMgcmVzaXplIGhhbmRsaW5nIGluIGNhc2UgdGhlIHNjcm9sbCBjb250YWluZXIgaXMgc3RpbGwgYmVpbmcgcmVzaXplZC5cbiAgICovXG4gIGhhbmRsZVJlc2l6ZSA9IGRlYm91bmNlKCgpID0+IHtcbiAgICBpZiAodGhpcy5ncmlkV3JhcHBlcikge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IHdpZHRoOiB0aGlzLmdyaWRXcmFwcGVyLmNsaWVudFdpZHRoIH0pO1xuICAgIH1cbiAgfSwgUkVTSVpFX0RFQk9VTkNFKTtcblxuICB1cGRhdGVTY3JvbGxQb3NpdGlvbiA9IHRocm90dGxlKCgpID0+IHtcbiAgICBpZiAoIXRoaXMuc2Nyb2xsQ29udGFpbmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNjcm9sbENvbnRhaW5lciA9IHRoaXMuc2Nyb2xsQ29udGFpbmVyLmdldFNjcm9sbENvbnRhaW5lclJlZigpO1xuXG4gICAgaWYgKCFzY3JvbGxDb250YWluZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHNjcm9sbFRvcDogZ2V0U2Nyb2xsUG9zKHNjcm9sbENvbnRhaW5lciksXG4gICAgfSk7XG5cbiAgICB0aGlzLmhhbmRsZVZpcnR1YWxpemF0aW9uV2luZG93VXBkYXRlKCk7XG4gIH0pO1xuXG4gIG1lYXN1cmVDb250YWluZXJBc3luYyA9IGRlYm91bmNlKCgpID0+IHtcbiAgICB0aGlzLm1lYXN1cmVDb250YWluZXIoKTtcbiAgfSwgMCk7XG5cbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAvKipcbiAgICAgKiBUaGUgcHJlZmVycmVkL3RhcmdldCBpdGVtIHdpZHRoLiBJZiBgZmxleGlibGVgIGlzIHNldCwgdGhlIGl0ZW0gd2lkdGggd2lsbFxuICAgICAqIGdyb3cgdG8gZmlsbCBjb2x1bW4gc3BhY2UsIGFuZCBzaHJpbmsgdG8gZml0IGlmIGJlbG93IG1pbiBjb2x1bW5zLlxuICAgICAqL1xuICAgIGNvbHVtbldpZHRoOiBQcm9wVHlwZXMubnVtYmVyLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbXBvbmVudCB0byByZW5kZXIuXG4gICAgICovXG4gICAgLyogZXNsaW50IHJlYWN0L25vLXVudXNlZC1wcm9wLXR5cGVzOiAwICovXG4gICAgY29tcDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBwcmVmZXJyZWQvdGFyZ2V0IGl0ZW0gd2lkdGguIEl0ZW0gd2lkdGggd2lsbCBncm93IHRvIGZpbGxcbiAgICAgKiBjb2x1bW4gc3BhY2UsIGFuZCBzaHJpbmsgdG8gZml0IGlmIGJlbG93IG1pbiBjb2x1bW5zLlxuICAgICAqL1xuICAgIGZsZXhpYmxlOiBQcm9wVHlwZXMuYm9vbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBhbW91bnQgb2Ygc3BhY2UgYmV0d2VlbiBlYWNoIGl0ZW0uXG4gICAgICovXG4gICAgZ3V0dGVyV2lkdGg6IFByb3BUeXBlcy5udW1iZXIsXG5cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBhbGwgb2JqZWN0cyB0byBkaXNwbGF5IGluIHRoZSBncmlkLlxuICAgICAqL1xuICAgIGl0ZW1zOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc2hhcGUoe30pKS5pc1JlcXVpcmVkLFxuXG4gICAgLyoqXG4gICAgICogTWVhc3VyZW1lbnQgU3RvcmVcbiAgICAgKi9cbiAgICBtZWFzdXJlbWVudFN0b3JlOiBQcm9wVHlwZXMuaW5zdGFuY2VPZihNZWFzdXJlbWVudFN0b3JlKSxcblxuICAgIC8qKlxuICAgICAqIExheW91dCBzeXN0ZW0gdG8gdXNlIGZvciBpdGVtc1xuICAgICAqL1xuICAgIGxheW91dDogUHJvcFR5cGVzLm9uZU9mVHlwZShbXG4gICAgICBQcm9wVHlwZXMuaW5zdGFuY2VPZihMZWdhY3lNYXNvbnJ5TGF5b3V0KSxcbiAgICAgIFByb3BUeXBlcy5pbnN0YW5jZU9mKExlZ2FjeVVuaWZvcm1Sb3dMYXlvdXQpLFxuICAgICAgUHJvcFR5cGVzLnN5bWJvbCxcbiAgICBdKSxcblxuICAgIC8qKlxuICAgICAqIEEgY2FsbGJhY2sgd2hpY2ggdGhlIGdyaWQgY2FsbHMgd2hlbiB3ZSBuZWVkIHRvIGxvYWQgbW9yZSBpdGVtcyBhcyB0aGUgdXNlciBzY3JvbGxzLlxuICAgICAqIFRoZSBjYWxsYmFjayBzaG91bGQgdXBkYXRlIHRoZSBzdGF0ZSBvZiB0aGUgaXRlbXMsIGFuZCBwYXNzIHRob3NlIGluIGFzIHByb3BzXG4gICAgICogdG8gdGhpcyBjb21wb25lbnQuXG4gICAgICovXG4gICAgbG9hZEl0ZW1zOiBQcm9wVHlwZXMuZnVuYyxcblxuICAgIC8qKlxuICAgICAqIE1pbmltdW0gbnVtYmVyIG9mIGNvbHVtbnMgdG8gZGlzcGxheS5cbiAgICAgKi9cbiAgICBtaW5Db2xzOiBQcm9wVHlwZXMubnVtYmVyLFxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdGhhdCB0aGUgZ3JpZCBjYWxscyB0byBnZXQgdGhlIHNjcm9sbCBjb250YWluZXIuXG4gICAgICogVGhpcyBpcyByZXF1aXJlZCBpZiB0aGUgZ3JpZCBpcyBleHBlY3RlZCB0byBiZSBzY3JvbGxhYmxlLlxuICAgICAqL1xuICAgIHNjcm9sbENvbnRhaW5lcjogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIG9yIG5vdCB0byB1c2UgYWN0dWFsIHZpcnR1YWxpemF0aW9uXG4gICAgICovXG4gICAgdmlydHVhbGl6ZTogUHJvcFR5cGVzLmJvb2wsXG4gIH07XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICBjb2x1bW5XaWR0aDogMjM2LFxuICAgIG1lYXN1cmVtZW50U3RvcmU6IG5ldyBNZWFzdXJlbWVudFN0b3JlKCksXG4gICAgbWluQ29sczogMyxcbiAgICBsYXlvdXQ6IERlZmF1bHRMYXlvdXRTeW1ib2wsXG4gICAgbG9hZEl0ZW1zOiAoKSA9PiB7fSxcbiAgICB2aXJ0dWFsaXplOiBmYWxzZSxcbiAgfTtcblxuICBjb25zdHJ1Y3Rvcihwcm9wczogUHJvcHM8VD4pIHtcbiAgICBzdXBlcihwcm9wcyk7XG5cbiAgICB0aGlzLmNvbnRhaW5lckhlaWdodCA9IDA7XG4gICAgdGhpcy5jb250YWluZXJPZmZzZXQgPSAwO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGhhc1BlbmRpbmdNZWFzdXJlbWVudHM6IHByb3BzLml0ZW1zLnNvbWUoXG4gICAgICAgIGl0ZW0gPT4gISFpdGVtICYmICFwcm9wcy5tZWFzdXJlbWVudFN0b3JlLmhhcyhpdGVtKVxuICAgICAgKSxcbiAgICAgIGhlaWdodDogMCxcbiAgICAgIGl0ZW1zVG9SZW5kZXI6IFtdLFxuICAgICAgaXRlbXNUb01lYXN1cmU6IFtdLFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L25vLXVudXNlZC1zdGF0ZVxuICAgICAgaXRlbXM6IHByb3BzLml0ZW1zLFxuICAgICAgbWVhc3VyaW5nUG9zaXRpb25zOiBbXSxcbiAgICAgIHJlbmRlclBvc2l0aW9uczogW10sXG4gICAgICBzY3JvbGxUb3A6IDAsXG4gICAgICB3aWR0aDogdW5kZWZpbmVkLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBob29rcyBhZnRlciB0aGUgY29tcG9uZW50IG1vdW50cy5cbiAgICovXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLmhhbmRsZVJlc2l6ZSk7XG5cbiAgICB0aGlzLm1lYXN1cmVDb250YWluZXIoKTtcblxuICAgIGxldCB7IHNjcm9sbFRvcCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAodGhpcy5zY3JvbGxDb250YWluZXIgIT0gbnVsbCkge1xuICAgICAgY29uc3Qgc2Nyb2xsQ29udGFpbmVyID0gdGhpcy5zY3JvbGxDb250YWluZXIuZ2V0U2Nyb2xsQ29udGFpbmVyUmVmKCk7XG4gICAgICBpZiAoc2Nyb2xsQ29udGFpbmVyKSB7XG4gICAgICAgIHNjcm9sbFRvcCA9IGdldFNjcm9sbFBvcyhzY3JvbGxDb250YWluZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc2V0U3RhdGUocHJldlN0YXRlID0+IHtcbiAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5ncmlkV3JhcHBlclxuICAgICAgICA/IHRoaXMuZ3JpZFdyYXBwZXIuY2xpZW50V2lkdGhcbiAgICAgICAgOiBwcmV2U3RhdGUud2lkdGg7XG4gICAgICBjb25zdCBzdGF0ZVdpdGhXaWR0aCA9IHsgLi4udGhpcy5zdGF0ZSwgd2lkdGggfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNjcm9sbFRvcCxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIC4uLnN0YXRlc0ZvclJlbmRlcmluZyh0aGlzLnByb3BzLCBzdGF0ZVdpdGhXaWR0aCksXG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gbmVlZCB0byBtYWtlIHN1cmUgcGFyZW50IGNvbXBvbmVudCBoYXMgdGhlIGNvcnJlY3QgcGVuZGluZyBtZWFzdXJlbWVudCB2YWx1ZVxuICAgIHRoaXMuaGFuZGxlT25BdXRvTWVhc3VyaW5nVXBkYXRlKFxuICAgICAgdGhpcy5zdGF0ZS5oYXNQZW5kaW5nTWVhc3VyZW1lbnRzID8gJ21lYXN1cmluZycgOiAnaWRsZSdcbiAgICApO1xuICB9XG5cbiAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wczogUHJvcHM8VD4sIHByZXZTdGF0ZTogU3RhdGU8VD4pIHtcbiAgICBjb25zdCB7IGl0ZW1zLCBtZWFzdXJlbWVudFN0b3JlIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgdGhpcy5tZWFzdXJlQ29udGFpbmVyQXN5bmMoKTtcblxuICAgIGlmIChwcmV2U3RhdGUud2lkdGggIT0gbnVsbCAmJiB0aGlzLnN0YXRlLndpZHRoICE9PSBwcmV2U3RhdGUud2lkdGgpIHtcbiAgICAgIG1lYXN1cmVtZW50U3RvcmUucmVzZXQoKTtcbiAgICB9XG4gICAgLy8gY2FsY3VsYXRlIHdoZXRoZXIgd2Ugc3RpbGwgaGF2ZSBwZW5kaW5nIG1lYXN1cmVtZW50c1xuICAgIGNvbnN0IGhhc1BlbmRpbmdNZWFzdXJlbWVudHMgPSBpdGVtcy5zb21lKFxuICAgICAgaXRlbSA9PiAhIWl0ZW0gJiYgIW1lYXN1cmVtZW50U3RvcmUuaGFzKGl0ZW0pXG4gICAgKTtcblxuICAgIGlmIChoYXNQZW5kaW5nTWVhc3VyZW1lbnRzICYmICFwcmV2U3RhdGUuaGFzUGVuZGluZ01lYXN1cmVtZW50cykge1xuICAgICAgdGhpcy5oYW5kbGVPbkF1dG9NZWFzdXJpbmdVcGRhdGUoJ21lYXN1cmluZycpO1xuICAgIH0gZWxzZSBpZiAoIWhhc1BlbmRpbmdNZWFzdXJlbWVudHMgJiYgcHJldlN0YXRlLmhhc1BlbmRpbmdNZWFzdXJlbWVudHMpIHtcbiAgICAgIHRoaXMuaGFuZGxlT25BdXRvTWVhc3VyaW5nVXBkYXRlKCdpZGxlJyk7XG4gICAgfVxuICAgIHRoaXMuaGFuZGxlVmlydHVhbGl6YXRpb25XaW5kb3dVcGRhdGUoKTtcblxuICAgIGlmIChcbiAgICAgIGhhc1BlbmRpbmdNZWFzdXJlbWVudHMgfHxcbiAgICAgIGhhc1BlbmRpbmdNZWFzdXJlbWVudHMgIT09IHRoaXMuc3RhdGUuaGFzUGVuZGluZ01lYXN1cmVtZW50cyB8fFxuICAgICAgcHJldlN0YXRlLndpZHRoID09IG51bGxcbiAgICApIHtcbiAgICAgIHRoaXMuaW5zZXJ0QW5pbWF0aW9uRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICBjb25zdCByZW5kZXJpbmdTdGF0ZXMgPSBzdGF0ZXNGb3JSZW5kZXJpbmcodGhpcy5wcm9wcywgdGhpcy5zdGF0ZSk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIGhhc1BlbmRpbmdNZWFzdXJlbWVudHMsXG4gICAgICAgICAgLi4ucmVuZGVyaW5nU3RhdGVzLFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoaGFzUGVuZGluZ01lYXN1cmVtZW50cyB8fCBwcmV2U3RhdGUuaXRlbXMgIT09IGl0ZW1zKSB7XG4gICAgICB0aGlzLmluc2VydEFuaW1hdGlvbkZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgY29uc3QgcmVuZGVyaW5nU3RhdGVzID0gc3RhdGVzRm9yUmVuZGVyaW5nKHRoaXMucHJvcHMsIHRoaXMuc3RhdGUpO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgLi4ucmVuZGVyaW5nU3RhdGVzIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBsaXN0ZW5lcnMgd2hlbiB1bm1vdW50aW5nLlxuICAgKi9cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgaWYgKHRoaXMuaW5zZXJ0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuaW5zZXJ0QW5pbWF0aW9uRnJhbWUpO1xuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSBhc3luYyBtZXRob2RzIGFyZSBjYW5jZWxsZWQuXG4gICAgdGhpcy5tZWFzdXJlQ29udGFpbmVyQXN5bmMuY2xlYXJUaW1lb3V0KCk7XG4gICAgdGhpcy5oYW5kbGVSZXNpemUuY2xlYXJUaW1lb3V0KCk7XG4gICAgdGhpcy51cGRhdGVTY3JvbGxQb3NpdGlvbi5jbGVhclRpbWVvdXQoKTtcblxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLmhhbmRsZVJlc2l6ZSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKHByb3BzOiBQcm9wczxUPiwgc3RhdGU6IFN0YXRlPFQ+KSB7XG4gICAgY29uc3QgeyBpdGVtcywgbWVhc3VyZW1lbnRTdG9yZSB9ID0gcHJvcHM7XG4gICAgLy8gd2hlbmV2ZXIgd2UncmUgcmVjZWl2aW5nIG5ldyBwcm9wcywgZGV0ZXJtaW5lIHdoZXRoZXIgYW55IGl0ZW1zIG5lZWQgdG8gYmUgbWVhc3VyZWRcbiAgICAvLyBUT0RPIC0gd2Ugc2hvdWxkIHRyZWF0IGl0ZW1zIGFzIGltbXV0YWJsZVxuICAgIGNvbnN0IGhhc1BlbmRpbmdNZWFzdXJlbWVudHMgPSBpdGVtcy5zb21lKFxuICAgICAgaXRlbSA9PiBpdGVtICYmICFtZWFzdXJlbWVudFN0b3JlLmhhcyhpdGVtKVxuICAgICk7XG5cbiAgICBjb25zdCBuZXdTdGF0ZTogU3RhdGU8VD4gPSB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIGhhc1BlbmRpbmdNZWFzdXJlbWVudHMsXG4gICAgICBpdGVtcyxcbiAgICB9O1xuXG4gICAgLy8gU2hhbGxvdyBjb21wYXJlIGFsbCBpdGVtcywgaWYgYW55IGNoYW5nZSByZWZsb3cgdGhlIGdyaWQuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgLy8gV2UndmUgcmVhY2hlZCB0aGUgZW5kIG9mIG91ciBjdXJyZW50IHByb3BzIGFuZCBldmVyeXRoaW5nIG1hdGNoZXMuXG4gICAgICAvLyBJZiB3ZSBoaXQgdGhpcyBjYXNlIGl0IG1lYW5zIHdlIG5lZWQgdG8gaW5zZXJ0IG5ldyBpdGVtcy5cbiAgICAgIGlmIChzdGF0ZS5pdGVtc1tpXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaGFzUGVuZGluZ01lYXN1cmVtZW50cyxcbiAgICAgICAgICBpdGVtcyxcbiAgICAgICAgICAuLi5zdGF0ZXNGb3JSZW5kZXJpbmcocHJvcHMsIG5ld1N0YXRlKSxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVzZXQgZ3JpZCBpdGVtcyB3aGVuOlxuICAgICAgaWYgKFxuICAgICAgICAvLyBBbiBpdGVtIG9iamVjdCByZWYgZG9lcyBub3QgbWF0Y2guXG4gICAgICAgIGl0ZW1zW2ldICE9PSBzdGF0ZS5pdGVtc1tpXSB8fFxuICAgICAgICAvLyBPciBsZXNzIGl0ZW1zIHRoYW4gd2UgY3VycmVudGx5IGhhdmUgYXJlIHBhc3NlZCBpbi5cbiAgICAgICAgaXRlbXMubGVuZ3RoIDwgc3RhdGUuaXRlbXMubGVuZ3RoXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBoYXNQZW5kaW5nTWVhc3VyZW1lbnRzLFxuICAgICAgICAgIGl0ZW1zLFxuICAgICAgICAgIC4uLnN0YXRlc0ZvclJlbmRlcmluZyhwcm9wcywgbmV3U3RhdGUpLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlc2V0IGl0ZW1zIGlmIG5ldyBpdGVtcyBhcnJheSBpcyBlbXB0eS5cbiAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAwICYmIHN0YXRlLml0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhhc1BlbmRpbmdNZWFzdXJlbWVudHMsXG4gICAgICAgIGl0ZW1zLFxuICAgICAgICAuLi5zdGF0ZXNGb3JSZW5kZXJpbmcocHJvcHMsIG5ld1N0YXRlKSxcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChoYXNQZW5kaW5nTWVhc3VyZW1lbnRzICE9PSBzdGF0ZS5oYXNQZW5kaW5nTWVhc3VyZW1lbnRzKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgd2UgYWx3YXlzIHVwZGF0ZSBoYXNQZW5kaW5nTWVhc3VyZW1lbnRzXG4gICAgICByZXR1cm4ge1xuICAgICAgICBoYXNQZW5kaW5nTWVhc3VyZW1lbnRzLFxuICAgICAgICBpdGVtcyxcbiAgICAgICAgLi4uc3RhdGVzRm9yUmVuZGVyaW5nKHByb3BzLCBuZXdTdGF0ZSksXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIFJldHVybiBudWxsIHRvIGluZGljYXRlIG5vIGNoYW5nZSB0byBzdGF0ZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHNldEdyaWRXcmFwcGVyUmVmID0gKHJlZjogP0hUTUxFbGVtZW50KSA9PiB7XG4gICAgdGhpcy5ncmlkV3JhcHBlciA9IHJlZjtcbiAgfTtcblxuICBzZXRTY3JvbGxDb250YWluZXJSZWYgPSAocmVmOiA/U2Nyb2xsQ29udGFpbmVyKSA9PiB7XG4gICAgdGhpcy5zY3JvbGxDb250YWluZXIgPSByZWY7XG4gIH07XG5cbiAgaGFuZGxlVmlydHVhbGl6YXRpb25XaW5kb3dVcGRhdGUgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBoZWlnaHQsIHdpZHRoIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmIChcbiAgICAgIHR5cGVvZiB0aGlzLnByb3BzLm9uVmlydHVhbGl6YXRpb25XaW5kb3dVcGRhdGUgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIHRoaXMuY29udGFpbmVySGVpZ2h0XG4gICAgKSB7XG4gICAgICBjb25zdCB2aWV3cG9ydCA9IHtcbiAgICAgICAgdG9wOiB0aGlzLnN0YXRlLnNjcm9sbFRvcCxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLmNvbnRhaW5lckhlaWdodCxcbiAgICAgICAgd2lkdGg6IHdpZHRoIHx8IDAsXG4gICAgICB9O1xuICAgICAgY29uc3QgY29udGVudCA9IHtcbiAgICAgICAgdG9wOiB0aGlzLmNvbnRhaW5lck9mZnNldCxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICB3aWR0aDogd2lkdGggfHwgMCxcbiAgICAgIH07XG5cbiAgICAgIHRoaXMucHJvcHMub25WaXJ0dWFsaXphdGlvbldpbmRvd1VwZGF0ZShjb250ZW50LCB2aWV3cG9ydCk7XG4gICAgfVxuICB9O1xuXG4gIGhhbmRsZU9uQXV0b01lYXN1cmluZ1VwZGF0ZSA9IChzdGF0ZTogTWVhc3VyZW1lbnRTdGF0ZSkgPT4ge1xuICAgIGlmICh0aGlzLnByb3BzLm9uQXV0b01lYXN1cmluZ1VwZGF0ZSkge1xuICAgICAgdGhpcy5wcm9wcy5vbkF1dG9NZWFzdXJpbmdVcGRhdGUoc3RhdGUpO1xuICAgIH1cbiAgfTtcblxuICBjb250YWluZXJIZWlnaHQ6IG51bWJlcjtcblxuICBjb250YWluZXJPZmZzZXQ6IG51bWJlcjtcblxuICBncmlkV3JhcHBlcjogP0hUTUxFbGVtZW50O1xuXG4gIGluc2VydEFuaW1hdGlvbkZyYW1lOiBBbmltYXRpb25GcmFtZUlEO1xuXG4gIG1lYXN1cmVUaW1lb3V0OiBUaW1lb3V0SUQ7XG5cbiAgc2Nyb2xsQ29udGFpbmVyOiA/U2Nyb2xsQ29udGFpbmVyO1xuXG4gIG1lYXN1cmVDb250YWluZXIoKSB7XG4gICAgaWYgKHRoaXMuc2Nyb2xsQ29udGFpbmVyICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHsgc2Nyb2xsQ29udGFpbmVyIH0gPSB0aGlzO1xuICAgICAgY29uc3Qgc2Nyb2xsQ29udGFpbmVyUmVmID0gc2Nyb2xsQ29udGFpbmVyLmdldFNjcm9sbENvbnRhaW5lclJlZigpO1xuICAgICAgaWYgKHNjcm9sbENvbnRhaW5lclJlZikge1xuICAgICAgICB0aGlzLmNvbnRhaW5lckhlaWdodCA9IGdldEVsZW1lbnRIZWlnaHQoc2Nyb2xsQ29udGFpbmVyUmVmKTtcbiAgICAgICAgY29uc3QgZWwgPSB0aGlzLmdyaWRXcmFwcGVyO1xuICAgICAgICBpZiAoZWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgIGNvbnN0IHJlbGF0aXZlU2Nyb2xsVG9wID0gZ2V0UmVsYXRpdmVTY3JvbGxUb3Aoc2Nyb2xsQ29udGFpbmVyUmVmKTtcbiAgICAgICAgICB0aGlzLmNvbnRhaW5lck9mZnNldCA9XG4gICAgICAgICAgICBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKyByZWxhdGl2ZVNjcm9sbFRvcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhciBtZWFzdXJlbWVudHMvcG9zaXRpb25zIGFuZCBmb3JjZSBhIHJlZmxvdyBvZiB0aGUgZW50aXJlIGdyaWQuXG4gICAqIE9ubHkgdXNlIHRoaXMgaWYgYWJzb2x1dGVseSBuZWNlc3NhcnkgLSBleDogV2UgbmVlZCB0byByZWZsb3cgaXRlbXMgaWYgdGhlXG4gICAqIG51bWJlciBvZiBjb2x1bW5zIHdlIHdvdWxkIGRpc3BsYXkgc2hvdWxkIGNoYW5nZSBhZnRlciBhIHJlc2l6ZS5cbiAgICovXG4gIHJlZmxvdygpIHtcbiAgICB0aGlzLnByb3BzLm1lYXN1cmVtZW50U3RvcmUucmVzZXQoKTtcbiAgICB0aGlzLm1lYXN1cmVDb250YWluZXIoKTtcbiAgICB0aGlzLmhhbmRsZVZpcnR1YWxpemF0aW9uV2luZG93VXBkYXRlKCk7XG4gICAgdGhpcy5mb3JjZVVwZGF0ZSgpO1xuICB9XG5cbiAgcmVuZGVyTWFzb25yeUNvbXBvbmVudCA9IChpdGVtRGF0YTogVCwgaWR4OiBudW1iZXIsIHBvc2l0aW9uOiAqKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgY29tcDogQ29tcG9uZW50LFxuICAgICAgdmlydHVhbGl6ZSxcbiAgICAgIHZpcnR1YWxCb3VuZHNUb3AsXG4gICAgICB2aXJ0dWFsQm91bmRzQm90dG9tLFxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgdG9wLCBsZWZ0LCB3aWR0aCwgaGVpZ2h0IH0gPSBwb3NpdGlvbjtcblxuICAgIGxldCBpc1Zpc2libGU7XG4gICAgaWYgKHRoaXMucHJvcHMuc2Nyb2xsQ29udGFpbmVyKSB7XG4gICAgICBjb25zdCB2aXJ0dWFsQnVmZmVyID0gdGhpcy5jb250YWluZXJIZWlnaHQgKiBWSVJUVUFMX0JVRkZFUl9GQUNUT1I7XG4gICAgICBjb25zdCBvZmZzZXRTY3JvbGxQb3MgPSB0aGlzLnN0YXRlLnNjcm9sbFRvcCAtIHRoaXMuY29udGFpbmVyT2Zmc2V0O1xuICAgICAgY29uc3Qgdmlld3BvcnRUb3AgPSB2aXJ0dWFsQm91bmRzVG9wXG4gICAgICAgID8gb2Zmc2V0U2Nyb2xsUG9zIC0gdmlydHVhbEJvdW5kc1RvcFxuICAgICAgICA6IG9mZnNldFNjcm9sbFBvcyAtIHZpcnR1YWxCdWZmZXI7XG4gICAgICBjb25zdCB2aWV3cG9ydEJvdHRvbSA9IHZpcnR1YWxCb3VuZHNCb3R0b21cbiAgICAgICAgPyBvZmZzZXRTY3JvbGxQb3MgKyB0aGlzLmNvbnRhaW5lckhlaWdodCArIHZpcnR1YWxCb3VuZHNCb3R0b21cbiAgICAgICAgOiBvZmZzZXRTY3JvbGxQb3MgKyB0aGlzLmNvbnRhaW5lckhlaWdodCArIHZpcnR1YWxCdWZmZXI7XG5cbiAgICAgIGlzVmlzaWJsZSA9ICEoXG4gICAgICAgIHBvc2l0aW9uLnRvcCArIHBvc2l0aW9uLmhlaWdodCA8IHZpZXdwb3J0VG9wIHx8XG4gICAgICAgIHBvc2l0aW9uLnRvcCA+IHZpZXdwb3J0Qm90dG9tXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBubyBzY3JvbGwgY29udGFpbmVyIGlzIHBhc3NlZCBpbiwgaXRlbXMgc2hvdWxkIGFsd2F5cyBiZSB2aXNpYmxlXG4gICAgICBpc1Zpc2libGUgPSB0cnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGl0ZW1Db21wb25lbnQgPSAoXG4gICAgICA8ZGl2XG4gICAgICAgIGtleT17YGl0ZW0tJHtpZHh9YH1cbiAgICAgICAgY2xhc3NOYW1lPXtbc3R5bGVzLk1hc29ucnlfX0l0ZW0sIHN0eWxlcy5NYXNvbnJ5X19JdGVtX19Nb3VudGVkXS5qb2luKFxuICAgICAgICAgICcgJ1xuICAgICAgICApfVxuICAgICAgICBkYXRhLWdyaWQtaXRlbVxuICAgICAgICBzdHlsZT17e1xuICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZVgoJHtsZWZ0fXB4KSB0cmFuc2xhdGVZKCR7dG9wfXB4KWAsXG4gICAgICAgICAgV2Via2l0VHJhbnNmb3JtOiBgdHJhbnNsYXRlWCgke2xlZnR9cHgpIHRyYW5zbGF0ZVkoJHt0b3B9cHgpYCxcbiAgICAgICAgICB3aWR0aDogbGF5b3V0TnVtYmVyVG9Dc3NEaW1lbnNpb24od2lkdGgpLFxuICAgICAgICAgIGhlaWdodDogbGF5b3V0TnVtYmVyVG9Dc3NEaW1lbnNpb24oaGVpZ2h0KSxcbiAgICAgICAgfX1cbiAgICAgID5cbiAgICAgICAgPENvbXBvbmVudCBkYXRhPXtpdGVtRGF0YX0gaXRlbUlkeD17aWR4fSBpc01lYXN1cmluZz17ZmFsc2V9IC8+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuXG4gICAgcmV0dXJuIHZpcnR1YWxpemUgPyAoaXNWaXNpYmxlICYmIGl0ZW1Db21wb25lbnQpIHx8IG51bGwgOiBpdGVtQ29tcG9uZW50O1xuICB9O1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb2x1bW5XaWR0aCxcbiAgICAgIGNvbXA6IENvbXBvbmVudCxcbiAgICAgIGZsZXhpYmxlLFxuICAgICAgbWVhc3VyZW1lbnRTdG9yZSxcbiAgICAgIGl0ZW1zLFxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHtcbiAgICAgIGhhc1BlbmRpbmdNZWFzdXJlbWVudHMsXG4gICAgICBoZWlnaHQsXG4gICAgICBpdGVtc1RvTWVhc3VyZSxcbiAgICAgIGl0ZW1zVG9SZW5kZXIsXG4gICAgICBtZWFzdXJpbmdQb3NpdGlvbnMsXG4gICAgICByZW5kZXJQb3NpdGlvbnMsXG4gICAgICB3aWR0aCxcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBsZXQgZ3JpZEJvZHk7XG4gICAgaWYgKHdpZHRoID09IG51bGwgJiYgaGFzUGVuZGluZ01lYXN1cmVtZW50cykge1xuICAgICAgLy8gV2hlbiBoeXJkYXRpbmcgZnJvbSBhIHNlcnZlciByZW5kZXIsIHdlIGRvbid0IGhhdmUgdGhlIHdpZHRoIG9mIHRoZSBncmlkXG4gICAgICAvLyBhbmQgdGhlIG1lYXN1cmVtZW50IHN0b3JlIGlzIGVtcHR5XG4gICAgICBncmlkQm9keSA9IChcbiAgICAgICAgPGRpdlxuICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLk1hc29ucnl9XG4gICAgICAgICAgc3R5bGU9e3sgaGVpZ2h0OiAwLCB3aWR0aDogJzEwMCUnIH19XG4gICAgICAgICAgcmVmPXt0aGlzLnNldEdyaWRXcmFwcGVyUmVmfVxuICAgICAgICA+XG4gICAgICAgICAge2l0ZW1zLmZpbHRlcihpdGVtID0+IGl0ZW0pLm1hcCgoaXRlbSwgaSkgPT4gKFxuICAgICAgICAgICAgPGRpdiAvLyBrZWVwIHRoaXMgaW4gc3luYyB3aXRoIHJlbmRlck1hc29ucnlDb21wb25lbnRcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwic3RhdGljXCJcbiAgICAgICAgICAgICAgZGF0YS1ncmlkLWl0ZW1cbiAgICAgICAgICAgICAga2V5PXtpfVxuICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoMHB4KSB0cmFuc2xhdGVZKDBweCknLFxuICAgICAgICAgICAgICAgIFdlYmtpdFRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoMHB4KSB0cmFuc2xhdGVZKDBweCknLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBmbGV4aWJsZVxuICAgICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgIDogbGF5b3V0TnVtYmVyVG9Dc3NEaW1lbnNpb24oY29sdW1uV2lkdGgpLCAvLyB3ZSBjYW4ndCBzZXQgYSB3aWR0aCBmb3Igc2VydmVyIHJlbmRlcmVkIGZsZXhpYmxlIGl0ZW1zXG4gICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgIHJlZj17ZWwgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlbCAmJiAhZmxleGlibGUpIHtcbiAgICAgICAgICAgICAgICAgIC8vIG9ubHkgbWVhc3VyZSBmbGV4aWJsZSBpdGVtcyBvbiBjbGllbnRcbiAgICAgICAgICAgICAgICAgIG1lYXN1cmVtZW50U3RvcmUuc2V0KGl0ZW0sIGVsLmNsaWVudEhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8Q29tcG9uZW50IGRhdGE9e2l0ZW19IGl0ZW1JZHg9e2l9IGlzTWVhc3VyaW5nPXtmYWxzZX0gLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICkpfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICh3aWR0aCA9PSBudWxsKSB7XG4gICAgICAvLyBXaGVuIHRoZSB3aWR0aCBpcyBlbXB0eSAodXN1YWxseSBhZnRlciBhIHJlLW1vdW50KSByZW5kZXIgYW4gZW1wdHlcbiAgICAgIC8vIGRpdiB0byBjb2xsZWN0IHRoZSB3aWR0aCBmb3IgbGF5b3V0XG4gICAgICBncmlkQm9keSA9IDxkaXYgc3R5bGU9e3sgd2lkdGg6ICcxMDAlJyB9fSByZWY9e3RoaXMuc2V0R3JpZFdyYXBwZXJSZWZ9IC8+O1xuICAgIH0gZWxzZSB7XG4gICAgICBncmlkQm9keSA9IChcbiAgICAgICAgPGRpdiBzdHlsZT17eyB3aWR0aDogJzEwMCUnIH19IHJlZj17dGhpcy5zZXRHcmlkV3JhcHBlclJlZn0+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5NYXNvbnJ5fSBzdHlsZT17eyBoZWlnaHQsIHdpZHRoIH19PlxuICAgICAgICAgICAge2l0ZW1zVG9SZW5kZXIubWFwKChpdGVtLCBpKSA9PlxuICAgICAgICAgICAgICAvLyAkRmxvd0ZpeE1lIHRoaXMgaXMgdGhlIHJpZ2h0IGRlZmluaXRpb24sIGl0IGFuIEFycmF5PFQ+XG4gICAgICAgICAgICAgIHRoaXMucmVuZGVyTWFzb25yeUNvbXBvbmVudChpdGVtLCBpLCByZW5kZXJQb3NpdGlvbnNbaV0pXG4gICAgICAgICAgICApfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuTWFzb25yeX0gc3R5bGU9e3sgd2lkdGggfX0+XG4gICAgICAgICAgICB7aXRlbXNUb01lYXN1cmUubWFwKChkYXRhLCBpKSA9PiB7XG4gICAgICAgICAgICAgIC8vIGl0ZW1zVG9NZWFzdXJlIGlzIGFsd2F5cyB0aGUgbGVuZ3RoIG9mIG1pbkNvbHMsIHNvIGkgd2lsbCBhbHdheXMgYmUgMC4ubWluQ29scy5sZW5ndGhcbiAgICAgICAgICAgICAgLy8gd2Ugbm9ybWFsaXplIHRoZSBpbmRleCBoZXJlIHJlbGF0aXZlIHRvIHRoZSBpdGVtIGxpc3QgYXMgYSB3aG9sZSBzbyB0aGF0IGl0ZW1JZHggaXMgY29ycmVjdFxuICAgICAgICAgICAgICAvLyBhbmQgc28gdGhhdCBSZWFjdCBkb2VzbnQgcmV1c2UgdGhlIG1lYXN1cmVtZW50IG5vZGVzXG4gICAgICAgICAgICAgIGNvbnN0IG1lYXN1cmVtZW50SW5kZXggPSBpdGVtc1RvUmVuZGVyLmxlbmd0aCArIGk7XG4gICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gbWVhc3VyaW5nUG9zaXRpb25zW2ldO1xuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgIGtleT17YG1lYXN1cmluZy0ke21lYXN1cmVtZW50SW5kZXh9YH1cbiAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6ICdoaWRkZW4nLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiBsYXlvdXROdW1iZXJUb0Nzc0RpbWVuc2lvbihwb3NpdGlvbi50b3ApLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBsYXlvdXROdW1iZXJUb0Nzc0RpbWVuc2lvbihwb3NpdGlvbi5sZWZ0KSxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGxheW91dE51bWJlclRvQ3NzRGltZW5zaW9uKHBvc2l0aW9uLndpZHRoKSxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBsYXlvdXROdW1iZXJUb0Nzc0RpbWVuc2lvbihwb3NpdGlvbi5oZWlnaHQpLFxuICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgIHJlZj17ZWwgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICBtZWFzdXJlbWVudFN0b3JlLnNldChkYXRhLCBlbC5jbGllbnRIZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIDxDb21wb25lbnRcbiAgICAgICAgICAgICAgICAgICAgZGF0YT17ZGF0YX1cbiAgICAgICAgICAgICAgICAgICAgaXRlbUlkeD17bWVhc3VyZW1lbnRJbmRleH1cbiAgICAgICAgICAgICAgICAgICAgaXNNZWFzdXJpbmdcbiAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KX1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnByb3BzLnNjcm9sbENvbnRhaW5lciA/IChcbiAgICAgIDxTY3JvbGxDb250YWluZXJcbiAgICAgICAgcmVmPXt0aGlzLnNldFNjcm9sbENvbnRhaW5lclJlZn1cbiAgICAgICAgb25TY3JvbGw9e3RoaXMudXBkYXRlU2Nyb2xsUG9zaXRpb259XG4gICAgICAgIHNjcm9sbENvbnRhaW5lcj17dGhpcy5wcm9wcy5zY3JvbGxDb250YWluZXJ9XG4gICAgICA+XG4gICAgICAgIHtncmlkQm9keX1cbiAgICAgIDwvU2Nyb2xsQ29udGFpbmVyPlxuICAgICkgOiAoXG4gICAgICBncmlkQm9keVxuICAgICk7XG4gIH1cbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgRmV0Y2hJdGVtcyBmcm9tICcuL0ZldGNoSXRlbXMuanMnO1xuaW1wb3J0IE1lYXN1cmVtZW50U3RvcmUgZnJvbSAnLi9NZWFzdXJlbWVudFN0b3JlLmpzJztcbmltcG9ydCBNYXNvbnJ5LCB7IHR5cGUgUHJvcHMsIHR5cGUgTWVhc3VyZW1lbnRTdGF0ZSB9IGZyb20gJy4vTWFzb25yeUJldGEuanMnO1xuaW1wb3J0IHsgdHlwZSBQb3NpdGlvbiB9IGZyb20gJy4vZGVmYXVsdExheW91dC5qcyc7XG5cbnR5cGUgU3RhdGU8VD4gPSB7fFxuICBjb250YWluZXJIZWlnaHQ6IG51bWJlcixcbiAgaGFzUGVuZGluZ01lYXN1cmVtZW50czogYm9vbGVhbixcbiAgaXNGZXRjaGluZzogYm9vbGVhbixcbiAgaXRlbXM6IEFycmF5PFQ+LFxuICBzY3JvbGxUb3A6IG51bWJlcixcbiAgc2Nyb2xsSGVpZ2h0OiBudW1iZXIsXG58fTtcblxuLyoqXG4gKiBUaGlzIE1hc29ucnlJbmZpbml0ZUJldGEgaXMgYmFja3dhcmQgY29tcGF0aWJsZSB3aXRoIE1hc29ucnkgYW5kXG4gKiBzZXJ2ZXMgdG8gaGVscCB3aXRoIG1pZ3JhdGluZyB0byBhIE1hc3JvbnkgdGhhdCBkb2Vzbid0IGhhdmVcbiAqIHRoZSBzY3JvbCBmZXRjaCBjb25jZXJucy5cbiAqXG4gKiBJdCBpcyBpbiBiZXRhIHNvIHRoYXQgaXQgY2FuIGJlIGJhdHRsZSB0ZXN0ZWQuXG4gKlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXNvbnJ5SW5maW5pdGVCZXRhPFQ+IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFxuICBQcm9wczxUPixcbiAgU3RhdGU8VD5cbj4ge1xuICBzdGF0aWMgY3JlYXRlTWVhc3VyZW1lbnRTdG9yZSgpIHtcbiAgICByZXR1cm4gbmV3IE1lYXN1cmVtZW50U3RvcmUoKTtcbiAgfVxuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSBNYXNvbnJ5LmRlZmF1bHRQcm9wcztcblxuICBjb25zdHJ1Y3Rvcihwcm9wczogUHJvcHM8VD4pIHtcbiAgICBzdXBlcihwcm9wcyk7XG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgY29udGFpbmVySGVpZ2h0OiAwLFxuICAgICAgaGFzUGVuZGluZ01lYXN1cmVtZW50czogZmFsc2UsXG4gICAgICBpc0ZldGNoaW5nOiBmYWxzZSxcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9uby11bnVzZWQtc3RhdGVcbiAgICAgIGl0ZW1zOiBwcm9wcy5pdGVtcyxcbiAgICAgIHNjcm9sbFRvcDogMCxcbiAgICAgIHNjcm9sbEhlaWdodDogMCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnRlbnQgbGF5ZXIgYW5kIFZpZXdwb3J0IGxheWVyIGlzIGFzIGRlZmluZWQgaW4gQ29sbGVjdGlvbi5cbiAgICovXG4gIG9uVmlydHVhbGl6YXRpb25XaW5kb3dVcGRhdGUgPSAoY29udGVudDogUG9zaXRpb24sIHZpZXdwb3J0OiBQb3NpdGlvbikgPT4ge1xuICAgIGNvbnN0IHsgY29udGFpbmVySGVpZ2h0LCBzY3JvbGxUb3AsIHNjcm9sbEhlaWdodCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoXG4gICAgICB2aWV3cG9ydC5oZWlnaHQgIT09IGNvbnRhaW5lckhlaWdodCB8fFxuICAgICAgdmlld3BvcnQudG9wICE9PSBzY3JvbGxUb3AgfHxcbiAgICAgIGNvbnRlbnQuaGVpZ2h0ICE9PSBzY3JvbGxIZWlnaHRcbiAgICApIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBjb250YWluZXJIZWlnaHQ6IHZpZXdwb3J0LmhlaWdodCxcbiAgICAgICAgc2Nyb2xsVG9wOiB2aWV3cG9ydC50b3AsXG4gICAgICAgIHNjcm9sbEhlaWdodDogY29udGVudC5oZWlnaHQsXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhwcm9wczogUHJvcHM8VD4sIHN0YXRlOiBTdGF0ZTxUPikge1xuICAgIGNvbnN0IHsgaXRlbXMgfSA9IHByb3BzO1xuXG4gICAgLy8gYXNzdW1lIGltbXV0YWJsZSBpdGVtc1xuICAgIGlmIChwcm9wcy5pdGVtcyAhPT0gc3RhdGUuaXRlbXMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGl0ZW1zLFxuICAgICAgICBpc0ZldGNoaW5nOiBmYWxzZSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIG51bGwgdG8gaW5kaWNhdGUgbm8gY2hhbmdlIHRvIHN0YXRlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgc2V0UmVmID0gKHJlZjogUmVhY3QuRWxlbWVudFJlZjwqPikgPT4ge1xuICAgIGlmIChyZWYpIHtcbiAgICAgIHRoaXMuZ3JpZFJlZiA9IHJlZjtcbiAgICB9XG4gIH07XG5cbiAgZmV0Y2hNb3JlID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgbG9hZEl0ZW1zIH0gPSB0aGlzLnByb3BzO1xuICAgIGlmIChsb2FkSXRlbXMgJiYgdHlwZW9mIGxvYWRJdGVtcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5zZXRTdGF0ZShcbiAgICAgICAge1xuICAgICAgICAgIGlzRmV0Y2hpbmc6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgICgpID0+IGxvYWRJdGVtcyh7IGZyb206IHRoaXMucHJvcHMuaXRlbXMubGVuZ3RoIH0pXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICBoYW5kbGVPbkF1dG9NZWFzdXJpbmdVcGRhdGUgPSAoc3RhdGU6IE1lYXN1cmVtZW50U3RhdGUpID0+IHtcbiAgICBjb25zdCBoYXNQZW5kaW5nTWVhc3VyZW1lbnRzID0gc3RhdGUgPT09ICdtZWFzdXJpbmcnO1xuICAgIGlmICh0aGlzLnN0YXRlLmhhc1BlbmRpbmdNZWFzdXJlbWVudHMgIT09IGhhc1BlbmRpbmdNZWFzdXJlbWVudHMpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBoYXNQZW5kaW5nTWVhc3VyZW1lbnRzIH0pO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGhpcy5wcm9wcy5vbkF1dG9NZWFzdXJpbmdVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMucHJvcHMub25BdXRvTWVhc3VyaW5nVXBkYXRlKHN0YXRlKTtcbiAgICB9XG4gIH07XG5cbiAgcmVmbG93ID0gKCkgPT4ge1xuICAgIGlmICh0aGlzLmdyaWRSZWYpIHtcbiAgICAgIHRoaXMuZ3JpZFJlZi5yZWZsb3coKTtcbiAgICB9XG4gIH07XG5cbiAgaGFuZGxlUmVzaXplID0gKCkgPT4ge1xuICAgIGlmICh0aGlzLmdyaWRSZWYpIHtcbiAgICAgIHRoaXMuZ3JpZFJlZi5oYW5kbGVSZXNpemUoKTtcbiAgICB9XG4gIH07XG5cbiAgZ3JpZFJlZjogTWFzb25yeTxUPjtcblxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMuc2Nyb2xsQ29udGFpbmVyID8gKFxuICAgICAgPFJlYWN0LkZyYWdtZW50PlxuICAgICAgICA8RmV0Y2hJdGVtc1xuICAgICAgICAgIGNvbnRhaW5lckhlaWdodD17dGhpcy5zdGF0ZS5jb250YWluZXJIZWlnaHR9XG4gICAgICAgICAgZmV0Y2hNb3JlPXt0aGlzLmZldGNoTW9yZX1cbiAgICAgICAgICBpc0ZldGNoaW5nPXtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuaXNGZXRjaGluZyB8fCB0aGlzLnN0YXRlLmhhc1BlbmRpbmdNZWFzdXJlbWVudHNcbiAgICAgICAgICB9XG4gICAgICAgICAgc2Nyb2xsSGVpZ2h0PXt0aGlzLnN0YXRlLnNjcm9sbEhlaWdodH1cbiAgICAgICAgICBzY3JvbGxUb3A9e3RoaXMuc3RhdGUuc2Nyb2xsVG9wfVxuICAgICAgICAvPlxuICAgICAgICA8TWFzb25yeVxuICAgICAgICAgIHsuLi50aGlzLnByb3BzfVxuICAgICAgICAgIG9uVmlydHVhbGl6YXRpb25XaW5kb3dVcGRhdGU9e3RoaXMub25WaXJ0dWFsaXphdGlvbldpbmRvd1VwZGF0ZX1cbiAgICAgICAgICBvbkF1dG9NZWFzdXJpbmdVcGRhdGU9e3RoaXMuaGFuZGxlT25BdXRvTWVhc3VyaW5nVXBkYXRlfVxuICAgICAgICAgIHJlZj17dGhpcy5zZXRSZWZ9XG4gICAgICAgIC8+XG4gICAgICA8L1JlYWN0LkZyYWdtZW50PlxuICAgICkgOiAoXG4gICAgICA8TWFzb25yeSB7Li4udGhpcy5wcm9wc30gcmVmPXt0aGlzLnNldFJlZn0gLz5cbiAgICApO1xuICB9XG59XG4iLCIvKiBAZmxvdyAqL1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG50eXBlIFByb3BzID0ge3xcbiAgY2hpbGRyZW4/OiBSZWFjdC5Ob2RlLFxufH07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vU2Nyb2xsQmVoYXZpb3IgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8UHJvcHM+IHtcbiAgY29uc3RydWN0b3IocHJvcHM6IFByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMucHJldk92ZXJmbG93ID0gbnVsbDtcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5wcmV2T3ZlcmZsb3cgPSB3aW5kb3cuZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdztcbiAgICAgIHdpbmRvdy5kb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgfVxuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB3aW5kb3cuZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9IHRoaXMucHJldk92ZXJmbG93O1xuICAgIH1cbiAgfVxuXG4gIHByZXZPdmVyZmxvdzogc3RyaW5nIHwgbnVsbDtcblxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW47XG4gIH1cbn1cbiIsIi8qIEBmbG93ICovXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBjaGlsZHJlbj86IFJlYWN0Lk5vZGUsXG58fTtcblxuZnVuY3Rpb24gcXVlcnlGb2N1c2FibGVBbGwoZWw6IEhUTUxEaXZFbGVtZW50KSB7XG4gIGNvbnN0IHNlbGVjdG9yID0gW1xuICAgICdhW2hyZWZdJyxcbiAgICAnYXJlYVtocmVmXScsXG4gICAgJ2lucHV0Om5vdChbZGlzYWJsZWRdKScsXG4gICAgJ3NlbGVjdDpub3QoW2Rpc2FibGVkXSknLFxuICAgICd0ZXh0YXJlYTpub3QoW2Rpc2FibGVkXSknLFxuICAgICdidXR0b246bm90KFtkaXNhYmxlZF0pJyxcbiAgICAnaWZyYW1lJyxcbiAgICAnb2JqZWN0JyxcbiAgICAnZW1iZWQnLFxuICAgICdbdGFiaW5kZXg9XCItMVwiXScsXG4gICAgJ1t0YWJpbmRleD1cIjBcIl0nLFxuICAgICdbY29udGVudGVkaXRhYmxlXScsXG4gICAgJ2F1ZGlvW2NvbnRyb2xzXScsXG4gICAgJ3ZpZGVvW2NvbnRyb2xzXScsXG4gICAgJ3N1bW1hcnknLFxuICBdLmpvaW4oJywnKTtcbiAgcmV0dXJuIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xufVxuXG5jb25zdCBmb2N1c0VsZW1lbnQgPSAoZWw6IEhUTUxFbGVtZW50KSA9PiB7XG4gIGlmICh0eXBlb2YgZWwuZm9jdXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBlbC5mb2N1cygpO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUcmFwRm9jdXNCZWhhdmlvciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxQcm9wcz4ge1xuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLnByZXZpb3VzbHlGb2N1c2VkRWwgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIHRoaXMuZm9jdXNGaXJzdENoaWxkKCk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLmhhbmRsZUZvY3VzLCB0cnVlKTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5oYW5kbGVGb2N1cywgdHJ1ZSk7XG4gICAgaWYgKHRoaXMucHJldmlvdXNseUZvY3VzZWRFbCkge1xuICAgICAgZm9jdXNFbGVtZW50KHRoaXMucHJldmlvdXNseUZvY3VzZWRFbCk7XG4gICAgfVxuICB9XG5cbiAgc2V0RWxSZWYgPSAoZWw6ID9IVE1MRGl2RWxlbWVudCkgPT4ge1xuICAgIGlmIChlbCkge1xuICAgICAgdGhpcy5lbCA9IGVsO1xuICAgIH1cbiAgfTtcblxuICBoYW5kbGVGb2N1cyA9IChldmVudDogRm9jdXNFdmVudCkgPT4ge1xuICAgIGlmIChcbiAgICAgICF0aGlzLmVsIHx8XG4gICAgICAoZXZlbnQudGFyZ2V0IGluc3RhbmNlb2YgTm9kZSAmJiB0aGlzLmVsLmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLmZvY3VzRmlyc3RDaGlsZCgpO1xuICB9O1xuXG4gIGZvY3VzRmlyc3RDaGlsZCgpIHtcbiAgICBjb25zdCB7IGVsIH0gPSB0aGlzO1xuICAgIGlmIChlbCkge1xuICAgICAgZm9jdXNFbGVtZW50KHF1ZXJ5Rm9jdXNhYmxlQWxsKGVsKVswXSk7XG4gICAgfVxuICB9XG5cbiAgZWw6ID9IVE1MRGl2RWxlbWVudDtcblxuICBwcmV2aW91c2x5Rm9jdXNlZEVsOiA/SFRNTEVsZW1lbnQ7XG5cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiA8ZGl2IHJlZj17dGhpcy5zZXRFbFJlZn0+e3RoaXMucHJvcHMuY2hpbGRyZW59PC9kaXY+O1xuICB9XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBCb3ggZnJvbSAnLi9Cb3guanMnO1xuaW1wb3J0IERpdmlkZXIgZnJvbSAnLi9EaXZpZGVyLmpzJztcbmltcG9ydCBIZWFkaW5nIGZyb20gJy4vSGVhZGluZy5qcyc7XG5pbXBvcnQgSWNvbkJ1dHRvbiBmcm9tICcuL0ljb25CdXR0b24uanMnO1xuaW1wb3J0IFN0b3BTY3JvbGxCZWhhdmlvciBmcm9tICcuL2JlaGF2aW9ycy9TdG9wU2Nyb2xsQmVoYXZpb3IuanMnO1xuaW1wb3J0IFRyYXBGb2N1c0JlaGF2aW9yIGZyb20gJy4vYmVoYXZpb3JzL1RyYXBGb2N1c0JlaGF2aW9yLmpzJztcbmltcG9ydCBPdXRzaWRlRXZlbnRCZWhhdmlvciBmcm9tICcuL2JlaGF2aW9ycy9PdXRzaWRlRXZlbnRCZWhhdmlvci5qcyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vTW9kYWwuY3NzJztcblxudHlwZSBQcm9wcyA9IHt8XG4gIGFjY2Vzc2liaWxpdHlDbG9zZUxhYmVsOiBzdHJpbmcsXG4gIGFjY2Vzc2liaWxpdHlNb2RhbExhYmVsOiBzdHJpbmcsXG4gIGNoaWxkcmVuPzogUmVhY3QuTm9kZSxcbiAgZm9vdGVyPzogUmVhY3QuTm9kZSxcbiAgaGVhZGluZzogc3RyaW5nLFxuICBvbkRpc21pc3M6ICgpID0+IHZvaWQsXG4gIHJvbGU/OiAnYWxlcnRkaWFsb2cnIHwgJ2RpYWxvZycsXG4gIHNpemU/OiAnc20nIHwgJ21kJyB8ICdsZycsXG58fTtcblxuY29uc3QgU0laRV9XSURUSF9NQVAgPSB7XG4gIHNtOiA0MTQsXG4gIG1kOiA1NDQsXG4gIGxnOiA4MDQsXG59O1xuXG5jb25zdCBFU0NBUEVfS0VZX0NPREUgPSAyNztcblxuY29uc3QgQmFja2Ryb3AgPSAoeyBjaGlsZHJlbiB9OiB7IGNoaWxkcmVuPzogUmVhY3QuTm9kZSB9KSA9PiAoXG4gIDxSZWFjdC5GcmFnbWVudD5cbiAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLkJhY2tkcm9wfSAvPlxuICAgIHtjaGlsZHJlbn1cbiAgPC9SZWFjdC5GcmFnbWVudD5cbik7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vZGFsIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFByb3BzPiB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICAgIGFjY2Vzc2liaWxpdHlDbG9zZUxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgZm9vdGVyOiBQcm9wVHlwZXMubm9kZSxcbiAgICBoZWFkaW5nOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgYWNjZXNzaWJpbGl0eU1vZGFsTGFiZWw6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBvbkRpc21pc3M6IFByb3BUeXBlcy5mdW5jLFxuICAgIHJvbGU6IFByb3BUeXBlcy5vbmVPZihbJ2FsZXJ0ZGlhbG9nJywgJ2RpYWxvZyddKSxcbiAgICBzaXplOiBQcm9wVHlwZXMub25lT2YoWydzbScsICdtZCcsICdsZyddKSxcbiAgfTtcblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLmhhbmRsZUtleVVwKTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMuaGFuZGxlS2V5VXApO1xuICB9XG5cbiAgaGFuZGxlT3V0c2lkZUNsaWNrID0gKCkgPT4ge1xuICAgIHRoaXMucHJvcHMub25EaXNtaXNzKCk7XG4gIH07XG5cbiAgaGFuZGxlQ2xvc2VDbGljayA9ICgpID0+IHtcbiAgICB0aGlzLnByb3BzLm9uRGlzbWlzcygpO1xuICB9O1xuXG4gIGhhbmRsZUtleVVwID0gKGV2ZW50OiB7IGtleUNvZGU6IG51bWJlciB9KSA9PiB7XG4gICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IEVTQ0FQRV9LRVlfQ09ERSkge1xuICAgICAgdGhpcy5wcm9wcy5vbkRpc21pc3MoKTtcbiAgICB9XG4gIH07XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGFjY2Vzc2liaWxpdHlDbG9zZUxhYmVsLFxuICAgICAgYWNjZXNzaWJpbGl0eU1vZGFsTGFiZWwsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGZvb3RlcixcbiAgICAgIGhlYWRpbmcsXG4gICAgICByb2xlID0gJ2RpYWxvZycsXG4gICAgICBzaXplID0gJ3NtJyxcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB3aWR0aCA9IFNJWkVfV0lEVEhfTUFQW3NpemVdO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxTdG9wU2Nyb2xsQmVoYXZpb3I+XG4gICAgICAgIDxUcmFwRm9jdXNCZWhhdmlvcj5cbiAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICBhcmlhLWxhYmVsPXthY2Nlc3NpYmlsaXR5TW9kYWxMYWJlbH1cbiAgICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLmNvbnRhaW5lcn1cbiAgICAgICAgICAgIHJvbGU9e3JvbGV9XG4gICAgICAgICAgPlxuICAgICAgICAgICAgPEJhY2tkcm9wPlxuICAgICAgICAgICAgICA8T3V0c2lkZUV2ZW50QmVoYXZpb3Igb25DbGljaz17dGhpcy5oYW5kbGVPdXRzaWRlQ2xpY2t9PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMud3JhcHBlcn0gdGFiSW5kZXg9ey0xfSBzdHlsZT17eyB3aWR0aCB9fT5cbiAgICAgICAgICAgICAgICAgIDxCb3hcbiAgICAgICAgICAgICAgICAgICAgZmxleD1cImdyb3dcIlxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbj1cInJlbGF0aXZlXCJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheT1cImZsZXhcIlxuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb249XCJjb2x1bW5cIlxuICAgICAgICAgICAgICAgICAgICB3aWR0aD1cIjEwMCVcIlxuICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICA8Qm94IGZpdD5cbiAgICAgICAgICAgICAgICAgICAgICB7cm9sZSA9PT0gJ2RpYWxvZycgPyAoXG4gICAgICAgICAgICAgICAgICAgICAgICA8Qm94XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRhbmdlcm91c2x5U2V0SW5saW5lU3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3N0eWxlOiB7IHBhZGRpbmdMZWZ0OiA1MCwgcGFkZGluZ1JpZ2h0OiA1MCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5PVwiZmxleFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGp1c3RpZnlDb250ZW50PVwiY2VudGVyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZ1k9ezV9XG4gICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDxIZWFkaW5nIHNpemU9XCJ4c1wiIGFjY2Vzc2liaWxpdHlMZXZlbD17MX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2hlYWRpbmd9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDwvSGVhZGluZz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvQm94PlxuICAgICAgICAgICAgICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICAgICAgICAgICAgICA8Qm94IGRpc3BsYXk9XCJmbGV4XCIgcGFkZGluZz17NH0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDxIZWFkaW5nIHNpemU9XCJzbVwiIGFjY2Vzc2liaWxpdHlMZXZlbD17MX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2hlYWRpbmd9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDwvSGVhZGluZz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvQm94PlxuICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgICAge3JvbGUgPT09ICdkaWFsb2cnICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIDxCb3ggcGFkZGluZz17Mn0gcG9zaXRpb249XCJhYnNvbHV0ZVwiIHRvcCByaWdodD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgPEljb25CdXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2Nlc3NpYmlsaXR5TGFiZWw9e2FjY2Vzc2liaWxpdHlDbG9zZUxhYmVsfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb249XCJjYW5jZWxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMuaGFuZGxlQ2xvc2VDbGlja31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvQm94PlxuICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgICAge3JvbGUgPT09ICdkaWFsb2cnICYmIDxEaXZpZGVyIC8+fVxuICAgICAgICAgICAgICAgICAgICA8L0JveD5cbiAgICAgICAgICAgICAgICAgICAgPEJveCBmbGV4PVwiZ3Jvd1wiIG92ZXJmbG93PVwiYXV0b1wiIHBvc2l0aW9uPVwicmVsYXRpdmVcIj5cbiAgICAgICAgICAgICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgICAgICAgICAgICAgIDwvQm94PlxuICAgICAgICAgICAgICAgICAgICA8Qm94IGZpdD5cbiAgICAgICAgICAgICAgICAgICAgICB7Zm9vdGVyICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIDxCb3g+XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHtyb2xlID09PSAnZGlhbG9nJyAmJiA8RGl2aWRlciAvPn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgPEJveCBwYWRkaW5nPXs0fT57Zm9vdGVyfTwvQm94PlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9Cb3g+XG4gICAgICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICAgICAgPC9Cb3g+XG4gICAgICAgICAgICAgICAgICA8L0JveD5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPC9PdXRzaWRlRXZlbnRCZWhhdmlvcj5cbiAgICAgICAgICAgIDwvQmFja2Ryb3A+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvVHJhcEZvY3VzQmVoYXZpb3I+XG4gICAgICA8L1N0b3BTY3JvbGxCZWhhdmlvcj5cbiAgICApO1xuICB9XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBCb3ggZnJvbSAnLi9Cb3guanMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL1B1bHNhci5jc3MnO1xuXG50eXBlIFByb3BzID0ge1xuICBwYXVzZWQ/OiBib29sZWFuLFxuICBzaXplPzogbnVtYmVyLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUHVsc2FyKHByb3BzOiBQcm9wcykge1xuICBjb25zdCB7IHBhdXNlZCwgc2l6ZSA9IDEzNSB9ID0gcHJvcHM7XG5cbiAgcmV0dXJuIChcbiAgICA8Qm94XG4gICAgICBkYW5nZXJvdXNseVNldElubGluZVN0eWxlPXt7XG4gICAgICAgIF9fc3R5bGU6IHtcbiAgICAgICAgICBhbmltYXRpb25JdGVyYXRpb25Db3VudDogcGF1c2VkID8gMCA6ICdpbmZpbml0ZScsXG4gICAgICAgICAgb3V0bGluZTogJ25vbmUnLFxuICAgICAgICAgIGJveFNoYWRvdzogJ25vbmUnLFxuICAgICAgICB9LFxuICAgICAgfX1cbiAgICAgIGRpc3BsYXk9e3BhdXNlZCA/ICdub25lJyA6ICdibG9jayd9XG4gICAgICBoZWlnaHQ9e3NpemV9XG4gICAgICBwb3NpdGlvbj1cInJlbGF0aXZlXCJcbiAgICAgIHdpZHRoPXtzaXplfVxuICAgID5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuaW5uZXJDaXJjbGV9PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLm91dGVyQ2lyY2xlfSAvPlxuICAgICAgPC9kaXY+XG4gICAgPC9Cb3g+XG4gICk7XG59XG5cblB1bHNhci5wcm9wVHlwZXMgPSB7XG4gIHBhdXNlZDogUHJvcFR5cGVzLmJvb2wsXG4gIHNpemU6IFByb3BUeXBlcy5udW1iZXIsXG59O1xuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9SYWRpb0J1dHRvbi5jc3MnO1xuXG50eXBlIFByb3BzID0ge3xcbiAgY2hlY2tlZD86IGJvb2xlYW4sXG4gIGRpc2FibGVkPzogYm9vbGVhbixcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZT86IHN0cmluZyxcbiAgb25DaGFuZ2U6ICh7XG4gICAgZXZlbnQ6IFN5bnRoZXRpY0lucHV0RXZlbnQ8PixcbiAgICBjaGVja2VkOiBib29sZWFuLFxuICB9KSA9PiB2b2lkLFxuICB2YWx1ZTogc3RyaW5nLFxuICBzaXplPzogJ3NtJyB8ICdtZCcsXG58fTtcblxudHlwZSBTdGF0ZSA9IHt8XG4gIGZvY3VzZWQ6IGJvb2xlYW4sXG58fTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmFkaW9CdXR0b24gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8UHJvcHMsIFN0YXRlPiB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgY2hlY2tlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgIGlkOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICB2YWx1ZTogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIHNpemU6IFByb3BUeXBlcy5vbmVPZihbJ3NtJywgJ21kJ10pLFxuICB9O1xuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgY2hlY2tlZDogZmFsc2UsXG4gICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgIHNpemU6ICdtZCcsXG4gIH07XG5cbiAgc3RhdGUgPSB7XG4gICAgZm9jdXNlZDogZmFsc2UsXG4gIH07XG5cbiAgaGFuZGxlQ2hhbmdlID0gKGV2ZW50OiBTeW50aGV0aWNJbnB1dEV2ZW50PD4pID0+IHtcbiAgICBjb25zdCB7IGNoZWNrZWQgfSA9IGV2ZW50LnRhcmdldDtcbiAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHsgY2hlY2tlZCwgZXZlbnQgfSk7XG4gIH07XG5cbiAgaGFuZGxlQmx1ciA9ICgpID0+IHRoaXMuc2V0U3RhdGUoeyBmb2N1c2VkOiBmYWxzZSB9KTtcblxuICBoYW5kbGVGb2N1cyA9ICgpID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHsgZm9jdXNlZDogdHJ1ZSB9KTtcbiAgfTtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBjaGVja2VkLCBkaXNhYmxlZCwgaWQsIG5hbWUsIHNpemUsIHZhbHVlIH0gPSB0aGlzLnByb3BzO1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2XG4gICAgICAgIGNsYXNzTmFtZT17Y2xhc3NuYW1lcyhzdHlsZXMuUmFkaW9CdXR0b24sIHtcbiAgICAgICAgICBbc3R5bGVzLlJhZGlvQnV0dG9uSXNGb2N1c2VkXTogdGhpcy5zdGF0ZS5mb2N1c2VkLFxuICAgICAgICAgIFtzdHlsZXMuUmFkaW9CdXR0b25TbV06IHNpemUgPT09ICdzbScsXG4gICAgICAgICAgW3N0eWxlcy5SYWRpb0J1dHRvbk1kXTogc2l6ZSA9PT0gJ21kJyxcbiAgICAgICAgICBbc3R5bGVzLlJhZGlvQnV0dG9uV2hpdGVCZ106ICFkaXNhYmxlZCB8fCBjaGVja2VkLFxuICAgICAgICAgIFtzdHlsZXMuUmFkaW9CdXR0b25MaWdodEdyYXlCZ106IGRpc2FibGVkICYmICFjaGVja2VkLFxuICAgICAgICB9KX1cbiAgICAgID5cbiAgICAgICAgPGlucHV0XG4gICAgICAgICAgY2hlY2tlZD17Y2hlY2tlZH1cbiAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzbmFtZXMoc3R5bGVzLklucHV0LCB7XG4gICAgICAgICAgICBbc3R5bGVzLklucHV0RW5hYmxlZF06ICFkaXNhYmxlZCxcbiAgICAgICAgICAgIFtzdHlsZXMuSW5wdXRTbV06IHNpemUgPT09ICdzbScsXG4gICAgICAgICAgICBbc3R5bGVzLklucHV0TWRdOiBzaXplID09PSAnbWQnLFxuICAgICAgICAgIH0pfVxuICAgICAgICAgIGRpc2FibGVkPXtkaXNhYmxlZH1cbiAgICAgICAgICBpZD17aWR9XG4gICAgICAgICAgbmFtZT17bmFtZX1cbiAgICAgICAgICBvbkJsdXI9e3RoaXMuaGFuZGxlQmx1cn1cbiAgICAgICAgICBvbkNoYW5nZT17dGhpcy5oYW5kbGVDaGFuZ2V9XG4gICAgICAgICAgb25Gb2N1cz17dGhpcy5oYW5kbGVGb2N1c31cbiAgICAgICAgICB0eXBlPVwicmFkaW9cIlxuICAgICAgICAgIHZhbHVlPXt2YWx1ZX1cbiAgICAgICAgLz5cbiAgICAgICAge2NoZWNrZWQgJiYgKFxuICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NuYW1lcyhzdHlsZXMuQ2hlY2ssIHtcbiAgICAgICAgICAgICAgW3N0eWxlcy5DaGVja1NtXTogc2l6ZSA9PT0gJ3NtJyxcbiAgICAgICAgICAgICAgW3N0eWxlcy5DaGVja01kXTogc2l6ZSA9PT0gJ21kJyxcbiAgICAgICAgICAgICAgW3N0eWxlcy5DaGVja0VuYWJsZWRdOiAhZGlzYWJsZWQsXG4gICAgICAgICAgICAgIFtzdHlsZXMuQ2hlY2tEaXNhYmxlZF06IGRpc2FibGVkLFxuICAgICAgICAgICAgfSl9XG4gICAgICAgICAgLz5cbiAgICAgICAgKX1cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IEZldGNoSXRlbXMgZnJvbSAnLi9GZXRjaEl0ZW1zLmpzJztcbmltcG9ydCBTY3JvbGxDb250YWluZXIgZnJvbSAnLi9TY3JvbGxDb250YWluZXIuanMnO1xuaW1wb3J0IHtcbiAgZ2V0RWxlbWVudEhlaWdodCxcbiAgZ2V0U2Nyb2xsSGVpZ2h0LFxuICBnZXRTY3JvbGxQb3MsXG59IGZyb20gJy4vc2Nyb2xsVXRpbHMuanMnO1xuaW1wb3J0IHRocm90dGxlIGZyb20gJy4vdGhyb3R0bGUuanMnO1xuXG50eXBlIFByb3BzID0ge1xuICBjb250YWluZXI/OiBIVE1MRWxlbWVudCxcbiAgaXNBdEVuZD86IGJvb2xlYW4sXG4gIGlzRmV0Y2hpbmc6IGJvb2xlYW4sXG4gIGZldGNoTW9yZT86ICgpID0+IHZvaWQsXG4gIHJlbmRlckhlaWdodD86ICgpID0+IG51bWJlcixcbn07XG5cbnR5cGUgU3RhdGUgPSB7XG4gIGNvbnRhaW5lckhlaWdodDogbnVtYmVyLFxuICBzY3JvbGxIZWlnaHQ6IG51bWJlcixcbiAgc2Nyb2xsVG9wOiBudW1iZXIsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTY3JvbGxGZXRjaCBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQ8UHJvcHMsIFN0YXRlPiB7XG4gIC8qKlxuICAgKiBGZXRjaGVzIGFkZGl0aW9uYWwgaXRlbXMgaWYgbmVlZGVkLlxuICAgKi9cbiAgdXBkYXRlUG9zaXRpb24gPSB0aHJvdHRsZSgoKSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh0aGlzLmdldFNjcm9sbFN0YXRlKCkpO1xuICB9KTtcblxuICBzdGF0aWMgZGVmYXVsdFByb3BzOiB7fTtcblxuICBzdGF0ZSA9IHtcbiAgICBjb250YWluZXJIZWlnaHQ6IDAsXG4gICAgc2Nyb2xsSGVpZ2h0OiAwLFxuICAgIHNjcm9sbFRvcDogMCxcbiAgfTtcblxuICAvKipcbiAgICogQWRkcyBzY3JvbGwgbGlzdGVuZXIgYWZ0ZXIgdGhlIGNvbXBvbmVudCBtb3VudHMuXG4gICAqL1xuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBjb25zdCB7IGNvbnRhaW5lciB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBjb250YWluZXJIZWlnaHQ6IGdldEVsZW1lbnRIZWlnaHQoY29udGFpbmVyKSxcbiAgICAgICAgLi4udGhpcy5nZXRTY3JvbGxTdGF0ZSgpLFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHNjcm9sbCBidWZmZXIgYW5kIGNoZWNrIGFmdGVyIHRoZSBjb21wb25lbnQgdXBkYXRlcy5cbiAgICovXG4gIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAvLyBzZXRUaW1lb3V0IHNvIHRoZSBwYXJlbnQgY29tcG9uZW50IGNhbiBjYWxjdWxhdGUgcmVuZGVySGVpZ2h0KCkuXG4gICAgdGhpcy51cGRhdGVQb3NpdGlvbigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNjcm9sbGFibGUgY29udGVudCBoZWlnaHQuXG4gICAqL1xuICBnZXRTY3JvbGxIZWlnaHQgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb250YWluZXIgfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0U2Nyb2xsSGVpZ2h0KGNvbnRhaW5lcik7XG4gIH07XG5cbiAgZ2V0U2Nyb2xsU3RhdGUoKSB7XG4gICAgY29uc3QgeyBjb250YWluZXIsIHJlbmRlckhlaWdodCB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHNjcm9sbEhlaWdodCA9IHJlbmRlckhlaWdodCB8fCB0aGlzLmdldFNjcm9sbEhlaWdodDtcblxuICAgIHJldHVybiB7XG4gICAgICBzY3JvbGxIZWlnaHQ6IHNjcm9sbEhlaWdodCgpLFxuICAgICAgc2Nyb2xsVG9wOiBnZXRTY3JvbGxQb3MoY29udGFpbmVyKSxcbiAgICB9O1xuICB9XG5cbiAgc2Nyb2xsQnVmZmVyOiBudW1iZXI7XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgY29udGFpbmVySGVpZ2h0LCBzY3JvbGxIZWlnaHQsIHNjcm9sbFRvcCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCB7IGNvbnRhaW5lciwgZmV0Y2hNb3JlLCBpc0F0RW5kLCBpc0ZldGNoaW5nIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgY29uc3QgcHJvcHMgPSB7XG4gICAgICBjb250YWluZXJIZWlnaHQsXG4gICAgICBmZXRjaE1vcmUsXG4gICAgICBpc0F0RW5kLFxuICAgICAgaXNGZXRjaGluZyxcbiAgICAgIHNjcm9sbEhlaWdodCxcbiAgICAgIHNjcm9sbFRvcCxcbiAgICB9O1xuXG4gICAgaWYgKCFjb250YWluZXIgfHwgaXNBdEVuZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAoXG4gICAgICA8U2Nyb2xsQ29udGFpbmVyXG4gICAgICAgIG9uU2Nyb2xsPXt0aGlzLnVwZGF0ZVBvc2l0aW9ufVxuICAgICAgICBzY3JvbGxDb250YWluZXI9e2NvbnRhaW5lcn1cbiAgICAgID5cbiAgICAgICAgPEZldGNoSXRlbXMgey4uLnByb3BzfSAvPlxuICAgICAgPC9TY3JvbGxDb250YWluZXI+XG4gICAgKTtcbiAgfVxufVxuXG5TY3JvbGxGZXRjaC5wcm9wVHlwZXMgPSB7XG4gIC8qKlxuICAgKiBUaGUgc2Nyb2xsIGNvbnRhaW5lciB0byB1c2UuIERlZmF1bHRzIHRvIHdpbmRvdy5cbiAgICovXG4gIGNvbnRhaW5lcjogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBhZGRFdmVudExpc3RlbmVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICByZW1vdmVFdmVudExpc3RlbmVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgfSksXG4gIHJlbmRlckhlaWdodDogUHJvcFR5cGVzLmZ1bmMsXG4gIGlzQXRFbmQ6IFByb3BUeXBlcy5ib29sLFxuICBpc0ZldGNoaW5nOiBQcm9wVHlwZXMuYm9vbCxcbiAgZmV0Y2hNb3JlOiBQcm9wVHlwZXMuZnVuYyxcbn07XG5cblNjcm9sbEZldGNoLmRlZmF1bHRQcm9wcyA9IHtcbiAgY29udGFpbmVyOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IG51bGwsXG59O1xuIiwiLy8gQGZsb3dcblxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9TZWFyY2hGaWVsZC5jc3MnO1xuaW1wb3J0IEJveCBmcm9tICcuL0JveC5qcyc7XG5pbXBvcnQgSWNvbiBmcm9tICcuL0ljb24uanMnO1xuXG50eXBlIFByb3BzID0ge3xcbiAgYWNjZXNzaWJpbGl0eUxhYmVsOiBzdHJpbmcsXG4gIGF1dG9Db21wbGV0ZT86ICdvbicgfCAnb2ZmJyB8ICd1c2VybmFtZScgfCAnbmFtZScsXG4gIGlkOiBzdHJpbmcsXG4gIG9uQmx1cj86ICh7IGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MSW5wdXRFbGVtZW50PiB9KSA9PiB2b2lkLFxuICBvbkNoYW5nZTogKHtcbiAgICB2YWx1ZTogc3RyaW5nLFxuICAgIHN5bnRoZXRpY0V2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MSW5wdXRFbGVtZW50PixcbiAgfSkgPT4gdm9pZCxcbiAgb25Gb2N1cz86ICh7XG4gICAgdmFsdWU6IHN0cmluZyxcbiAgICBzeW50aGV0aWNFdmVudDogU3ludGhldGljRXZlbnQ8SFRNTElucHV0RWxlbWVudD4sXG4gIH0pID0+IHZvaWQsXG4gIHBsYWNlaG9sZGVyPzogc3RyaW5nLFxuICB2YWx1ZT86IHN0cmluZyxcbnx9O1xuXG50eXBlIFN0YXRlID0ge3xcbiAgZm9jdXNlZDogYm9vbGVhbixcbiAgaG92ZXJlZDogYm9vbGVhbixcbnx9O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZWFyY2hGaWVsZCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxQcm9wcywgU3RhdGU+IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICBhY2Nlc3NpYmlsaXR5TGFiZWw6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBhdXRvQ29tcGxldGU6IFByb3BUeXBlcy5vbmVPZihbJ29uJywgJ29mZicsICd1c2VybmFtZScsICduYW1lJ10pLFxuICAgIGlkOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgb25CbHVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBvbkZvY3VzOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBwbGFjZWhvbGRlcjogUHJvcFR5cGVzLnN0cmluZyxcbiAgICB2YWx1ZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgfTtcblxuICBzdGF0ZTogU3RhdGUgPSB7XG4gICAgZm9jdXNlZDogZmFsc2UsXG4gICAgaG92ZXJlZDogZmFsc2UsXG4gIH07XG5cbiAgaGFuZGxlQ2hhbmdlID0gKGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xuICAgIHRoaXMucHJvcHMub25DaGFuZ2Uoe1xuICAgICAgdmFsdWU6IGV2ZW50LmN1cnJlbnRUYXJnZXQudmFsdWUsXG4gICAgICBzeW50aGV0aWNFdmVudDogZXZlbnQsXG4gICAgfSk7XG4gIH07XG5cbiAgaGFuZGxlQ2xlYXIgPSAoZXZlbnQ6IFN5bnRoZXRpY0V2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XG4gICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh7XG4gICAgICB2YWx1ZTogJycsXG4gICAgICBzeW50aGV0aWNFdmVudDogZXZlbnQsXG4gICAgfSk7XG4gIH07XG5cbiAgaGFuZGxlTW91c2VFbnRlciA9ICgpID0+IHRoaXMuc2V0U3RhdGUoeyBob3ZlcmVkOiB0cnVlIH0pO1xuXG4gIGhhbmRsZU1vdXNlTGVhdmUgPSAoKSA9PiB0aGlzLnNldFN0YXRlKHsgaG92ZXJlZDogZmFsc2UgfSk7XG5cbiAgaGFuZGxlRm9jdXMgPSAoZXZlbnQ6IFN5bnRoZXRpY0V2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGZvY3VzZWQ6IHRydWUgfSk7XG5cbiAgICBpZiAodGhpcy5wcm9wcy5vbkZvY3VzKSB7XG4gICAgICB0aGlzLnByb3BzLm9uRm9jdXMoe1xuICAgICAgICB2YWx1ZTogZXZlbnQuY3VycmVudFRhcmdldC52YWx1ZSxcbiAgICAgICAgc3ludGhldGljRXZlbnQ6IGV2ZW50LFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIGhhbmRsZUJsdXIgPSAoZXZlbnQ6IFN5bnRoZXRpY0V2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGZvY3VzZWQ6IGZhbHNlIH0pO1xuXG4gICAgaWYgKHRoaXMucHJvcHMub25CbHVyKSB7XG4gICAgICB0aGlzLnByb3BzLm9uQmx1cih7IGV2ZW50IH0pO1xuICAgIH1cbiAgfTtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgYWNjZXNzaWJpbGl0eUxhYmVsLFxuICAgICAgYXV0b0NvbXBsZXRlLFxuICAgICAgaWQsXG4gICAgICBwbGFjZWhvbGRlcixcbiAgICAgIHZhbHVlLFxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgLy8gVGhpcyBtaXJyb3JzIHRoZSBidWlsdCBpbiBicm93c2VyIGJlaGF2aW9yLiBJZiB0aGVyZSdzIGEgdmFsdWUsIHNob3cgdGhlXG4gICAgLy8gY2xlYXIgYnV0dG9uIGlmIHlvdSdyZSBob3ZlcmluZyBvciBpZiB5b3UndmUgZm9jdXNlZCBvbiB0aGUgZmllbGRcbiAgICBjb25zdCBzaG93Q2xlYXIgPVxuICAgICAgKHRoaXMuc3RhdGUuZm9jdXNlZCB8fCB0aGlzLnN0YXRlLmhvdmVyZWQpICYmIHZhbHVlICYmIHZhbHVlLmxlbmd0aCA+IDA7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPEJveFxuICAgICAgICBkaXNwbGF5PVwiZmxleFwiXG4gICAgICAgIHBvc2l0aW9uPVwicmVsYXRpdmVcIlxuICAgICAgICBhbGlnbkl0ZW1zPVwiY2VudGVyXCJcbiAgICAgICAgb25Nb3VzZUVudGVyPXt0aGlzLmhhbmRsZU1vdXNlRW50ZXJ9XG4gICAgICAgIG9uTW91c2VMZWF2ZT17dGhpcy5oYW5kbGVNb3VzZUxlYXZlfVxuICAgICAgICBvbkZvY3VzPXt0aGlzLmhhbmRsZUZvY3VzfVxuICAgICAgICBvbkJsdXI9e3RoaXMuaGFuZGxlQmx1cn1cbiAgICAgICAgY29sb3I9XCJ3aGl0ZVwiXG4gICAgICA+XG4gICAgICAgIDxCb3hcbiAgICAgICAgICBkYW5nZXJvdXNseVNldElubGluZVN0eWxlPXt7XG4gICAgICAgICAgICBfX3N0eWxlOiB7XG4gICAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbiAgICAgICAgICAgICAgLy8gQWRkZWQgdGhlIGZvbGxvd2luZyBsaW5lcyBmb3IgU2FmYXJpIHN1cHBvcnRcbiAgICAgICAgICAgICAgdG9wOiAnNTAlJyxcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWSgtNTAlKScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH19XG4gICAgICAgICAgcG9zaXRpb249XCJhYnNvbHV0ZVwiXG4gICAgICAgICAgbGVmdFxuICAgICAgICAgIHBhZGRpbmdYPXs0fVxuICAgICAgICA+XG4gICAgICAgICAgPEljb24gaWNvbj1cInNlYXJjaFwiIGFjY2Vzc2liaWxpdHlMYWJlbD1cIlwiIC8+XG4gICAgICAgIDwvQm94PlxuICAgICAgICA8aW5wdXRcbiAgICAgICAgICBhcmlhLWxhYmVsPXthY2Nlc3NpYmlsaXR5TGFiZWx9XG4gICAgICAgICAgYXV0b0NvbXBsZXRlPXthdXRvQ29tcGxldGV9XG4gICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMuaW5wdXR9XG4gICAgICAgICAgaWQ9e2lkfVxuICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLmhhbmRsZUNoYW5nZX1cbiAgICAgICAgICBwbGFjZWhvbGRlcj17cGxhY2Vob2xkZXJ9XG4gICAgICAgICAgcm9sZT1cInNlYXJjaGJveFwiXG4gICAgICAgICAgdHlwZT1cInNlYXJjaFwiXG4gICAgICAgICAgdmFsdWU9e3ZhbHVlfVxuICAgICAgICAvPlxuICAgICAgICB7c2hvd0NsZWFyICYmIChcbiAgICAgICAgICA8Qm94IHBvc2l0aW9uPVwiYWJzb2x1dGVcIiByaWdodCB0b3A+XG4gICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLmNsZWFyfVxuICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLmhhbmRsZUNsZWFyfVxuICAgICAgICAgICAgICB0YWJJbmRleD17LTF9XG4gICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8SWNvbiBpY29uPVwiY2xlYXJcIiBhY2Nlc3NpYmlsaXR5TGFiZWw9XCJcIiAvPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgPC9Cb3g+XG4gICAgICAgICl9XG4gICAgICA8L0JveD5cbiAgICApO1xuICB9XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IEJveCBmcm9tICcuL0JveC5qcyc7XG5pbXBvcnQgVGV4dCBmcm9tICcuL1RleHQuanMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL1NlZ21lbnRlZENvbnRyb2wuY3NzJztcblxudHlwZSBQcm9wcyA9IHt8XG4gIGl0ZW1zOiBBcnJheTxSZWFjdC5Ob2RlPixcbiAgb25DaGFuZ2U6ICh7IGV2ZW50OiBTeW50aGV0aWNNb3VzZUV2ZW50PD4sIGFjdGl2ZUluZGV4OiBudW1iZXIgfSkgPT4gdm9pZCxcbiAgc2VsZWN0ZWRJdGVtSW5kZXg6IG51bWJlcixcbiAgc2l6ZT86ICdtZCcgfCAnbGcnLFxufH07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFNlZ21lbnRlZENvbnRyb2wocHJvcHM6IFByb3BzKSB7XG4gIGNvbnN0IHsgaXRlbXMsIG9uQ2hhbmdlLCBzZWxlY3RlZEl0ZW1JbmRleCwgc2l6ZSA9ICdtZCcgfSA9IHByb3BzO1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIGNsYXNzTmFtZT17Y2xhc3NuYW1lcyhzdHlsZXMuU2VnbWVudGVkQ29udHJvbCwge1xuICAgICAgICBbc3R5bGVzLm1kXTogc2l6ZSA9PT0gJ21kJyxcbiAgICAgICAgW3N0eWxlcy5sZ106IHNpemUgPT09ICdsZycsXG4gICAgICB9KX1cbiAgICAgIHJvbGU9XCJ0YWJsaXN0XCJcbiAgICA+XG4gICAgICB7aXRlbXMubWFwKChpdGVtLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzU2VsZWN0ZWQgPSBpID09PSBzZWxlY3RlZEl0ZW1JbmRleDtcbiAgICAgICAgY29uc3QgY3MgPSBjbGFzc25hbWVzKHN0eWxlcy5pdGVtLCB7XG4gICAgICAgICAgW3N0eWxlcy5pdGVtSXNOb3RTZWxlY3RlZF06ICFpc1NlbGVjdGVkLFxuICAgICAgICAgIFtzdHlsZXMuaXRlbUlzU2VsZWN0ZWRdOiBpc1NlbGVjdGVkLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICBhcmlhLXNlbGVjdGVkPXtpc1NlbGVjdGVkfVxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjc31cbiAgICAgICAgICAgIGtleT17aX1cbiAgICAgICAgICAgIG9uQ2xpY2s9e2UgPT4gb25DaGFuZ2UoeyBldmVudDogZSwgYWN0aXZlSW5kZXg6IGkgfSl9XG4gICAgICAgICAgICByb2xlPVwidGFiXCJcbiAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgID5cbiAgICAgICAgICAgIHt0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycgPyAoXG4gICAgICAgICAgICAgIDxUZXh0XG4gICAgICAgICAgICAgICAgYm9sZFxuICAgICAgICAgICAgICAgIGNvbG9yPXtpc1NlbGVjdGVkID8gJ2RhcmtHcmF5JyA6ICdncmF5J31cbiAgICAgICAgICAgICAgICBhbGlnbj1cImNlbnRlclwiXG4gICAgICAgICAgICAgICAgc2l6ZT17c2l6ZX1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIHtpdGVtfVxuICAgICAgICAgICAgICA8L1RleHQ+XG4gICAgICAgICAgICApIDogKFxuICAgICAgICAgICAgICA8Qm94IGRpc3BsYXk9XCJmbGV4XCIganVzdGlmeUNvbnRlbnQ9XCJjZW50ZXJcIj5cbiAgICAgICAgICAgICAgICB7aXRlbX1cbiAgICAgICAgICAgICAgPC9Cb3g+XG4gICAgICAgICAgICApfVxuICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICApO1xuICAgICAgfSl9XG4gICAgPC9kaXY+XG4gICk7XG59XG5cblNlZ21lbnRlZENvbnRyb2wucHJvcFR5cGVzID0ge1xuICBpdGVtczogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm5vZGUpLmlzUmVxdWlyZWQsXG4gIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBzZWxlY3RlZEl0ZW1JbmRleDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxufTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgQm94IGZyb20gJy4vQm94LmpzJztcbmltcG9ydCBGbHlvdXQgZnJvbSAnLi9GbHlvdXQuanMnO1xuaW1wb3J0IFRleHQgZnJvbSAnLi9UZXh0LmpzJztcbmltcG9ydCBJY29uIGZyb20gJy4vSWNvbi5qcyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vU2VsZWN0TGlzdC5jc3MnO1xuXG50eXBlIFN0YXRlID0ge1xuICBmb2N1c2VkOiBib29sZWFuLFxuICBlcnJvcklzT3BlbjogYm9vbGVhbixcbiAgZXJyb3JNZXNzYWdlPzogc3RyaW5nLFxufTtcblxudHlwZSBQcm9wcyA9IHt8XG4gIGVycm9yTWVzc2FnZT86IHN0cmluZyxcbiAgZGlzYWJsZWQ/OiBib29sZWFuLFxuICBpZDogc3RyaW5nLFxuICBpZGVhbEVycm9yRGlyZWN0aW9uPzogJ3VwJyB8ICdyaWdodCcgfCAnZG93bicgfCAnbGVmdCcgLyogZGVmYXVsdDogcmlnaHQgKi8sXG4gIG5hbWU/OiBzdHJpbmcsXG4gIG9uQ2hhbmdlOiAoeyBldmVudDogU3ludGhldGljSW5wdXRFdmVudDw+LCB2YWx1ZTogc3RyaW5nIH0pID0+IHZvaWQsXG4gIG9wdGlvbnM6IEFycmF5PHtcbiAgICBsYWJlbDogc3RyaW5nLFxuICAgIHZhbHVlOiBzdHJpbmcsXG4gIH0+LFxuICBwbGFjZWhvbGRlcj86IHN0cmluZyxcbiAgdmFsdWU/OiA/c3RyaW5nLFxufH07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlbGVjdExpc3QgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8UHJvcHMsIFN0YXRlPiB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgIGVycm9yTWVzc2FnZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBpZDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIGlkZWFsRXJyb3JEaXJlY3Rpb246IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBvcHRpb25zOiBQcm9wVHlwZXMuYXJyYXlPZihcbiAgICAgIFByb3BUeXBlcy5leGFjdCh7XG4gICAgICAgIGxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgICAgIHZhbHVlOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgICB9KVxuICAgICksXG4gICAgcGxhY2Vob2xkZXI6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgdmFsdWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIH07XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgaWRlYWxFcnJvckRpcmVjdGlvbjogJ3JpZ2h0JyxcbiAgICBvcHRpb25zOiBbXSxcbiAgfTtcblxuICBzdGF0ZSA9IHtcbiAgICBmb2N1c2VkOiBmYWxzZSxcbiAgICBlcnJvcklzT3BlbjogZmFsc2UsXG4gIH07XG5cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhwcm9wczogUHJvcHMsIHN0YXRlOiBTdGF0ZSkge1xuICAgIGlmIChwcm9wcy5lcnJvck1lc3NhZ2UgIT09IHN0YXRlLmVycm9yTWVzc2FnZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3JJc09wZW46ICEhcHJvcHMuZXJyb3JNZXNzYWdlLFxuICAgICAgICBlcnJvck1lc3NhZ2U6IHByb3BzLmVycm9yTWVzc2FnZSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBoYW5kbGVPbkNoYW5nZSA9IChldmVudDogU3ludGhldGljSW5wdXRFdmVudDw+KSA9PiB7XG4gICAgaWYgKFxuICAgICAgZXZlbnQudGFyZ2V0IGluc3RhbmNlb2YgSFRNTFNlbGVjdEVsZW1lbnQgJiZcbiAgICAgIHRoaXMucHJvcHMudmFsdWUgIT09IGV2ZW50LnRhcmdldC52YWx1ZVxuICAgICkge1xuICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh7IGV2ZW50LCB2YWx1ZTogZXZlbnQudGFyZ2V0LnZhbHVlIH0pO1xuXG4gICAgICBpZiAodGhpcy5wcm9wcy5lcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGVycm9ySXNPcGVuOiBmYWxzZSB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgaGFuZGxlQmx1ciA9ICgpID0+IHtcbiAgICBpZiAodGhpcy5wcm9wcy5lcnJvck1lc3NhZ2UpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBlcnJvcklzT3BlbjogZmFsc2UgfSk7XG4gICAgfVxuICB9O1xuXG4gIGhhbmRsZUZvY3VzID0gKCkgPT4ge1xuICAgIGlmICh0aGlzLnByb3BzLmVycm9yTWVzc2FnZSkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGVycm9ySXNPcGVuOiB0cnVlIH0pO1xuICAgIH1cbiAgfTtcblxuICBzZWxlY3Q6ID9IVE1MU2VsZWN0RWxlbWVudDtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGlzYWJsZWQsXG4gICAgICBlcnJvck1lc3NhZ2UsXG4gICAgICBpZCxcbiAgICAgIGlkZWFsRXJyb3JEaXJlY3Rpb24sXG4gICAgICBuYW1lLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIHBsYWNlaG9sZGVyLFxuICAgICAgdmFsdWUsXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb25zdCBjbGFzc2VzID0gY2xhc3NuYW1lcyhcbiAgICAgIHN0eWxlcy5zZWxlY3QsXG4gICAgICBkaXNhYmxlZCA/IHN0eWxlcy5kaXNhYmxlZCA6IHN0eWxlcy5lbmFibGVkLFxuICAgICAgZXJyb3JNZXNzYWdlID8gc3R5bGVzLmVycm9yZWQgOiBzdHlsZXMubm9ybWFsXG4gICAgKTtcblxuICAgIHJldHVybiAoXG4gICAgICA8Qm94XG4gICAgICAgIGNvbG9yPXtkaXNhYmxlZCA/ICdsaWdodEdyYXknIDogJ3doaXRlJ31cbiAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbmxpbmVTdHlsZT17eyBfX3N0eWxlOiB7IGJvcmRlclJhZGl1czogNCB9IH19XG4gICAgICAgIGRpc3BsYXk9XCJmbGV4XCJcbiAgICAgICAgcG9zaXRpb249XCJyZWxhdGl2ZVwiXG4gICAgICAgIHdpZHRoPVwiMTAwJVwiXG4gICAgICA+XG4gICAgICAgIDxCb3hcbiAgICAgICAgICBhbGlnbkl0ZW1zPVwiY2VudGVyXCJcbiAgICAgICAgICBib3R0b21cbiAgICAgICAgICBkYW5nZXJvdXNseVNldElubGluZVN0eWxlPXt7XG4gICAgICAgICAgICBfX3N0eWxlOiB7IHBhZGRpbmdSaWdodDogMTQsIHBhZGRpbmdUb3A6IDIgfSxcbiAgICAgICAgICB9fVxuICAgICAgICAgIGRpc3BsYXk9XCJmbGV4XCJcbiAgICAgICAgICBwb3NpdGlvbj1cImFic29sdXRlXCJcbiAgICAgICAgICByaWdodFxuICAgICAgICAgIHRvcFxuICAgICAgICA+XG4gICAgICAgICAgPEljb25cbiAgICAgICAgICAgIGljb249XCJhcnJvdy1kb3duXCJcbiAgICAgICAgICAgIHNpemU9ezEyfVxuICAgICAgICAgICAgY29sb3I9e2Rpc2FibGVkID8gJ2dyYXknIDogJ2RhcmtHcmF5J31cbiAgICAgICAgICAgIGFjY2Vzc2liaWxpdHlMYWJlbD1cIlwiXG4gICAgICAgICAgLz5cbiAgICAgICAgPC9Cb3g+XG4gICAgICAgIDxzZWxlY3RcbiAgICAgICAgICBhcmlhLWRlc2NyaWJlZGJ5PXtcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSAmJiB0aGlzLnN0YXRlLmZvY3VzZWQgPyBgJHtpZH0tZ2VzdGFsdC1lcnJvcmAgOiBudWxsXG4gICAgICAgICAgfVxuICAgICAgICAgIGFyaWEtaW52YWxpZD17ZXJyb3JNZXNzYWdlID8gJ3RydWUnIDogJ2ZhbHNlJ31cbiAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzZXN9XG4gICAgICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxuICAgICAgICAgIGlkPXtpZH1cbiAgICAgICAgICBuYW1lPXtuYW1lfVxuICAgICAgICAgIG9uQmx1cj17dGhpcy5oYW5kbGVCbHVyfVxuICAgICAgICAgIG9uRm9jdXM9e3RoaXMuaGFuZGxlRm9jdXN9XG4gICAgICAgICAgb25DaGFuZ2U9e3RoaXMuaGFuZGxlT25DaGFuZ2V9XG4gICAgICAgICAgcmVmPXtjID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ID0gYztcbiAgICAgICAgICB9fVxuICAgICAgICAgIHZhbHVlPXt2YWx1ZX1cbiAgICAgICAgPlxuICAgICAgICAgIHtwbGFjZWhvbGRlciAmJlxuICAgICAgICAgICAgIXZhbHVlICYmIChcbiAgICAgICAgICAgICAgPG9wdGlvbiBzZWxlY3RlZCBkaXNhYmxlZCB2YWx1ZSBoaWRkZW4+XG4gICAgICAgICAgICAgICAge3BsYWNlaG9sZGVyfVxuICAgICAgICAgICAgICA8L29wdGlvbj5cbiAgICAgICAgICAgICl9XG4gICAgICAgICAge29wdGlvbnMubWFwKG9wdGlvbiA9PiAoXG4gICAgICAgICAgICA8b3B0aW9uIGtleT17b3B0aW9uLnZhbHVlfSB2YWx1ZT17b3B0aW9uLnZhbHVlfT5cbiAgICAgICAgICAgICAge29wdGlvbi5sYWJlbH1cbiAgICAgICAgICAgIDwvb3B0aW9uPlxuICAgICAgICAgICkpfVxuICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAge2Vycm9yTWVzc2FnZSAmJlxuICAgICAgICAgIHRoaXMuc3RhdGUuZXJyb3JJc09wZW4gJiYgKFxuICAgICAgICAgICAgPEZseW91dFxuICAgICAgICAgICAgICBhbmNob3I9e3RoaXMuc2VsZWN0fVxuICAgICAgICAgICAgICBjb2xvcj1cIm9yYW5nZVwiXG4gICAgICAgICAgICAgIGlkZWFsRGlyZWN0aW9uPXtpZGVhbEVycm9yRGlyZWN0aW9ufVxuICAgICAgICAgICAgICBvbkRpc21pc3M9eygpID0+IHRoaXMuc2V0U3RhdGUoeyBlcnJvcklzT3BlbjogZmFsc2UgfSl9XG4gICAgICAgICAgICAgIHNob3VsZEZvY3VzPXtmYWxzZX1cbiAgICAgICAgICAgICAgc2l6ZT1cInNtXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgPEJveCBwYWRkaW5nPXszfT5cbiAgICAgICAgICAgICAgICA8VGV4dCBib2xkIGNvbG9yPVwid2hpdGVcIj5cbiAgICAgICAgICAgICAgICAgIDxzcGFuIGlkPXtgJHtpZH0tZ2VzdGFsdC1lcnJvcmB9PntlcnJvck1lc3NhZ2V9PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvVGV4dD5cbiAgICAgICAgICAgICAgPC9Cb3g+XG4gICAgICAgICAgICA8L0ZseW91dD5cbiAgICAgICAgICApfVxuICAgICAgPC9Cb3g+XG4gICAgKTtcbiAgfVxufVxuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgQm94IGZyb20gJy4vQm94LmpzJztcbmltcG9ydCBJY29uIGZyb20gJy4vSWNvbi5qcyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vU3Bpbm5lci5jc3MnO1xuXG5jb25zdCBTSVpFID0gNDA7XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBhY2Nlc3NpYmlsaXR5TGFiZWw6IHN0cmluZyxcbiAgc2hvdzogYm9vbGVhbixcbnx9O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTcGlubmVyKHsgYWNjZXNzaWJpbGl0eUxhYmVsLCBzaG93IH06IFByb3BzKSB7XG4gIHJldHVybiBzaG93ID8gKFxuICAgIDxCb3ggeHM9e3sgZGlzcGxheTogJ2ZsZXgnIH19IGp1c3RpZnlDb250ZW50PVwiYXJvdW5kXCIgb3ZlcmZsb3c9XCJoaWRkZW5cIj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuaWNvbn0+XG4gICAgICAgIDxJY29uXG4gICAgICAgICAgaWNvbj1cImtub29wXCJcbiAgICAgICAgICBhY2Nlc3NpYmlsaXR5TGFiZWw9e2FjY2Vzc2liaWxpdHlMYWJlbH1cbiAgICAgICAgICBzaXplPXtTSVpFfVxuICAgICAgICAvPlxuICAgICAgPC9kaXY+XG4gICAgPC9Cb3g+XG4gICkgOiAoXG4gICAgPGRpdiAvPlxuICApO1xufVxuXG5TcGlubmVyLnByb3BUeXBlcyA9IHtcbiAgc2hvdzogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgYWNjZXNzaWJpbGl0eUxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG59O1xuIiwiLy8gQGZsb3dcblxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBsYXlvdXQgZnJvbSAnLi9MYXlvdXQuY3NzJztcblxudHlwZSBUaHJlc2hvbGQgPVxuICB8IHt8IHRvcDogbnVtYmVyIHwgc3RyaW5nIHx9XG4gIHwge3wgYm90dG9tOiBudW1iZXIgfCBzdHJpbmcgfH1cbiAgfCB7fCBsZWZ0OiBudW1iZXIgfCBzdHJpbmcgfH1cbiAgfCB7fCByaWdodDogbnVtYmVyIHwgc3RyaW5nIHx9XG4gIHwge3wgdG9wOiBudW1iZXIgfCBzdHJpbmcsIGJvdHRvbTogbnVtYmVyIHwgc3RyaW5nIHx9XG4gIHwge3wgbGVmdDogbnVtYmVyIHwgc3RyaW5nLCByaWdodDogbnVtYmVyIHwgc3RyaW5nIHx9XG4gIHwge3xcbiAgICAgIHRvcDogbnVtYmVyIHwgc3RyaW5nLFxuICAgICAgbGVmdDogbnVtYmVyIHwgc3RyaW5nLFxuICAgICAgcmlnaHQ6IG51bWJlciB8IHN0cmluZyxcbiAgICAgIGJvdHRvbTogbnVtYmVyIHwgc3RyaW5nLFxuICAgIHx9O1xuXG50eXBlIFByb3BzID0ge3xcbiAgY2hpbGRyZW46IFJlYWN0Lk5vZGUsXG4gIGRhbmdlcm91c2x5U2V0WkluZGV4PzogeyBfX3pJbmRleDogbnVtYmVyIH0sXG4gIC4uLlRocmVzaG9sZCxcbnx9O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTdGlja3kocHJvcHM6IFByb3BzKSB7XG4gIGNvbnN0IHsgZGFuZ2Vyb3VzbHlTZXRaSW5kZXggPSB7IF9fekluZGV4OiAxIH0sIGNoaWxkcmVuIH0gPSBwcm9wcztcbiAgY29uc3Qgc3R5bGUgPSB7XG4gICAgdG9wOiBwcm9wcy50b3AgIT0gbnVsbCA/IHByb3BzLnRvcCA6IHVuZGVmaW5lZCxcbiAgICBsZWZ0OiBwcm9wcy5sZWZ0ICE9IG51bGwgPyBwcm9wcy5sZWZ0IDogdW5kZWZpbmVkLFxuICAgIHJpZ2h0OiBwcm9wcy5yaWdodCAhPSBudWxsID8gcHJvcHMucmlnaHQgOiB1bmRlZmluZWQsXG4gICAgYm90dG9tOiBwcm9wcy5ib3R0b20gIT0gbnVsbCA/IHByb3BzLmJvdHRvbSA6IHVuZGVmaW5lZCxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZXJzY29yZS1kYW5nbGVcbiAgICB6SW5kZXg6IGRhbmdlcm91c2x5U2V0WkluZGV4Ll9fekluZGV4LFxuICB9O1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtsYXlvdXQuc3RpY2t5fSBzdHlsZT17c3R5bGV9PlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvZGl2PlxuICApO1xufVxuXG5TdGlja3kucHJvcFR5cGVzID0ge1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gIGRhbmdlcm91c2x5U2V0WkluZGV4OiBQcm9wVHlwZXMuZXhhY3Qoe1xuICAgIF9fekluZGV4OiBQcm9wVHlwZXMubnVtYmVyLFxuICB9KSxcbiAgdG9wOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG4gIGxlZnQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgYm90dG9tOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG4gIHJpZ2h0OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG59O1xuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9Td2l0Y2guY3NzJztcblxudHlwZSBQcm9wcyA9IHt8XG4gIGRpc2FibGVkPzogYm9vbGVhbixcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZT86IHN0cmluZyxcbiAgb25DaGFuZ2U6ICh7IGV2ZW50OiBTeW50aGV0aWNJbnB1dEV2ZW50PD4sIHZhbHVlOiBib29sZWFuIH0pID0+IHZvaWQsXG4gIHN3aXRjaGVkPzogYm9vbGVhbixcbnx9O1xuXG50eXBlIFN0YXRlID0ge3xcbiAgZm9jdXNlZDogYm9vbGVhbixcbnx9O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTd2l0Y2ggZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8UHJvcHMsIFN0YXRlPiB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgIGlkOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBzd2l0Y2hlZDogUHJvcFR5cGVzLmJvb2wsXG4gIH07XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgc3dpdGNoZWQ6IGZhbHNlLFxuICB9O1xuXG4gIHN0YXRlOiBTdGF0ZSA9IHtcbiAgICBmb2N1c2VkOiBmYWxzZSxcbiAgfTtcblxuICBoYW5kbGVCbHVyID0gKCkgPT4gdGhpcy5zZXRTdGF0ZSh7IGZvY3VzZWQ6IGZhbHNlIH0pO1xuXG4gIGhhbmRsZUNoYW5nZSA9IChldmVudDogU3ludGhldGljSW5wdXRFdmVudDw+KSA9PiB7XG4gICAgY29uc3QgeyBjaGVja2VkIH0gPSBldmVudC50YXJnZXQ7XG4gICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh7XG4gICAgICBldmVudCxcbiAgICAgIHZhbHVlOiBjaGVja2VkLFxuICAgIH0pO1xuICB9O1xuXG4gIGhhbmRsZUZvY3VzID0gKCkgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoeyBmb2N1c2VkOiB0cnVlIH0pO1xuICB9O1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGRpc2FibGVkLCBpZCwgbmFtZSwgc3dpdGNoZWQgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb25zdCBzd2l0Y2hTdHlsZXMgPSBjbGFzc25hbWVzKFxuICAgICAgc3R5bGVzLnN3aXRjaCxcbiAgICAgIHtcbiAgICAgICAgW3N0eWxlcy5mb2N1c2VkXTogdGhpcy5zdGF0ZS5mb2N1c2VkLFxuICAgICAgfSxcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgICAgZGlzYWJsZWRcbiAgICAgICAgPyBzd2l0Y2hlZFxuICAgICAgICAgID8gc3R5bGVzLnN3aXRjaEdyYXlcbiAgICAgICAgICA6IHN0eWxlcy5zd2l0Y2hMaWdodEdyYXlcbiAgICAgICAgOiBzd2l0Y2hlZFxuICAgICAgICAgID8gc3R5bGVzLnN3aXRjaERhcmtHcmF5XG4gICAgICAgICAgOiBzdHlsZXMuc3dpdGNoV2hpdGVcbiAgICApO1xuXG4gICAgY29uc3Qgc2xpZGVyU3R5bGVzID0gY2xhc3NuYW1lcyhcbiAgICAgIHN0eWxlcy5zbGlkZXIsXG4gICAgICBzd2l0Y2hlZCA/IHN0eWxlcy5zbGlkZXJSaWdodCA6IHN0eWxlcy5zbGlkZXJMZWZ0LFxuICAgICAgc3dpdGNoZWQgJiYgIWRpc2FibGVkID8gc3R5bGVzLnNsaWRlckRhcmsgOiBzdHlsZXMuc2xpZGVyTGlnaHRcbiAgICApO1xuXG4gICAgY29uc3QgaW5wdXRTdHlsZXMgPSBjbGFzc25hbWVzKHN0eWxlcy5jaGVja2JveCwge1xuICAgICAgW3N0eWxlcy5jaGVja2JveEVuYWJsZWRdOiAhZGlzYWJsZWQsXG4gICAgfSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N3aXRjaFN0eWxlc30+XG4gICAgICAgIDxpbnB1dFxuICAgICAgICAgIGNoZWNrZWQ9e3N3aXRjaGVkfVxuICAgICAgICAgIGNsYXNzTmFtZT17aW5wdXRTdHlsZXN9XG4gICAgICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxuICAgICAgICAgIGlkPXtpZH1cbiAgICAgICAgICBuYW1lPXtuYW1lfVxuICAgICAgICAgIG9uQmx1cj17dGhpcy5oYW5kbGVCbHVyfVxuICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLmhhbmRsZUNoYW5nZX1cbiAgICAgICAgICBvbkZvY3VzPXt0aGlzLmhhbmRsZUZvY3VzfVxuICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgIC8+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzbGlkZXJTdHlsZXN9IC8+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IFRleHQgZnJvbSAnLi9UZXh0LmpzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9UYWJzLmNzcyc7XG5pbXBvcnQgbGF5b3V0IGZyb20gJy4vTGF5b3V0LmNzcyc7XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBhY3RpdmVUYWJJbmRleDogbnVtYmVyLFxuICB0YWJzOiBBcnJheTx7fFxuICAgIHRleHQ6IFJlYWN0Lk5vZGUsXG4gICAgaHJlZjogc3RyaW5nLFxuICB8fT4sXG4gIG9uQ2hhbmdlOiAoe1xuICAgIGV2ZW50OiBTeW50aGV0aWNNb3VzZUV2ZW50PD4sXG4gICAgYWN0aXZlVGFiSW5kZXg6IG51bWJlcixcbiAgfSkgPT4gdm9pZCxcbiAgd3JhcD86IGJvb2xlYW4sXG58fTtcblxudHlwZSBTdGF0ZSA9IHt8XG4gIGZvY3VzZWRUYWJJbmRleDogP251bWJlcixcbiAgaG92ZXJlZFRhYkluZGV4OiA/bnVtYmVyLFxufH07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRhYnMgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8UHJvcHMsIFN0YXRlPiB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgYWN0aXZlVGFiSW5kZXg6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgICB0YWJzOiBQcm9wVHlwZXMuYXJyYXlPZihcbiAgICAgIFByb3BUeXBlcy5leGFjdCh7XG4gICAgICAgIHRleHQ6IFByb3BUeXBlcy5ub2RlLFxuICAgICAgICBocmVmOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgfSlcbiAgICApLmlzUmVxdWlyZWQsXG4gICAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgd3JhcDogUHJvcFR5cGVzLmJvb2wsXG4gIH07XG5cbiAgc3RhdGU6IFN0YXRlID0ge1xuICAgIGZvY3VzZWRUYWJJbmRleDogdW5kZWZpbmVkLFxuICAgIGhvdmVyZWRUYWJJbmRleDogdW5kZWZpbmVkLFxuICB9O1xuXG4gIGhhbmRsZVRhYkNsaWNrID0gKGk6IG51bWJlciwgZTogU3ludGhldGljTW91c2VFdmVudDw+KSA9PiB7XG4gICAgY29uc3QgeyBvbkNoYW5nZSB9ID0gdGhpcy5wcm9wcztcbiAgICBvbkNoYW5nZSh7IGFjdGl2ZVRhYkluZGV4OiBpLCBldmVudDogZSB9KTtcbiAgfTtcblxuICBoYW5kbGVUYWJGb2N1cyA9IChpOiBudW1iZXIpID0+IHRoaXMuc2V0U3RhdGUoeyBmb2N1c2VkVGFiSW5kZXg6IGkgfSk7XG5cbiAgaGFuZGxlVGFiQmx1ciA9ICgpID0+IHRoaXMuc2V0U3RhdGUoeyBmb2N1c2VkVGFiSW5kZXg6IHVuZGVmaW5lZCB9KTtcblxuICBoYW5kbGVUYWJNb3VzZUVudGVyID0gKGk6IG51bWJlcikgPT4gdGhpcy5zZXRTdGF0ZSh7IGhvdmVyZWRUYWJJbmRleDogaSB9KTtcblxuICBoYW5kbGVUYWJNb3VzZUxlYXZlID0gKCkgPT4gdGhpcy5zZXRTdGF0ZSh7IGhvdmVyZWRUYWJJbmRleDogdW5kZWZpbmVkIH0pO1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IHRhYnMsIGFjdGl2ZVRhYkluZGV4LCB3cmFwIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgZm9jdXNlZFRhYkluZGV4LCBob3ZlcmVkVGFiSW5kZXggfSA9IHRoaXMuc3RhdGU7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXZcbiAgICAgICAgY2xhc3NOYW1lPXtjbGFzc25hbWVzKHN0eWxlcy5UYWJzLCB3cmFwICYmIGxheW91dC5mbGV4V3JhcCl9XG4gICAgICAgIHJvbGU9XCJ0YWJsaXN0XCJcbiAgICAgID5cbiAgICAgICAge3RhYnMubWFwKCh7IHRleHQsIGhyZWYgfSwgaSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGlzQWN0aXZlID0gaSA9PT0gYWN0aXZlVGFiSW5kZXg7XG4gICAgICAgICAgY29uc3QgaXNIb3ZlcmVkID0gaSA9PT0gaG92ZXJlZFRhYkluZGV4O1xuICAgICAgICAgIGNvbnN0IGlzRm9jdXNlZCA9IGkgPT09IGZvY3VzZWRUYWJJbmRleDtcbiAgICAgICAgICBjb25zdCBjcyA9IGNsYXNzbmFtZXMoc3R5bGVzLnRhYiwge1xuICAgICAgICAgICAgW3N0eWxlcy50YWJJc05vdEFjdGl2ZV06ICFpc0FjdGl2ZSxcbiAgICAgICAgICAgIFtzdHlsZXMudGFiSXNBY3RpdmVdOiBpc0FjdGl2ZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGFcbiAgICAgICAgICAgICAgYXJpYS1zZWxlY3RlZD17aXNBY3RpdmV9XG4gICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3N9XG4gICAgICAgICAgICAgIGhyZWY9e2hyZWZ9XG4gICAgICAgICAgICAgIGtleT17YCR7aX0ke2hyZWZ9YH1cbiAgICAgICAgICAgICAgb25DbGljaz17KGU6IFN5bnRoZXRpY01vdXNlRXZlbnQ8PikgPT4gdGhpcy5oYW5kbGVUYWJDbGljayhpLCBlKX1cbiAgICAgICAgICAgICAgb25Gb2N1cz17KCkgPT4gdGhpcy5oYW5kbGVUYWJGb2N1cyhpKX1cbiAgICAgICAgICAgICAgb25CbHVyPXt0aGlzLmhhbmRsZVRhYkJsdXJ9XG4gICAgICAgICAgICAgIG9uTW91c2VFbnRlcj17KCkgPT4gdGhpcy5oYW5kbGVUYWJNb3VzZUVudGVyKGkpfVxuICAgICAgICAgICAgICBvbk1vdXNlTGVhdmU9e3RoaXMuaGFuZGxlVGFiTW91c2VMZWF2ZX1cbiAgICAgICAgICAgICAgcm9sZT1cInRhYlwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIDxUZXh0XG4gICAgICAgICAgICAgICAgYm9sZFxuICAgICAgICAgICAgICAgIGNvbG9yPXtpc0FjdGl2ZSB8fCBpc0hvdmVyZWQgfHwgaXNGb2N1c2VkID8gJ2RhcmtHcmF5JyA6ICdncmF5J31cbiAgICAgICAgICAgICAgICBzaXplPVwibWRcIlxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAge3RleHR9XG4gICAgICAgICAgICAgIDwvVGV4dD5cbiAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICApO1xuICAgICAgICB9KX1cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cbiIsIi8vIEBmbG93XG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBGbHlvdXQgZnJvbSAnLi9GbHlvdXQuanMnO1xuaW1wb3J0IEJveCBmcm9tICcuL0JveC5qcyc7XG5pbXBvcnQgVGV4dCBmcm9tICcuL1RleHQuanMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL1RleHRBcmVhLmNzcyc7XG5cbnR5cGUgU3RhdGUgPSB7XG4gIGZvY3VzZWQ6IGJvb2xlYW4sXG4gIGVycm9ySXNPcGVuOiBib29sZWFuLFxuICBlcnJvck1lc3NhZ2U/OiBzdHJpbmcsXG59O1xuXG50eXBlIFByb3BzID0ge3xcbiAgZXJyb3JNZXNzYWdlPzogc3RyaW5nLFxuICBkaXNhYmxlZD86IGJvb2xlYW4sXG4gIGhhc0Vycm9yPzogYm9vbGVhbixcbiAgaWQ6IHN0cmluZyxcbiAgaWRlYWxFcnJvckRpcmVjdGlvbj86ICd1cCcgfCAncmlnaHQnIHwgJ2Rvd24nIHwgJ2xlZnQnIC8qIGRlZmF1bHQ6IHJpZ2h0ICovLFxuICBuYW1lPzogc3RyaW5nLFxuICBvbkJsdXI/OiAoe1xuICAgIGV2ZW50OiBTeW50aGV0aWNGb2N1c0V2ZW50PEhUTUxUZXh0QXJlYUVsZW1lbnQ+LFxuICAgIHZhbHVlOiBzdHJpbmcsXG4gIH0pID0+IHZvaWQsXG4gIG9uQ2hhbmdlOiAoe1xuICAgIGV2ZW50OiBTeW50aGV0aWNJbnB1dEV2ZW50PEhUTUxUZXh0QXJlYUVsZW1lbnQ+LFxuICAgIHZhbHVlOiBzdHJpbmcsXG4gIH0pID0+IHZvaWQsXG4gIG9uRm9jdXM/OiAoe1xuICAgIGV2ZW50OiBTeW50aGV0aWNGb2N1c0V2ZW50PEhUTUxUZXh0QXJlYUVsZW1lbnQ+LFxuICAgIHZhbHVlOiBzdHJpbmcsXG4gIH0pID0+IHZvaWQsXG4gIG9uS2V5RG93bj86ICh7XG4gICAgZXZlbnQ6IFN5bnRoZXRpY0tleWJvYXJkRXZlbnQ8SFRNTFRleHRBcmVhRWxlbWVudD4sXG4gICAgdmFsdWU6IHN0cmluZyxcbiAgfSkgPT4gdm9pZCxcbiAgcGxhY2Vob2xkZXI/OiBzdHJpbmcsXG4gIHJvd3M/OiBudW1iZXIgLyogZGVmYXVsdDogMyAqLyxcbiAgdmFsdWU/OiBzdHJpbmcsXG58fTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGV4dEFyZWEgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8UHJvcHMsIFN0YXRlPiB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgIGVycm9yTWVzc2FnZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBoYXNFcnJvcjogUHJvcFR5cGVzLmJvb2wsXG4gICAgaWQ6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBpZGVhbEVycm9yRGlyZWN0aW9uOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIG5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgb25CbHVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBvbkZvY3VzOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbktleURvd246IFByb3BUeXBlcy5mdW5jLFxuICAgIHBsYWNlaG9sZGVyOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIHJvd3M6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgdmFsdWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIH07XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgaGFzRXJyb3I6IGZhbHNlLFxuICAgIGlkZWFsRXJyb3JEaXJlY3Rpb246ICdyaWdodCcsXG4gICAgcm93czogMyxcbiAgfTtcblxuICBzdGF0ZSA9IHtcbiAgICBmb2N1c2VkOiBmYWxzZSxcbiAgICBlcnJvcklzT3BlbjogZmFsc2UsXG4gIH07XG5cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhwcm9wczogUHJvcHMsIHN0YXRlOiBTdGF0ZSkge1xuICAgIGlmIChwcm9wcy5lcnJvck1lc3NhZ2UgIT09IHN0YXRlLmVycm9yTWVzc2FnZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3JJc09wZW46ICEhcHJvcHMuZXJyb3JNZXNzYWdlLFxuICAgICAgICBlcnJvck1lc3NhZ2U6IHByb3BzLmVycm9yTWVzc2FnZSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBoYW5kbGVDaGFuZ2UgPSAoZXZlbnQ6IFN5bnRoZXRpY0lucHV0RXZlbnQ8SFRNTFRleHRBcmVhRWxlbWVudD4pID0+IHtcbiAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHtcbiAgICAgIGV2ZW50LFxuICAgICAgdmFsdWU6IGV2ZW50LmN1cnJlbnRUYXJnZXQudmFsdWUsXG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5wcm9wcy5lcnJvck1lc3NhZ2UpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBlcnJvcklzT3BlbjogdHJ1ZSB9KTtcbiAgICB9XG4gIH07XG5cbiAgaGFuZGxlQmx1ciA9IChldmVudDogU3ludGhldGljRm9jdXNFdmVudDxIVE1MVGV4dEFyZWFFbGVtZW50PikgPT4ge1xuICAgIGlmICh0aGlzLnByb3BzLmVycm9yTWVzc2FnZSkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGVycm9ySXNPcGVuOiBmYWxzZSB9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMucHJvcHMub25CbHVyKSB7XG4gICAgICB0aGlzLnByb3BzLm9uQmx1cih7XG4gICAgICAgIGV2ZW50LFxuICAgICAgICB2YWx1ZTogZXZlbnQuY3VycmVudFRhcmdldC52YWx1ZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBoYW5kbGVGb2N1cyA9IChldmVudDogU3ludGhldGljRm9jdXNFdmVudDxIVE1MVGV4dEFyZWFFbGVtZW50PikgPT4ge1xuICAgIGlmICh0aGlzLnByb3BzLmVycm9yTWVzc2FnZSkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGVycm9ySXNPcGVuOiB0cnVlIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5wcm9wcy5vbkZvY3VzKSB7XG4gICAgICB0aGlzLnByb3BzLm9uRm9jdXMoe1xuICAgICAgICBldmVudCxcbiAgICAgICAgdmFsdWU6IGV2ZW50LmN1cnJlbnRUYXJnZXQudmFsdWUsXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgaGFuZGxlS2V5RG93biA9IChldmVudDogU3ludGhldGljS2V5Ym9hcmRFdmVudDxIVE1MVGV4dEFyZWFFbGVtZW50PikgPT4ge1xuICAgIGlmICh0aGlzLnByb3BzLm9uS2V5RG93bikge1xuICAgICAgdGhpcy5wcm9wcy5vbktleURvd24oe1xuICAgICAgICBldmVudCxcbiAgICAgICAgdmFsdWU6IGV2ZW50LmN1cnJlbnRUYXJnZXQudmFsdWUsXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgdGV4dGFyZWE6ID9IVE1MRWxlbWVudDtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGlzYWJsZWQsXG4gICAgICBlcnJvck1lc3NhZ2UsXG4gICAgICBoYXNFcnJvcixcbiAgICAgIGlkLFxuICAgICAgaWRlYWxFcnJvckRpcmVjdGlvbixcbiAgICAgIG5hbWUsXG4gICAgICBwbGFjZWhvbGRlcixcbiAgICAgIHJvd3MsXG4gICAgICB2YWx1ZSxcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIGNvbnN0IGNsYXNzZXMgPSBjbGFzc25hbWVzKFxuICAgICAgc3R5bGVzLnRleHRBcmVhLFxuICAgICAgZGlzYWJsZWQgPyBzdHlsZXMuZGlzYWJsZWQgOiBzdHlsZXMuZW5hYmxlZCxcbiAgICAgIGhhc0Vycm9yIHx8IGVycm9yTWVzc2FnZSA/IHN0eWxlcy5lcnJvcmVkIDogc3R5bGVzLm5vcm1hbFxuICAgICk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPHNwYW4+XG4gICAgICAgIDx0ZXh0YXJlYVxuICAgICAgICAgIGFyaWEtZGVzY3JpYmVkYnk9e1xuICAgICAgICAgICAgZXJyb3JNZXNzYWdlICYmIHRoaXMuc3RhdGUuZm9jdXNlZCA/IGAke2lkfS1nZXN0YWx0LWVycm9yYCA6IG51bGxcbiAgICAgICAgICB9XG4gICAgICAgICAgYXJpYS1pbnZhbGlkPXtlcnJvck1lc3NhZ2UgfHwgaGFzRXJyb3IgPyAndHJ1ZScgOiAnZmFsc2UnfVxuICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3Nlc31cbiAgICAgICAgICBkaXNhYmxlZD17ZGlzYWJsZWR9XG4gICAgICAgICAgaWQ9e2lkfVxuICAgICAgICAgIG5hbWU9e25hbWV9XG4gICAgICAgICAgb25CbHVyPXt0aGlzLmhhbmRsZUJsdXJ9XG4gICAgICAgICAgb25DaGFuZ2U9e3RoaXMuaGFuZGxlQ2hhbmdlfVxuICAgICAgICAgIG9uRm9jdXM9e3RoaXMuaGFuZGxlRm9jdXN9XG4gICAgICAgICAgb25LZXlEb3duPXt0aGlzLmhhbmRsZUtleURvd259XG4gICAgICAgICAgcGxhY2Vob2xkZXI9e3BsYWNlaG9sZGVyfVxuICAgICAgICAgIHJlZj17YyA9PiB7XG4gICAgICAgICAgICB0aGlzLnRleHRhcmVhID0gYztcbiAgICAgICAgICB9fVxuICAgICAgICAgIHJvd3M9e3Jvd3N9XG4gICAgICAgICAgdmFsdWU9e3ZhbHVlfVxuICAgICAgICAvPlxuICAgICAgICB7ZXJyb3JNZXNzYWdlICYmIHRoaXMuc3RhdGUuZXJyb3JJc09wZW4gPyAoXG4gICAgICAgICAgPEZseW91dFxuICAgICAgICAgICAgYW5jaG9yPXt0aGlzLnRleHRhcmVhfVxuICAgICAgICAgICAgY29sb3I9XCJvcmFuZ2VcIlxuICAgICAgICAgICAgaWRlYWxEaXJlY3Rpb249e2lkZWFsRXJyb3JEaXJlY3Rpb259XG4gICAgICAgICAgICBvbkRpc21pc3M9eygpID0+IHRoaXMuc2V0U3RhdGUoeyBlcnJvcklzT3BlbjogZmFsc2UgfSl9XG4gICAgICAgICAgICBzaG91bGRGb2N1cz17ZmFsc2V9XG4gICAgICAgICAgICBzaXplPVwic21cIlxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxCb3ggcGFkZGluZz17M30+XG4gICAgICAgICAgICAgIDxUZXh0IGJvbGQgY29sb3I9XCJ3aGl0ZVwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGlkPXtgJHtpZH0tZ2VzdGFsdC1lcnJvcmB9PntlcnJvck1lc3NhZ2V9PC9zcGFuPlxuICAgICAgICAgICAgICA8L1RleHQ+XG4gICAgICAgICAgICA8L0JveD5cbiAgICAgICAgICA8L0ZseW91dD5cbiAgICAgICAgKSA6IG51bGx9XG4gICAgICA8L3NwYW4+XG4gICAgKTtcbiAgfVxufVxuIiwiLy8gQGZsb3dcblxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IEZseW91dCBmcm9tICcuL0ZseW91dC5qcyc7XG5pbXBvcnQgQm94IGZyb20gJy4vQm94LmpzJztcbmltcG9ydCBUZXh0IGZyb20gJy4vVGV4dC5qcyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vVGV4dEZpZWxkLmNzcyc7XG5cbnR5cGUgU3RhdGUgPSB7XG4gIGZvY3VzZWQ6IGJvb2xlYW4sXG4gIGVycm9ySXNPcGVuOiBib29sZWFuLFxuICBlcnJvck1lc3NhZ2U/OiBzdHJpbmcsXG59O1xuXG50eXBlIFByb3BzID0ge3xcbiAgYXV0b0NvbXBsZXRlPzogJ2N1cnJlbnQtcGFzc3dvcmQnIHwgJ29uJyB8ICdvZmYnIHwgJ3VzZXJuYW1lJyxcbiAgZGlzYWJsZWQ/OiBib29sZWFuLFxuICBlcnJvck1lc3NhZ2U/OiBzdHJpbmcsXG4gIGhhc0Vycm9yPzogYm9vbGVhbixcbiAgaWQ6IHN0cmluZyxcbiAgaWRlYWxFcnJvckRpcmVjdGlvbj86ICd1cCcgfCAncmlnaHQnIHwgJ2Rvd24nIHwgJ2xlZnQnIC8qIGRlZmF1bHQ6IHJpZ2h0ICovLFxuICBuYW1lPzogc3RyaW5nLFxuICBvbkJsdXI/OiAoe1xuICAgIGV2ZW50OiBTeW50aGV0aWNGb2N1c0V2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+LFxuICAgIHZhbHVlOiBzdHJpbmcsXG4gIH0pID0+IHZvaWQsXG4gIG9uQ2hhbmdlOiAoe1xuICAgIGV2ZW50OiBTeW50aGV0aWNJbnB1dEV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+LFxuICAgIHZhbHVlOiBzdHJpbmcsXG4gIH0pID0+IHZvaWQsXG4gIG9uRm9jdXM/OiAoe1xuICAgIGV2ZW50OiBTeW50aGV0aWNGb2N1c0V2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+LFxuICAgIHZhbHVlOiBzdHJpbmcsXG4gIH0pID0+IHZvaWQsXG4gIG9uS2V5RG93bj86ICh7XG4gICAgZXZlbnQ6IFN5bnRoZXRpY0tleWJvYXJkRXZlbnQ8SFRNTElucHV0RWxlbWVudD4sXG4gICAgdmFsdWU6IHN0cmluZyxcbiAgfSkgPT4gdm9pZCxcbiAgcGxhY2Vob2xkZXI/OiBzdHJpbmcsXG4gIHR5cGU/OiAnZGF0ZScgfCAnZW1haWwnIHwgJ251bWJlcicgfCAncGFzc3dvcmQnIHwgJ3RleHQnIHwgJ3VybCcsXG4gIHZhbHVlPzogc3RyaW5nLFxufH07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRleHRGaWVsZCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxQcm9wcywgU3RhdGU+IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICBhdXRvQ29tcGxldGU6IFByb3BUeXBlcy5vbmVPZihbXG4gICAgICAnY3VycmVudC1wYXNzd29yZCcsXG4gICAgICAnb24nLFxuICAgICAgJ29mZicsXG4gICAgICAndXNlcm5hbWUnLFxuICAgIF0pLFxuICAgIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBlcnJvck1lc3NhZ2U6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgaGFzRXJyb3I6IFByb3BUeXBlcy5ib29sLFxuICAgIGlkOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgaWRlYWxFcnJvckRpcmVjdGlvbjogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBuYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIG9uQmx1cjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgb25Gb2N1czogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25LZXlEb3duOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBwbGFjZWhvbGRlcjogUHJvcFR5cGVzLnN0cmluZyxcbiAgICB0eXBlOiBQcm9wVHlwZXMub25lT2YoW1xuICAgICAgJ2RhdGUnLFxuICAgICAgJ2VtYWlsJyxcbiAgICAgICdudW1iZXInLFxuICAgICAgJ3Bhc3N3b3JkJyxcbiAgICAgICd0ZXh0JyxcbiAgICAgICd1cmwnLFxuICAgIF0pLFxuICAgIHZhbHVlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICB9O1xuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgIGhhc0Vycm9yOiBmYWxzZSxcbiAgICBpZGVhbEVycm9yRGlyZWN0aW9uOiAncmlnaHQnLFxuICAgIHR5cGU6ICd0ZXh0JyxcbiAgfTtcblxuICBzdGF0ZSA9IHtcbiAgICBmb2N1c2VkOiBmYWxzZSxcbiAgICBlcnJvcklzT3BlbjogZmFsc2UsXG4gIH07XG5cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhwcm9wczogUHJvcHMsIHN0YXRlOiBTdGF0ZSkge1xuICAgIGlmIChwcm9wcy5lcnJvck1lc3NhZ2UgIT09IHN0YXRlLmVycm9yTWVzc2FnZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3JJc09wZW46ICEhcHJvcHMuZXJyb3JNZXNzYWdlLFxuICAgICAgICBlcnJvck1lc3NhZ2U6IHByb3BzLmVycm9yTWVzc2FnZSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBoYW5kbGVDaGFuZ2UgPSAoZXZlbnQ6IFN5bnRoZXRpY0lucHV0RXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcbiAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHtcbiAgICAgIGV2ZW50LFxuICAgICAgdmFsdWU6IGV2ZW50LmN1cnJlbnRUYXJnZXQudmFsdWUsXG4gICAgfSk7XG4gIH07XG5cbiAgaGFuZGxlQmx1ciA9IChldmVudDogU3ludGhldGljRm9jdXNFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xuICAgIGlmICh0aGlzLnByb3BzLmVycm9yTWVzc2FnZSkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGVycm9ySXNPcGVuOiBmYWxzZSB9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMucHJvcHMub25CbHVyKSB7XG4gICAgICB0aGlzLnByb3BzLm9uQmx1cih7XG4gICAgICAgIGV2ZW50LFxuICAgICAgICB2YWx1ZTogZXZlbnQuY3VycmVudFRhcmdldC52YWx1ZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBoYW5kbGVGb2N1cyA9IChldmVudDogU3ludGhldGljRm9jdXNFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xuICAgIGlmICh0aGlzLnByb3BzLmVycm9yTWVzc2FnZSkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGVycm9ySXNPcGVuOiB0cnVlIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5wcm9wcy5vbkZvY3VzKSB7XG4gICAgICB0aGlzLnByb3BzLm9uRm9jdXMoe1xuICAgICAgICBldmVudCxcbiAgICAgICAgdmFsdWU6IGV2ZW50LmN1cnJlbnRUYXJnZXQudmFsdWUsXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgaGFuZGxlS2V5RG93biA9IChldmVudDogU3ludGhldGljS2V5Ym9hcmRFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xuICAgIGlmICh0aGlzLnByb3BzLm9uS2V5RG93bikge1xuICAgICAgdGhpcy5wcm9wcy5vbktleURvd24oe1xuICAgICAgICBldmVudCxcbiAgICAgICAgdmFsdWU6IGV2ZW50LmN1cnJlbnRUYXJnZXQudmFsdWUsXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgdGV4dGZpZWxkOiA/SFRNTEVsZW1lbnQ7XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGF1dG9Db21wbGV0ZSxcbiAgICAgIGRpc2FibGVkLFxuICAgICAgZXJyb3JNZXNzYWdlLFxuICAgICAgaGFzRXJyb3IsXG4gICAgICBpZCxcbiAgICAgIGlkZWFsRXJyb3JEaXJlY3Rpb24sXG4gICAgICBuYW1lLFxuICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICB0eXBlLFxuICAgICAgdmFsdWUsXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb25zdCBjbGFzc2VzID0gY2xhc3NuYW1lcyhcbiAgICAgIHN0eWxlcy50ZXh0RmllbGQsXG4gICAgICBkaXNhYmxlZCA/IHN0eWxlcy5kaXNhYmxlZCA6IHN0eWxlcy5lbmFibGVkLFxuICAgICAgaGFzRXJyb3IgfHwgZXJyb3JNZXNzYWdlID8gc3R5bGVzLmVycm9yZWQgOiBzdHlsZXMubm9ybWFsXG4gICAgKTtcblxuICAgIC8vIHR5cGU9J251bWJlcicgZG9lc24ndCB3b3JrIG9uIGlvcyBzYWZhcmkgd2l0aG91dCBhIHBhdHRlcm5cbiAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNDQ0NzY2OC9pbnB1dC10eXBlLW51bWJlci1pcy1ub3Qtc2hvd2luZy1hLW51bWJlci1rZXlwYWQtb24taW9zXG4gICAgY29uc3QgcGF0dGVybiA9IHR5cGUgPT09ICdudW1iZXInID8gJ1xcXFxkKicgOiB1bmRlZmluZWQ7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPHNwYW4+XG4gICAgICAgIDxpbnB1dFxuICAgICAgICAgIGFyaWEtZGVzY3JpYmVkYnk9e1xuICAgICAgICAgICAgZXJyb3JNZXNzYWdlICYmIHRoaXMuc3RhdGUuZm9jdXNlZCA/IGAke2lkfS1nZXN0YWx0LWVycm9yYCA6IG51bGxcbiAgICAgICAgICB9XG4gICAgICAgICAgYXJpYS1pbnZhbGlkPXtlcnJvck1lc3NhZ2UgfHwgaGFzRXJyb3IgPyAndHJ1ZScgOiAnZmFsc2UnfVxuICAgICAgICAgIGF1dG9Db21wbGV0ZT17YXV0b0NvbXBsZXRlfVxuICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3Nlc31cbiAgICAgICAgICBkaXNhYmxlZD17ZGlzYWJsZWR9XG4gICAgICAgICAgaWQ9e2lkfVxuICAgICAgICAgIG5hbWU9e25hbWV9XG4gICAgICAgICAgb25CbHVyPXt0aGlzLmhhbmRsZUJsdXJ9XG4gICAgICAgICAgb25DaGFuZ2U9e3RoaXMuaGFuZGxlQ2hhbmdlfVxuICAgICAgICAgIG9uRm9jdXM9e3RoaXMuaGFuZGxlRm9jdXN9XG4gICAgICAgICAgb25LZXlEb3duPXt0aGlzLmhhbmRsZUtleURvd259XG4gICAgICAgICAgcGF0dGVybj17cGF0dGVybn1cbiAgICAgICAgICBwbGFjZWhvbGRlcj17cGxhY2Vob2xkZXJ9XG4gICAgICAgICAgcmVmPXtjID0+IHtcbiAgICAgICAgICAgIHRoaXMudGV4dGZpZWxkID0gYztcbiAgICAgICAgICB9fVxuICAgICAgICAgIHR5cGU9e3R5cGV9XG4gICAgICAgICAgdmFsdWU9e3ZhbHVlfVxuICAgICAgICAvPlxuICAgICAgICB7ZXJyb3JNZXNzYWdlICYmXG4gICAgICAgICAgdGhpcy5zdGF0ZS5lcnJvcklzT3BlbiAmJiAoXG4gICAgICAgICAgICA8Rmx5b3V0XG4gICAgICAgICAgICAgIGFuY2hvcj17dGhpcy50ZXh0ZmllbGR9XG4gICAgICAgICAgICAgIGNvbG9yPVwib3JhbmdlXCJcbiAgICAgICAgICAgICAgaWRlYWxEaXJlY3Rpb249e2lkZWFsRXJyb3JEaXJlY3Rpb259XG4gICAgICAgICAgICAgIG9uRGlzbWlzcz17KCkgPT4gdGhpcy5zZXRTdGF0ZSh7IGVycm9ySXNPcGVuOiBmYWxzZSB9KX1cbiAgICAgICAgICAgICAgc2hvdWxkRm9jdXM9e2ZhbHNlfVxuICAgICAgICAgICAgICBzaXplPVwic21cIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8Qm94IHBhZGRpbmc9ezN9PlxuICAgICAgICAgICAgICAgIDxUZXh0IGJvbGQgY29sb3I9XCJ3aGl0ZVwiPlxuICAgICAgICAgICAgICAgICAgPHNwYW4gaWQ9e2Ake2lkfS1nZXN0YWx0LWVycm9yYH0+e2Vycm9yTWVzc2FnZX08L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9UZXh0PlxuICAgICAgICAgICAgICA8L0JveD5cbiAgICAgICAgICAgIDwvRmx5b3V0PlxuICAgICAgICAgICl9XG4gICAgICA8L3NwYW4+XG4gICAgKTtcbiAgfVxufVxuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgQm94IGZyb20gJy4vQm94LmpzJztcbmltcG9ydCBNYXNrIGZyb20gJy4vTWFzay5qcyc7XG5pbXBvcnQgVGV4dCBmcm9tICcuL1RleHQuanMnO1xuaW1wb3J0IEljb24gZnJvbSAnLi9JY29uLmpzJztcblxudHlwZSBQcm9wcyA9IHt8XG4gIGNvbG9yPzogJ2RhcmtHcmF5JyB8ICdvcmFuZ2UnLFxuICBpY29uPzogJ2Fycm93LWNpcmNsZS1mb3J3YXJkJywgLy8gbGVhdmluZyBvcGVuIHRvIGFkZGl0aW9uYWwgaWNvbnMgaW4gdGhlIGZ1dHVyZVxuICB0ZXh0OiBzdHJpbmcgfCBBcnJheTxzdHJpbmc+LFxuICB0aHVtYm5haWw/OiBSZWFjdC5Ob2RlLFxufH07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFRvYXN0KHByb3BzOiBQcm9wcykge1xuICBjb25zdCB7IGNvbG9yID0gJ2RhcmtHcmF5JywgaWNvbiwgdGh1bWJuYWlsLCB0ZXh0IH0gPSBwcm9wcztcblxuICBsZXQgY29udGVudHM7XG4gIC8vIENvbmZpcm1hdGlvbiBUb2FzdHNcbiAgaWYgKHRleHQgaW5zdGFuY2VvZiBBcnJheSAmJiB0ZXh0Lmxlbmd0aCA+IDEpIHtcbiAgICBjb250ZW50cyA9IChcbiAgICAgIDxCb3ggeHM9e3sgZGlzcGxheTogJ2ZsZXgnIH19PlxuICAgICAgICA8Qm94IHhzPXt7IGRpc3BsYXk6ICdmbGV4Q29sdW1uJyB9fSBmbGV4PVwibm9uZVwiIGp1c3RpZnlDb250ZW50PVwiY2VudGVyXCI+XG4gICAgICAgICAge3RodW1ibmFpbCA/IChcbiAgICAgICAgICAgIDxNYXNrIHNoYXBlPVwicm91bmRlZFwiIGhlaWdodD17NDh9IHdpZHRoPXs0OH0+XG4gICAgICAgICAgICAgIHt0aHVtYm5haWx9XG4gICAgICAgICAgICA8L01hc2s+XG4gICAgICAgICAgKSA6IG51bGx9XG4gICAgICAgIDwvQm94PlxuICAgICAgICA8Qm94XG4gICAgICAgICAgeHM9e3sgZGlzcGxheTogJ2ZsZXhDb2x1bW4nIH19XG4gICAgICAgICAganVzdGlmeUNvbnRlbnQ9XCJjZW50ZXJcIlxuICAgICAgICAgIGRhbmdlcm91c2x5U2V0SW5saW5lU3R5bGU9e3sgX19zdHlsZTogeyBwYWRkaW5nTGVmdDogMTAgfSB9fVxuICAgICAgICA+XG4gICAgICAgICAgPEJveFxuICAgICAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbmxpbmVTdHlsZT17eyBfX3N0eWxlOiB7IGZvbnRXZWlnaHQ6ICdub3JtYWwnIH0gfX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8VGV4dCBjb2xvcj1cIndoaXRlXCIgc2l6ZT1cImxnXCI+XG4gICAgICAgICAgICAgIHt0ZXh0WzBdfVxuICAgICAgICAgICAgPC9UZXh0PlxuICAgICAgICAgIDwvQm94PlxuICAgICAgICAgIDxUZXh0IGJvbGQgY29sb3I9XCJ3aGl0ZVwiIHNpemU9XCJsZ1wiPlxuICAgICAgICAgICAge3RleHRbMV19XG4gICAgICAgICAgPC9UZXh0PlxuICAgICAgICA8L0JveD5cbiAgICAgIDwvQm94PlxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG9hc3RzIGFzIEd1aWRlc1xuICAgIGNvbnRlbnRzID0gKFxuICAgICAgPEJveFxuICAgICAgICB4cz17eyBkaXNwbGF5OiAnZmxleCcgfX1cbiAgICAgICAganVzdGlmeUNvbnRlbnQ9XCJiZXR3ZWVuXCJcbiAgICAgICAgYWxpZ25JdGVtcz1cImNlbnRlclwiXG4gICAgICA+XG4gICAgICAgIDxUZXh0IGJvbGQgY29sb3I9XCJ3aGl0ZVwiIHNpemU9XCJsZ1wiPlxuICAgICAgICAgIHt0ZXh0fVxuICAgICAgICA8L1RleHQ+XG4gICAgICAgIHtpY29uICYmIChcbiAgICAgICAgICA8Qm94IGRhbmdlcm91c2x5U2V0SW5saW5lU3R5bGU9e3sgX19zdHlsZTogeyBwYWRkaW5nTGVmdDogMjQgfSB9fT5cbiAgICAgICAgICAgIDxJY29uIGFjY2Vzc2liaWxpdHlMYWJlbD1cIlwiIGNvbG9yPVwid2hpdGVcIiBpY29uPXtpY29ufSBzaXplPXszNn0gLz5cbiAgICAgICAgICA8L0JveD5cbiAgICAgICAgKX1cbiAgICAgIDwvQm94PlxuICAgICk7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxCb3ggbWFyZ2luQm90dG9tPXszfSBwYWRkaW5nWD17NH0gbWF4V2lkdGg9ezM3Nn0gd2lkdGg9XCIxMDB2d1wiPlxuICAgICAgPEJveCBjb2xvcj17Y29sb3J9IGZpdCBwYWRkaW5nWD17OH0gcGFkZGluZ1k9ezV9IHNoYXBlPVwicGlsbFwiPlxuICAgICAgICB7Y29udGVudHN9XG4gICAgICA8L0JveD5cbiAgICA8L0JveD5cbiAgKTtcbn1cblxuVG9hc3QucHJvcFR5cGVzID0ge1xuICBjb2xvcjogUHJvcFR5cGVzLm9uZU9mKFsnZGFya0dyYXknLCAnb3JhbmdlJ10pLFxuICBpY29uOiBQcm9wVHlwZXMub25lT2YoWydhcnJvdy1jaXJjbGUtZm9yd2FyZCddKSwgLy8gbGVhdmluZyBvcGVuIHRvIGFkZGl0aW9uYWwgaWNvbnMgaW4gdGhlIGZ1dHVyZVxuICB0ZXh0OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcbiAgICBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5zdHJpbmcpLFxuICBdKS5pc1JlcXVpcmVkLFxuICB0aHVtYm5haWw6IFByb3BUeXBlcy5ub2RlLFxufTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vVG91Y2hhYmxlLmNzcyc7XG5cbnR5cGUgU2hhcGUgPVxuICB8ICdzcXVhcmUnXG4gIHwgJ3JvdW5kZWQnXG4gIHwgJ3BpbGwnXG4gIHwgJ2NpcmNsZSdcbiAgfCAncm91bmRlZFRvcCdcbiAgfCAncm91bmRlZEJvdHRvbSdcbiAgfCAncm91bmRlZExlZnQnXG4gIHwgJ3JvdW5kZWRSaWdodCc7XG5cbnR5cGUgTW91c2VDdXJzb3IgPVxuICB8ICdjb3B5J1xuICB8ICdncmFiJ1xuICB8ICdncmFiYmluZydcbiAgfCAnbW92ZSdcbiAgfCAnbm9Ecm9wJ1xuICB8ICdwb2ludGVyJ1xuICB8ICd6b29tSW4nXG4gIHwgJ3pvb21PdXQnO1xuXG50eXBlIFByb3BzID0ge3xcbiAgY2hpbGRyZW4/OiBSZWFjdC5Ob2RlLFxuICBmdWxsSGVpZ2h0PzogYm9vbGVhbixcbiAgZnVsbFdpZHRoPzogYm9vbGVhbixcbiAgbW91c2VDdXJzb3I/OiBNb3VzZUN1cnNvcixcbiAgb25Nb3VzZUVudGVyPzogKHsgZXZlbnQ6IFN5bnRoZXRpY01vdXNlRXZlbnQ8SFRNTERpdkVsZW1lbnQ+IH0pID0+IHZvaWQsXG4gIG9uTW91c2VMZWF2ZT86ICh7IGV2ZW50OiBTeW50aGV0aWNNb3VzZUV2ZW50PEhUTUxEaXZFbGVtZW50PiB9KSA9PiB2b2lkLFxuICBvblRvdWNoPzogKHtcbiAgICBldmVudDpcbiAgICAgIHwgU3ludGhldGljTW91c2VFdmVudDxIVE1MRGl2RWxlbWVudD5cbiAgICAgIHwgU3ludGhldGljS2V5Ym9hcmRFdmVudDxIVE1MRGl2RWxlbWVudD4sXG4gIH0pID0+IHZvaWQsXG4gIHNoYXBlPzogU2hhcGUsXG58fTtcblxuY29uc3QgU1BBQ0VfQ0hBUl9DT0RFID0gMzI7XG5jb25zdCBFTlRFUl9DSEFSX0NPREUgPSAxMztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVG91Y2hhYmxlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFByb3BzPiB7XG4gIGhhbmRsZUtleVByZXNzID0gKGV2ZW50OiBTeW50aGV0aWNLZXlib2FyZEV2ZW50PEhUTUxEaXZFbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IHsgb25Ub3VjaCB9ID0gdGhpcy5wcm9wcztcbiAgICAvLyBDaGVjayB0byBzZWUgaWYgc3BhY2Ugb3IgZW50ZXIgd2VyZSBwcmVzc2VkXG4gICAgaWYgKFxuICAgICAgb25Ub3VjaCAmJlxuICAgICAgKGV2ZW50LmNoYXJDb2RlID09PSBTUEFDRV9DSEFSX0NPREUgfHwgZXZlbnQuY2hhckNvZGUgPT09IEVOVEVSX0NIQVJfQ09ERSlcbiAgICApIHtcbiAgICAgIC8vIFByZXZlbnQgdGhlIGRlZmF1bHQgYWN0aW9uIHRvIHN0b3Agc2Nyb2xsaW5nIHdoZW4gc3BhY2UgaXMgcHJlc3NlZFxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIG9uVG91Y2goeyBldmVudCB9KTtcbiAgICB9XG4gIH07XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgZnVsbFdpZHRoID0gdHJ1ZSxcbiAgICAgIGZ1bGxIZWlnaHQsXG4gICAgICBtb3VzZUN1cnNvciA9ICdwb2ludGVyJyxcbiAgICAgIG9uTW91c2VFbnRlcixcbiAgICAgIG9uTW91c2VMZWF2ZSxcbiAgICAgIG9uVG91Y2gsXG4gICAgICBzaGFwZSA9ICdzcXVhcmUnLFxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgY29uc3QgY2xhc3NlcyA9IGNsYXNzbmFtZXMoXG4gICAgICBzdHlsZXMudG91Y2hhYmxlLFxuICAgICAgc3R5bGVzW21vdXNlQ3Vyc29yXSxcbiAgICAgIHN0eWxlc1tzaGFwZV0sXG4gICAgICB7XG4gICAgICAgIFtzdHlsZXMuZnVsbEhlaWdodF06IGZ1bGxIZWlnaHQsXG4gICAgICAgIFtzdHlsZXMuZnVsbFdpZHRoXTogZnVsbFdpZHRoLFxuICAgICAgfVxuICAgICk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdlxuICAgICAgICBjbGFzc05hbWU9e2NsYXNzZXN9XG4gICAgICAgIG9uQ2xpY2s9e2V2ZW50ID0+IG9uVG91Y2ggJiYgb25Ub3VjaCh7IGV2ZW50IH0pfVxuICAgICAgICBvbk1vdXNlRW50ZXI9e2V2ZW50ID0+IG9uTW91c2VFbnRlciAmJiBvbk1vdXNlRW50ZXIoeyBldmVudCB9KX1cbiAgICAgICAgb25Nb3VzZUxlYXZlPXtldmVudCA9PiBvbk1vdXNlTGVhdmUgJiYgb25Nb3VzZUxlYXZlKHsgZXZlbnQgfSl9XG4gICAgICAgIG9uS2V5UHJlc3M9e3RoaXMuaGFuZGxlS2V5UHJlc3N9XG4gICAgICAgIHJvbGU9XCJidXR0b25cIlxuICAgICAgICB0YWJJbmRleD1cIjBcIlxuICAgICAgPlxuICAgICAgICB7Y2hpbGRyZW59XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG5cblRvdWNoYWJsZS5wcm9wVHlwZXMgPSB7XG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgZnVsbEhlaWdodDogUHJvcFR5cGVzLmJvb2wsXG4gIGZ1bGxXaWR0aDogUHJvcFR5cGVzLmJvb2wsXG4gIG1vdXNlQ3Vyc29yOiBQcm9wVHlwZXMub25lT2YoW1xuICAgICdjb3B5JyxcbiAgICAnZ3JhYicsXG4gICAgJ2dyYWJiaW5nJyxcbiAgICAnbW92ZScsXG4gICAgJ25vRHJvcCcsXG4gICAgJ3BvaW50ZXInLFxuICAgICd6b29tSW4nLFxuICAgICd6b29tT3V0JyxcbiAgXSksXG4gIG9uVG91Y2g6IFByb3BUeXBlcy5mdW5jLFxuICBvbk1vdXNlRW50ZXI6IFByb3BUeXBlcy5mdW5jLFxuICBvbk1vdXNlTGVhdmU6IFByb3BUeXBlcy5mdW5jLFxuICBzaGFwZTogUHJvcFR5cGVzLm9uZU9mKFtcbiAgICAnc3F1YXJlJyxcbiAgICAncm91bmRlZCcsXG4gICAgJ3BpbGwnLFxuICAgICdjaXJjbGUnLFxuICAgICdyb3VuZGVkVG9wJyxcbiAgICAncm91bmRlZEJvdHRvbScsXG4gICAgJ3JvdW5kZWRMZWZ0JyxcbiAgICAncm91bmRlZFJpZ2h0JyxcbiAgXSksXG59O1xuIiwiLy8gQGZsb3dcblxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBCb3ggZnJvbSAnLi9Cb3guanMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL1ZpZGVvLmNzcyc7XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBjdXJyZW50VGltZTogbnVtYmVyLFxuICBkdXJhdGlvbjogbnVtYmVyLFxuICBzZWVrOiAodGltZTogbnVtYmVyKSA9PiB2b2lkLFxufH07XG5cbnR5cGUgU3RhdGUgPSB7fFxuICBzZWVraW5nOiBib29sZWFuLFxufH07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZpZGVvUGxheWhlYWQgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50PFByb3BzLCBTdGF0ZT4ge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIGN1cnJlbnRUaW1lOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gICAgZHVyYXRpb246IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgICBzZWVrOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB9O1xuXG4gIHN0YXRlID0ge1xuICAgIHNlZWtpbmc6IGZhbHNlLFxuICB9O1xuXG4gIHNldFBsYXloZWFkUmVmID0gKHJlZjogP0hUTUxEaXZFbGVtZW50KSA9PiB7XG4gICAgdGhpcy5wbGF5aGVhZCA9IHJlZjtcbiAgfTtcblxuICBzZWVrID0gKGNsaWVudFg6IG51bWJlcikgPT4ge1xuICAgIGlmICh0aGlzLnBsYXloZWFkKSB7XG4gICAgICBjb25zdCB7IGR1cmF0aW9uLCBzZWVrIH0gPSB0aGlzLnByb3BzO1xuICAgICAgY29uc3QgeyBsZWZ0LCB3aWR0aCB9ID0gdGhpcy5wbGF5aGVhZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IHBlcmNlbnQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigoY2xpZW50WCAtIGxlZnQpIC8gd2lkdGgsIDEpKTtcbiAgICAgIGNvbnN0IG5ld1RpbWUgPSBwZXJjZW50ICogZHVyYXRpb247XG4gICAgICBzZWVrKG5ld1RpbWUpO1xuICAgIH1cbiAgfTtcblxuICBzdG9wQ2xpY2sgPSAoZXZlbnQ6IFN5bnRoZXRpY0V2ZW50PEhUTUxEaXZFbGVtZW50PikgPT5cbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICBoYW5kbGVNb3VzZURvd24gPSAoZXZlbnQ6IFN5bnRoZXRpY01vdXNlRXZlbnQ8SFRNTERpdkVsZW1lbnQ+KSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IHNlZWtpbmc6IHRydWUgfSk7XG4gICAgdGhpcy5zZWVrKGV2ZW50LmNsaWVudFgpO1xuICB9O1xuXG4gIGhhbmRsZU1vdXNlTW92ZSA9IChldmVudDogU3ludGhldGljTW91c2VFdmVudDxIVE1MRGl2RWxlbWVudD4pID0+IHtcbiAgICBjb25zdCB7IHNlZWtpbmcgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHNlZWtpbmcpIHtcbiAgICAgIHRoaXMuc2VlayhldmVudC5jbGllbnRYKTtcbiAgICB9XG4gIH07XG5cbiAgaGFuZGxlTW91c2VVcCA9ICgpID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHsgc2Vla2luZzogZmFsc2UgfSk7XG4gIH07XG5cbiAgcGxheWhlYWQ6ID9IVE1MRGl2RWxlbWVudDtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBjdXJyZW50VGltZSwgZHVyYXRpb24gfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qgd2lkdGggPSBgJHtNYXRoLmZsb29yKChjdXJyZW50VGltZSAqIDEwMDAwKSAvIGR1cmF0aW9uKSAvIDEwMH0lYDtcbiAgICByZXR1cm4gKFxuICAgICAgPEJveFxuICAgICAgICBwb3NpdGlvbj1cInJlbGF0aXZlXCJcbiAgICAgICAgZGlzcGxheT1cImZsZXhcIlxuICAgICAgICBmbGV4PVwiZ3Jvd1wiXG4gICAgICAgIGFsaWduSXRlbXM9XCJjZW50ZXJcIlxuICAgICAgICBoZWlnaHQ9ezE2fVxuICAgICAgPlxuICAgICAgICA8ZGl2XG4gICAgICAgICAgYXJpYS12YWx1ZW1heD17ZHVyYXRpb259XG4gICAgICAgICAgYXJpYS12YWx1ZW1pbj1cIjBcIlxuICAgICAgICAgIGFyaWEtdmFsdWVub3c9e2N1cnJlbnRUaW1lfVxuICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLnBsYXloZWFkfVxuICAgICAgICAgIG9uQ2xpY2s9e3RoaXMuc3RvcENsaWNrfVxuICAgICAgICAgIG9uS2V5UHJlc3M9e3RoaXMuc3RvcENsaWNrfVxuICAgICAgICAgIG9uTW91c2VEb3duPXt0aGlzLmhhbmRsZU1vdXNlRG93bn1cbiAgICAgICAgICBvbk1vdXNlTW92ZT17dGhpcy5oYW5kbGVNb3VzZU1vdmV9XG4gICAgICAgICAgb25Nb3VzZVVwPXt0aGlzLmhhbmRsZU1vdXNlVXB9XG4gICAgICAgICAgcmVmPXt0aGlzLnNldFBsYXloZWFkUmVmfVxuICAgICAgICAgIHJvbGU9XCJwcm9ncmVzc2JhclwiXG4gICAgICAgICAgdGFiSW5kZXg9XCItMVwiXG4gICAgICAgID5cbiAgICAgICAgICA8Qm94XG4gICAgICAgICAgICBsZWZ0XG4gICAgICAgICAgICByaWdodFxuICAgICAgICAgICAgcG9zaXRpb249XCJhYnNvbHV0ZVwiXG4gICAgICAgICAgICBjb2xvcj1cImxpZ2h0R3JheVwiXG4gICAgICAgICAgICBzaGFwZT1cInJvdW5kZWRcIlxuICAgICAgICAgICAgaGVpZ2h0PXs0fVxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxCb3ggY29sb3I9XCJ3aGl0ZVwiIHNoYXBlPVwicm91bmRlZFwiIGhlaWdodD1cIjEwMCVcIiB3aWR0aD17d2lkdGh9IC8+XG4gICAgICAgICAgPC9Cb3g+XG4gICAgICAgICAgPEJveFxuICAgICAgICAgICAgcG9zaXRpb249XCJhYnNvbHV0ZVwiXG4gICAgICAgICAgICBzaGFwZT1cInJvdW5kZWRcIlxuICAgICAgICAgICAgaGVpZ2h0PXs0fVxuICAgICAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbmxpbmVTdHlsZT17eyBfX3N0eWxlOiB7IGxlZnQ6IHdpZHRoIH0gfX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8Qm94XG4gICAgICAgICAgICAgIHNoYXBlPVwiY2lyY2xlXCJcbiAgICAgICAgICAgICAgd2lkdGg9ezE2fVxuICAgICAgICAgICAgICBoZWlnaHQ9ezE2fVxuICAgICAgICAgICAgICBjb2xvcj1cIndoaXRlXCJcbiAgICAgICAgICAgICAgbWFyZ2luTGVmdD17LTJ9XG4gICAgICAgICAgICAgIGRhbmdlcm91c2x5U2V0SW5saW5lU3R5bGU9e3sgX19zdHlsZTogeyBtYXJnaW5Ub3A6IC02IH0gfX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgPC9Cb3g+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9Cb3g+XG4gICAgKTtcbiAgfVxufVxuIiwiLy8gQGZsb3dcblxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBCb3ggZnJvbSAnLi9Cb3guanMnO1xuaW1wb3J0IEljb24gZnJvbSAnLi9JY29uLmpzJztcbmltcG9ydCBUZXh0IGZyb20gJy4vVGV4dC5qcyc7XG5pbXBvcnQgVG91Y2hhYmxlIGZyb20gJy4vVG91Y2hhYmxlLmpzJztcbmltcG9ydCBWaWRlb1BsYXloZWFkIGZyb20gJy4vVmlkZW9QbGF5aGVhZC5qcyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vVmlkZW8uY3NzJztcblxudHlwZSBQcm9wcyA9IHt8XG4gIGFjY2Vzc2liaWxpdHlNYXhpbWl6ZUxhYmVsOiBzdHJpbmcsXG4gIGFjY2Vzc2liaWxpdHlNaW5pbWl6ZUxhYmVsOiBzdHJpbmcsXG4gIGFjY2Vzc2liaWxpdHlNdXRlTGFiZWw6IHN0cmluZyxcbiAgYWNjZXNzaWJpbGl0eVBhdXNlTGFiZWw6IHN0cmluZyxcbiAgYWNjZXNzaWJpbGl0eVBsYXlMYWJlbDogc3RyaW5nLFxuICBhY2Nlc3NpYmlsaXR5VW5tdXRlTGFiZWw6IHN0cmluZyxcbiAgY3VycmVudFRpbWU6IG51bWJlcixcbiAgZHVyYXRpb246IG51bWJlcixcbiAgZnVsbHNjcmVlbjogYm9vbGVhbixcbiAgb25GdWxsc2NyZWVuQ2hhbmdlOiAoKSA9PiB2b2lkLFxuICBvblBhdXNlOiAoZXZlbnQ6IFN5bnRoZXRpY0V2ZW50PEhUTUxEaXZFbGVtZW50PikgPT4gdm9pZCxcbiAgb25QbGF5OiAoZXZlbnQ6IFN5bnRoZXRpY0V2ZW50PEhUTUxEaXZFbGVtZW50PikgPT4gdm9pZCxcbiAgb25Wb2x1bWVDaGFuZ2U6IChldmVudDogU3ludGhldGljRXZlbnQ8SFRNTERpdkVsZW1lbnQ+KSA9PiB2b2lkLFxuICBwbGF5aW5nOiBib29sZWFuLFxuICBzZWVrOiAodGltZTogbnVtYmVyKSA9PiB2b2lkLFxuICB2b2x1bWU6IG51bWJlcixcbnx9O1xuXG5jb25zdCBmdWxsc2NyZWVuRW5hYmxlZCA9ICgpID0+XG4gIC8vICRGbG93SXNzdWUgLSB2ZW5kb3IgcHJlZml4IG1pc3NpbmcgZnJvbSBGbG93XG4gIGRvY3VtZW50LmZ1bGxzY3JlZW5FbmFibGVkIHx8XG4gIC8vICRGbG93SXNzdWUgLSB2ZW5kb3IgcHJlZml4IG1pc3NpbmcgZnJvbSBGbG93XG4gIGRvY3VtZW50LndlYmtpdEZ1bGxzY3JlZW5FbmFibGVkIHx8XG4gIC8vICRGbG93SXNzdWUgLSB2ZW5kb3IgcHJlZml4IG1pc3NpbmcgZnJvbSBGbG93XG4gIGRvY3VtZW50Lm1vekZ1bGxTY3JlZW5FbmFibGVkIHx8XG4gIC8vICRGbG93SXNzdWUgLSB2ZW5kb3IgcHJlZml4IG1pc3NpbmcgZnJvbSBGbG93XG4gIGRvY3VtZW50Lm1zRnVsbHNjcmVlbkVuYWJsZWQ7XG5cbmNvbnN0IHRpbWVUb1N0cmluZyA9ICh0aW1lPzogbnVtYmVyKSA9PiB7XG4gIGNvbnN0IHJvdW5kZWQgPSBNYXRoLmZsb29yKHRpbWUgfHwgMCk7XG4gIGNvbnN0IG1pbnV0ZXMgPSBNYXRoLmZsb29yKHJvdW5kZWQgLyA2MCk7XG4gIGNvbnN0IHNlY29uZHMgPSByb3VuZGVkIC0gbWludXRlcyAqIDYwO1xuICBjb25zdCBtaW51dGVzU3RyID0gbWludXRlcyA8IDEwID8gYDAke21pbnV0ZXN9YCA6IG1pbnV0ZXM7XG4gIGNvbnN0IHNlY29uZHNTdHIgPSBzZWNvbmRzIDwgMTAgPyBgMCR7c2Vjb25kc31gIDogc2Vjb25kcztcbiAgcmV0dXJuIGAke21pbnV0ZXNTdHJ9OiR7c2Vjb25kc1N0cn1gO1xufTtcblxuY2xhc3MgVmlkZW9Db250cm9scyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxQcm9wcz4ge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIGFjY2Vzc2liaWxpdHlNYXhpbWl6ZUxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgYWNjZXNzaWJpbGl0eU1pbmltaXplTGFiZWw6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBhY2Nlc3NpYmlsaXR5TXV0ZUxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgYWNjZXNzaWJpbGl0eVBhdXNlTGFiZWw6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBhY2Nlc3NpYmlsaXR5UGxheUxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgYWNjZXNzaWJpbGl0eVVubXV0ZUxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgY3VycmVudFRpbWU6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgICBkdXJhdGlvbjogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICAgIGZ1bGxzY3JlZW46IFByb3BUeXBlcy5ib29sLmlzUmVxdWlyZWQsXG4gICAgb25GdWxsc2NyZWVuQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIG9uUGF1c2U6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgb25QbGF5OiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIG9uVm9sdW1lQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIHBsYXlpbmc6IFByb3BUeXBlcy5ib29sLmlzUmVxdWlyZWQsXG4gICAgc2VlazogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICB2b2x1bWU6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgfTtcblxuICBoYW5kbGVGdWxsc2NyZWVuQ2hhbmdlID0gKHtcbiAgICBldmVudCxcbiAgfToge1xuICAgIGV2ZW50OlxuICAgICAgfCBTeW50aGV0aWNNb3VzZUV2ZW50PEhUTUxEaXZFbGVtZW50PlxuICAgICAgfCBTeW50aGV0aWNLZXlib2FyZEV2ZW50PEhUTUxEaXZFbGVtZW50PixcbiAgfSkgPT4ge1xuICAgIGNvbnN0IHsgb25GdWxsc2NyZWVuQ2hhbmdlIH0gPSB0aGlzLnByb3BzO1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIG9uRnVsbHNjcmVlbkNoYW5nZSgpO1xuICB9O1xuXG4gIGhhbmRsZVBsYXlpbmdDaGFuZ2UgPSAoe1xuICAgIGV2ZW50LFxuICB9OiB7XG4gICAgZXZlbnQ6XG4gICAgICB8IFN5bnRoZXRpY01vdXNlRXZlbnQ8SFRNTERpdkVsZW1lbnQ+XG4gICAgICB8IFN5bnRoZXRpY0tleWJvYXJkRXZlbnQ8SFRNTERpdkVsZW1lbnQ+LFxuICB9KSA9PiB7XG4gICAgY29uc3QgeyBwbGF5aW5nLCBvblBhdXNlLCBvblBsYXkgfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKHBsYXlpbmcpIHtcbiAgICAgIG9uUGF1c2UoZXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvblBsYXkoZXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICBoYW5kbGVWb2x1bWVDaGFuZ2UgPSAoe1xuICAgIGV2ZW50LFxuICB9OiB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3Qvbm8tdW51c2VkLXByb3AtdHlwZXMgKi9cbiAgICBldmVudDpcbiAgICAgIHwgU3ludGhldGljTW91c2VFdmVudDxIVE1MRGl2RWxlbWVudD5cbiAgICAgIHwgU3ludGhldGljS2V5Ym9hcmRFdmVudDxIVE1MRGl2RWxlbWVudD4sXG4gICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC9uby11bnVzZWQtcHJvcC10eXBlcyAqL1xuICB9KSA9PiB7XG4gICAgY29uc3QgeyBvblZvbHVtZUNoYW5nZSB9ID0gdGhpcy5wcm9wcztcbiAgICBvblZvbHVtZUNoYW5nZShldmVudCk7XG4gIH07XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGFjY2Vzc2liaWxpdHlNYXhpbWl6ZUxhYmVsLFxuICAgICAgYWNjZXNzaWJpbGl0eU1pbmltaXplTGFiZWwsXG4gICAgICBhY2Nlc3NpYmlsaXR5TXV0ZUxhYmVsLFxuICAgICAgYWNjZXNzaWJpbGl0eVBhdXNlTGFiZWwsXG4gICAgICBhY2Nlc3NpYmlsaXR5UGxheUxhYmVsLFxuICAgICAgYWNjZXNzaWJpbGl0eVVubXV0ZUxhYmVsLFxuICAgICAgY3VycmVudFRpbWUsXG4gICAgICBkdXJhdGlvbixcbiAgICAgIGZ1bGxzY3JlZW4sXG4gICAgICBwbGF5aW5nLFxuICAgICAgc2VlayxcbiAgICAgIHZvbHVtZSxcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBtdXRlZCA9IHZvbHVtZSA9PT0gMDtcbiAgICBjb25zdCBzaG93RnVsbHNjcmVlbkJ1dHRvbiA9XG4gICAgICB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmICEhZnVsbHNjcmVlbkVuYWJsZWQoKTtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5jb250cm9sc30+XG4gICAgICAgIDxCb3ggcGFkZGluZz17Mn0+XG4gICAgICAgICAgPFRvdWNoYWJsZSBvblRvdWNoPXt0aGlzLmhhbmRsZVBsYXlpbmdDaGFuZ2V9IGZ1bGxXaWR0aD17ZmFsc2V9PlxuICAgICAgICAgICAgPEljb25cbiAgICAgICAgICAgICAgYWNjZXNzaWJpbGl0eUxhYmVsPXtcbiAgICAgICAgICAgICAgICBwbGF5aW5nID8gYWNjZXNzaWJpbGl0eVBhdXNlTGFiZWwgOiBhY2Nlc3NpYmlsaXR5UGxheUxhYmVsXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29sb3I9XCJ3aGl0ZVwiXG4gICAgICAgICAgICAgIGljb249e3BsYXlpbmcgPyAncGF1c2UnIDogJ3BsYXknfVxuICAgICAgICAgICAgICBzaXplPXsyMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgPC9Ub3VjaGFibGU+XG4gICAgICAgIDwvQm94PlxuICAgICAgICA8Qm94IHdpZHRoPXs1MH0gcGFkZGluZz17Mn0+XG4gICAgICAgICAgPFRleHQgY29sb3I9XCJ3aGl0ZVwiIGFsaWduPVwicmlnaHRcIiBzaXplPVwieHNcIj5cbiAgICAgICAgICAgIHt0aW1lVG9TdHJpbmcoY3VycmVudFRpbWUpfVxuICAgICAgICAgIDwvVGV4dD5cbiAgICAgICAgPC9Cb3g+XG4gICAgICAgIDxCb3ggcGFkZGluZz17Mn0gZmxleD1cImdyb3dcIj5cbiAgICAgICAgICA8VmlkZW9QbGF5aGVhZFxuICAgICAgICAgICAgY3VycmVudFRpbWU9e2N1cnJlbnRUaW1lfVxuICAgICAgICAgICAgZHVyYXRpb249e2R1cmF0aW9ufVxuICAgICAgICAgICAgc2Vlaz17c2Vla31cbiAgICAgICAgICAvPlxuICAgICAgICA8L0JveD5cbiAgICAgICAgPEJveCB3aWR0aD17NTB9IHBhZGRpbmc9ezJ9PlxuICAgICAgICAgIDxUZXh0IGNvbG9yPVwid2hpdGVcIiBhbGlnbj1cInJpZ2h0XCIgc2l6ZT1cInhzXCI+XG4gICAgICAgICAgICB7dGltZVRvU3RyaW5nKGR1cmF0aW9uKX1cbiAgICAgICAgICA8L1RleHQ+XG4gICAgICAgIDwvQm94PlxuICAgICAgICA8Qm94IHBhZGRpbmc9ezJ9PlxuICAgICAgICAgIDxUb3VjaGFibGUgb25Ub3VjaD17dGhpcy5oYW5kbGVWb2x1bWVDaGFuZ2V9IGZ1bGxXaWR0aD17ZmFsc2V9PlxuICAgICAgICAgICAgPEljb25cbiAgICAgICAgICAgICAgYWNjZXNzaWJpbGl0eUxhYmVsPXtcbiAgICAgICAgICAgICAgICBtdXRlZCA/IGFjY2Vzc2liaWxpdHlVbm11dGVMYWJlbCA6IGFjY2Vzc2liaWxpdHlNdXRlTGFiZWxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb2xvcj1cIndoaXRlXCJcbiAgICAgICAgICAgICAgaWNvbj17bXV0ZWQgPyAnbXV0ZScgOiAnc291bmQnfVxuICAgICAgICAgICAgICBzaXplPXsyMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgPC9Ub3VjaGFibGU+XG4gICAgICAgIDwvQm94PlxuICAgICAgICB7c2hvd0Z1bGxzY3JlZW5CdXR0b24gJiYgKFxuICAgICAgICAgIDxCb3ggcGFkZGluZz17Mn0+XG4gICAgICAgICAgICA8VG91Y2hhYmxlIG9uVG91Y2g9e3RoaXMuaGFuZGxlRnVsbHNjcmVlbkNoYW5nZX0gZnVsbFdpZHRoPXtmYWxzZX0+XG4gICAgICAgICAgICAgIDxJY29uXG4gICAgICAgICAgICAgICAgYWNjZXNzaWJpbGl0eUxhYmVsPXtcbiAgICAgICAgICAgICAgICAgIGZ1bGxzY3JlZW5cbiAgICAgICAgICAgICAgICAgICAgPyBhY2Nlc3NpYmlsaXR5TWluaW1pemVMYWJlbFxuICAgICAgICAgICAgICAgICAgICA6IGFjY2Vzc2liaWxpdHlNYXhpbWl6ZUxhYmVsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbG9yPVwid2hpdGVcIlxuICAgICAgICAgICAgICAgIGljb249e2Z1bGxzY3JlZW4gPyAnbWluaW1pemUnIDogJ21heGltaXplJ31cbiAgICAgICAgICAgICAgICBzaXplPXsyMH1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvVG91Y2hhYmxlPlxuICAgICAgICAgIDwvQm94PlxuICAgICAgICApfVxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBWaWRlb0NvbnRyb2xzO1xuIiwiLy8gQGZsb3dcblxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBWaWRlb0NvbnRyb2xzIGZyb20gJy4vVmlkZW9Db250cm9scy5qcyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vVmlkZW8uY3NzJztcblxudHlwZSBTb3VyY2UgPVxuICB8IHN0cmluZ1xuICB8IEFycmF5PHt8IHR5cGU6ICd2aWRlby9tM3U4JyB8ICd2aWRlby9tcDQnIHwgJ3ZpZGVvL29nZycsIHNyYzogc3RyaW5nIHx9PjtcblxudHlwZSBQcm9wcyA9IHt8XG4gIGFjY2Vzc2liaWxpdHlNYXhpbWl6ZUxhYmVsOiBzdHJpbmcsXG4gIGFjY2Vzc2liaWxpdHlNaW5pbWl6ZUxhYmVsOiBzdHJpbmcsXG4gIGFjY2Vzc2liaWxpdHlNdXRlTGFiZWw6IHN0cmluZyxcbiAgYWNjZXNzaWJpbGl0eVBhdXNlTGFiZWw6IHN0cmluZyxcbiAgYWNjZXNzaWJpbGl0eVBsYXlMYWJlbDogc3RyaW5nLFxuICBhY2Nlc3NpYmlsaXR5VW5tdXRlTGFiZWw6IHN0cmluZyxcbiAgYXNwZWN0UmF0aW86IG51bWJlcixcbiAgY2FwdGlvbnM6IHN0cmluZyxcbiAgY29udHJvbHM/OiBib29sZWFuLFxuICBsb29wPzogYm9vbGVhbixcbiAgb25EdXJhdGlvbkNoYW5nZT86ICh7XG4gICAgZXZlbnQ6IFN5bnRoZXRpY0V2ZW50PEhUTUxWaWRlb0VsZW1lbnQ+LFxuICAgIGR1cmF0aW9uOiBudW1iZXIsXG4gIH0pID0+IHZvaWQsXG4gIG9uRW5kZWQ/OiAoeyBldmVudDogU3ludGhldGljRXZlbnQ8SFRNTFZpZGVvRWxlbWVudD4gfSkgPT4gdm9pZCxcbiAgb25GdWxsc2NyZWVuQ2hhbmdlPzogKHsgZXZlbnQ6IEV2ZW50LCBmdWxsc2NyZWVuOiBib29sZWFuIH0pID0+IHZvaWQsXG4gIG9uTG9hZGVkQ2hhbmdlPzogKHtcbiAgICBldmVudDogU3ludGhldGljRXZlbnQ8SFRNTFZpZGVvRWxlbWVudD4sXG4gICAgbG9hZGVkOiBudW1iZXIsXG4gIH0pID0+IHZvaWQsXG4gIG9uUGxheT86ICh7IGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MRGl2RWxlbWVudD4gfSkgPT4gdm9pZCxcbiAgb25QYXVzZT86ICh7IGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MRGl2RWxlbWVudD4gfSkgPT4gdm9pZCxcbiAgb25SZWFkeT86ICh7IGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MVmlkZW9FbGVtZW50PiB9KSA9PiB2b2lkLFxuICBvblNlZWs/OiAoeyBldmVudDogU3ludGhldGljRXZlbnQ8SFRNTFZpZGVvRWxlbWVudD4gfSkgPT4gdm9pZCxcbiAgb25UaW1lQ2hhbmdlPzogKHtcbiAgICBldmVudDogU3ludGhldGljRXZlbnQ8SFRNTFZpZGVvRWxlbWVudD4sXG4gICAgdGltZTogbnVtYmVyLFxuICB9KSA9PiB2b2lkLFxuICBvblZvbHVtZUNoYW5nZT86ICh7XG4gICAgZXZlbnQ6IFN5bnRoZXRpY0V2ZW50PEhUTUxEaXZFbGVtZW50PixcbiAgICB2b2x1bWU6IG51bWJlcixcbiAgfSkgPT4gdm9pZCxcbiAgcGxheWJhY2tSYXRlOiBudW1iZXIsXG4gIHBsYXlpbmc6IGJvb2xlYW4sXG4gIHBsYXlzSW5saW5lPzogYm9vbGVhbixcbiAgcG9zdGVyPzogc3RyaW5nLFxuICBwcmVsb2FkOiAnYXV0bycgfCAnbWV0YWRhdGEnIHwgJ25vbmUnLFxuICBzcmM6IFNvdXJjZSxcbiAgdm9sdW1lOiBudW1iZXIsXG58fTtcblxudHlwZSBTdGF0ZSA9IHt8XG4gIGN1cnJlbnRUaW1lOiBudW1iZXIsXG4gIGR1cmF0aW9uOiBudW1iZXIsXG4gIGZ1bGxzY3JlZW46IGJvb2xlYW4sXG58fTtcblxuLy8gRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gZnVsbHNjcmVlbiBhbmQgdmVuZG9yIHByZWZpeGVzIHNlZVxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Z1bGxzY3JlZW5fQVBJXG5cbmNvbnN0IHJlcXVlc3RGdWxsc2NyZWVuID0gKGVsZW1lbnQ6IEhUTUxFbGVtZW50KSA9PiB7XG4gIGlmIChlbGVtZW50LnJlcXVlc3RGdWxsc2NyZWVuKSB7XG4gICAgZWxlbWVudC5yZXF1ZXN0RnVsbHNjcmVlbigpO1xuICAgIC8vICRGbG93SXNzdWUgLSB2ZW5kb3IgcHJlZml4IG1pc3NpbmcgZnJvbSBGbG93XG4gIH0gZWxzZSBpZiAoZWxlbWVudC53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbikge1xuICAgIC8vICRGbG93SXNzdWUgLSB2ZW5kb3IgcHJlZml4IG1pc3NpbmcgZnJvbSBGbG93XG4gICAgZWxlbWVudC53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbigpO1xuICAgIC8vICRGbG93SXNzdWUgLSB2ZW5kb3IgcHJlZml4IG1pc3NpbmcgZnJvbSBGbG93XG4gIH0gZWxzZSBpZiAoZWxlbWVudC5tb3pSZXF1ZXN0RnVsbFNjcmVlbikge1xuICAgIC8vICRGbG93SXNzdWUgLSB2ZW5kb3IgcHJlZml4IG1pc3NpbmcgZnJvbSBGbG93XG4gICAgZWxlbWVudC5tb3pSZXF1ZXN0RnVsbFNjcmVlbigpO1xuICAgIC8vICRGbG93SXNzdWUgLSB2ZW5kb3IgcHJlZml4IG1pc3NpbmcgZnJvbSBGbG93XG4gIH0gZWxzZSBpZiAoZWxlbWVudC5tc1JlcXVlc3RGdWxsc2NyZWVuKSB7XG4gICAgLy8gJEZsb3dJc3N1ZSAtIHZlbmRvciBwcmVmaXggbWlzc2luZyBmcm9tIEZsb3dcbiAgICBlbGVtZW50Lm1zUmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgfVxufTtcblxuY29uc3QgZXhpdEZ1bGxzY3JlZW4gPSAoKSA9PiB7XG4gIC8vICRGbG93SXNzdWUgLSB2ZW5kb3IgcHJlZml4IG1pc3NpbmcgZnJvbSBGbG93XG4gIGlmIChkb2N1bWVudC5leGl0RnVsbHNjcmVlbikge1xuICAgIC8vICRGbG93SXNzdWUgLSB2ZW5kb3IgcHJlZml4IG1pc3NpbmcgZnJvbSBGbG93XG4gICAgZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4oKTtcbiAgICAvLyAkRmxvd0lzc3VlIC0gdmVuZG9yIHByZWZpeCBtaXNzaW5nIGZyb20gRmxvd1xuICB9IGVsc2UgaWYgKGRvY3VtZW50LndlYmtpdEV4aXRGdWxsc2NyZWVuKSB7XG4gICAgLy8gJEZsb3dJc3N1ZSAtIHZlbmRvciBwcmVmaXggbWlzc2luZyBmcm9tIEZsb3dcbiAgICBkb2N1bWVudC53ZWJraXRFeGl0RnVsbHNjcmVlbigpO1xuICAgIC8vICRGbG93SXNzdWUgLSB2ZW5kb3IgcHJlZml4IG1pc3NpbmcgZnJvbSBGbG93XG4gIH0gZWxzZSBpZiAoZG9jdW1lbnQubW96Q2FuY2VsRnVsbFNjcmVlbikge1xuICAgIC8vICRGbG93SXNzdWUgLSB2ZW5kb3IgcHJlZml4IG1pc3NpbmcgZnJvbSBGbG93XG4gICAgZG9jdW1lbnQubW96Q2FuY2VsRnVsbFNjcmVlbigpO1xuICAgIC8vICRGbG93SXNzdWUgLSB2ZW5kb3IgcHJlZml4IG1pc3NpbmcgZnJvbSBGbG93XG4gIH0gZWxzZSBpZiAoZG9jdW1lbnQubXNFeGl0RnVsbHNjcmVlbikge1xuICAgIC8vICRGbG93SXNzdWUgLSB2ZW5kb3IgcHJlZml4IG1pc3NpbmcgZnJvbSBGbG93XG4gICAgZG9jdW1lbnQubXNFeGl0RnVsbHNjcmVlbigpO1xuICB9XG59O1xuXG4vLyBOb3JtYWxseSBkb2N1bWVudC5mdWxsc2NyZWVuIHN1ZmZpY2VzIGhlcmUgYXMgYSBmbGFnLCBidXQgSUUxMSBkb2VzIG5vdFxuLy8gaGF2ZSBhIHZlbmRvciBzcGVjaWZpYyB2ZXJzaW9uIHNvIHdlIG11c3QgaW5zdGVhZCB1c2UgdGhlIGFjdHVhbCBlbGVtZW50XG5jb25zdCBpc0Z1bGxzY3JlZW4gPSAoKSA9PlxuICAvLyAkRmxvd0lzc3VlIC0gdmVuZG9yIHByZWZpeCBtaXNzaW5nIGZyb20gRmxvd1xuICBkb2N1bWVudC5mdWxsc2NyZWVuRWxlbWVudCB8fFxuICAvLyAkRmxvd0lzc3VlIC0gdmVuZG9yIHByZWZpeCBtaXNzaW5nIGZyb20gRmxvd1xuICBkb2N1bWVudC53ZWJraXRGdWxsc2NyZWVuRWxlbWVudCB8fFxuICAvLyAkRmxvd0lzc3VlIC0gdmVuZG9yIHByZWZpeCBtaXNzaW5nIGZyb20gRmxvd1xuICBkb2N1bWVudC5tb3pGdWxsU2NyZWVuRWxlbWVudCB8fFxuICAvLyAkRmxvd0lzc3VlIC0gdmVuZG9yIHByZWZpeCBtaXNzaW5nIGZyb20gRmxvd1xuICBkb2N1bWVudC5tc0Z1bGxzY3JlZW5FbGVtZW50O1xuXG5jb25zdCBhZGRGdWxsc2NyZWVuRXZlbnRMaXN0ZW5lciA9IChsaXN0ZW5lcjogRXZlbnRMaXN0ZW5lcikgPT4ge1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdmdWxsc2NyZWVuY2hhbmdlJywgbGlzdGVuZXIpO1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd3ZWJraXRmdWxsc2NyZWVuY2hhbmdlJywgbGlzdGVuZXIpO1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3pmdWxsc2NyZWVuY2hhbmdlJywgbGlzdGVuZXIpO1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdNU0Z1bGxzY3JlZW5DaGFuZ2UnLCBsaXN0ZW5lcik7XG59O1xuXG5jb25zdCByZW1vdmVGdWxsc2NyZWVuRXZlbnRMaXN0ZW5lciA9IChsaXN0ZW5lcjogRXZlbnRMaXN0ZW5lcikgPT4ge1xuICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdmdWxsc2NyZWVuY2hhbmdlJywgbGlzdGVuZXIpO1xuICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd3ZWJraXRmdWxsc2NyZWVuY2hhbmdlJywgbGlzdGVuZXIpO1xuICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3pmdWxsc2NyZWVuY2hhbmdlJywgbGlzdGVuZXIpO1xuICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdNU0Z1bGxzY3JlZW5DaGFuZ2UnLCBsaXN0ZW5lcik7XG59O1xuXG5jb25zdCBpc05ld1NvdXJjZSA9IChvbGRTb3VyY2U6IFNvdXJjZSwgbmV3U291cmNlOiBTb3VyY2UpOiBib29sZWFuID0+IHtcbiAgaWYgKHR5cGVvZiBvbGRTb3VyY2UgIT09IHR5cGVvZiBuZXdTb3VyY2UpIHtcbiAgICAvLyBJZiB0aGUgc291cmNlIHR5cGUgY2hhbmdlZCBmcm9tIHN0cmluZyB0byBBcnJheVxuICAgIC8vIG9yIHZpY2UgdmVyc2EsIHdlIGhhdmUgYSBuZXcgc291cmNlXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkobmV3U291cmNlKSkge1xuICAgIGlmIChvbGRTb3VyY2UubGVuZ3RoICE9PSBuZXdTb3VyY2UubGVuZ3RoKSB7XG4gICAgICAvLyBJZiB0aGUgc291cmNlcyBhcmUgYm90aCBhbiBBcnJheSwgYW5kIHRoZSBsZW5ndGhzXG4gICAgICAvLyBkbyBub3QgbWF0Y2ggd2UgZXZhbHVhdGUgYXMgYSBuZXcgc291cmNlXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gSWYgdGhlIHNvdXJjZXMgYXJlIGJvdGggYW4gQXJyYXkgYW5kIHRoZSBzYW1lIGxlbmd0aCxcbiAgICAvLyB2ZXJpZnkgZXZlcnkgZWxlbWVudCBzdGF5ZWQgdGhlIHNhbWVcbiAgICByZXR1cm4gbmV3U291cmNlLnNvbWUoXG4gICAgICAoc291cmNlLCBpbmRleCkgPT5cbiAgICAgICAgIUFycmF5LmlzQXJyYXkob2xkU291cmNlKSB8fFxuICAgICAgICBzb3VyY2UudHlwZSAhPT0gb2xkU291cmNlW2luZGV4XS50eXBlIHx8XG4gICAgICAgIHNvdXJjZS5zcmMgIT09IG9sZFNvdXJjZVtpbmRleF0uc3JjXG4gICAgKTtcbiAgfVxuICAvLyBJZiB0aGUgc291cmNlcyBhcmUgYm90aCBhIHN0cmluZywgc2ltcGx5IGNvbXBhcmVcbiAgLy8gdGhlIG5ldyB3aXRoIHRoZSBvbGRcbiAgcmV0dXJuIG5ld1NvdXJjZSAhPT0gb2xkU291cmNlO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmlkZW8gZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50PFByb3BzLCBTdGF0ZT4ge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIGFjY2Vzc2liaWxpdHlNYXhpbWl6ZUxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIGFjY2Vzc2liaWxpdHlNaW5pbWl6ZUxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIGFjY2Vzc2liaWxpdHlNdXRlTGFiZWw6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgYWNjZXNzaWJpbGl0eVBhdXNlTGFiZWw6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgYWNjZXNzaWJpbGl0eVBsYXlMYWJlbDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBhY2Nlc3NpYmlsaXR5VW5tdXRlTGFiZWw6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgYXNwZWN0UmF0aW86IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgICBjYXB0aW9uczogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIGNvbnRyb2xzOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBsb29wOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBvbkR1cmF0aW9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkVuZGVkOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkZ1bGxzY3JlZW5DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uTG9hZGVkQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvblBsYXk6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uUGF1c2U6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uUmVhZHk6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uU2VlazogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25UaW1lQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvblZvbHVtZUNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgcGxheWJhY2tSYXRlOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIHBsYXlpbmc6IFByb3BUeXBlcy5ib29sLFxuICAgIHBsYXlzSW5saW5lOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBwb3N0ZXI6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgcHJlbG9hZDogUHJvcFR5cGVzLm9uZU9mKFsnYXV0bycsICdtZXRhZGF0YScsICdub25lJ10pLFxuICAgIHNyYzogUHJvcFR5cGVzLm9uZU9mVHlwZShbXG4gICAgICBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgUHJvcFR5cGVzLmFycmF5T2YoXG4gICAgICAgIFByb3BUeXBlcy5zaGFwZSh7XG4gICAgICAgICAgdHlwZTogUHJvcFR5cGVzLm9uZU9mKFsndmlkZW8vbTN1OCcsICd2aWRlby9tcDQnLCAndmlkZW8vb2dnJ10pXG4gICAgICAgICAgICAuaXNSZXF1aXJlZCxcbiAgICAgICAgICBzcmM6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICAgICAgfSlcbiAgICAgICksXG4gICAgXSkuaXNSZXF1aXJlZCxcbiAgICB2b2x1bWU6IFByb3BUeXBlcy5udW1iZXIsXG4gIH07XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICBwbGF5YmFja1JhdGU6IDEsXG4gICAgcGxheWluZzogZmFsc2UsXG4gICAgcHJlbG9hZDogJ2F1dG8nLFxuICAgIHZvbHVtZTogMSxcbiAgfTtcblxuICBzdGF0ZSA9IHtcbiAgICBjdXJyZW50VGltZTogMCxcbiAgICBkdXJhdGlvbjogMCxcbiAgICBmdWxsc2NyZWVuOiBmYWxzZSxcbiAgfTtcblxuICAvKipcbiAgICogUmVhY3QgbGlmZWN5Y2xlIGhvb2tzIHBlcnRpbmVudCB0byBWaWRlb1xuICAgKi9cblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBjb25zdCB7IHBsYXliYWNrUmF0ZSwgcGxheWluZywgdm9sdW1lIH0gPSB0aGlzLnByb3BzO1xuICAgIC8vIFNldCB1cCBldmVudCBsaXN0ZW5lcnMgdG8gY2F0Y2ggYmFja2Rvb3JzIGluIGZ1bGxzY3JlZW5cbiAgICAvLyBjaGFuZ2VzIHN1Y2ggYXMgdXNpbmcgdGhlIEVTQyBrZXkgdG8gZXhpdFxuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBhZGRGdWxsc2NyZWVuRXZlbnRMaXN0ZW5lcih0aGlzLmhhbmRsZUZ1bGxzY3JlZW5DaGFuZ2UpO1xuICAgIH1cbiAgICAvLyBMb2FkIHRoZSB2aWRlbyB0byBoeWRyYXRlIHRoZSBET00gYWZ0ZXIgYSBzZXJ2ZXIgcmVuZGVyXG4gICAgdGhpcy5sb2FkKCk7XG4gICAgLy8gU2V0IHRoZSBpbml0aWFsIHZvbHVtZVxuICAgIHRoaXMuc2V0Vm9sdW1lKHZvbHVtZSk7XG4gICAgLy8gU2V0IHRoZSBpbml0aWFsIHBsYXliYWNrIHJhdGVcbiAgICB0aGlzLnNldFBsYXliYWNrUmF0ZShwbGF5YmFja1JhdGUpO1xuICAgIC8vIFNpbXVsYXRlIGFuIGF1dG9wbGF5IGVmZmVjdCBpZiB0aGUgY29tcG9uZW50XG4gICAgaWYgKHBsYXlpbmcpIHtcbiAgICAgIHRoaXMucGxheSgpO1xuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHM6IFByb3BzKSB7XG4gICAgLy8gSWYgdGhlIHZpZGVvIHNvdXJjZSBjaGFuZ2VkLCByZWxvYWQgdGhlIHZpZGVvXG4gICAgaWYgKGlzTmV3U291cmNlKHByZXZQcm9wcy5zcmMsIHRoaXMucHJvcHMuc3JjKSkge1xuICAgICAgdGhpcy5sb2FkKCk7XG4gICAgfVxuICAgIC8vIElmIHRoZSB2b2x1bWUgY2hhbmdlZCwgc2V0IHRoZSBuZXcgdm9sdW1lXG4gICAgaWYgKHByZXZQcm9wcy52b2x1bWUgIT09IHRoaXMucHJvcHMudm9sdW1lKSB7XG4gICAgICB0aGlzLnNldFZvbHVtZSh0aGlzLnByb3BzLnZvbHVtZSk7XG4gICAgfVxuICAgIC8vIElmIHRoZSBwbGF5YmFjayByYXRlIGNoYW5nZWQsIHNldCB0aGUgbmV3IHJhdGVcbiAgICBpZiAocHJldlByb3BzLnBsYXliYWNrUmF0ZSAhPT0gdGhpcy5wcm9wcy5wbGF5YmFja1JhdGUpIHtcbiAgICAgIHRoaXMuc2V0UGxheWJhY2tSYXRlKHRoaXMucHJvcHMucGxheWJhY2tSYXRlKTtcbiAgICB9XG4gICAgLy8gSWYgdGhlIHBsYXliYWNrIGNoYW5nZWQsIHBsYXkgb3IgcGF1c2UgdGhlIHZpZGVvXG4gICAgaWYgKHByZXZQcm9wcy5wbGF5aW5nICE9PSB0aGlzLnByb3BzLnBsYXlpbmcpIHtcbiAgICAgIGlmICh0aGlzLnByb3BzLnBsYXlpbmcpIHtcbiAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgcmVtb3ZlRnVsbHNjcmVlbkV2ZW50TGlzdGVuZXIodGhpcy5oYW5kbGVGdWxsc2NyZWVuQ2hhbmdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBET00gcmVmZXJlbmNlIGhvdXNla2VlcGluZyB0aGF0IGlzIG5lZWRlZCBmb3IgZnVuY3Rpb25hbGl0eVxuICAgKi9cblxuICAvLyBUaGUgcGxheWVyIGVsZW1lbnQgZW5jYXBzdWxhdGVzIHRoZSBhY3R1YWwgdmlkZW8gRE9NXG4gIC8vIGVsZW1lbnQgYXMgd2VsbCBhcyB0aGUgY29udHJvbHMgdG8gYnJpbmcgYm90aCBmdWxsc2NyZWVuXG4gIHNldFBsYXllclJlZiA9IChyZWY6ID9IVE1MRGl2RWxlbWVudCkgPT4ge1xuICAgIHRoaXMucGxheWVyID0gcmVmO1xuICB9O1xuXG4gIC8vIFRoZSBhY3R1YWwgcmVmZXJlbmNlIHRvIHRoZSB2aWRlbyBIVE1MIERPTSBlbGVtZW50XG4gIHNldFZpZGVvUmVmID0gKHJlZjogP0hUTUxWaWRlb0VsZW1lbnQpID0+IHtcbiAgICB0aGlzLnZpZGVvID0gcmVmO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGdW5jdGlvbnMgdGhhdCBkaXJlY3RseSBpbnRlcmFjdCB3aXRoIHRoZSBIVE1MIHZpZGVvIGVsZW1lbnRcbiAgICovXG5cbiAgLy8gU2V0IHRoZSB2aWRlbyB0byB0aGUgZGVzaXJlZCBwbGF5YmFjayByYXRlOiAxIChub3JtYWwpXG4gIHNldFBsYXliYWNrUmF0ZSA9IChwbGF5YmFja1JhdGU6IG51bWJlcikgPT4ge1xuICAgIGlmICh0aGlzLnZpZGVvKSB7XG4gICAgICB0aGlzLnZpZGVvLnBsYXliYWNrUmF0ZSA9IHBsYXliYWNrUmF0ZTtcbiAgICB9XG4gIH07XG5cbiAgLy8gU2V0IHRoZSB2aWRlbyB0byB0aGUgZGVzaXJlZCB2b2x1bWU6IDAgKG11dGVkKSAtPiAxIChtYXgpXG4gIHNldFZvbHVtZSA9ICh2b2x1bWU6IG51bWJlcikgPT4ge1xuICAgIGlmICh0aGlzLnZpZGVvKSB7XG4gICAgICB0aGlzLnZpZGVvLnZvbHVtZSA9IHZvbHVtZTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQ2hhbmdlIHRoZSB2aWRlbyBzb3VyY2UgYW5kIHJlLWxvYWQgdGhlIHZpZGVvXG4gIGxvYWQgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMudmlkZW8pIHtcbiAgICAgIHRoaXMudmlkZW8ubG9hZCgpO1xuICAgIH1cbiAgfTtcblxuICAvLyBQYXVzZSB0aGUgdmlkZW9cbiAgcGF1c2UgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMudmlkZW8pIHtcbiAgICAgIHRoaXMudmlkZW8ucGF1c2UoKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gUGxheSB0aGUgdmlkZW9cbiAgcGxheSA9ICgpID0+IHtcbiAgICBpZiAodGhpcy52aWRlbykge1xuICAgICAgdGhpcy52aWRlby5wbGF5KCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFNlZWsgdGhlIHZpZGVvIHRvIHRoZSBkZXNpcmVkIHRpbWVcbiAgc2VlayA9ICh0aW1lOiBudW1iZXIpID0+IHtcbiAgICBpZiAodGhpcy52aWRlbykge1xuICAgICAgdGhpcy52aWRlby5jdXJyZW50VGltZSA9IHRpbWU7XG4gICAgfVxuICB9O1xuXG4gIC8vIEVudGVyL2V4aXQgZnVsbHNjcmVlbiB2aWRlbyBwbGF5ZXIgbW9kZVxuICB0b2dnbGVGdWxsc2NyZWVuID0gKCkgPT4ge1xuICAgIGlmIChpc0Z1bGxzY3JlZW4oKSkge1xuICAgICAgZXhpdEZ1bGxzY3JlZW4oKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucGxheWVyKSB7XG4gICAgICByZXF1ZXN0RnVsbHNjcmVlbih0aGlzLnBsYXllcik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGVycyBmb3IgdmFyaW91cyBtZWRpYSBldmVudHMgb24gdGhlIHZpZGVvXG4gICAqL1xuXG4gIC8vIFNlbnQgd2hlbiBlbm91Z2ggZGF0YSBpcyBhdmFpbGFibGUgdGhhdCB0aGUgbWVkaWEgY2FuIGJlIHBsYXllZFxuICBoYW5kbGVDYW5QbGF5ID0gKGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MVmlkZW9FbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IHsgb25SZWFkeSB9ID0gdGhpcy5wcm9wcztcblxuICAgIGlmIChvblJlYWR5KSB7XG4gICAgICBvblJlYWR5KHsgZXZlbnQgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFRoZSBtZXRhZGF0YSBoYXMgbG9hZGVkIG9yIGNoYW5nZWQsIGluZGljYXRpbmcgYSBjaGFuZ2UgaW5cbiAgLy8gZHVyYXRpb24gb2YgdGhlIG1lZGlhXG4gIGhhbmRsZUR1cmF0aW9uQ2hhbmdlID0gKGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MVmlkZW9FbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IHsgb25EdXJhdGlvbkNoYW5nZSB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBkdXJhdGlvbiA9ICh0aGlzLnZpZGVvICYmIHRoaXMudmlkZW8uZHVyYXRpb24pIHx8IDA7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGR1cmF0aW9uIH0pO1xuXG4gICAgaWYgKG9uRHVyYXRpb25DaGFuZ2UpIHtcbiAgICAgIG9uRHVyYXRpb25DaGFuZ2UoeyBldmVudCwgZHVyYXRpb24gfSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFNlbnQgd2hlbiBwbGF5YmFjayBjb21wbGV0ZXMuXG4gIGhhbmRsZUVuZGVkID0gKGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MVmlkZW9FbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IHsgb25FbmRlZCB9ID0gdGhpcy5wcm9wcztcblxuICAgIGlmIChvbkVuZGVkKSB7XG4gICAgICBvbkVuZGVkKHsgZXZlbnQgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFNlbnQgd2hlbiB0aGUgdmlkZW8gaXMgc3dpdGNoZWQgdG8vb3V0LW9mIGZ1bGxzY3JlZW4gbW9kZVxuICBoYW5kbGVGdWxsc2NyZWVuQ2hhbmdlID0gKGV2ZW50OiBFdmVudCkgPT4ge1xuICAgIGNvbnN0IHsgb25GdWxsc2NyZWVuQ2hhbmdlIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGZ1bGxzY3JlZW4gPSAhIWlzRnVsbHNjcmVlbigpO1xuICAgIHRoaXMuc2V0U3RhdGUoeyBmdWxsc2NyZWVuIH0pO1xuXG4gICAgaWYgKG9uRnVsbHNjcmVlbkNoYW5nZSkge1xuICAgICAgb25GdWxsc2NyZWVuQ2hhbmdlKHsgZXZlbnQsIGZ1bGxzY3JlZW4gfSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFNlbnQgd2hlbiBwbGF5YmFjayBvZiB0aGUgbWVkaWEgc3RhcnRzIGFmdGVyIGhhdmluZyBiZWVuIHBhdXNlZC5cbiAgaGFuZGxlUGxheSA9IChldmVudDogU3ludGhldGljRXZlbnQ8SFRNTERpdkVsZW1lbnQ+KSA9PiB7XG4gICAgY29uc3QgeyBvblBsYXkgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBpZiAob25QbGF5KSB7XG4gICAgICBvblBsYXkoeyBldmVudCB9KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gU2VudCB3aGVuIHBsYXliYWNrIGlzIHBhdXNlZC5cbiAgaGFuZGxlUGF1c2UgPSAoZXZlbnQ6IFN5bnRoZXRpY0V2ZW50PEhUTUxEaXZFbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IHsgb25QYXVzZSB9ID0gdGhpcy5wcm9wcztcblxuICAgIGlmIChvblBhdXNlKSB7XG4gICAgICBvblBhdXNlKHsgZXZlbnQgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFNlbnQgcGVyaW9kaWNhbGx5IHRvIGluZm9ybSBpbnRlcmVzdGVkIHBhcnRpZXMgb2YgcHJvZ3Jlc3MgZG93bmxvYWRpbmcgdGhlIG1lZGlhXG4gIGhhbmRsZVByb2dyZXNzID0gKGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MVmlkZW9FbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IHsgb25Mb2FkZWRDaGFuZ2UgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgeyBidWZmZXJlZCB9ID0gdGhpcy52aWRlbyB8fCB7fTtcbiAgICBjb25zdCBsb2FkZWQgPVxuICAgICAgYnVmZmVyZWQgJiYgYnVmZmVyZWQubGVuZ3RoID4gMCA/IGJ1ZmZlcmVkLmVuZChidWZmZXJlZC5sZW5ndGggLSAxKSA6IDA7XG5cbiAgICBpZiAob25Mb2FkZWRDaGFuZ2UpIHtcbiAgICAgIG9uTG9hZGVkQ2hhbmdlKHsgZXZlbnQsIGxvYWRlZCB9KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gU2VudCB3aGVuIGEgc2VlayBvcGVyYXRpb24gY29tcGxldGVzLlxuICBoYW5kbGVTZWVrID0gKGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MVmlkZW9FbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IHsgb25TZWVrIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgaWYgKG9uU2Vlaykge1xuICAgICAgb25TZWVrKHsgZXZlbnQgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFRoZSB0aW1lIGluZGljYXRlZCBieSB0aGUgZWxlbWVudCdzIGN1cnJlbnRUaW1lIGF0dHJpYnV0ZSBoYXMgY2hhbmdlZFxuICBoYW5kbGVUaW1lVXBkYXRlID0gKGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MVmlkZW9FbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IHsgb25UaW1lQ2hhbmdlIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gKHRoaXMudmlkZW8gJiYgdGhpcy52aWRlby5jdXJyZW50VGltZSkgfHwgMDtcbiAgICB0aGlzLnNldFN0YXRlKHsgY3VycmVudFRpbWUgfSk7XG5cbiAgICBpZiAob25UaW1lQ2hhbmdlKSB7XG4gICAgICBvblRpbWVDaGFuZ2UoeyBldmVudCwgdGltZTogY3VycmVudFRpbWUgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFNlbnQgd2hlbiB0aGUgYXVkaW8gdm9sdW1lIGNoYW5nZXNcbiAgaGFuZGxlVm9sdW1lQ2hhbmdlID0gKGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MRGl2RWxlbWVudD4pID0+IHtcbiAgICBjb25zdCB7IG9uVm9sdW1lQ2hhbmdlIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IG11dGVkID0gKHRoaXMudmlkZW8gJiYgdGhpcy52aWRlby5tdXRlZCkgfHwgZmFsc2U7XG5cbiAgICBpZiAob25Wb2x1bWVDaGFuZ2UpIHtcbiAgICAgIG9uVm9sdW1lQ2hhbmdlKHsgZXZlbnQsIHZvbHVtZTogbXV0ZWQgPyAxIDogMCB9KTtcbiAgICB9XG4gIH07XG5cbiAgdmlkZW86ID9IVE1MVmlkZW9FbGVtZW50O1xuXG4gIHBsYXllcjogP0hUTUxEaXZFbGVtZW50O1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBhc3BlY3RSYXRpbyxcbiAgICAgIGNhcHRpb25zLFxuICAgICAgbG9vcCxcbiAgICAgIHBsYXlpbmcsXG4gICAgICBwbGF5c0lubGluZSxcbiAgICAgIHBvc3RlcixcbiAgICAgIHByZWxvYWQsXG4gICAgICBzcmMsXG4gICAgICB2b2x1bWUsXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgeyBjdXJyZW50VGltZSwgZHVyYXRpb24sIGZ1bGxzY3JlZW4gfSA9IHRoaXMuc3RhdGU7XG5cbiAgICBjb25zdCBwYWRkaW5nQm90dG9tID0gKGZ1bGxzY3JlZW4gJiYgJzAnKSB8fCBgJHsoMSAvIGFzcGVjdFJhdGlvKSAqIDEwMH0lYDtcblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2XG4gICAgICAgIHJlZj17dGhpcy5zZXRQbGF5ZXJSZWZ9XG4gICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLnBsYXllcn1cbiAgICAgICAgc3R5bGU9e3sgcGFkZGluZ0JvdHRvbSwgaGVpZ2h0OiBmdWxsc2NyZWVuID8gJzEwMCUnIDogMCB9fVxuICAgICAgPlxuICAgICAgICA8dmlkZW9cbiAgICAgICAgICBhdXRvUGxheT17cGxheWluZ31cbiAgICAgICAgICBsb29wPXtsb29wfVxuICAgICAgICAgIG11dGVkPXt2b2x1bWUgPT09IDB9XG4gICAgICAgICAgcGxheXNJbmxpbmU9e3BsYXlzSW5saW5lfVxuICAgICAgICAgIHBvc3Rlcj17cG9zdGVyfVxuICAgICAgICAgIHByZWxvYWQ9e3ByZWxvYWR9XG4gICAgICAgICAgc3JjPXt0eXBlb2Ygc3JjID09PSAnc3RyaW5nJyA/IHNyYyA6IHVuZGVmaW5lZH1cbiAgICAgICAgICByZWY9e3RoaXMuc2V0VmlkZW9SZWZ9XG4gICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMudmlkZW99XG4gICAgICAgICAgb25DYW5QbGF5PXt0aGlzLmhhbmRsZUNhblBsYXl9XG4gICAgICAgICAgb25EdXJhdGlvbkNoYW5nZT17dGhpcy5oYW5kbGVEdXJhdGlvbkNoYW5nZX1cbiAgICAgICAgICBvbkVuZGVkPXt0aGlzLmhhbmRsZUVuZGVkfVxuICAgICAgICAgIG9uU2Vla2VkPXt0aGlzLmhhbmRsZVNlZWt9XG4gICAgICAgICAgb25UaW1lVXBkYXRlPXt0aGlzLmhhbmRsZVRpbWVVcGRhdGV9XG4gICAgICAgICAgb25Qcm9ncmVzcz17dGhpcy5oYW5kbGVQcm9ncmVzc31cbiAgICAgICAgPlxuICAgICAgICAgIHtBcnJheS5pc0FycmF5KHNyYykgJiZcbiAgICAgICAgICAgIHNyYy5tYXAoc291cmNlID0+IChcbiAgICAgICAgICAgICAgPHNvdXJjZSBrZXk9e3NvdXJjZS5zcmN9IHNyYz17c291cmNlLnNyY30gdHlwZT17c291cmNlLnR5cGV9IC8+XG4gICAgICAgICAgICApKX1cbiAgICAgICAgICA8dHJhY2sga2luZD1cImNhcHRpb25zXCIgc3JjPXtjYXB0aW9uc30gLz5cbiAgICAgICAgPC92aWRlbz5cbiAgICAgICAgey8qIE5lZWQgdG8gdXNlIGZ1bGwgcGF0aCBmb3IgdGhlc2UgcHJvcHMgc28gRmxvdyBjYW4gaW5mZXIgY29ycmVjdCBzdWJ0eXBlICovfVxuICAgICAgICB7dGhpcy5wcm9wcy5jb250cm9scyAmJiAoXG4gICAgICAgICAgPFZpZGVvQ29udHJvbHNcbiAgICAgICAgICAgIGFjY2Vzc2liaWxpdHlNYXhpbWl6ZUxhYmVsPXt0aGlzLnByb3BzLmFjY2Vzc2liaWxpdHlNYXhpbWl6ZUxhYmVsfVxuICAgICAgICAgICAgYWNjZXNzaWJpbGl0eU1pbmltaXplTGFiZWw9e3RoaXMucHJvcHMuYWNjZXNzaWJpbGl0eU1pbmltaXplTGFiZWx9XG4gICAgICAgICAgICBhY2Nlc3NpYmlsaXR5TXV0ZUxhYmVsPXt0aGlzLnByb3BzLmFjY2Vzc2liaWxpdHlNdXRlTGFiZWx9XG4gICAgICAgICAgICBhY2Nlc3NpYmlsaXR5UGF1c2VMYWJlbD17dGhpcy5wcm9wcy5hY2Nlc3NpYmlsaXR5UGF1c2VMYWJlbH1cbiAgICAgICAgICAgIGFjY2Vzc2liaWxpdHlQbGF5TGFiZWw9e3RoaXMucHJvcHMuYWNjZXNzaWJpbGl0eVBsYXlMYWJlbH1cbiAgICAgICAgICAgIGFjY2Vzc2liaWxpdHlVbm11dGVMYWJlbD17dGhpcy5wcm9wcy5hY2Nlc3NpYmlsaXR5VW5tdXRlTGFiZWx9XG4gICAgICAgICAgICBjdXJyZW50VGltZT17Y3VycmVudFRpbWV9XG4gICAgICAgICAgICBkdXJhdGlvbj17ZHVyYXRpb259XG4gICAgICAgICAgICBmdWxsc2NyZWVuPXtmdWxsc2NyZWVufVxuICAgICAgICAgICAgb25QbGF5PXt0aGlzLmhhbmRsZVBsYXl9XG4gICAgICAgICAgICBvblBhdXNlPXt0aGlzLmhhbmRsZVBhdXNlfVxuICAgICAgICAgICAgb25GdWxsc2NyZWVuQ2hhbmdlPXt0aGlzLnRvZ2dsZUZ1bGxzY3JlZW59XG4gICAgICAgICAgICBvblZvbHVtZUNoYW5nZT17dGhpcy5oYW5kbGVWb2x1bWVDaGFuZ2V9XG4gICAgICAgICAgICBwbGF5aW5nPXtwbGF5aW5nfVxuICAgICAgICAgICAgc2Vlaz17dGhpcy5zZWVrfVxuICAgICAgICAgICAgdm9sdW1lPXt2b2x1bWV9XG4gICAgICAgICAgLz5cbiAgICAgICAgKX1cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJpZGVudGl0eSIsIlNldCIsImZyb21DbGFzc05hbWUiLCJjbGFzc05hbWVzIiwiZnJvbUlubGluZVN0eWxlIiwiaW5saW5lU3R5bGUiLCJjb25jYXQiLCJzdHlsZXMiLCJyZWR1Y2UiLCJjbGFzc05hbWVBIiwiY2xhc3NOYW1lIiwiaW5saW5lU3R5bGVBIiwiY2xhc3NOYW1lQiIsImlubGluZVN0eWxlQiIsIm1hcENsYXNzTmFtZSIsImZuIiwiQXJyYXkiLCJmcm9tIiwibWFwIiwidG9Qcm9wcyIsInByb3BzIiwic2l6ZSIsInNvcnQiLCJqb2luIiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsInN0eWxlIiwidG9nZ2xlIiwidmFsIiwibWFwcGluZyIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsInJhbmdlIiwic2NhbGUiLCJuIiwiTWF0aCIsImFicyIsInJhbmdlV2l0aG91dFplcm8iLCJiaW5kIiwic2NvcGUiLCJuYW1lIiwidW5pb24iLCJmbnMiLCJtYXJnaW5TdGFydCIsIndoaXRlc3BhY2UiLCJtYXJnaW5FbmQiLCJtYXJnaW5Ub3AiLCJtYXJnaW5SaWdodCIsIm1hcmdpbkJvdHRvbSIsIm1hcmdpbkxlZnQiLCJtYXJnaW4iLCJzbU1hcmdpblRvcCIsInNtTWFyZ2luUmlnaHQiLCJzbU1hcmdpbkJvdHRvbSIsInNtTWFyZ2luTGVmdCIsInNtTWFyZ2luIiwibWRNYXJnaW5Ub3AiLCJtZE1hcmdpblJpZ2h0IiwibWRNYXJnaW5Cb3R0b20iLCJtZE1hcmdpbkxlZnQiLCJtZE1hcmdpbiIsImxnTWFyZ2luVG9wIiwibGdNYXJnaW5SaWdodCIsImxnTWFyZ2luQm90dG9tIiwibGdNYXJnaW5MZWZ0IiwibGdNYXJnaW4iLCJwYWRkaW5nWCIsInBhZGRpbmdZIiwicGFkZGluZyIsInNtUGFkZGluZ1giLCJzbVBhZGRpbmdZIiwic21QYWRkaW5nIiwibWRQYWRkaW5nWCIsIm1kUGFkZGluZ1kiLCJtZFBhZGRpbmciLCJsZ1BhZGRpbmdYIiwibGdQYWRkaW5nWSIsImxnUGFkZGluZyIsInByZWZpeCIsInByZSIsImRpc3BsYXkiLCJ2YWx1ZSIsImNvbHVtbiIsImZvcm1hdEludEJvaW50IiwieCIsInRvU3RyaW5nIiwicHJvcFRvRm4iLCJjIiwieHNEaXNwbGF5Tm9uZSIsInhzRGlzcGxheUZsZXgiLCJ4c0Rpc3BsYXlCbG9jayIsInhzRGlzcGxheUlubGluZUJsb2NrIiwieHNEaXNwbGF5VmlzdWFsbHlIaWRkZW4iLCJ4c0RpcmVjdGlvblJvdyIsInhzRGlyZWN0aW9uQ29sdW1uIiwic21EaXNwbGF5Tm9uZSIsInNtRGlzcGxheUZsZXgiLCJzbURpc3BsYXlCbG9jayIsInNtRGlzcGxheUlubGluZUJsb2NrIiwic21EaXNwbGF5VmlzdWFsbHlIaWRkZW4iLCJzbURpcmVjdGlvblJvdyIsInNtRGlyZWN0aW9uQ29sdW1uIiwibWREaXNwbGF5Tm9uZSIsIm1kRGlzcGxheUZsZXgiLCJtZERpc3BsYXlCbG9jayIsIm1kRGlzcGxheUlubGluZUJsb2NrIiwibWREaXNwbGF5VmlzdWFsbHlIaWRkZW4iLCJtZERpcmVjdGlvblJvdyIsIm1kRGlyZWN0aW9uQ29sdW1uIiwibGdEaXNwbGF5Tm9uZSIsImxnRGlzcGxheUZsZXgiLCJsZ0Rpc3BsYXlCbG9jayIsImxnRGlzcGxheUlubGluZUJsb2NrIiwibGdEaXNwbGF5VmlzdWFsbHlIaWRkZW4iLCJsZ0RpcmVjdGlvblJvdyIsImxnRGlyZWN0aW9uQ29sdW1uIiwibGF5b3V0IiwiY29udGVudFN0YXJ0IiwiY29udGVudEVuZCIsImNvbnRlbnRDZW50ZXIiLCJjb250ZW50QmV0d2VlbiIsImNvbnRlbnRBcm91bmQiLCJpdGVtc1N0YXJ0IiwiaXRlbXNFbmQiLCJpdGVtc0NlbnRlciIsIml0ZW1zQmFzZWxpbmUiLCJzZWxmU3RhcnQiLCJzZWxmRW5kIiwic2VsZkNlbnRlciIsInNlbGZCYXNlbGluZSIsInNlbGZTdHJldGNoIiwiYm90dG9tMCIsImNvbG9ycyIsImJsdWVCZyIsImRhcmtHcmF5QmciLCJwaW5lQmciLCJncmF5QmciLCJyZWRCZyIsIm9saXZlQmciLCJsaWdodEdyYXlCZyIsIndoaXRlQmciLCJvcmFuZ2VCZyIsImdyZWVuQmciLCJuYXZ5QmciLCJtaWRuaWdodEJnIiwicHVycGxlQmciLCJvcmNoaWRCZyIsImVnZ3BsYW50QmciLCJtYXJvb25CZyIsIndhdGVybWVsb25CZyIsImxpZ2h0V2FzaEJnIiwiZGFya1dhc2hCZyIsImZpdCIsImZsZXhHcm93IiwiZmxleE5vbmUiLCJoZWlnaHQiLCJqdXN0aWZ5RW5kIiwianVzdGlmeUNlbnRlciIsImp1c3RpZnlCZXR3ZWVuIiwianVzdGlmeUFyb3VuZCIsImxlZnQwIiwibXQiLCJtYiIsIm1sIiwibXIiLCJ3aGl0ZXNwYWNlTGVnYWN5IiwidG9wIiwiYm90dG9tIiwibGVmdCIsIm1sQXV0byIsInJpZ2h0IiwibXJBdXRvIiwibWF4SGVpZ2h0IiwibWF4V2lkdGgiLCJtaW5IZWlnaHQiLCJtaW5XaWR0aCIsIm92ZXJmbG93SGlkZGVuIiwib3ZlcmZsb3dTY3JvbGwiLCJvdmVyZmxvd0F1dG8iLCJvdmVyZmxvd1Njcm9sbFgiLCJvdmVyZmxvd1Njcm9sbFkiLCJ5IiwiYWJzb2x1dGUiLCJyZWxhdGl2ZSIsImZpeGVkIiwicmlnaHQwIiwiYm9yZGVycyIsImNpcmNsZSIsInBpbGwiLCJyb3VuZGVkIiwicm91bmRlZEJvdHRvbSIsInJvdW5kZWRMZWZ0Iiwicm91bmRlZFJpZ2h0Iiwicm91bmRlZFRvcCIsInRvcDAiLCJ3aWR0aCIsImZsZXhXcmFwIiwiX19zdHlsZSIsImNvbnRhaW5zIiwia2V5IiwiYXJyIiwiaW5kZXhPZiIsIm9taXQiLCJvYmoiLCJhY2MiLCJrIiwiQm94IiwiUmVhY3QiLCJyZWYiLCJjaGlsZHJlbiIsImJsYWNrbGlzdCIsInMiLCJib3giLCJwcm9wIiwiUmVhY3QuY3JlYXRlRWxlbWVudCIsImRpc3BsYXlOYW1lIiwiQ29sdW1uUHJvcFR5cGUiLCJQcm9wVHlwZXMiLCJvbmVPZiIsIk1hcmdpblByb3BUeXBlIiwiUGFkZGluZ1Byb3BUeXBlIiwicHJvcFR5cGVzIiwibm9kZSIsImV4YWN0Iiwib2JqZWN0Iiwib25lT2ZUeXBlIiwiYm9vbCIsIm51bWJlciIsInNoYXBlIiwic3RyaW5nIiwiYWRkQ2lyY2xlIiwiYWRkUGluIiwiYWxpZ25Cb3R0b21DZW50ZXIiLCJhbGlnbkJvdHRvbUxlZnQiLCJhbGlnbkJvdHRvbVJpZ2h0IiwiYWxpZ25Cb3R0b20iLCJhbGlnbk1pZGRsZSIsImFsaWduVG9wQ2VudGVyIiwiYWxpZ25Ub3BMZWZ0IiwiYWxpZ25Ub3BSaWdodCIsImFsaWduVG9wIiwiYW5nbGVkUGluIiwiYXJyb3dCYWNrIiwiYXJyb3dDaXJjbGVEb3duIiwiYXJyb3dDaXJjbGVGb3J3YXJkIiwiYXJyb3dEb3duIiwiYXJyb3dGb3J3YXJkIiwiYXJyb3dVcCIsImFycm93VXBSaWdodCIsImNhbWVyYVJvbGwiLCJjYW5vbmljYWxQaW4iLCJjb2xvclBpY2tlciIsImNoZWNrQ2lyY2xlIiwiY2lyY2xlT3V0bGluZSIsImVsbGlwc2lzQ2lyY2xlT3V0bGluZSIsImZhY2VIYXBweSIsImZhY2VTYWQiLCJmYWNlU21pbGV5IiwiZmlsbE9wYXF1ZSIsImZpbGxUcmFuc3BhcmVudCIsImdsb2JlQ2hlY2tlZCIsImdvb2dsZVBsdXMiLCJncmFwaEJhciIsImhhbmRQb2ludGluZyIsImhlYXJ0QnJva2VuIiwibG9nb0xhcmdlIiwibG9nb1NtYWxsIiwibWFyZ2luc0xhcmdlIiwibWFyZ2luc01lZGl1bSIsIm1hcmdpbnNTbWFsbCIsIm92ZXJsYXlUZXh0IiwicGVyc29uQWRkIiwicGluSGlkZSIsInF1ZXN0aW9uTWFyayIsInNob3BwaW5nQmFnIiwic21pbGV5T3V0bGluZSIsInNwZWVjaEVsbGlwc2lzIiwic3dpdGNoQWNjb3VudCIsInRleHRBbGlnbkxlZnQiLCJ0ZXh0QWxpZ25DZW50ZXIiLCJ0ZXh0QWxpZ25SaWdodCIsInRleHRFeHRyYVNtYWxsIiwidGV4dExhcmdlIiwidGV4dE1lZGl1bSIsInRleHRTbWFsbCIsInZpZXdUeXBlRGVmYXVsdCIsInZpZXdUeXBlRGVuc2UiLCJ2aWV3VHlwZUxpc3QiLCJJY29uTmFtZXMiLCJpY29ucyIsIkljb24iLCJhY2Nlc3NpYmlsaXR5TGFiZWwiLCJjb2xvciIsImljb24iLCJpbmxpbmUiLCJkYW5nZXJvdXNseVNldFN2Z1BhdGgiLCJjcyIsImNsYXNzbmFtZXMiLCJpY29uQmxvY2siLCJwYXRoIiwiX19wYXRoIiwidW5kZWZpbmVkIiwiYXJpYUhpZGRlbiIsImlzUmVxdWlyZWQiLCJzaG91bGRTY2FsZUltYWdlIiwiSW1hZ2UiLCJoYW5kbGVMb2FkIiwib25Mb2FkIiwiaGFuZGxlRXJyb3IiLCJvbkVycm9yIiwibG9hZEltYWdlIiwicHJldlByb3BzIiwic3JjIiwid2luZG93IiwiaW1hZ2UiLCJvbmxvYWQiLCJvbmVycm9yIiwiYWx0IiwibmF0dXJhbEhlaWdodCIsIm5hdHVyYWxXaWR0aCIsInNpemVzIiwic3JjU2V0IiwiaXNTY2FsZWRJbWFnZSIsImNoaWxkQ29udGVudCIsImltZyIsImZ1bmMiLCJkZWZhdWx0UHJvcHMiLCJNYXNrIiwid2FzaCIsImN4IiwiU3F1YXJlIiwicGFkZGluZ0JvdHRvbSIsIkRlZmF1bHRBdmF0YXIiLCJmaXJzdEluaXRpYWwiLCJ0b1VwcGVyQ2FzZSIsInR5cG9ncmFwaHkiLCJhbnRpYWxpYXNlZCIsInNhbnNTZXJpZiIsImxlYWRpbmdTbWFsbCIsImZvbnRXZWlnaHRCb2xkIiwiQXZhdGFyIiwic3RhdGUiLCJoYW5kbGVJbWFnZUVycm9yIiwic2V0U3RhdGUiLCJpc0ltYWdlTG9hZGVkIiwib3V0bGluZSIsInZlcmlmaWVkIiwiU0laRV9TQ0FMRSIsIlRleHQiLCJhbGlnbiIsImJvbGQiLCJpdGFsaWMiLCJvdmVyZmxvdyIsInNtU2l6ZSIsIm1kU2l6ZSIsImxnU2l6ZSIsImxlYWRpbmciLCJ0cnVuY2F0ZSIsIl9fZGFuZ2Vyb3VzbHlJbmNyZWFzZUxpbmVIZWlnaHQiLCJzbVNjYWxlIiwibWRTY2FsZSIsImxnU2NhbGUiLCJibHVlIiwiZGFya0dyYXkiLCJlZ2dwbGFudCIsImdyYXkiLCJncmVlbiIsImxpZ2h0R3JheSIsIm1hcm9vbiIsIm1pZG5pZ2h0IiwibmF2eSIsIm9saXZlIiwib3JhbmdlIiwib3JjaGlkIiwicGluZSIsInB1cnBsZSIsInJlZCIsIndhdGVybWVsb24iLCJ3aGl0ZSIsImxlYWRpbmdTaG9ydCIsImxlYWRpbmdUYWxsIiwiYWxpZ25DZW50ZXIiLCJhbGlnbkp1c3RpZnkiLCJhbGlnbkxlZnQiLCJhbGlnblJpZ2h0IiwiYnJlYWtXb3JkIiwiZm9udFN0eWxlSXRhbGljIiwiZm9udFN0eWxlTm9ybWFsIiwiZm9udFdlaWdodE5vcm1hbCIsIlRhZyIsInRpdGxlIiwiQnV0dG9uIiwiYWNjZXNzaWJpbGl0eUV4cGFuZGVkIiwiYWNjZXNzaWJpbGl0eUhhc3BvcHVwIiwiZGlzYWJsZWQiLCJvbkNsaWNrIiwidGV4dCIsInR5cGUiLCJ0ZXh0Q29sb3IiLCJjbGFzc2VzIiwiYnV0dG9uIiwic20iLCJtZCIsImxnIiwic29saWQiLCJlbmFibGVkIiwiYmxvY2siLCJldmVudCIsIkNhcmQiLCJoYW5kbGVNb3VzZUVudGVyIiwib25Nb3VzZUVudGVyIiwiaG92ZXJlZCIsImhhbmRsZU1vdXNlTGVhdmUiLCJvbk1vdXNlTGVhdmUiLCJhY3RpdmUiLCJjYXJkIiwiaG92ZXIiLCJDaGVja2JveCIsImhhbmRsZUNoYW5nZSIsImNoZWNrZWQiLCJ0YXJnZXQiLCJvbkNoYW5nZSIsImhhbmRsZUNsaWNrIiwiY3VycmVudFRhcmdldCIsImhhbmRsZUJsdXIiLCJmb2N1c2VkIiwiaGFuZGxlRm9jdXMiLCJpbmRldGVybWluYXRlIiwic2V0SW5kZXRlcm1pbmF0ZSIsInByZXZpb3VzUHJvcHMiLCJpbnB1dCIsImhhc0Vycm9yIiwiaWQiLCJib3JkZXJTdHlsZSIsImJvcmRlciIsImJvcmRlckRhcmsiLCJib3JkZXJFcnJvciIsImlucHV0RW5hYmxlZCIsImlucHV0U20iLCJpbnB1dE1kIiwiZWwiLCJjaGVjayIsImNoZWNrRW5hYmxlZCIsImNoZWNrRm9jdXNlZCIsImNoZWNrTWQiLCJjaGVja1NtIiwiQ29sbGVjdGlvbiIsIkl0ZW0iLCJ2aWV3cG9ydFRvcCIsInZpZXdwb3J0TGVmdCIsIm1heCIsIml0ZW0iLCJ2aWV3cG9ydFdpZHRoIiwidmlld3BvcnRIZWlnaHQiLCJpdGVtcyIsInBvc2l0aW9uIiwiaWR4IiwicHVzaCIsImxheW91dFN0eWxlcyIsImFueSIsImFycmF5T2YiLCJVUCIsIkRPV04iLCJNSUQiLCJjb2x1bW5MYXlvdXQiLCJudW1PZkNvbHVtbnMiLCJwYWRkaW5nQWxsIiwiZ3V0dGVyIiwicG9zaXRpb25zIiwibWluZGV4IiwibWluSW5kZXgiLCJpIiwiY29sdW1uc0ZvckNvbGxhZ2VXaXRoQ292ZXIiLCJnZXRDb2xsYWdlTGF5b3V0IiwiY292ZXIiLCJudW1Db2xzIiwiY29sdW1ucyIsImgiLCJ3IiwibGF5b3V0S2V5IiwiZ3JpZENvbHMiLCJsYXlvdXRJZHgiLCJjb2xIZWlnaHRzIiwiZmlsbCIsImNvbENvdW50cyIsImNvbCIsImNvbElkeCIsIml0ZW1IZWlnaHQiLCJjb3ZlckltYWdlV2lkdGgiLCJjZWlsIiwidW5zaGlmdCIsIkNvbGxhZ2UiLCJyZW5kZXJJbWFnZSIsImluZGV4IiwiQ29sdW1uIiwieHMiLCJkZXByZWNhdGVkQ29sdW1uIiwic3BhbiIsInNtU3BhbiIsIm1kU3BhbiIsImxnU3BhbiIsIkNvbnRhaW5lciIsIkRpdmlkZXIiLCJkaXZpZGVyIiwiQ2FyZXQiLCJkaXJlY3Rpb24iLCJTUEFDRVNfSU5ERVhfTUFQIiwiRElSX0lOREVYX01BUCIsIk1BUkdJTiIsIkNBUkVUX0hFSUdIVCIsIkNBUkVUX09GRlNFVF9GUk9NX1NJREUiLCJCT1JERVJfUkFESVVTIiwiZ2V0TWFpbkRpciIsImZseW91dFNpemUiLCJpZGVhbERpcmVjdGlvbiIsInRyaWdnZXJSZWN0Iiwid2luZG93U2l6ZSIsInVwIiwiZG93biIsInNwYWNlcyIsIm1haW5EaXIiLCJnZXRTdWJEaXIiLCJvZmZzZXQiLCJ0cmlnZ2VyTWlkIiwid2luZG93U3BhY2VBdmFpbGFibGUiLCJhYm92ZU9yTGVmdCIsImJlbG93T3JSaWdodCIsInN1YkRpciIsImNhbGNFZGdlU2hpZnRzIiwiZmx5b3V0VmVydGljYWxTaGlmdCIsImZseW91dEhvcml6b250YWxTaGlmdCIsImNhcmV0VmVydGljYWxTaGlmdCIsImNhcmV0SG9yaXpvbnRhbFNoaWZ0IiwiaXNDbG9zZVZlcnRpY2FsbHkiLCJpc0Nsb3NlSG9yaXpvbnRhbGx5IiwiYWRqdXN0T2Zmc2V0cyIsImJhc2UiLCJlZGdlU2hpZnQiLCJmbHlvdXRMZWZ0IiwiZmx5b3V0VG9wIiwiY2FyZXRUb3AiLCJjYXJldFJpZ2h0IiwiY2FyZXRCb3R0b20iLCJjYXJldExlZnQiLCJmbHlvdXQiLCJjYXJldCIsImJhc2VPZmZzZXRzIiwicmVsYXRpdmVPZmZzZXQiLCJIQUxGX0NBUkVUIiwic2Nyb2xsWSIsInNjcm9sbFgiLCJDb250ZW50cyIsInNldEZseW91dFBvc2l0aW9uIiwicG9zaXRpb25SZWxhdGl2ZVRvQW5jaG9yIiwicGFnZVhPZmZzZXQiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsInNjcm9sbExlZnQiLCJwYWdlWU9mZnNldCIsInNjcm9sbFRvcCIsImlubmVySGVpZ2h0IiwiaW5uZXJXaWR0aCIsImNsaWVudEhlaWdodCIsImVkZ2VTaGlmdHMiLCJmbHlvdXRPZmZzZXQiLCJjYXJldE9mZnNldCIsInNob3VsZEZvY3VzIiwiZm9jdXMiLCJhZGRFdmVudExpc3RlbmVyIiwib25SZXNpemUiLCJvbktleURvd24iLCJuZXh0UHJvcHMiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYmdDb2xvciIsInZpc2liaWxpdHkiLCJiYWNrZ3JvdW5kIiwic3Ryb2tlIiwiYm9yZGVyQ29sb3IiLCJjb250YWluZXIiLCJkaW1lbnNpb25zIiwiY29udGVudHMiLCJpbm5lckNvbnRlbnRzIiwiT3V0c2lkZUV2ZW50QmVoYXZpb3IiLCJoYW5kbGVDbGlja0V2ZW50IiwiZmluZERPTU5vZGUiLCJOb2RlIiwiU0laRV9XSURUSF9NQVAiLCJFU0NBUEVfS0VZX0NPREUiLCJDb250cm9sbGVyIiwiaGFuZGxlS2V5RG93biIsImtleUNvZGUiLCJvbkRpc21pc3MiLCJoYW5kbGVQYWdlQ2xpY2siLCJhbmNob3IiLCJoYW5kbGVSZXNpemUiLCJ1cGRhdGVUcmlnZ2VyUmVjdCIsInRyaWdnZXJCb3VuZGluZ1JlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJvZmZzZXRMZWZ0Iiwib2Zmc2V0VG9wIiwiRmx5b3V0IiwiemlwIiwiYSIsImIiLCJCT1JERVJfV0lEVEgiLCJBVkFUQVJfU0laRVMiLCJhdmF0YXJMYXlvdXQiLCJ0ZXh0TGF5b3V0IiwiZGVnVG9SYWQiLCJkZWciLCJQSSIsInF1YXJ0ZXJQYWRkaW5nIiwic2luIiwiaW5pdGlhbCIsIkdyb3VwQXZhdGFyIiwiY29sbGFib3JhdG9ycyIsImF2YXRhcldpZHRoIiwiYXZhdGFySGVpZ2h0IiwiYm94U2hhZG93IiwiY29sbGFib3JhdG9yIiwiZGVmYXVsdEhlYWRpbmdMZXZlbHMiLCJIZWFkaW5nIiwiYWNjZXNzaWJpbGl0eUxldmVsIiwiaGVhZGluZ0xldmVsIiwiU0laRV9OQU1FX1RPX1BJWEVMIiwiZGVmYXVsdEljb25CdXR0b25JY29uQ29sb3JzIiwiUG9nIiwiaWNvbkNvbG9yIiwiaWNvblNpemUiLCJwb2ciLCJJY29uQnV0dG9uIiwiaGFuZGxlTW91c2VEb3duIiwiaGFuZGxlTW91c2VVcCIsIkxhYmVsIiwiaHRtbEZvciIsImxhYmVsIiwiTGF5ZXIiLCJjcmVhdGVFbGVtZW50Iiwid2FybiIsImJvZHkiLCJhcHBlbmRDaGlsZCIsIm1vdW50ZWQiLCJyZW1vdmVDaGlsZCIsImNyZWF0ZVBvcnRhbCIsImFzcGVjdFJhdGlvIiwiTGV0dGVyYm94IiwiY29udGVudEFzcGVjdFJhdGlvIiwidmlld3BvcnRBc3BlY3RSYXRpbyIsImNvbnRlbnRIZWlnaHQiLCJjb250ZW50V2lkdGgiLCJUQUJfS0VZX0NPREUiLCJMaW5rIiwiaHJlZiIsImVuYWJsZUZvY3VzU3R5bGVzIiwiaGFuZGxlS2V5VXAiLCJyZWwiLCJsaW5rVGFyZ2V0IiwibGluayIsImFjY2Vzc2libGVGb2N1c1N0eWxlIiwiZGVib3VuY2UiLCJ0aHJlc2hob2xkIiwiZGVmZXJUaW1lciIsImRlYm91bmNlZCIsImFyZ3MiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiRmV0Y2hJdGVtcyIsImNvbnRhaW5lckhlaWdodCIsImlzQXRFbmQiLCJpc0ZldGNoaW5nIiwiZmV0Y2hNb3JlIiwic2Nyb2xsSGVpZ2h0Iiwic2Nyb2xsQnVmZmVyIiwiZ2V0U2Nyb2xsQ29udGFpbmVyIiwic2Nyb2xsQ29udGFpbmVyIiwiU2Nyb2xsQ29udGFpbmVyIiwiZ2V0U2Nyb2xsQ29udGFpbmVyUmVmIiwiaGFuZGxlU2Nyb2xsIiwib25TY3JvbGwiLCJ1cGRhdGVTY3JvbGxDb250YWluZXIiLCJuZXh0U2Nyb2xsQ29udGFpbmVyIiwib25seSIsInRocm90dGxlIiwibGFzdCIsInRocm90dGxlZCIsIm5vdyIsIkRhdGUiLCJNZWFzdXJlbWVudFN0b3JlIiwiV2Vha01hcCIsImdldCIsImhhcyIsInNldCIsImdldEVsZW1lbnRIZWlnaHQiLCJlbGVtZW50IiwiZ2V0V2luZG93U2Nyb2xsUG9zIiwiZ2V0UmVsYXRpdmVTY3JvbGxUb3AiLCJnZXRTY3JvbGxIZWlnaHQiLCJnZXRTY3JvbGxQb3MiLCJEZWZhdWx0TGF5b3V0U3ltYm9sIiwiU3ltYm9sIiwiVW5pZm9ybVJvd0xheW91dFN5bWJvbCIsIm9mZnNjcmVlbiIsIkluZmluaXR5IiwiY2FjaGUiLCJjb2x1bW5XaWR0aCIsIm1pbkNvbHMiLCJjb2x1bW5XaWR0aEFuZEd1dHRlciIsImNvbHVtbkNvdW50IiwiZmxvb3IiLCJoZWlnaHRzIiwiY2VudGVyT2Zmc2V0IiwiaGVpZ2h0QW5kR3V0dGVyIiwicm93Iiwic2xpY2UiLCJzdW0iLCJpZGVhbENvbHVtbldpZHRoIiwiY29sZ3Vlc3MiLCJNYXNvbnJ5TGF5b3V0IiwiVW5pZm9ybVJvd0xheW91dCIsIlJFU0laRV9ERUJPVU5DRSIsIlZJUlRVQUxfQlVGRkVSX0ZBQ1RPUiIsImxheW91dE51bWJlclRvQ3NzRGltZW5zaW9uIiwiTWFzb25yeSIsImdyaWRXcmFwcGVyIiwiY2xpZW50V2lkdGgiLCJ1cGRhdGVTY3JvbGxQb3NpdGlvbiIsIm1lYXN1cmVDb250YWluZXJBc3luYyIsIm1lYXN1cmVDb250YWluZXIiLCJzZXRHcmlkV3JhcHBlclJlZiIsInNldFNjcm9sbENvbnRhaW5lclJlZiIsImxvYWRJdGVtcyIsInJlbmRlck1hc29ucnlDb21wb25lbnQiLCJpdGVtRGF0YSIsIkNvbXBvbmVudCIsImNvbXAiLCJ2aXJ0dWFsaXplIiwidmlydHVhbEJvdW5kc1RvcCIsInZpcnR1YWxCb3VuZHNCb3R0b20iLCJpc1Zpc2libGUiLCJ2aXJ0dWFsQnVmZmVyIiwib2Zmc2V0U2Nyb2xsUG9zIiwiY29udGFpbmVyT2Zmc2V0Iiwidmlld3BvcnRCb3R0b20iLCJpdGVtQ29tcG9uZW50IiwiTWFzb25yeV9fSXRlbSIsIk1hc29ucnlfX0l0ZW1fX01vdW50ZWQiLCJzb21lIiwibWVhc3VyZW1lbnRTdG9yZSIsInByZXZTdGF0ZSIsInJlc2V0IiwiaGFzUGVuZGluZ01lYXN1cmVtZW50cyIsImluc2VydEFuaW1hdGlvbkZyYW1lIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwic2Nyb2xsQ29udGFpbmVyUmVmIiwiSFRNTEVsZW1lbnQiLCJyZWxhdGl2ZVNjcm9sbFRvcCIsImZvcmNlVXBkYXRlIiwiZmxleGlibGUiLCJndXR0ZXJXaWR0aCIsImZ1bGxXaWR0aExheW91dCIsIkxlZ2FjeVVuaWZvcm1Sb3dMYXlvdXQiLCJ1bmlmb3JtUm93TGF5b3V0IiwiZGVmYXVsdExheW91dCIsImdyaWRCb2R5IiwiZmlsdGVyIiwiaXRlbXNUb1JlbmRlciIsIml0ZW1zVG9NZWFzdXJlIiwibWVhc3VyaW5nUG9zaXRpb25zIiwicG9zIiwiZGF0YSIsIm1lYXN1cmVtZW50SW5kZXgiLCJpbnN0YW5jZU9mIiwiTGVnYWN5TWFzb25yeUxheW91dCIsInN5bWJvbCIsImxheW91dENsYXNzIiwic3RhdGVzRm9yUmVuZGVyaW5nIiwicmVuZGVyUG9zaXRpb25zIiwiTWFzb25yeUJldGEiLCJoYW5kbGVWaXJ0dWFsaXphdGlvbldpbmRvd1VwZGF0ZSIsIm9uVmlydHVhbGl6YXRpb25XaW5kb3dVcGRhdGUiLCJ2aWV3cG9ydCIsImNvbnRlbnQiLCJoYW5kbGVPbkF1dG9NZWFzdXJpbmdVcGRhdGUiLCJvbkF1dG9NZWFzdXJpbmdVcGRhdGUiLCJzdGF0ZVdpdGhXaWR0aCIsInJlbmRlcmluZ1N0YXRlcyIsIm5ld1N0YXRlIiwiTWFzb25yeUluZmluaXRlQmV0YSIsInNldFJlZiIsImdyaWRSZWYiLCJyZWZsb3ciLCJOb1Njcm9sbEJlaGF2aW9yIiwicHJldk92ZXJmbG93IiwicXVlcnlGb2N1c2FibGVBbGwiLCJzZWxlY3RvciIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJmb2N1c0VsZW1lbnQiLCJUcmFwRm9jdXNCZWhhdmlvciIsInNldEVsUmVmIiwic3RvcFByb3BhZ2F0aW9uIiwicHJldmVudERlZmF1bHQiLCJmb2N1c0ZpcnN0Q2hpbGQiLCJwcmV2aW91c2x5Rm9jdXNlZEVsIiwiYWN0aXZlRWxlbWVudCIsIkJhY2tkcm9wIiwiTW9kYWwiLCJoYW5kbGVPdXRzaWRlQ2xpY2siLCJoYW5kbGVDbG9zZUNsaWNrIiwiYWNjZXNzaWJpbGl0eUNsb3NlTGFiZWwiLCJhY2Nlc3NpYmlsaXR5TW9kYWxMYWJlbCIsImZvb3RlciIsImhlYWRpbmciLCJyb2xlIiwid3JhcHBlciIsInBhZGRpbmdMZWZ0IiwicGFkZGluZ1JpZ2h0IiwiUHVsc2FyIiwicGF1c2VkIiwiaW5uZXJDaXJjbGUiLCJvdXRlckNpcmNsZSIsIlJhZGlvQnV0dG9uIiwiUmFkaW9CdXR0b25Jc0ZvY3VzZWQiLCJSYWRpb0J1dHRvblNtIiwiUmFkaW9CdXR0b25NZCIsIlJhZGlvQnV0dG9uV2hpdGVCZyIsIlJhZGlvQnV0dG9uTGlnaHRHcmF5QmciLCJJbnB1dCIsIklucHV0RW5hYmxlZCIsIklucHV0U20iLCJJbnB1dE1kIiwiQ2hlY2siLCJDaGVja1NtIiwiQ2hlY2tNZCIsIkNoZWNrRW5hYmxlZCIsIkNoZWNrRGlzYWJsZWQiLCJTY3JvbGxGZXRjaCIsInVwZGF0ZVBvc2l0aW9uIiwiZ2V0U2Nyb2xsU3RhdGUiLCJyZW5kZXJIZWlnaHQiLCJTZWFyY2hGaWVsZCIsImhhbmRsZUNsZWFyIiwib25Gb2N1cyIsIm9uQmx1ciIsImF1dG9Db21wbGV0ZSIsInBsYWNlaG9sZGVyIiwic2hvd0NsZWFyIiwiY2xlYXIiLCJTZWdtZW50ZWRDb250cm9sIiwic2VsZWN0ZWRJdGVtSW5kZXgiLCJpc1NlbGVjdGVkIiwiaXRlbUlzTm90U2VsZWN0ZWQiLCJpdGVtSXNTZWxlY3RlZCIsImUiLCJhY3RpdmVJbmRleCIsIlNlbGVjdExpc3QiLCJoYW5kbGVPbkNoYW5nZSIsIkhUTUxTZWxlY3RFbGVtZW50IiwiZXJyb3JNZXNzYWdlIiwiZXJyb3JJc09wZW4iLCJpZGVhbEVycm9yRGlyZWN0aW9uIiwib3B0aW9ucyIsInNlbGVjdCIsImVycm9yZWQiLCJub3JtYWwiLCJib3JkZXJSYWRpdXMiLCJwYWRkaW5nVG9wIiwib3B0aW9uIiwiU0laRSIsIlNwaW5uZXIiLCJzaG93IiwiU3RpY2t5IiwiZGFuZ2Vyb3VzbHlTZXRaSW5kZXgiLCJfX3pJbmRleCIsInN0aWNreSIsIlN3aXRjaCIsInN3aXRjaGVkIiwic3dpdGNoU3R5bGVzIiwic3dpdGNoIiwic3dpdGNoR3JheSIsInN3aXRjaExpZ2h0R3JheSIsInN3aXRjaERhcmtHcmF5Iiwic3dpdGNoV2hpdGUiLCJzbGlkZXJTdHlsZXMiLCJzbGlkZXIiLCJzbGlkZXJSaWdodCIsInNsaWRlckxlZnQiLCJzbGlkZXJEYXJrIiwic2xpZGVyTGlnaHQiLCJpbnB1dFN0eWxlcyIsImNoZWNrYm94IiwiY2hlY2tib3hFbmFibGVkIiwiVGFicyIsImhhbmRsZVRhYkNsaWNrIiwiYWN0aXZlVGFiSW5kZXgiLCJoYW5kbGVUYWJGb2N1cyIsImZvY3VzZWRUYWJJbmRleCIsImhhbmRsZVRhYkJsdXIiLCJoYW5kbGVUYWJNb3VzZUVudGVyIiwiaG92ZXJlZFRhYkluZGV4IiwiaGFuZGxlVGFiTW91c2VMZWF2ZSIsInRhYnMiLCJ3cmFwIiwiaXNBY3RpdmUiLCJpc0hvdmVyZWQiLCJpc0ZvY3VzZWQiLCJ0YWIiLCJ0YWJJc05vdEFjdGl2ZSIsInRhYklzQWN0aXZlIiwiVGV4dEFyZWEiLCJyb3dzIiwidGV4dEFyZWEiLCJ0ZXh0YXJlYSIsIlRleHRGaWVsZCIsInRleHRGaWVsZCIsInBhdHRlcm4iLCJ0ZXh0ZmllbGQiLCJUb2FzdCIsInRodW1ibmFpbCIsImZvbnRXZWlnaHQiLCJTUEFDRV9DSEFSX0NPREUiLCJFTlRFUl9DSEFSX0NPREUiLCJUb3VjaGFibGUiLCJoYW5kbGVLZXlQcmVzcyIsIm9uVG91Y2giLCJjaGFyQ29kZSIsImZ1bGxXaWR0aCIsImZ1bGxIZWlnaHQiLCJtb3VzZUN1cnNvciIsInRvdWNoYWJsZSIsIlZpZGVvUGxheWhlYWQiLCJzZXRQbGF5aGVhZFJlZiIsInBsYXloZWFkIiwic2VlayIsImNsaWVudFgiLCJkdXJhdGlvbiIsInBlcmNlbnQiLCJtaW4iLCJuZXdUaW1lIiwic3RvcENsaWNrIiwic2Vla2luZyIsImhhbmRsZU1vdXNlTW92ZSIsImN1cnJlbnRUaW1lIiwiZnVsbHNjcmVlbkVuYWJsZWQiLCJ3ZWJraXRGdWxsc2NyZWVuRW5hYmxlZCIsIm1vekZ1bGxTY3JlZW5FbmFibGVkIiwibXNGdWxsc2NyZWVuRW5hYmxlZCIsInRpbWVUb1N0cmluZyIsInRpbWUiLCJtaW51dGVzIiwic2Vjb25kcyIsIm1pbnV0ZXNTdHIiLCJzZWNvbmRzU3RyIiwiVmlkZW9Db250cm9scyIsImhhbmRsZUZ1bGxzY3JlZW5DaGFuZ2UiLCJvbkZ1bGxzY3JlZW5DaGFuZ2UiLCJoYW5kbGVQbGF5aW5nQ2hhbmdlIiwicGxheWluZyIsIm9uUGF1c2UiLCJvblBsYXkiLCJoYW5kbGVWb2x1bWVDaGFuZ2UiLCJvblZvbHVtZUNoYW5nZSIsImFjY2Vzc2liaWxpdHlNYXhpbWl6ZUxhYmVsIiwiYWNjZXNzaWJpbGl0eU1pbmltaXplTGFiZWwiLCJhY2Nlc3NpYmlsaXR5TXV0ZUxhYmVsIiwiYWNjZXNzaWJpbGl0eVBhdXNlTGFiZWwiLCJhY2Nlc3NpYmlsaXR5UGxheUxhYmVsIiwiYWNjZXNzaWJpbGl0eVVubXV0ZUxhYmVsIiwiZnVsbHNjcmVlbiIsInZvbHVtZSIsIm11dGVkIiwic2hvd0Z1bGxzY3JlZW5CdXR0b24iLCJjb250cm9scyIsInJlcXVlc3RGdWxsc2NyZWVuIiwid2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4iLCJtb3pSZXF1ZXN0RnVsbFNjcmVlbiIsIm1zUmVxdWVzdEZ1bGxzY3JlZW4iLCJleGl0RnVsbHNjcmVlbiIsIndlYmtpdEV4aXRGdWxsc2NyZWVuIiwibW96Q2FuY2VsRnVsbFNjcmVlbiIsIm1zRXhpdEZ1bGxzY3JlZW4iLCJpc0Z1bGxzY3JlZW4iLCJmdWxsc2NyZWVuRWxlbWVudCIsIndlYmtpdEZ1bGxzY3JlZW5FbGVtZW50IiwibW96RnVsbFNjcmVlbkVsZW1lbnQiLCJtc0Z1bGxzY3JlZW5FbGVtZW50IiwiYWRkRnVsbHNjcmVlbkV2ZW50TGlzdGVuZXIiLCJsaXN0ZW5lciIsInJlbW92ZUZ1bGxzY3JlZW5FdmVudExpc3RlbmVyIiwiaXNOZXdTb3VyY2UiLCJvbGRTb3VyY2UiLCJuZXdTb3VyY2UiLCJpc0FycmF5Iiwic291cmNlIiwiVmlkZW8iLCJzZXRQbGF5ZXJSZWYiLCJwbGF5ZXIiLCJzZXRWaWRlb1JlZiIsInZpZGVvIiwic2V0UGxheWJhY2tSYXRlIiwicGxheWJhY2tSYXRlIiwic2V0Vm9sdW1lIiwibG9hZCIsInBhdXNlIiwicGxheSIsInRvZ2dsZUZ1bGxzY3JlZW4iLCJoYW5kbGVDYW5QbGF5Iiwib25SZWFkeSIsImhhbmRsZUR1cmF0aW9uQ2hhbmdlIiwib25EdXJhdGlvbkNoYW5nZSIsImhhbmRsZUVuZGVkIiwib25FbmRlZCIsImhhbmRsZVBsYXkiLCJoYW5kbGVQYXVzZSIsImhhbmRsZVByb2dyZXNzIiwib25Mb2FkZWRDaGFuZ2UiLCJidWZmZXJlZCIsImxvYWRlZCIsImVuZCIsImhhbmRsZVNlZWsiLCJvblNlZWsiLCJoYW5kbGVUaW1lVXBkYXRlIiwib25UaW1lQ2hhbmdlIiwiY2FwdGlvbnMiLCJsb29wIiwicGxheXNJbmxpbmUiLCJwb3N0ZXIiLCJwcmVsb2FkIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5QkEsQUFBTyxJQUFNQSxXQUFXLFNBQVhBLFFBQVc7U0FBYztlQUN6QixJQUFJQyxHQUFKLEVBRHlCO2lCQUV2QjtHQUZTO0NBQWpCOzs7Ozs7QUFLUCxBQUFPLElBQU1DLGdCQUFnQixTQUFoQkEsYUFBZ0I7b0NBQUlDLFVBQUo7Y0FBQTs7O1NBQTBDO2VBQzFELElBQUlGLEdBQUosQ0FBUUUsVUFBUixDQUQwRDtpQkFFeEQ7R0FGYztDQUF0Qjs7QUFLUCxBQUFPLElBQU1DLGtCQUFrQixTQUFsQkEsZUFBa0IsQ0FBQ0MsV0FBRDtTQUFzQztlQUN4RCxJQUFJSixHQUFKLEVBRHdEOztHQUF0QztDQUF4Qjs7QUFLUCxBQUFPLElBQU1LLFNBQVMsU0FBVEEsTUFBUyxDQUFDQyxNQUFEO1NBQ3BCQSxPQUFPQyxNQUFQLENBQ0U7UUFDZUMsVUFEZixRQUNJQyxTQURKO1FBQ3dDQyxZQUR4QyxRQUMyQk4sV0FEM0I7UUFFZU8sVUFGZixTQUVJRixTQUZKO1FBRXdDRyxZQUZ4QyxTQUUyQlIsV0FGM0I7V0FHTTtpQkFDTyxJQUFJSixHQUFKLDZCQUFZUSxVQUFaLHFCQUEyQkcsVUFBM0IsR0FEUDtnQ0FFY0QsWUFBbEIsRUFBbUNFLFlBQW5DO0tBTEY7R0FERixFQVFFYixVQVJGLENBRG9CO0NBQWY7O0FBWVAsQUFBTyxJQUFNYyxlQUFlLFNBQWZBLFlBQWUsQ0FBQ0MsRUFBRDtTQUErQjtRQUN6REwsU0FEeUQsU0FDekRBLFNBRHlEO1FBRXpETCxXQUZ5RCxTQUV6REEsV0FGeUQ7V0FHdEM7aUJBQ1IsSUFBSUosR0FBSixDQUFRZSxNQUFNQyxJQUFOLENBQVdQLFNBQVgsRUFBc0JRLEdBQXRCLENBQTBCSCxFQUExQixDQUFSLENBRFE7O0tBSHNDO0dBQS9CO0NBQXJCOztBQVFQLEFBQU8sSUFBTUksVUFBVSxTQUFWQSxPQUFVLFFBR2lDO01BRnREVCxTQUVzRCxTQUZ0REEsU0FFc0Q7TUFEdERMLFdBQ3NELFNBRHREQSxXQUNzRDs7TUFDaERlLFFBQVEsRUFBZDs7TUFFSVYsVUFBVVcsSUFBVixHQUFpQixDQUFyQixFQUF3Qjs7OztVQUloQlgsU0FBTixHQUFrQk0sTUFBTUMsSUFBTixDQUFXUCxTQUFYLEVBQ2ZZLElBRGUsR0FFZkMsSUFGZSxDQUVWLEdBRlUsQ0FBbEI7OztNQUtFQyxPQUFPQyxJQUFQLENBQVlwQixXQUFaLEVBQXlCcUIsTUFBekIsR0FBa0MsQ0FBdEMsRUFBeUM7VUFDakNDLEtBQU4sR0FBY3RCLFdBQWQ7OztTQUdLZSxLQUFQO0NBbkJLOztBQ3BEUDs7Ozs7Ozs7Ozs7O0FBY0EsQUFBTyxJQUFNUSxTQUFTLFNBQVRBLE1BQVM7b0NBQUl6QixVQUFKO2NBQUE7OztTQUFrQyxVQUFDMEIsR0FBRDtXQUN0REEsTUFBTTNCLCtCQUFpQkMsVUFBakIsQ0FBTixHQUFxQ0gsVUFEaUI7R0FBbEM7Q0FBZjs7Ozs7O0FBT1AsQUFBTyxJQUFNOEIsVUFBVSxTQUFWQSxPQUFVLENBQUNaLEdBQUQ7U0FBb0MsVUFBQ1csR0FBRDtXQUN6REwsT0FBT08sU0FBUCxDQUFpQkMsY0FBakIsQ0FBZ0NDLElBQWhDLENBQXFDZixHQUFyQyxFQUEwQ1csR0FBMUMsSUFDSTNCLGNBQWNnQixJQUFJVyxHQUFKLENBQWQsQ0FESixHQUVJN0IsVUFIcUQ7R0FBcEM7Q0FBaEI7Ozs7OztBQVNQLEFBQU8sSUFBTWtDLFFBQVEsU0FBUkEsS0FBUSxDQUFDQyxLQUFEO1NBQW1CLFVBQUNDLENBQUQ7V0FDdENsQyxtQkFBaUJpQyxLQUFqQixJQUF5QkMsSUFBSSxDQUFKLFNBQVlDLEtBQUtDLEdBQUwsQ0FBU0YsQ0FBVCxDQUFaLEdBQTRCQSxDQUFyRCxFQURzQztHQUFuQjtDQUFkOzs7Ozs7QUFPUCxBQUFPLElBQU1HLG1CQUFtQixTQUFuQkEsZ0JBQW1CLENBQUNKLEtBQUQ7U0FBbUIsVUFBQ0MsQ0FBRDtXQUNqREEsTUFBTSxDQUFOLEdBQVVwQyxVQUFWLEdBQXVCa0MsTUFBTUMsS0FBTixFQUFhQyxDQUFiLENBRDBCO0dBQW5CO0NBQXpCOzs7OztBQU1QLEFBQU8sSUFBTUksT0FBTyxTQUFQQSxJQUFPLENBQUN6QixFQUFELEVBQWMwQixLQUFkO1NBQW1ELFVBQ3JFWixHQURxRTtXQUVsRWYsYUFBYTthQUFRMkIsTUFBTUMsSUFBTixDQUFSO0tBQWIsRUFBa0MzQixHQUFHYyxHQUFILENBQWxDLENBRmtFO0dBQW5EO0NBQWI7Ozs7QUFNUCxBQUFPLElBQU1jLFFBQVEsU0FBUkEsS0FBUTtxQ0FBSUMsR0FBSjtPQUFBOzs7U0FBNEIsVUFBQ2YsR0FBRDtXQUMvQ3ZCLE9BQU9zQyxJQUFJMUIsR0FBSixDQUFRO2FBQU1ILEdBQUdjLEdBQUgsQ0FBTjtLQUFSLENBQVAsQ0FEK0M7R0FBNUI7Q0FBZDs7QUNqQlA7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMExBLElBQU1nQixjQUFjTCxLQUFLRCxpQkFBaUIsYUFBakIsQ0FBTCxFQUFzQ08sVUFBdEMsQ0FBcEI7QUFDQSxJQUFNQyxZQUFZUCxLQUFLRCxpQkFBaUIsV0FBakIsQ0FBTCxFQUFvQ08sVUFBcEMsQ0FBbEI7QUFDQSxJQUFNRSxZQUFZUixLQUFLRCxpQkFBaUIsV0FBakIsQ0FBTCxFQUFvQ08sVUFBcEMsQ0FBbEI7QUFDQSxJQUFNRyxjQUFjVCxLQUFLRCxpQkFBaUIsYUFBakIsQ0FBTCxFQUFzQ08sVUFBdEMsQ0FBcEI7QUFDQSxJQUFNSSxlQUFlVixLQUFLRCxpQkFBaUIsY0FBakIsQ0FBTCxFQUF1Q08sVUFBdkMsQ0FBckI7QUFDQSxJQUFNSyxhQUFhWCxLQUFLRCxpQkFBaUIsWUFBakIsQ0FBTCxFQUFxQ08sVUFBckMsQ0FBbkI7QUFDQSxJQUFNTSxTQUFTVCxNQUFNSyxTQUFOLEVBQWlCRSxZQUFqQixFQUErQkMsVUFBL0IsRUFBMkNGLFdBQTNDLENBQWY7O0FBRUEsSUFBTUksY0FBY2IsS0FBS0QsaUJBQWlCLGFBQWpCLENBQUwsRUFBc0NPLFVBQXRDLENBQXBCO0FBQ0EsSUFBTVEsZ0JBQWdCZCxLQUFLRCxpQkFBaUIsZUFBakIsQ0FBTCxFQUF3Q08sVUFBeEMsQ0FBdEI7QUFDQSxJQUFNUyxpQkFBaUJmLEtBQUtELGlCQUFpQixnQkFBakIsQ0FBTCxFQUF5Q08sVUFBekMsQ0FBdkI7QUFDQSxJQUFNVSxlQUFlaEIsS0FBS0QsaUJBQWlCLGNBQWpCLENBQUwsRUFBdUNPLFVBQXZDLENBQXJCO0FBQ0EsSUFBTVcsV0FBV2QsTUFDZlUsV0FEZSxFQUVmRSxjQUZlLEVBR2ZDLFlBSGUsRUFJZkYsYUFKZSxDQUFqQjs7QUFPQSxJQUFNSSxjQUFjbEIsS0FBS0QsaUJBQWlCLGFBQWpCLENBQUwsRUFBc0NPLFVBQXRDLENBQXBCO0FBQ0EsSUFBTWEsZ0JBQWdCbkIsS0FBS0QsaUJBQWlCLGVBQWpCLENBQUwsRUFBd0NPLFVBQXhDLENBQXRCO0FBQ0EsSUFBTWMsaUJBQWlCcEIsS0FBS0QsaUJBQWlCLGdCQUFqQixDQUFMLEVBQXlDTyxVQUF6QyxDQUF2QjtBQUNBLElBQU1lLGVBQWVyQixLQUFLRCxpQkFBaUIsY0FBakIsQ0FBTCxFQUF1Q08sVUFBdkMsQ0FBckI7QUFDQSxJQUFNZ0IsV0FBV25CLE1BQ2ZlLFdBRGUsRUFFZkUsY0FGZSxFQUdmQyxZQUhlLEVBSWZGLGFBSmUsQ0FBakI7O0FBT0EsSUFBTUksY0FBY3ZCLEtBQUtELGlCQUFpQixhQUFqQixDQUFMLEVBQXNDTyxVQUF0QyxDQUFwQjtBQUNBLElBQU1rQixnQkFBZ0J4QixLQUFLRCxpQkFBaUIsZUFBakIsQ0FBTCxFQUF3Q08sVUFBeEMsQ0FBdEI7QUFDQSxJQUFNbUIsaUJBQWlCekIsS0FBS0QsaUJBQWlCLGdCQUFqQixDQUFMLEVBQXlDTyxVQUF6QyxDQUF2QjtBQUNBLElBQU1vQixlQUFlMUIsS0FBS0QsaUJBQWlCLGNBQWpCLENBQUwsRUFBdUNPLFVBQXZDLENBQXJCO0FBQ0EsSUFBTXFCLFdBQVd4QixNQUNmb0IsV0FEZSxFQUVmRSxjQUZlLEVBR2ZDLFlBSGUsRUFJZkYsYUFKZSxDQUFqQjs7QUFPQSxJQUFNSSxXQUFXNUIsS0FBS0QsaUJBQWlCLFVBQWpCLENBQUwsRUFBbUNPLFVBQW5DLENBQWpCO0FBQ0EsSUFBTXVCLFdBQVc3QixLQUFLRCxpQkFBaUIsVUFBakIsQ0FBTCxFQUFtQ08sVUFBbkMsQ0FBakI7QUFDQSxJQUFNd0IsVUFBVTNCLE1BQU15QixRQUFOLEVBQWdCQyxRQUFoQixDQUFoQjs7QUFFQSxJQUFNRSxhQUFhL0IsS0FBS0QsaUJBQWlCLFlBQWpCLENBQUwsRUFBcUNPLFVBQXJDLENBQW5CO0FBQ0EsSUFBTTBCLGFBQWFoQyxLQUFLRCxpQkFBaUIsWUFBakIsQ0FBTCxFQUFxQ08sVUFBckMsQ0FBbkI7QUFDQSxJQUFNMkIsWUFBWTlCLE1BQU00QixVQUFOLEVBQWtCQyxVQUFsQixDQUFsQjs7QUFFQSxJQUFNRSxhQUFhbEMsS0FBS0QsaUJBQWlCLFlBQWpCLENBQUwsRUFBcUNPLFVBQXJDLENBQW5CO0FBQ0EsSUFBTTZCLGFBQWFuQyxLQUFLRCxpQkFBaUIsWUFBakIsQ0FBTCxFQUFxQ08sVUFBckMsQ0FBbkI7QUFDQSxJQUFNOEIsWUFBWWpDLE1BQU0rQixVQUFOLEVBQWtCQyxVQUFsQixDQUFsQjs7QUFFQSxJQUFNRSxhQUFhckMsS0FBS0QsaUJBQWlCLFlBQWpCLENBQUwsRUFBcUNPLFVBQXJDLENBQW5CO0FBQ0EsSUFBTWdDLGFBQWF0QyxLQUFLRCxpQkFBaUIsWUFBakIsQ0FBTCxFQUFxQ08sVUFBckMsQ0FBbkI7QUFDQSxJQUFNaUMsWUFBWXBDLE1BQU1rQyxVQUFOLEVBQWtCQyxVQUFsQixDQUFsQjs7Ozs7Ozs7QUFRQSxJQUFNRSxTQUFTLFNBQVRBLE1BQVMsQ0FBQ0MsR0FBRDtTQUFpQm5FLGFBQWE7Z0JBQVdtRSxHQUFYLEdBQWlCdkMsSUFBakI7R0FBYixDQUFqQjtDQUFmO0FBQ0EsSUFBTXdDLFVBQVUsU0FBVkEsT0FBVSxRQUFTO1VBQ2ZDLEtBQVI7U0FDTyxNQUFMO2FBQ1NqRixjQUFjLGFBQWQsRUFBNkIsY0FBN0IsQ0FBUDtTQUNHLFlBQUw7YUFDU0EsY0FBYyxhQUFkLEVBQTZCLGlCQUE3QixDQUFQO1NBQ0csYUFBTDthQUNTQSxjQUFjLG9CQUFkLENBQVA7U0FDRyxnQkFBTDthQUNTQSxjQUFjLHVCQUFkLENBQVA7U0FDRyxLQUFMO2FBQ1NBLGNBQWMsYUFBZCxDQUFQOzs7YUFHT0EsY0FBYyxjQUFkLENBQVA7O0NBZE47QUFpQkEsSUFBTWtGLFNBQVNsRCxNQUFNLEtBQU4sQ0FBZjs7QUFFQSxJQUFNbUQsaUJBQWlCLFNBQWpCQSxjQUFpQjtTQUFNQyxJQUFJLENBQUosU0FBWWpELEtBQUtDLEdBQUwsQ0FBU2dELENBQVQsQ0FBWixHQUE0QkEsRUFBRUMsUUFBRixFQUFsQztDQUF2Qjs7Ozs7Ozs7QUFRQSxJQUFNQyxXQUFXO01BQ1gsbUJBQVM7UUFDUCxDQUFDTCxLQUFMLEVBQVk7YUFDSG5GLFVBQVA7O1dBRUtjLGFBQWE7YUFBS1AsT0FBT2tGLENBQVAsQ0FBTDtLQUFiLEVBQ0xULE9BQU8sSUFBUCxFQUNFMUUsT0FBTyxDQUNMNkUsTUFBTUMsTUFBTixHQUFlQSxPQUFPRCxNQUFNQyxNQUFiLENBQWYsR0FBc0NwRixVQURqQyxFQUVMLE9BQU9tRixNQUFNRCxPQUFiLEtBQXlCLFdBQXpCLEdBQ0lBLFFBQVFDLE1BQU1ELE9BQWQsQ0FESixHQUVJbEYsVUFKQyxDQUFQLENBREYsQ0FESyxDQUFQO0dBTGE7TUFnQlgsbUJBQVM7UUFDUCxDQUFDbUYsS0FBTCxFQUFZO2FBQ0huRixVQUFQOztXQUVLYyxhQUFhO2FBQUtQLE9BQU9rRixDQUFQLENBQUw7S0FBYixFQUNMVCxPQUFPLElBQVAsRUFDRTFFLE9BQU8sQ0FDTDZFLE1BQU1DLE1BQU4sR0FBZUEsT0FBT0QsTUFBTUMsTUFBYixDQUFmLEdBQXNDcEYsVUFEakMsRUFFTCxPQUFPbUYsTUFBTUQsT0FBYixLQUF5QixXQUF6QixHQUNJQSxRQUFRQyxNQUFNRCxPQUFkLENBREosR0FFSWxGLFVBSkMsQ0FBUCxDQURGLENBREssQ0FBUDtHQXBCYTtNQStCWCxtQkFBUztRQUNQLENBQUNtRixLQUFMLEVBQVk7YUFDSG5GLFVBQVA7O1dBRUtjLGFBQWE7YUFBS1AsT0FBT2tGLENBQVAsQ0FBTDtLQUFiLEVBQ0xULE9BQU8sSUFBUCxFQUNFMUUsT0FBTyxDQUNMNkUsTUFBTUMsTUFBTixHQUFlQSxPQUFPRCxNQUFNQyxNQUFiLENBQWYsR0FBc0NwRixVQURqQyxFQUVMLE9BQU9tRixNQUFNRCxPQUFiLEtBQXlCLFdBQXpCLEdBQ0lBLFFBQVFDLE1BQU1ELE9BQWQsQ0FESixHQUVJbEYsVUFKQyxDQUFQLENBREYsQ0FESyxDQUFQO0dBbkNhO01BOENYLG1CQUFTO1FBQ1AsQ0FBQ21GLEtBQUwsRUFBWTthQUNIbkYsVUFBUDs7V0FFS2MsYUFBYTthQUFLUCxPQUFPa0YsQ0FBUCxDQUFMO0tBQWIsRUFDTFQsT0FBTyxJQUFQLEVBQ0UxRSxPQUFPLENBQ0w2RSxNQUFNQyxNQUFOLEdBQWVBLE9BQU9ELE1BQU1DLE1BQWIsQ0FBZixHQUFzQ3BGLFVBRGpDLEVBRUwsT0FBT21GLE1BQU1ELE9BQWIsS0FBeUIsV0FBekIsR0FDSUEsUUFBUUMsTUFBTUQsT0FBZCxDQURKLEdBRUlsRixVQUpDLENBQVAsQ0FERixDQURLLENBQVA7R0FsRGE7O1dBOEROOEIsUUFBUTtVQUNUdkIsT0FBT21GLGFBREU7VUFFVG5GLE9BQU9vRixhQUZFO1dBR1JwRixPQUFPcUYsY0FIQztpQkFJRnJGLE9BQU9zRixvQkFKTDtvQkFLQ3RGLE9BQU91RjtHQUxoQixDQTlETTtVQXFFUHRELEtBQUtOLE1BQU0sT0FBTixDQUFMLEVBQXFCM0IsTUFBckIsQ0FyRU87YUFzRUp1QixRQUFRO1NBQ1p2QixPQUFPd0YsY0FESztZQUVUeEYsT0FBT3lGO0dBRk4sQ0F0RUk7O2FBMkVKbEUsUUFBUTtVQUNYdkIsT0FBTzBGLGFBREk7VUFFWDFGLE9BQU8yRixhQUZJO1dBR1YzRixPQUFPNEYsY0FIRztpQkFJSjVGLE9BQU82RixvQkFKSDtvQkFLRDdGLE9BQU84RjtHQUxkLENBM0VJO1lBa0ZMN0QsS0FBS04sTUFBTSxPQUFOLENBQUwsRUFBcUIzQixNQUFyQixDQWxGSztlQW1GRnVCLFFBQVE7U0FDZHZCLE9BQU8rRixjQURPO1lBRVgvRixPQUFPZ0c7R0FGSixDQW5GRTs7YUF3Rkp6RSxRQUFRO1VBQ1h2QixPQUFPaUcsYUFESTtVQUVYakcsT0FBT2tHLGFBRkk7V0FHVmxHLE9BQU9tRyxjQUhHO2lCQUlKbkcsT0FBT29HLG9CQUpIO29CQUtEcEcsT0FBT3FHO0dBTGQsQ0F4Rkk7WUErRkxwRSxLQUFLTixNQUFNLE9BQU4sQ0FBTCxFQUFxQjNCLE1BQXJCLENBL0ZLO2VBZ0dGdUIsUUFBUTtTQUNkdkIsT0FBT3NHLGNBRE87WUFFWHRHLE9BQU91RztHQUZKLENBaEdFOzthQXFHSmhGLFFBQVE7VUFDWHZCLE9BQU93RyxhQURJO1VBRVh4RyxPQUFPeUcsYUFGSTtXQUdWekcsT0FBTzBHLGNBSEc7aUJBSUoxRyxPQUFPMkcsb0JBSkg7b0JBS0QzRyxPQUFPNEc7R0FMZCxDQXJHSTtZQTRHTDNFLEtBQUtOLE1BQU0sT0FBTixDQUFMLEVBQXFCM0IsTUFBckIsQ0E1R0s7ZUE2R0Z1QixRQUFRO1NBQ2R2QixPQUFPNkcsY0FETztZQUVYN0csT0FBTzhHO0dBRkosQ0E3R0U7O2dCQWtIRHZGLFFBQVE7V0FDYndGLE9BQU9DLFlBRE07U0FFZkQsT0FBT0UsVUFGUTtZQUdaRixPQUFPRyxhQUhLO2FBSVhILE9BQU9JLGNBSkk7WUFLWkosT0FBT0s7O0dBTEgsQ0FsSEM7Y0EwSEg3RixRQUFRO1dBQ1h3RixPQUFPTSxVQURJO1NBRWJOLE9BQU9PLFFBRk07WUFHVlAsT0FBT1EsV0FIRztjQUlSUixPQUFPUzs7R0FKUCxDQTFIRzthQWlJSmpHLFFBQVE7V0FDVndGLE9BQU9VLFNBREc7U0FFWlYsT0FBT1csT0FGSztZQUdUWCxPQUFPWSxVQUhFO2NBSVBaLE9BQU9hLFlBSkE7YUFLUmIsT0FBT2M7O0dBTFAsQ0FqSUk7VUF5SVB4RyxPQUFPMEYsT0FBT2UsT0FBZCxDQXpJTztTQTBJUnZHLFFBQVE7VUFDUHdHLE9BQU9DLE1BREE7Y0FFSEQsT0FBT0UsVUFGSjtVQUdQRixPQUFPRyxNQUhBO1VBSVBILE9BQU9JLE1BSkE7U0FLUkosT0FBT0ssS0FMQztXQU1OTCxPQUFPTSxPQU5EO2VBT0ZOLE9BQU9PLFdBUEw7V0FRTlAsT0FBT1EsT0FSRDtZQVNMUixPQUFPUyxRQVRGO1dBVU5ULE9BQU9VLE9BVkQ7VUFXUFYsT0FBT1csTUFYQTtjQVlIWCxPQUFPWSxVQVpKO1lBYUxaLE9BQU9hLFFBYkY7WUFjTGIsT0FBT2MsUUFkRjtjQWVIZCxPQUFPZSxVQWZKO1lBZ0JMZixPQUFPZ0IsUUFoQkY7Z0JBaUJEaEIsT0FBT2lCLFlBakJOO2VBa0JGakIsT0FBT2tCLFdBbEJMO2NBbUJIbEIsT0FBT21COztHQW5CWixDQTFJUTtPQWdLVjdILE9BQU8wRixPQUFPb0MsR0FBZCxDQWhLVTtRQWlLVDVILFFBQVE7VUFDTndGLE9BQU9xQyxRQUREO1VBRU5yQyxPQUFPc0M7O0dBRlQsQ0FqS1M7Ozs7Ozs7Ozs7O0lBc0tQO1dBQVV4SixnQkFBZ0IsRUFBRXlKLGNBQUYsRUFBaEIsQ0FBVjtHQUFSLENBdEtlO2tCQXVLQy9ILFFBQVE7U0FDakJ3RixPQUFPd0MsVUFEVTtZQUVkeEMsT0FBT3lDLGFBRk87YUFHYnpDLE9BQU8wQyxjQUhNO1lBSWQxQyxPQUFPMkM7O0dBSkQsQ0F2S0Q7UUE4S1RySSxPQUFPMEYsT0FBTzRDLEtBQWQsQ0E5S1M7b0JBK0tHLGlDQUFTO1FBQ3JCQyxLQUFLbkssVUFBVDtRQUNJb0ssS0FBS3BLLFVBQVQ7UUFDSXFLLEtBQUtySyxVQUFUO1FBQ0lzSyxLQUFLdEssVUFBVDttQkFDZW1GLEtBQWYseUNBQWVBLEtBQWY7V0FDTyxRQUFMO2VBQ1NqRixjQUFjcUssdUJBQXFCbEYsZUFBZUYsS0FBZixDQUFyQixDQUFkLENBQVA7V0FDRyxRQUFMO1lBQ01BLE1BQU1xRixHQUFWLEVBQWU7ZUFDUnRLLGNBQ0hxSyx3QkFBc0JsRixlQUFlRixNQUFNcUYsR0FBckIsQ0FBdEIsQ0FERyxDQUFMOzs7WUFLRXJGLE1BQU1zRixNQUFWLEVBQWtCO2VBQ1h2SyxjQUNIcUssd0JBQXNCbEYsZUFBZUYsTUFBTXNGLE1BQXJCLENBQXRCLENBREcsQ0FBTDs7O1lBS0V0RixNQUFNdUYsSUFBVixFQUFnQjtlQUNUeEssY0FDSGlGLE1BQU11RixJQUFOLEtBQWUsTUFBZixHQUNJSCxpQkFBaUJJLE1BRHJCLEdBRUlKLHdCQUFzQmxGLGVBQWVGLE1BQU11RixJQUFyQixDQUF0QixDQUhELENBQUw7OztZQU9FdkYsTUFBTXlGLEtBQVYsRUFBaUI7ZUFDVjFLLGNBQ0hpRixNQUFNeUYsS0FBTixLQUFnQixNQUFoQixHQUNJTCxpQkFBaUJNLE1BRHJCLEdBRUlOLHdCQUFzQmxGLGVBQWVGLE1BQU15RixLQUFyQixDQUF0QixDQUhELENBQUw7O2VBTUt0SyxPQUFPLENBQUM2SixFQUFELEVBQUtDLEVBQUwsRUFBU0MsRUFBVCxFQUFhQyxFQUFiLENBQVAsQ0FBUDs7ZUFFT3RLLFVBQVA7O0dBck5TOzBCQUFBO3NCQUFBO2dCQUFBO3NCQUFBOzBCQUFBOzRCQUFBO3dCQUFBO29CQUFBOzBCQUFBOzhCQUFBO2dDQUFBOzRCQUFBO29CQUFBOzBCQUFBOzhCQUFBO2dDQUFBOzRCQUFBO29CQUFBOzBCQUFBOzhCQUFBO2dDQUFBOzRCQUFBOzs7Ozs7Ozs7OztJQThPSjtXQUFhSSxnQkFBZ0IsRUFBRTBLLG9CQUFGLEVBQWhCLENBQWI7R0FBWCxDQTlPZTs7Ozs7Ozs7Ozs7SUErT0w7V0FBWTFLLGdCQUFnQixFQUFFMkssa0JBQUYsRUFBaEIsQ0FBWjtHQUFWLENBL09lOzs7Ozs7Ozs7OztJQWdQSjtXQUFhM0ssZ0JBQWdCLEVBQUU0SyxvQkFBRixFQUFoQixDQUFiO0dBQVgsQ0FoUGU7Ozs7Ozs7Ozs7O0lBaVBMO1dBQVk1SyxnQkFBZ0IsRUFBRTZLLGtCQUFGLEVBQWhCLENBQVo7R0FBVixDQWpQZTtZQWtQTG5KLFFBQVE7WUFDUndGLE9BQU80RCxjQURDO1lBRVI1RCxPQUFPNkQsY0FGQztVQUdWN0QsT0FBTzhELFlBSEc7YUFJUDlELE9BQU8rRCxlQUpBO2FBS1AvRCxPQUFPZ0U7O0dBTFIsQ0FsUEs7cUJBMFBJLGtDQUFTO21CQUNYbkcsS0FBZix5Q0FBZUEsS0FBZjtXQUNPLFFBQUw7ZUFDU2pGLGNBQWNxSyx1QkFBcUJwRixLQUFyQixDQUFkLENBQVA7V0FDRyxRQUFMO2VBQ1M3RSxPQUFPLENBQ1o2RSxNQUFNRyxDQUFOLEdBQ0lwRixjQUFjcUssd0JBQXNCcEYsTUFBTUcsQ0FBNUIsQ0FBZCxDQURKLEdBRUl0RixVQUhRLEVBSVptRixNQUFNb0csQ0FBTixHQUNJckwsY0FBY3FLLHdCQUFzQnBGLE1BQU1vRyxDQUE1QixDQUFkLENBREosR0FFSXZMLFVBTlEsQ0FBUCxDQUFQOztlQVNPQSxVQUFQOztHQXhRUztrQkFBQTtvQkFBQTtvQkFBQTtzQkFBQTt3QkFBQTt3QkFBQTtzQkFBQTt3QkFBQTt3QkFBQTtzQkFBQTt3QkFBQTt3QkFBQTtZQXVSTDhCLFFBQVE7Y0FDTndGLE9BQU9rRSxRQUREO2NBRU5sRSxPQUFPbUUsUUFGRDtXQUdUbkUsT0FBT29FOztHQUhOLENBdlJLO1NBNlJSOUosT0FBTzBGLE9BQU9xRSxNQUFkLENBN1JRO1NBOFJSN0osUUFBUTtZQUNMOEosUUFBUUMsTUFESDtVQUVQRCxRQUFRRSxJQUZEO2FBR0pGLFFBQVFHLE9BSEo7bUJBSUVILFFBQVFJLGFBSlY7aUJBS0FKLFFBQVFLLFdBTFI7a0JBTUNMLFFBQVFNLFlBTlQ7Z0JBT0ROLFFBQVFPOztHQVBmLENBOVJRO09Bd1NWdkssT0FBTzBGLE9BQU84RSxJQUFkLENBeFNVOzs7Ozs7Ozs7OztJQXlTUjtXQUFTaE0sZ0JBQWdCLEVBQUVpTSxZQUFGLEVBQWhCLENBQVQ7R0FBUCxDQXpTZTtRQTBTVHpLLE9BQU8wRixPQUFPZ0YsUUFBZCxDQTFTUzs2QkEyU1k7OztlQUVoQm5ILE1BQU1vSCxPQUFmLEdBQXlCbk0sZ0JBQWdCK0UsTUFBTW9ILE9BQXRCLENBQXpCLEdBQTBEdk07OztDQTdTOUQ7Ozs7Ozs7O0FBc1RBLElBQU13TSxXQUFXLFNBQVhBLFFBQVcsQ0FBQ0MsR0FBRCxFQUFNQyxHQUFOO1NBQWNBLElBQUlDLE9BQUosQ0FBWUYsR0FBWixLQUFvQixDQUFsQztDQUFqQjtBQUNBLElBQU1HLE9BQU8sU0FBUEEsSUFBTyxDQUFDbkwsSUFBRCxFQUFPb0wsR0FBUDtTQUNYckwsT0FBT0MsSUFBUCxDQUFZb0wsR0FBWixFQUFpQnJNLE1BQWpCLENBQXdCLFVBQUNzTSxHQUFELEVBQU1DLENBQU4sRUFBWTtRQUM5QlAsU0FBU08sQ0FBVCxFQUFZdEwsSUFBWixDQUFKLEVBQXVCO2FBQ2RxTCxHQUFQOzt3QkFHR0EsR0FETCxxQkFFR0MsQ0FGSCxFQUVPRixJQUFJRSxDQUFKLENBRlA7R0FKRixFQVFHLEVBUkgsQ0FEVztDQUFiOzs7QUFZQSxJQUFNQyxNQUFNQyxVQUFBLENBQ1YsZ0JBQW1DQyxHQUFuQyxFQUFnRTtNQUE3REMsUUFBNkQsUUFBN0RBLFFBQTZEO01BQWhEL0wsS0FBZ0Q7Ozs7Ozs7Ozs7TUFTMURnTSxZQUFZLENBQUMsU0FBRCxFQUFZLFdBQVosRUFBeUIsT0FBekIsQ0FBaEI7Ozs7TUFJSUMsSUFBSW5OLGNBQWNLLE9BQU8rTSxHQUFyQixDQUFSOzs7Ozs7Ozs7Ozs7T0FZSyxJQUFNQyxJQUFYLElBQW1Cbk0sS0FBbkIsRUFBMEI7UUFDcEJJLE9BQU9PLFNBQVAsQ0FBaUJDLGNBQWpCLENBQWdDQyxJQUFoQyxDQUFxQ3VELFFBQXJDLEVBQStDK0gsSUFBL0MsQ0FBSixFQUEwRDtVQUNsRHhNLEtBQUt5RSxTQUFTK0gsSUFBVCxDQUFYO1VBQ01wSSxRQUFRL0QsTUFBTW1NLElBQU4sQ0FBZDtrQkFDWUgsVUFBVTlNLE1BQVYsQ0FBaUJpTixJQUFqQixDQUFaO1VBQ0lqTixPQUFPLENBQUMrTSxDQUFELEVBQUl0TSxHQUFHb0UsS0FBSCxDQUFKLENBQVAsQ0FBSjs7Ozs7U0FNRnFJOztpQkFBU1osS0FBS1EsU0FBTCxFQUFnQmhNLEtBQWhCLENBQVQsRUFBcUNELFFBQVFrTSxDQUFSLENBQXJDLElBQWlELEtBQUtILEdBQXREOztHQURGO0NBcENRLENBQVo7Ozs7QUE4Q0FGLElBQUlTLFdBQUosR0FBa0IsS0FBbEI7Ozs7Ozs7Ozs7QUFZQSxJQUFNQyxpQkFBaUJDLFVBQVVDLEtBQVYsQ0FBZ0IsQ0FDckMsQ0FEcUMsRUFFckMsQ0FGcUMsRUFHckMsQ0FIcUMsRUFJckMsQ0FKcUMsRUFLckMsQ0FMcUMsRUFNckMsQ0FOcUMsRUFPckMsQ0FQcUMsRUFRckMsQ0FScUMsRUFTckMsQ0FUcUMsRUFVckMsQ0FWcUMsRUFXckMsRUFYcUMsRUFZckMsRUFacUMsRUFhckMsRUFicUMsQ0FBaEIsQ0FBdkI7O0FBZ0JBLElBQU1DLGlCQUFpQkYsVUFBVUMsS0FBVixDQUFnQixDQUNyQyxDQUFDLEVBRG9DLEVBRXJDLENBQUMsRUFGb0MsRUFHckMsQ0FBQyxFQUhvQyxFQUlyQyxDQUFDLENBSm9DLEVBS3JDLENBQUMsQ0FMb0MsRUFNckMsQ0FBQyxDQU5vQyxFQU9yQyxDQUFDLENBUG9DLEVBUXJDLENBQUMsQ0FSb0MsRUFTckMsQ0FBQyxDQVRvQyxFQVVyQyxDQUFDLENBVm9DLEVBV3JDLENBQUMsQ0FYb0MsRUFZckMsQ0FBQyxDQVpvQyxFQWFyQyxDQWJxQyxFQWNyQyxDQWRxQyxFQWVyQyxDQWZxQyxFQWdCckMsQ0FoQnFDLEVBaUJyQyxDQWpCcUMsRUFrQnJDLENBbEJxQyxFQW1CckMsQ0FuQnFDLEVBb0JyQyxDQXBCcUMsRUFxQnJDLENBckJxQyxFQXNCckMsQ0F0QnFDLEVBdUJyQyxFQXZCcUMsRUF3QnJDLEVBeEJxQyxFQXlCckMsRUF6QnFDLENBQWhCLENBQXZCOztBQTRCQSxJQUFNRSxrQkFBa0JILFVBQVVDLEtBQVYsQ0FBZ0IsQ0FDdEMsQ0FEc0MsRUFFdEMsQ0FGc0MsRUFHdEMsQ0FIc0MsRUFJdEMsQ0FKc0MsRUFLdEMsQ0FMc0MsRUFNdEMsQ0FOc0MsRUFPdEMsQ0FQc0MsRUFRdEMsQ0FSc0MsRUFTdEMsQ0FUc0MsRUFVdEMsQ0FWc0MsRUFXdEMsRUFYc0MsRUFZdEMsRUFac0MsRUFhdEMsRUFic0MsQ0FBaEIsQ0FBeEI7O0FBZ0JBWixJQUFJZSxTQUFKLEdBQWdCO1lBQ0pKLFVBQVVLLElBRE47NkJBRWFMLFVBQVVNLEtBQVYsQ0FBZ0I7YUFDaENOLFVBQVVPO0dBRE0sQ0FGYjs7TUFNVlAsVUFBVU0sS0FBVixDQUFnQjthQUNUTixVQUFVUSxTQUFWLENBQW9CLENBQzNCUixVQUFVUyxJQURpQixFQUUzQlQsVUFBVUMsS0FBVixDQUFnQixDQUFDLE1BQUQsRUFBUyxZQUFULEVBQXVCLGFBQXZCLENBQWhCLENBRjJCLENBQXBCLENBRFM7WUFLVkQsVUFBVVU7R0FMaEIsQ0FOVTtNQWFWVixVQUFVTSxLQUFWLENBQWdCO2FBQ1ROLFVBQVVRLFNBQVYsQ0FBb0IsQ0FDM0JSLFVBQVVTLElBRGlCLEVBRTNCVCxVQUFVQyxLQUFWLENBQWdCLENBQUMsTUFBRCxFQUFTLFlBQVQsRUFBdUIsYUFBdkIsQ0FBaEIsQ0FGMkIsQ0FBcEIsQ0FEUztZQUtWRCxVQUFVVTtHQUxoQixDQWJVO01Bb0JWVixVQUFVTSxLQUFWLENBQWdCO2FBQ1ROLFVBQVVRLFNBQVYsQ0FBb0IsQ0FDM0JSLFVBQVVTLElBRGlCLEVBRTNCVCxVQUFVQyxLQUFWLENBQWdCLENBQUMsTUFBRCxFQUFTLFlBQVQsRUFBdUIsYUFBdkIsQ0FBaEIsQ0FGMkIsQ0FBcEIsQ0FEUztZQUtWRCxVQUFVVTtHQUxoQixDQXBCVTtNQTJCVlYsVUFBVU0sS0FBVixDQUFnQjthQUNUTixVQUFVUSxTQUFWLENBQW9CLENBQzNCUixVQUFVUyxJQURpQixFQUUzQlQsVUFBVUMsS0FBVixDQUFnQixDQUFDLE1BQUQsRUFBUyxZQUFULEVBQXVCLGFBQXZCLENBQWhCLENBRjJCLENBQXBCLENBRFM7WUFLVkQsVUFBVVU7R0FMaEIsQ0EzQlU7b0JBa0NJVixVQUFVUSxTQUFWLENBQW9CLENBQ3BDUixVQUFVVSxNQUQwQixFQUVwQ1YsVUFBVVcsS0FBVixDQUFnQjtTQUNUWCxVQUFVVSxNQUREO1lBRU5WLFVBQVVVLE1BRko7VUFHUlYsVUFBVVEsU0FBVixDQUFvQixDQUFDUixVQUFVVSxNQUFYLEVBQW1CVixVQUFVQyxLQUFWLENBQWdCLENBQUMsTUFBRCxDQUFoQixDQUFuQixDQUFwQixDQUhRO1dBSVBELFVBQVVRLFNBQVYsQ0FBb0IsQ0FBQ1IsVUFBVVUsTUFBWCxFQUFtQlYsVUFBVUMsS0FBVixDQUFnQixDQUFDLE1BQUQsQ0FBaEIsQ0FBbkIsQ0FBcEI7R0FKVCxDQUZvQyxDQUFwQixDQWxDSjtxQkEyQ0tELFVBQVVRLFNBQVYsQ0FBb0IsQ0FDckNSLFVBQVVVLE1BRDJCLEVBRXJDVixVQUFVVyxLQUFWLENBQWdCO09BQ1hYLFVBQVVVLE1BREM7T0FFWFYsVUFBVVU7R0FGZixDQUZxQyxDQUFwQixDQTNDTDs7V0FtRExWLFVBQVVDLEtBQVYsQ0FBZ0IsQ0FDdkIsTUFEdUIsRUFFdkIsTUFGdUIsRUFHdkIsT0FIdUIsRUFJdkIsYUFKdUIsRUFLdkIsZ0JBTHVCLENBQWhCLENBbkRLO2FBMERIRCxVQUFVQyxLQUFWLENBQWdCLENBQUMsS0FBRCxFQUFRLFFBQVIsQ0FBaEIsQ0ExREc7VUEyRE5GLGNBM0RNOzthQTZESEMsVUFBVUMsS0FBVixDQUFnQixDQUN6QixNQUR5QixFQUV6QixNQUZ5QixFQUd6QixPQUh5QixFQUl6QixhQUp5QixFQUt6QixnQkFMeUIsQ0FBaEIsQ0E3REc7ZUFvRURELFVBQVVDLEtBQVYsQ0FBZ0IsQ0FBQyxLQUFELEVBQVEsUUFBUixDQUFoQixDQXBFQztZQXFFSkYsY0FyRUk7O2FBdUVIQyxVQUFVQyxLQUFWLENBQWdCLENBQ3pCLE1BRHlCLEVBRXpCLE1BRnlCLEVBR3pCLE9BSHlCLEVBSXpCLGFBSnlCLEVBS3pCLGdCQUx5QixDQUFoQixDQXZFRztlQThFREQsVUFBVUMsS0FBVixDQUFnQixDQUFDLEtBQUQsRUFBUSxRQUFSLENBQWhCLENBOUVDO1lBK0VKRixjQS9FSTs7YUFpRkhDLFVBQVVDLEtBQVYsQ0FBZ0IsQ0FDekIsTUFEeUIsRUFFekIsTUFGeUIsRUFHekIsT0FIeUIsRUFJekIsYUFKeUIsRUFLekIsZ0JBTHlCLENBQWhCLENBakZHO2VBd0ZERCxVQUFVQyxLQUFWLENBQWdCLENBQUMsS0FBRCxFQUFRLFFBQVIsQ0FBaEIsQ0F4RkM7WUF5RkpGLGNBekZJOztnQkEyRkFDLFVBQVVDLEtBQVYsQ0FBZ0IsQ0FDNUIsT0FENEIsRUFFNUIsS0FGNEIsRUFHNUIsUUFINEIsRUFJNUIsU0FKNEIsRUFLNUIsUUFMNEIsRUFNNUIsU0FONEIsQ0FBaEIsQ0EzRkE7Y0FtR0ZELFVBQVVDLEtBQVYsQ0FBZ0IsQ0FDMUIsT0FEMEIsRUFFMUIsS0FGMEIsRUFHMUIsUUFIMEIsRUFJMUIsVUFKMEIsRUFLMUIsU0FMMEIsQ0FBaEIsQ0FuR0U7YUEwR0hELFVBQVVDLEtBQVYsQ0FBZ0IsQ0FDekIsTUFEeUIsRUFFekIsT0FGeUIsRUFHekIsS0FIeUIsRUFJekIsUUFKeUIsRUFLekIsVUFMeUIsRUFNekIsU0FOeUIsQ0FBaEIsQ0ExR0c7VUFrSE5ELFVBQVVTLElBbEhKO1NBbUhQVCxVQUFVQyxLQUFWLENBQWdCLENBQ3JCLE1BRHFCLEVBRXJCLFVBRnFCLEVBR3JCLFVBSHFCLEVBSXJCLFVBSnFCLEVBS3JCLE1BTHFCLEVBTXJCLE9BTnFCLEVBT3JCLFdBUHFCLEVBUXJCLFdBUnFCLEVBU3JCLFFBVHFCLEVBVXJCLFVBVnFCLEVBV3JCLE1BWHFCLEVBWXJCLE9BWnFCLEVBYXJCLFFBYnFCLEVBY3JCLFFBZHFCLEVBZXJCLE1BZnFCLEVBZ0JyQixRQWhCcUIsRUFpQnJCLEtBakJxQixFQWtCckIsYUFsQnFCLEVBbUJyQixZQW5CcUIsRUFvQnJCLE9BcEJxQixDQUFoQixDQW5ITztPQXlJVEQsVUFBVVMsSUF6SUQ7UUEwSVJULFVBQVVDLEtBQVYsQ0FBZ0IsQ0FBQyxNQUFELEVBQVMsUUFBVCxFQUFtQixNQUFuQixDQUFoQixDQTFJUTtRQTJJUkQsVUFBVVMsSUEzSUY7VUE0SU5ULFVBQVVRLFNBQVYsQ0FBb0IsQ0FBQ1IsVUFBVVUsTUFBWCxFQUFtQlYsVUFBVVksTUFBN0IsQ0FBcEIsQ0E1SU07a0JBNklFWixVQUFVQyxLQUFWLENBQWdCLENBQzlCLE9BRDhCLEVBRTlCLEtBRjhCLEVBRzlCLFFBSDhCLEVBSTlCLFNBSjhCLEVBSzlCLFFBTDhCLENBQWhCLENBN0lGO1FBb0pSRCxVQUFVUyxJQXBKRjs7ZUFzSkRQLGNBdEpDO2FBdUpIQSxjQXZKRzs7VUF5Sk5BLGNBekpNO2FBMEpIQSxjQTFKRztlQTJKREEsY0EzSkM7Z0JBNEpBQSxjQTVKQTtjQTZKRkEsY0E3SkU7O1lBK0pKQSxjQS9KSTtlQWdLREEsY0FoS0M7aUJBaUtDQSxjQWpLRDtrQkFrS0VBLGNBbEtGO2dCQW1LQUEsY0FuS0E7O1lBcUtKQSxjQXJLSTtlQXNLREEsY0F0S0M7aUJBdUtDQSxjQXZLRDtrQkF3S0VBLGNBeEtGO2dCQXlLQUEsY0F6S0E7O1lBMktKQSxjQTNLSTtlQTRLREEsY0E1S0M7aUJBNktDQSxjQTdLRDtrQkE4S0VBLGNBOUtGO2dCQStLQUEsY0EvS0E7O2FBaUxIRixVQUFVUSxTQUFWLENBQW9CLENBQUNSLFVBQVVVLE1BQVgsRUFBbUJWLFVBQVVZLE1BQTdCLENBQXBCLENBakxHO1lBa0xKWixVQUFVUSxTQUFWLENBQW9CLENBQUNSLFVBQVVVLE1BQVgsRUFBbUJWLFVBQVVZLE1BQTdCLENBQXBCLENBbExJO2FBbUxIWixVQUFVUSxTQUFWLENBQW9CLENBQUNSLFVBQVVVLE1BQVgsRUFBbUJWLFVBQVVZLE1BQTdCLENBQXBCLENBbkxHO1lBb0xKWixVQUFVUSxTQUFWLENBQW9CLENBQUNSLFVBQVVVLE1BQVgsRUFBbUJWLFVBQVVZLE1BQTdCLENBQXBCLENBcExJOztZQXNMSlosVUFBVUMsS0FBVixDQUFnQixDQUN4QixTQUR3QixFQUV4QixRQUZ3QixFQUd4QixRQUh3QixFQUl4QixTQUp3QixFQUt4QixTQUx3QixFQU14QixNQU53QixDQUFoQixDQXRMSTs7V0ErTExFLGVBL0xLO1lBZ01KQSxlQWhNSTtZQWlNSkEsZUFqTUk7O2FBbU1IQSxlQW5NRztjQW9NRkEsZUFwTUU7Y0FxTUZBLGVBck1FOzthQXVNSEEsZUF2TUc7Y0F3TUZBLGVBeE1FO2NBeU1GQSxlQXpNRTs7YUEyTUhBLGVBM01HO2NBNE1GQSxlQTVNRTtjQTZNRkEsZUE3TUU7O1lBK01KSCxVQUFVQyxLQUFWLENBQWdCLENBQUMsUUFBRCxFQUFXLFVBQVgsRUFBdUIsVUFBdkIsRUFBbUMsT0FBbkMsQ0FBaEIsQ0EvTUk7U0FnTlBELFVBQVVTLElBaE5IO1NBaU5QVCxVQUFVQyxLQUFWLENBQWdCLENBQ3JCLFFBRHFCLEVBRXJCLFNBRnFCLEVBR3JCLE1BSHFCLEVBSXJCLFFBSnFCLEVBS3JCLFlBTHFCLEVBTXJCLGVBTnFCLEVBT3JCLGFBUHFCLEVBUXJCLGNBUnFCLENBQWhCLENBak5PO09BMk5URCxVQUFVUyxJQTNORDtTQTROUFQsVUFBVVEsU0FBVixDQUFvQixDQUFDUixVQUFVVSxNQUFYLEVBQW1CVixVQUFVWSxNQUE3QixDQUFwQixDQTVOTztRQTZOUlosVUFBVVM7Q0E3TmxCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDOW5CQSxZQUFlO1VBQUE7Z0JBRUNJLFNBRkQ7YUFHRkMsTUFIRTt5QkFJVUMsaUJBSlY7dUJBS1FDLGVBTFI7d0JBTVNDLGdCQU5UO2tCQU9HQyxXQVBIO2tCQVFHQyxXQVJIO3NCQVNPQyxjQVRQO29CQVVLQyxZQVZMO3FCQVdNQyxhQVhOO2VBWUFDLFFBWkE7Z0JBYUNDLFNBYkQ7WUFBQTtnQkFlQ0MsU0FmRDt1QkFnQlFDLGVBaEJSOzBCQWlCV0Msa0JBakJYO2dCQWtCQ0MsU0FsQkQ7bUJBbUJJQyxZQW5CSjtjQW9CREMsT0FwQkM7b0JBcUJLQyxZQXJCTDtZQUFBO2dCQUFBO2lCQXdCRUMsVUF4QkY7Z0JBQUE7bUJBMEJJQyxZQTFCSjtrQkEyQkdDLFdBM0JIO2NBQUE7a0JBNkJHQyxXQTdCSDtvQkE4QktDLGFBOUJMO2NBQUE7Y0FBQTtVQUFBO2tCQUFBO2tCQUFBO1lBQUE7WUFBQTtvQkFBQTtZQUFBO29CQUFBOzZCQXlDY0MscUJBekNkO29CQUFBO1VBQUE7b0JBQUE7Z0JBNkNDQyxTQTdDRDtjQThDREMsT0E5Q0M7aUJBK0NFQyxVQS9DRjtpQkFnREVDLFVBaERGO3NCQWlET0MsZUFqRFA7Z0JBQUE7WUFBQTt3QkFBQTtnQ0FBQTs0QkFBQTtVQUFBO2NBQUE7bUJBeURJQyxZQXpESjtjQUFBO2lCQTJERUMsVUEzREY7ZUE0REFDLFFBNURBO2dCQUFBO21CQThESUMsWUE5REo7Y0FBQTtrQkFnRUdDLFdBaEVIO3NCQUFBO2NBQUE7c0JBQUE7WUFBQTtvQkFBQTtZQUFBO2dCQXVFQ0MsU0F2RUQ7Z0JBd0VDQyxTQXhFRDtnQkFBQTttQkEwRUlDLFlBMUVKO29CQTJFS0MsYUEzRUw7bUJBNEVJQyxZQTVFSjtvQkFBQTtzQkFBQTtZQUFBO29CQUFBO1lBQUE7WUFBQTtrQkFtRkdDLFdBbkZIO2NBQUE7Z0JBQUE7Z0JBQUE7Z0JBdUZDQyxTQXZGRDtVQUFBO2NBeUZEQyxPQXpGQztzQkFBQTtZQUFBO21CQTRGSUMsWUE1Rko7Z0JBQUE7Z0JBQUE7Z0JBQUE7Z0JBQUE7b0JBQUE7a0JBa0dHQyxXQWxHSDtnQkFBQTtvQkFvR0tDLGFBcEdMO1lBQUE7Y0FBQTtjQUFBO2dCQUFBO3FCQXlHTUMsY0F6R047WUFBQTtvQkEyR0tDLGFBM0dMO1VBQUE7Y0FBQTtxQkE4R01DLGFBOUdOO3VCQStHUUMsZUEvR1I7c0JBZ0hPQyxjQWhIUDtzQkFpSE9DLGNBakhQO2dCQWtIQ0MsU0FsSEQ7aUJBbUhFQyxVQW5IRjtnQkFvSENDLFNBcEhEO2tCQUFBO3VCQXNIUUMsZUF0SFI7cUJBdUhNQyxhQXZITjtvQkF3SEtDO0NBeEhwQjs7QUM5RUEsSUFBTUMsWUFBWTFRLE9BQU9DLElBQVAsQ0FBWTBRLEtBQVosQ0FBbEI7O0FBRUEsQUFBZSxTQUFTQyxJQUFULENBQWNoUixLQUFkLEVBQTRCO01BRXZDaVIsa0JBRnVDLEdBUXJDalIsS0FScUMsQ0FFdkNpUixrQkFGdUM7cUJBUXJDalIsS0FScUMsQ0FHdkNrUixLQUh1QztNQUd2Q0EsS0FIdUMsZ0NBRy9CLE1BSCtCO01BSXZDQyxJQUp1QyxHQVFyQ25SLEtBUnFDLENBSXZDbVIsSUFKdUM7TUFLdkNDLE1BTHVDLEdBUXJDcFIsS0FScUMsQ0FLdkNvUixNQUx1QztvQkFRckNwUixLQVJxQyxDQU12Q0MsSUFOdUM7TUFNdkNBLElBTnVDLCtCQU1oQyxFQU5nQztNQU92Q29SLHFCQVB1QyxHQVFyQ3JSLEtBUnFDLENBT3ZDcVIscUJBUHVDOzs7TUFVbkNDLEtBQUtDLFdBQVdwUyxTQUFPZ1MsSUFBbEIsRUFBd0JqSyxPQUFPZ0ssS0FBUCxDQUF4QixxQkFDUi9SLFNBQU9xUyxTQURDLEVBQ1csQ0FBQ0osTUFEWixFQUFYOztNQUlNSyxPQUNITixRQUFRSixNQUFNSSxJQUFOLENBQVQ7OzJCQUUwQkUsc0JBQXNCSyxNQUZoRCxJQUdBQyxTQUpGOztNQU1NQyxhQUFhWCx1QkFBdUIsRUFBdkIsR0FBNEIsSUFBNUIsR0FBbUMsSUFBdEQ7O1NBR0U3RTs7O2lCQUNha0YsRUFEYjtjQUVVclIsSUFGVjthQUdTQSxJQUhUO2VBSVUsV0FKVjtxQkFLZTJSLFVBTGY7b0JBTWNYLGtCQU5kO1lBT087Ozs7OztLQVBQOzRCQVVRLEdBQUdRLElBQVQ7R0FYSjs7O0FBZ0JGVCxLQUFLRCxLQUFMLEdBQWFELFNBQWI7O0FBRUFFLEtBQUtyRSxTQUFMLEdBQWlCO3NCQUNLSixVQUFVWSxNQUFWLENBQWlCMEUsVUFEdEI7U0FFUnRGLFVBQVVDLEtBQVYsQ0FBZ0IsQ0FDckIsTUFEcUIsRUFFckIsVUFGcUIsRUFHckIsVUFIcUIsRUFJckIsTUFKcUIsRUFLckIsT0FMcUIsRUFNckIsV0FOcUIsRUFPckIsUUFQcUIsRUFRckIsVUFScUIsRUFTckIsTUFUcUIsRUFVckIsT0FWcUIsRUFXckIsUUFYcUIsRUFZckIsUUFacUIsRUFhckIsTUFicUIsRUFjckIsUUFkcUIsRUFlckIsS0FmcUIsRUFnQnJCLFlBaEJxQixFQWlCckIsT0FqQnFCLENBQWhCLENBRlE7eUJBcUJRRCxVQUFVVyxLQUFWLENBQWdCO1lBQzdCWCxVQUFVWTtHQURHLENBckJSO1FBd0JUWixVQUFVQyxLQUFWLENBQWdCc0UsU0FBaEIsQ0F4QlM7VUF5QlB2RSxVQUFVUyxJQXpCSDtRQTBCVFQsVUFBVVEsU0FBVixDQUFvQixDQUFDUixVQUFVVSxNQUFYLEVBQW1CVixVQUFVWSxNQUE3QixDQUFwQjtDQTFCUjs7OztBQ2hGQSxJQUFNMkUsbUJBQW1CLFNBQW5CQSxnQkFBbUI7U0FBT3hKLFFBQVEsT0FBUixJQUFtQkEsUUFBUSxTQUFsQztDQUF6Qjs7SUFnQnFCeUo7Ozs7Ozs7Ozs7Ozs7O21MQWlDbkJDLGFBQWEsWUFBTTtVQUNiLE1BQUtoUyxLQUFMLENBQVdpUyxNQUFmLEVBQXVCO2NBQ2hCalMsS0FBTCxDQUFXaVMsTUFBWDs7YUFJSkMsY0FBYyxZQUFNO1VBQ2QsTUFBS2xTLEtBQUwsQ0FBV21TLE9BQWYsRUFBd0I7Y0FDakJuUyxLQUFMLENBQVdtUyxPQUFYOzs7Ozs7O3dDQXJCZ0I7VUFDZEwsaUJBQWlCLEtBQUs5UixLQUFMLENBQVdzSSxHQUE1QixDQUFKLEVBQXNDO2FBQy9COEosU0FBTDs7Ozs7dUNBSWVDLFdBQWtCO21CQUNkLEtBQUtyUyxLQURTO1VBQzNCc0ksR0FEMkIsVUFDM0JBLEdBRDJCO1VBQ3RCZ0ssR0FEc0IsVUFDdEJBLEdBRHNCOztVQUUvQlIsaUJBQWlCeEosR0FBakIsS0FBeUIrSixVQUFVQyxHQUFWLEtBQWtCQSxHQUEvQyxFQUFvRDthQUM3Q0YsU0FBTDs7Ozs7Z0NBZ0JRO1VBQ04sT0FBT0csTUFBUCxLQUFrQixXQUF0QixFQUFtQztZQUMzQkMsUUFBUSxJQUFJRCxPQUFPUixLQUFYLEVBQWQ7Y0FDTVUsTUFBTixHQUFlLEtBQUtULFVBQXBCO2NBQ01VLE9BQU4sR0FBZ0IsS0FBS1IsV0FBckI7Y0FDTUksR0FBTixHQUFZLEtBQUt0UyxLQUFMLENBQVdzUyxHQUF2Qjs7Ozs7NkJBSUs7b0JBV0gsS0FBS3RTLEtBWEY7VUFFTDJTLEdBRkssV0FFTEEsR0FGSztVQUdMekIsS0FISyxXQUdMQSxLQUhLO1VBSUxuRixRQUpLLFdBSUxBLFFBSks7VUFLTHpELEdBTEssV0FLTEEsR0FMSztVQU1Mc0ssYUFOSyxXQU1MQSxhQU5LO1VBT0xDLFlBUEssV0FPTEEsWUFQSztVQVFMQyxLQVJLLFdBUUxBLEtBUks7VUFTTFIsR0FUSyxXQVNMQSxHQVRLO1VBVUxTLE1BVkssV0FVTEEsTUFWSzs7O1VBYURDLGdCQUFnQmxCLGlCQUFpQnhKLEdBQWpCLENBQXRCO1VBQ00ySyxlQUFlbEgsV0FDbkJLO1dBQUE7VUFBSyxVQUFTLFVBQWQsRUFBeUIsU0FBekIsRUFBNkIsVUFBN0IsRUFBa0MsWUFBbEMsRUFBeUMsV0FBekMsRUFBK0MsVUFBUyxRQUF4RDs7T0FEbUIsR0FJakIsSUFKSjs7YUFNTzRHLGdCQUNMNUc7Ozt3QkFDY3VHLEdBRGQ7cUJBRWF4VCxTQUFPbUosR0FBUCxDQUZiO2lCQUdTOzZCQUNZNEksS0FEWjt3Q0FFb0JvQixHQUF6QjtXQUxKO2dCQU9POzs7T0FSRixHQWFMbEc7V0FBQTs7b0JBQ1csVUFEWDtxQ0FFNkI7cUJBQ2hCOytCQUNVOEUsS0FEVjs2QkFFWTBCLGdCQUFnQkMsWUFBakIsR0FBaUMsR0FBbkQ7Ozs7O2VBS0dGLEdBRFA7cUJBRWF4VCxTQUFPK1QsR0FGcEI7bUJBR1csS0FBS2hCLFdBSGhCO2tCQUlVLEtBQUtGLFVBSmY7aUJBS1NjLEtBTFQ7ZUFNT1IsR0FOUDtrQkFPVVM7VUFoQlo7O09BYkY7Ozs7RUExRStCbEg7O0FBQWRrRyxNQUNacEYsWUFBWTtPQUNaSixVQUFVWSxNQUFWLENBQWlCMEUsVUFETDtZQUVQdEYsVUFBVUssSUFGSDtTQUdWTCxVQUFVWSxNQUhBO09BSVpaLFVBQVVDLEtBQVYsQ0FBZ0IsQ0FBQyxTQUFELEVBQVksT0FBWixFQUFxQixNQUFyQixDQUFoQixDQUpZO2lCQUtGRCxVQUFVVSxNQUFWLENBQWlCNEUsVUFMZjtnQkFNSHRGLFVBQVVVLE1BQVYsQ0FBaUI0RSxVQU5kO1dBT1J0RixVQUFVNEcsSUFQRjtVQVFUNUcsVUFBVTRHLElBUkQ7U0FTVjVHLFVBQVVZLE1BVEE7T0FVWlosVUFBVVksTUFBVixDQUFpQjBFLFVBVkw7VUFXVHRGLFVBQVVZOztBQVpENEUsTUFlWnFCLGVBQWU7U0FDYixhQURhO09BRWY7Ozs7O0FDekJNLFNBQVNDLElBQVQsQ0FBY3JULEtBQWQsRUFBNEI7TUFDakMrTCxRQURpQyxHQUMyQi9MLEtBRDNCLENBQ2pDK0wsUUFEaUM7cUJBQzJCL0wsS0FEM0IsQ0FDdkJrTixLQUR1QjtNQUN2QkEsS0FEdUIsZ0NBQ2YsUUFEZTtNQUNMakMsS0FESyxHQUMyQmpMLEtBRDNCLENBQ0xpTCxLQURLO01BQ0V4QyxNQURGLEdBQzJCekksS0FEM0IsQ0FDRXlJLE1BREY7b0JBQzJCekksS0FEM0IsQ0FDVXNULElBRFY7TUFDVUEsSUFEViwrQkFDaUIsS0FEakI7O1NBR3ZDbEg7O01BQUssV0FBV21ILFdBQUdwVSxTQUFPa1UsSUFBVixFQUFnQmxVLFNBQU8rTixLQUFQLENBQWhCLENBQWhCLEVBQWdELE9BQU8sRUFBRWpDLFlBQUYsRUFBU3hDLGNBQVQsRUFBdkQ7WUFBQTtZQUVXMkQsdUJBQUssV0FBV2pOLFNBQU9tVSxJQUF2QjtHQUhiOzs7QUFRRkQsS0FBSzFHLFNBQUwsR0FBaUI7WUFDTEosVUFBVUssSUFETDtVQUVQTCxVQUFVUSxTQUFWLENBQW9CLENBQUNSLFVBQVVVLE1BQVgsRUFBbUJWLFVBQVVZLE1BQTdCLENBQXBCLENBRk87U0FHUlosVUFBVUMsS0FBVixDQUFnQixDQUFDLFFBQUQsRUFBVyxTQUFYLEVBQXNCLFFBQXRCLENBQWhCLENBSFE7U0FJUkQsVUFBVVEsU0FBVixDQUFvQixDQUFDUixVQUFVVSxNQUFYLEVBQW1CVixVQUFVWSxNQUE3QixDQUFwQixDQUpRO1FBS1RaLFVBQVVTO0NBTGxCOzs7O0FDZkEsSUFBTXdHLFNBQVMsU0FBVEEsTUFBUyxDQUFDeFQsS0FBRDtTQUNib007T0FBQTtpQkFBU3BNLEtBQVQsSUFBZ0IsVUFBUyxVQUF6QjtrQkFDRyxHQUFEO2lDQUM2QixFQUFFbUwsU0FBUyxFQUFFc0ksZUFBZSxNQUFqQixFQUFYLEVBRDdCO2dCQUVXO01BSGI7O1NBS0U7UUFBSyxVQUFTLFVBQWQsRUFBeUIsU0FBekIsRUFBNkIsVUFBN0IsRUFBa0MsWUFBbEMsRUFBeUMsV0FBekM7WUFDUzFIOztHQVBFO0NBQWY7O0FBWUEsSUFBTTJILGdCQUFnQixTQUFoQkEsYUFBZ0IsT0FBZ0M7TUFBN0JwUyxJQUE2QixRQUE3QkEsSUFBNkI7O01BQzlDcVMsZUFBZXJTLE9BQU8sNEJBQUlBLElBQUosR0FBVSxDQUFWLEVBQWFzUyxXQUFiLEVBQVAsR0FBb0MsRUFBekQ7U0FFRXhIO1VBQUE7TUFBUSxPQUFNLE1BQWQsRUFBcUIsT0FBTSxRQUEzQjtvQkFFSUE7OztlQUNRLE1BRFI7aUJBRVUsaUJBRlY7aUJBR1UsS0FIVjs2QkFJc0IsZUFKdEI7ZUFLUTs7Ozs7O09BTFI7Ozs7b0JBU2EsTUFEWDtnQkFFTyxNQUZQOzRCQUdtQixTQUhuQjtzQkFJYSxRQUpiO3FCQUthLENBQ1R5SCxXQUFXQyxXQURGLEVBRVRELFdBQVdFLFNBRkYsRUFHVEYsV0FBV0csWUFIRixFQUlUSCxXQUFXSSxjQUpGLEVBS1Q5VCxJQUxTLENBS0osR0FMSTs7Ozs7R0FoQnJCO0NBRkY7O0FBMkNBLElBQU0yUyxRQUFRO01BQ1IsRUFEUTtNQUVSLEVBRlE7TUFHUjtDQUhOOztJQU1xQm9COzs7Ozs7Ozs7Ozs7Ozt1TEFTbkJDLFFBQVE7cUJBQ1M7YUFHakJDLG1CQUFtQjthQUFNLE1BQUtDLFFBQUwsQ0FBYyxFQUFFQyxlQUFlLEtBQWpCLEVBQWQsQ0FBTjs7Ozs7OzZCQUVWO21CQUN3QyxLQUFLdFUsS0FEN0M7VUFDQ3NCLElBREQsVUFDQ0EsSUFERDtVQUNPaVQsT0FEUCxVQUNPQSxPQURQO1VBQ2dCdFUsSUFEaEIsVUFDZ0JBLElBRGhCO1VBQ3NCcVMsR0FEdEIsVUFDc0JBLEdBRHRCO1VBQzJCa0MsUUFEM0IsVUFDMkJBLFFBRDNCO1VBRUNGLGFBRkQsR0FFbUIsS0FBS0gsS0FGeEIsQ0FFQ0csYUFGRDs7VUFHRHJKLFFBQVFoTCxPQUFPNlMsTUFBTTdTLElBQU4sQ0FBUCxHQUFxQixNQUFuQztVQUNNd0ksU0FBU3hJLE9BQU82UyxNQUFNN1MsSUFBTixDQUFQLEdBQXFCLEVBQXBDO2FBRUVtTTtXQUFBOztpQkFDUTtXQUNEbUksVUFDRDtxQ0FDNkI7cUJBQ2hCO3lCQUNJOzs7U0FKaEIsR0FRRCxFQVZOO2lCQVdTdEosS0FYVDtrQkFZVXhDLE1BWlY7b0JBYVcsVUFiWDtpQkFjUTs7ZUFFRTZMLGFBQVAsR0FDQ2xJO2NBQUE7WUFBTSxPQUFNLFFBQVosRUFBcUIsVUFBckI7d0JBQ0csS0FBRDtpQkFDTzlLLElBRFA7bUJBRVEsU0FGUjsyQkFHaUIsQ0FIakI7MEJBSWdCLENBSmhCO2lCQUtPZ1IsR0FMUDtxQkFNVyxLQUFLOEI7O1NBUm5CLEdBWUNoSSxjQUFDLGFBQUQsSUFBZSxNQUFNOUssSUFBckIsR0E1Qko7b0JBK0JJOEs7YUFBQTs7c0JBQ1csVUFEWDttQkFFUSxLQUZSO29CQUdTLEtBSFQ7c0JBSVksQ0FKWjt1QkFLYSxDQUxiO3VDQU02Qjt1QkFDaEI7d0JBQ0MsSUFERDt1QkFFQTs7Ozs7ZUFJWDs7cUJBQ1EsT0FEUjtxQkFFUSxNQUZSO3NCQUdTLE1BSFQ7cUJBSVEsUUFKUjt5Q0FLNkI7eUJBQ2hCOzZCQUNJOzs7OzBCQUlkLElBQUQ7cUJBQ1EsS0FEUjtvQkFFTyxjQUZQO2tDQUdxQixFQUhyQjtvQkFJTzs7OztPQTVEakI7Ozs7RUFwQmdDUDs7QUFBZnFJLE9BQ1p2SCxZQUFZO1FBQ1hKLFVBQVVZLE1BQVYsQ0FBaUIwRSxVQUROO1dBRVJ0RixVQUFVUyxJQUZGO09BR1pULFVBQVVZLE1BSEU7UUFJWFosVUFBVUMsS0FBVixDQUFnQixDQUFDLElBQUQsRUFBTyxJQUFQLEVBQWEsSUFBYixDQUFoQixDQUpXO1lBS1BELFVBQVVTOzs7Ozs7O0FDbkV4QixJQUFNeUgsYUFBMEM7TUFDMUMsQ0FEMEM7TUFFMUMsQ0FGMEM7TUFHMUMsQ0FIMEM7TUFJMUMsQ0FKMEM7TUFLMUM7Q0FMTjs7QUEwQ0EsQUFBZSxTQUFTQyxJQUFULE9BZUw7d0JBZFJDLEtBY1E7TUFkUkEsS0FjUSw4QkFkQSxNQWNBO3VCQWJSQyxJQWFRO01BYlJBLElBYVEsNkJBYkQsS0FhQztNQVpSN0ksUUFZUSxRQVpSQSxRQVlRO3dCQVhSbUYsS0FXUTtNQVhSQSxLQVdRLDhCQVhBLFVBV0E7eUJBVlJFLE1BVVE7TUFWUkEsTUFVUSwrQkFWQyxLQVVEO3lCQVRSeUQsTUFTUTtNQVRSQSxNQVNRLCtCQVRDLEtBU0Q7MkJBUlJDLFFBUVE7TUFSUkEsUUFRUSxpQ0FSRyxXQVFIO3VCQVBSN1UsSUFPUTtNQVBSQSxJQU9RLDZCQVBELElBT0M7TUFOUjhVLE1BTVEsUUFOUkEsTUFNUTtNQUxSQyxNQUtRLFFBTFJBLE1BS1E7TUFKUkMsTUFJUSxRQUpSQSxNQUlRO01BSFJDLE9BR1EsUUFIUkEsT0FHUTsyQkFGUkMsUUFFUTtNQUZSQSxRQUVRLGlDQUZHLEtBRUg7bUNBRFJDLCtCQUNRO01BRFJBLCtCQUNRLHlDQUQwQixLQUMxQjs7TUFDRnJVLFFBQVEwVCxXQUFXeFUsSUFBWCxDQUFkO01BQ01vVixVQUFVWixXQUFXTSxNQUFYLENBQWhCO01BQ01PLFVBQVViLFdBQVdPLE1BQVgsQ0FBaEI7TUFDTU8sVUFBVWQsV0FBV1EsTUFBWCxDQUFoQjs7TUFFTTNELEtBQUtpQyxXQUNUcFUsU0FBT3VWLElBREUsRUFFVHZWLHNCQUFrQjRCLEtBQWxCLENBRlMsRUFHVGtVLFVBQVU5Vix3QkFBb0JvVyxPQUFwQixDQUhELEVBSVRQLFVBQVU3Vix3QkFBb0JtVyxPQUFwQixDQUpELEVBS1RQLFVBQVU1Vix3QkFBb0JrVyxPQUFwQixDQUxELEVBTVRuRSxVQUFVLE1BQVYsSUFBb0JoSyxPQUFPc08sSUFObEIsRUFPVHRFLFVBQVUsVUFBVixJQUF3QmhLLE9BQU91TyxRQVB0QixFQVFUdkUsVUFBVSxVQUFWLElBQXdCaEssT0FBT3dPLFFBUnRCLEVBU1R4RSxVQUFVLE1BQVYsSUFBb0JoSyxPQUFPeU8sSUFUbEIsRUFVVHpFLFVBQVUsT0FBVixJQUFxQmhLLE9BQU8wTyxLQVZuQixFQVdUMUUsVUFBVSxXQUFWLElBQXlCaEssT0FBTzJPLFNBWHZCLEVBWVQzRSxVQUFVLFFBQVYsSUFBc0JoSyxPQUFPNE8sTUFacEIsRUFhVDVFLFVBQVUsVUFBVixJQUF3QmhLLE9BQU82TyxRQWJ0QixFQWNUN0UsVUFBVSxNQUFWLElBQW9CaEssT0FBTzhPLElBZGxCLEVBZVQ5RSxVQUFVLE9BQVYsSUFBcUJoSyxPQUFPK08sS0FmbkIsRUFnQlQvRSxVQUFVLFFBQVYsSUFBc0JoSyxPQUFPZ1AsTUFoQnBCLEVBaUJUaEYsVUFBVSxRQUFWLElBQXNCaEssT0FBT2lQLE1BakJwQixFQWtCVGpGLFVBQVUsTUFBVixJQUFvQmhLLE9BQU9rUCxJQWxCbEIsRUFtQlRsRixVQUFVLFFBQVYsSUFBc0JoSyxPQUFPbVAsTUFuQnBCLEVBb0JUbkYsVUFBVSxLQUFWLElBQW1CaEssT0FBT29QLEdBcEJqQixFQXFCVHBGLFVBQVUsWUFBVixJQUEwQmhLLE9BQU9xUCxVQXJCeEIsRUFzQlRyRixVQUFVLE9BQVYsSUFBcUJoSyxPQUFPc1AsS0F0Qm5CLEVBdUJUdEIsWUFBWSxPQUFaLElBQXVCckIsV0FBVzRDLFlBdkJ6QixFQXdCVCxDQUFDdkIsWUFBWSxNQUFaLElBQXNCRSwrQkFBdkIsS0FDRXZCLFdBQVc2QyxXQXpCSixFQTBCVC9CLFVBQVUsUUFBVixJQUFzQmQsV0FBVzhDLFdBMUJ4QixFQTJCVGhDLFVBQVUsU0FBVixJQUF1QmQsV0FBVytDLFlBM0J6QixFQTRCVGpDLFVBQVUsTUFBVixJQUFvQmQsV0FBV2dELFNBNUJ0QixFQTZCVGxDLFVBQVUsT0FBVixJQUFxQmQsV0FBV2lELFVBN0J2QixFQThCVGhDLGFBQWEsV0FBYixJQUE0QmpCLFdBQVdrRCxTQTlCOUIsRUErQlRsQyxVQUFVaEIsV0FBV21ELGVBL0JaLEVBZ0NULENBQUNuQyxNQUFELElBQVdoQixXQUFXb0QsZUFoQ2IsRUFpQ1RyQyxRQUFRZixXQUFXSSxjQWpDVixFQWtDVCxDQUFDVyxJQUFELElBQVNmLFdBQVdxRCxnQkFsQ1gsRUFtQ1QvQixZQUFZdEIsV0FBV3NCLFFBbkNkLENBQVg7TUFxQ01nQyxNQUFNL0YsU0FBUyxNQUFULEdBQWtCLEtBQTlCOztTQUdFaEY7T0FBQTs7aUJBQ2FrRjtPQUNONkQsWUFBWSxPQUFPcEosUUFBUCxLQUFvQixRQUFoQyxHQUNELEVBQUVxTCxPQUFPckwsUUFBVCxFQURDLEdBRUQsSUFKTjs7R0FERjs7O0FBWUYySSxLQUFLL0gsU0FBTCxHQUFpQjttQ0FDa0JKLFVBQVVTLElBRDVCO1NBRVJULFVBQVVDLEtBQVYsQ0FBZ0IsQ0FBQyxNQUFELEVBQVMsT0FBVCxFQUFrQixRQUFsQixFQUE0QixTQUE1QixDQUFoQixDQUZRO1FBR1RELFVBQVVTLElBSEQ7WUFJTFQsVUFBVUssSUFKTDtTQUtSTCxVQUFVQyxLQUFWLENBQWdCLENBQ3JCLE9BRHFCLEVBRXJCLE1BRnFCLEVBR3JCLE9BSHFCLEVBSXJCLE1BSnFCLEVBS3JCLE1BTHFCLEVBTXJCLFVBTnFCLEVBT3JCLFFBUHFCLEVBUXJCLFFBUnFCLEVBU3JCLFVBVHFCLEVBVXJCLFFBVnFCLEVBV3JCLFlBWHFCLEVBWXJCLFFBWnFCLEVBYXJCLFVBYnFCLEVBY3JCLE1BZHFCLEVBZXJCLFdBZnFCLEVBZ0JyQixLQWhCcUIsRUFpQnJCLE9BakJxQixDQUFoQixDQUxRO1VBd0JQRCxVQUFVUyxJQXhCSDtVQXlCUFQsVUFBVVMsSUF6Qkg7V0EwQk5ULFVBQVVDLEtBQVYsQ0FBZ0IsQ0FBQyxNQUFELEVBQVMsT0FBVCxDQUFoQixDQTFCTTtVQTJCUEQsVUFBVUMsS0FBVixDQUFnQixDQUFDLElBQUQsRUFBTyxJQUFQLEVBQWEsSUFBYixFQUFtQixJQUFuQixFQUF5QixJQUF6QixDQUFoQixDQTNCTztVQTRCUEQsVUFBVUMsS0FBVixDQUFnQixDQUFDLElBQUQsRUFBTyxJQUFQLEVBQWEsSUFBYixFQUFtQixJQUFuQixFQUF5QixJQUF6QixDQUFoQixDQTVCTztZQTZCTEQsVUFBVUMsS0FBVixDQUFnQixDQUFDLFFBQUQsRUFBVyxXQUFYLENBQWhCLENBN0JLO1FBOEJURCxVQUFVQyxLQUFWLENBQWdCLENBQUMsSUFBRCxFQUFPLElBQVAsRUFBYSxJQUFiLEVBQW1CLElBQW5CLEVBQXlCLElBQXpCLENBQWhCLENBOUJTO1VBK0JQRCxVQUFVQyxLQUFWLENBQWdCLENBQUMsSUFBRCxFQUFPLElBQVAsRUFBYSxJQUFiLEVBQW1CLElBQW5CLEVBQXlCLElBQXpCLENBQWhCLENBL0JPO1lBZ0NMRCxVQUFVUztDQWhDdEI7O0FDdEdlLFNBQVNxSyxNQUFULENBQWdCclgsS0FBaEIsRUFBOEI7OztNQUV6Q3NYLHFCQUZ5QyxHQWF2Q3RYLEtBYnVDLENBRXpDc1gscUJBRnlDO01BR3pDQyxxQkFIeUMsR0FhdkN2WCxLQWJ1QyxDQUd6Q3VYLHFCQUh5QztNQUl6Q3RHLGtCQUp5QyxHQWF2Q2pSLEtBYnVDLENBSXpDaVIsa0JBSnlDO3FCQWF2Q2pSLEtBYnVDLENBS3pDa1IsS0FMeUM7TUFLekNBLEtBTHlDLGdDQUtqQyxNQUxpQzt3QkFhdkNsUixLQWJ1QyxDQU16Q3dYLFFBTnlDO01BTXpDQSxRQU55QyxtQ0FNOUIsS0FOOEI7c0JBYXZDeFgsS0FidUMsQ0FPekNvUixNQVB5QztNQU96Q0EsTUFQeUMsaUNBT2hDLEtBUGdDO01BUXpDOVAsSUFSeUMsR0FhdkN0QixLQWJ1QyxDQVF6Q3NCLElBUnlDO01BU3pDbVcsT0FUeUMsR0FhdkN6WCxLQWJ1QyxDQVN6Q3lYLE9BVHlDO29CQWF2Q3pYLEtBYnVDLENBVXpDQyxJQVZ5QztNQVV6Q0EsSUFWeUMsK0JBVWxDLElBVmtDO01BV3pDeVgsSUFYeUMsR0FhdkMxWCxLQWJ1QyxDQVd6QzBYLElBWHlDO29CQWF2QzFYLEtBYnVDLENBWXpDMlgsSUFaeUM7TUFZekNBLElBWnlDLCtCQVlsQyxRQVprQzs7O01BZXJDQyxZQUFZO1VBQ1YsT0FEVTtVQUVWLFVBRlU7U0FHWCxPQUhXO2lCQUlILE9BSkc7V0FLVDtHQUxUOztNQVFNQyxVQUFVdEcsV0FBV3BTLFNBQU8yWSxNQUFsQixpREFDYjNZLFNBQU80WSxFQURNLEVBQ0Q5WCxTQUFTLElBRFIsK0JBRWJkLFNBQU82WSxFQUZNLEVBRUQvWCxTQUFTLElBRlIsK0JBR2JkLFNBQU84WSxFQUhNLEVBR0RoWSxTQUFTLElBSFIsK0JBSWJkLFNBQU8rWSxLQUpNLEVBSUVoSCxVQUFVLGFBSlosK0JBS2IvUixTQUFPK1IsS0FBUCxDQUxhLEVBS0csQ0FBQ3NHLFFBTEosK0JBTWJyWSxTQUFPcVksUUFOTSxFQU1LQSxRQU5MLCtCQU9iclksU0FBT2daLE9BUE0sRUFPSSxDQUFDWCxRQVBMLCtCQVFiclksU0FBT2lTLE1BUk0sRUFRR0EsTUFSSCwrQkFTYmpTLFNBQU9pWixLQVRNLEVBU0UsQ0FBQ2hILE1BVEgsZ0JBQWhCOzs7U0FjRWhGOzs7dUJBQ2lCa0wscUJBRGpCO3VCQUVpQkMscUJBRmpCO29CQUdjdEcsa0JBSGQ7aUJBSWE0RyxPQUpiO2dCQUtZTCxRQUxaO1lBTVFsVyxJQU5SOzs7Ozs7Ozs7OztRQU9XO2VBQVNtVyxXQUFXQSxRQUFRLEVBQUVZLFlBQUYsRUFBUixDQUFwQjtPQUFULENBUEY7WUFRUVY7OztVQUVOOztlQUNRLFFBRFI7a0JBQUE7ZUFHU0gsV0FBVyxNQUFYLEdBQW9CSSxVQUFVMUcsS0FBVixDQUg3QjtrQkFJVyxRQUpYO2NBS1FqUjs7OztHQWhCWjs7OztBQXlCRm9YLE9BQU8xSyxTQUFQLEdBQW1CO3lCQUNNSixVQUFVUyxJQURoQjt5QkFFTVQsVUFBVVMsSUFGaEI7c0JBR0dULFVBQVVZLE1BSGI7U0FJVlosVUFBVUMsS0FBVixDQUFnQixDQUFDLE1BQUQsRUFBUyxNQUFULEVBQWlCLEtBQWpCLEVBQXdCLGFBQXhCLEVBQXVDLE9BQXZDLENBQWhCLENBSlU7WUFLUEQsVUFBVVMsSUFMSDtVQU1UVCxVQUFVUyxJQU5EO1FBT1hULFVBQVVZLE1BUEM7V0FRUlosVUFBVTRHLElBUkY7UUFTWDVHLFVBQVVDLEtBQVYsQ0FBZ0IsQ0FBQyxJQUFELEVBQU8sSUFBUCxFQUFhLElBQWIsQ0FBaEIsQ0FUVztRQVVYRCxVQUFVWSxNQUFWLENBQWlCMEUsVUFWTjtRQVdYdEYsVUFBVUMsS0FBVixDQUFnQixDQUFDLFFBQUQsRUFBVyxRQUFYLENBQWhCO0NBWFI7Ozs7SUMvRHFCOEw7Ozs7Ozs7Ozs7Ozs7O2lMQVNuQm5FLFFBQWU7ZUFDSjthQUdYb0UsbUJBQW1CLFVBQUNGLEtBQUQsRUFBZ0Q7VUFDekRHLFlBRHlELEdBQ3hDLE1BQUt4WSxLQURtQyxDQUN6RHdZLFlBRHlEOztZQUU1RG5FLFFBQUwsQ0FDRSxFQUFFb0UsU0FBUyxJQUFYLEVBREYsRUFFRUQsZ0JBQWlCO2VBQU1BLGFBQWEsRUFBRUgsWUFBRixFQUFiLENBQU47T0FGbkI7YUFNRkssbUJBQW1CLFVBQUNMLEtBQUQsRUFBZ0Q7VUFDekRNLFlBRHlELEdBQ3hDLE1BQUszWSxLQURtQyxDQUN6RDJZLFlBRHlEOztZQUU1RHRFLFFBQUwsQ0FDRSxFQUFFb0UsU0FBUyxLQUFYLEVBREYsRUFFRUUsZ0JBQWlCO2VBQU1BLGFBQWEsRUFBRU4sWUFBRixFQUFiLENBQU47T0FGbkI7Ozs7Ozs2QkFNTzttQkFDNkIsS0FBS3JZLEtBRGxDO1VBQ0M0WSxNQURELFVBQ0NBLE1BREQ7VUFDUzdNLFFBRFQsVUFDU0EsUUFEVDtVQUNtQnlHLEtBRG5CLFVBQ21CQSxLQURuQjtVQUVDaUcsT0FGRCxHQUVhLEtBQUt0RSxLQUZsQixDQUVDc0UsT0FGRDs7O1VBSURaLFVBQVV0RyxXQUFXcFMsU0FBTzBaLElBQWxCLHFCQUdiMVosU0FBTzJaLEtBSE0sRUFHRUYsVUFBV0EsVUFBVSxJQUFWLElBQWtCSCxPQUgvQixFQUFoQjs7YUFPRXJNO1dBQUE7O3dCQUNnQixLQUFLbU0sZ0JBRHJCO3dCQUVnQixLQUFLRyxnQkFGckI7b0JBR1c7O2lCQUVDdE07YUFBQTtZQUFLLGNBQWMsQ0FBbkI7O1NBTFo7O2FBTUU7OztTQU5GOytCQU9PLFdBQVd5TCxPQUFoQjtPQVJKOzs7O0VBdkM4QmhNOztBQUFieU0sS0FDWjNMLFlBQVk7VUFDVEosVUFBVVMsSUFERDtZQUVQVCxVQUFVSyxJQUZIO1NBR1ZMLFVBQVVLLElBSEE7Z0JBSUhMLFVBQVU0RyxJQUpQO2dCQUtINUcsVUFBVTRHOzs7OztJQ0dQNEY7Ozs7Ozs7Ozs7Ozs7O3lMQXFCbkI1RSxRQUFRO2VBQ0c7YUFxQlg2RSxlQUFlLFVBQUNYLEtBQUQsRUFBa0M7VUFDdkNZLE9BRHVDLEdBQzNCWixNQUFNYSxNQURxQixDQUN2Q0QsT0FEdUM7O1lBRTFDalosS0FBTCxDQUFXbVosUUFBWCxDQUFvQixFQUFFZCxZQUFGLEVBQVNZLGdCQUFULEVBQXBCO2FBR0ZHLGNBQWMsVUFBQ2YsS0FBRCxFQUFrRDtVQUN0RFosT0FEc0QsR0FDMUMsTUFBS3pYLEtBRHFDLENBQ3REeVgsT0FEc0Q7O1VBRTFEQSxPQUFKLEVBQWE7WUFDSHdCLFFBREcsR0FDU1osTUFBTWdCLGFBRGYsQ0FDSEosT0FERzs7Z0JBRUgsRUFBRVosWUFBRixFQUFTWSxpQkFBVCxFQUFSOzthQUlKSyxhQUFhO2FBQU0sTUFBS2pGLFFBQUwsQ0FBYyxFQUFFa0YsU0FBUyxLQUFYLEVBQWQsQ0FBTjthQUViQyxjQUFjO2FBQU0sTUFBS25GLFFBQUwsQ0FBYyxFQUFFa0YsU0FBUyxJQUFYLEVBQWQsQ0FBTjs7Ozs7O3dDQWpDTTtVQUNkLEtBQUt2WixLQUFMLENBQVd5WixhQUFmLEVBQThCO2FBQ3ZCQyxnQkFBTCxDQUFzQixDQUFDLENBQUMsS0FBSzFaLEtBQUwsQ0FBV3laLGFBQW5DOzs7Ozt1Q0FJZUUsZUFBc0I7VUFDbkNBLGNBQWNGLGFBQWQsS0FBZ0MsS0FBS3paLEtBQUwsQ0FBV3laLGFBQS9DLEVBQThEO2FBQ3ZEQyxnQkFBTCxDQUFzQixDQUFDLENBQUMsS0FBSzFaLEtBQUwsQ0FBV3laLGFBQW5DOzs7OztxQ0FJYUEsZUFBd0I7VUFDbkMsS0FBS0csS0FBVCxFQUFnQjthQUNUQSxLQUFMLENBQVdILGFBQVgsR0FBMkJBLGFBQTNCOzs7Ozs2QkF1Qks7Ozs7O21CQVNILEtBQUt6WixLQVRGO1VBRUxpWixPQUZLLFVBRUxBLE9BRks7VUFHTHpCLFFBSEssVUFHTEEsUUFISztVQUlMcUMsUUFKSyxVQUlMQSxRQUpLO1VBS0xDLEVBTEssVUFLTEEsRUFMSztVQU1MTCxhQU5LLFVBTUxBLGFBTks7VUFPTG5ZLElBUEssVUFPTEEsSUFQSztVQVFMckIsSUFSSyxVQVFMQSxJQVJLOzs7VUFXSDhaLGNBQWM1YSxTQUFPNmEsTUFBekI7VUFDSSxDQUFDeEMsUUFBRCxLQUFjeUIsV0FBV1EsYUFBekIsQ0FBSixFQUE2QztzQkFDN0J0YSxTQUFPOGEsVUFBckI7T0FERixNQUVPLElBQUlKLFFBQUosRUFBYztzQkFDTDFhLFNBQU8rYSxXQUFyQjs7O2FBSUE5TjtXQUFBO1VBQUssVUFBUyxVQUFkOzttQkFFYTZNLE9BRFg7cUJBRWExSCxXQUFXcFMsU0FBT3lhLEtBQWxCLGlEQUNSemEsU0FBT2diLFlBREMsRUFDYyxDQUFDM0MsUUFEZiwrQkFFUnJZLFNBQU9zYSxhQUZDLEVBRWVBLGFBRmYsK0JBR1J0YSxTQUFPaWIsT0FIQyxFQUdTbmEsU0FBUyxJQUhsQiwrQkFJUmQsU0FBT2tiLE9BSkMsRUFJU3BhLFNBQVMsSUFKbEIsZ0JBRmI7b0JBUVl1WCxRQVJaO2NBU01zQyxFQVROO2dCQVVReFksSUFWUjtrQkFXVSxLQUFLZ1ksVUFYZjtvQkFZWSxLQUFLTixZQVpqQjttQkFhVyxLQUFLSSxXQWJoQjttQkFjVyxLQUFLSSxXQWRoQjtlQWVPLGlCQUFNO21CQUNKSSxLQUFMLEdBQWFVLEVBQWI7V0FoQko7Z0JBa0JPO1VBbkJUOzs7O3VCQXNCZS9JLFdBQ1R3SSxXQURTLEVBRVQ1YSxTQUFPb2IsS0FGRTs7dUJBS0x0QixXQUFXUSxhQUFYLEdBQ0V2UyxPQUFPSSxNQURULEdBRUVKLE9BQU9PLFdBSGIsR0FJSXdSLFdBQVdRLGFBQVgsR0FDRXZTLE9BQU9FLFVBRFQsR0FFRUYsT0FBT1EsT0FWSixtREFZTnZJLFNBQU9xYixZQVpELEVBWWdCLENBQUNoRCxRQVpqQixnQ0FhTnJZLFNBQU9zYixZQWJELEVBYWdCLEtBQUt0RyxLQUFMLENBQVdvRixPQWIzQixnQ0FjTnBhLFNBQU91YixPQWRELEVBY1d6YSxTQUFTLElBZHBCLGdDQWVOZCxTQUFPd2IsT0FmRCxFQWVXMWEsU0FBUyxJQWZwQjs7V0FtQlRnWixXQUFXUSxhQUFaLEtBQ0NyTixjQUFDLElBQUQ7Z0NBQ3FCLEVBRHJCO21CQUVRLE9BRlI7a0JBR1FxTixnQkFBZ0IsTUFBaEIsR0FBeUIsT0FIakM7a0JBSVF4WixTQUFTLElBQVQsR0FBZ0IsQ0FBaEIsR0FBb0I7OztPQS9DcEM7Ozs7RUFoRmtDNEw7O0FBQWpCa04sU0FDWnBNLFlBQVk7V0FDUkosVUFBVVMsSUFERjtZQUVQVCxVQUFVUyxJQUZIO1lBR1BULFVBQVVTLElBSEg7TUFJYlQsVUFBVVksTUFBVixDQUFpQjBFLFVBSko7aUJBS0Z0RixVQUFVUyxJQUxSO1FBTVhULFVBQVVZLE1BTkM7WUFPUFosVUFBVTRHLElBQVYsQ0FBZXRCLFVBUFI7V0FRUnRGLFVBQVU0RyxJQVJGO1FBU1g1RyxVQUFVQyxLQUFWLENBQWdCLENBQUMsSUFBRCxFQUFPLElBQVAsQ0FBaEI7O0FBVld1TSxTQWFaM0YsZUFBZTtXQUNYLEtBRFc7WUFFVixLQUZVO1lBR1YsS0FIVTtpQkFJTCxLQUpLO1FBS2Q7OztJQ2FXd0g7Ozs7Ozs7Ozs7NkJBd0JWO21CQUNxRCxLQUFLNWEsS0FEMUQ7VUFDQzZhLElBREQsVUFDQ0EsSUFERDtVQUNPM1UsU0FEUCxVQUNPQSxNQURQO3NDQUNlNFUsV0FEZjtVQUNlQSxXQURmLHNDQUM2QixDQUQ3Qjt1Q0FDZ0NDLFlBRGhDO1VBQ2dDQSxZQURoQyx1Q0FDK0MsQ0FEL0M7Ozs7VUFJRDlQLFFBQVFoSyxLQUFLK1osR0FBTCwrQkFBWTlVLFVBQU9wRyxHQUFQLENBQVc7ZUFBUW1iLEtBQUszUixJQUFMLEdBQVkyUixLQUFLaFEsS0FBekI7T0FBWCxDQUFaLEVBQWQ7VUFDTXhDLFNBQVN4SCxLQUFLK1osR0FBTCwrQkFBWTlVLFVBQU9wRyxHQUFQLENBQVc7ZUFBUW1iLEtBQUs3UixHQUFMLEdBQVc2UixLQUFLeFMsTUFBeEI7T0FBWCxDQUFaLEVBQWY7OztvQkFHMkQsS0FBS3pJLEtBUnpEOzBDQVFDa2IsYUFSRDtVQVFDQSxhQVJELHlDQVFpQmpRLEtBUmpCOzBDQVF3QmtRLGNBUnhCO1VBUXdCQSxjQVJ4Qix5Q0FReUMxUyxNQVJ6Qzs7Ozs7VUFZRDJTLFFBQVFsVixVQUFPOUcsTUFBUCxDQUFjLFVBQUNzTSxHQUFELEVBQU0yUCxRQUFOLEVBQWdCQyxHQUFoQixFQUF3QjtZQUVoREQsU0FBU2pTLEdBQVQsR0FBZWlTLFNBQVM1UyxNQUF4QixHQUFpQ3FTLFdBQWpDLElBQ0FPLFNBQVNqUyxHQUFULEdBQWUrUixpQkFBaUJMLFdBRGhDLElBRUFPLFNBQVMvUixJQUFULEdBQWdCNFIsZ0JBQWdCSCxZQUZoQyxJQUdBTSxTQUFTL1IsSUFBVCxHQUFnQitSLFNBQVNwUSxLQUF6QixHQUFpQzhQLFlBSm5DLEVBS0U7Y0FDSVEsSUFBSixZQUFXRCxRQUFYLElBQW1CRCxRQUFuQjs7ZUFFSzNQLEdBQVA7T0FUWSxFQVVYLEVBVlcsQ0FBZDs7YUFhRVU7O1VBQUssV0FBV29QLE9BQWFuUixRQUE3QixFQUF1QyxPQUFPLEVBQUVZLFlBQUYsRUFBU3hDLGNBQVQsRUFBOUM7Y0FDUzNJLEdBQU4sQ0FBVTtjQUFHd2IsR0FBSCxRQUFHQSxHQUFIO2NBQVcvYSxLQUFYO2lCQUNUNkw7O2NBQUssS0FBS2tQLEdBQVYsRUFBZSxXQUFXRSxPQUFhcFIsUUFBdkMsRUFBaUQsT0FBTzdKLEtBQXhEOzBCQUNHLElBQUQsSUFBTSxLQUFLK2EsR0FBWDtXQUZPO1NBQVY7T0FGTDs7OztFQWhEb0N6UDs7QUFBbkIrTyxXQUNaak8sWUFBWTs7UUFFWEosVUFBVWtQLEdBRkM7VUFHVGxQLFVBQVVtUCxPQUFWLENBQ05uUCxVQUFVTSxLQUFWLENBQWdCO1NBQ1ROLFVBQVVVLE1BQVYsQ0FBaUI0RSxVQURSO1VBRVJ0RixVQUFVVSxNQUFWLENBQWlCNEUsVUFGVDtXQUdQdEYsVUFBVVUsTUFBVixDQUFpQjRFLFVBSFY7WUFJTnRGLFVBQVVVLE1BQVYsQ0FBaUI0RTtHQUozQixFQUtHQSxVQU5HLENBSFM7a0JBV0R0RixVQUFVVSxNQVhUO2dCQVlIVixVQUFVVSxNQVpQO2VBYUpWLFVBQVVVLE1BYk47aUJBY0ZWLFVBQVVVOztBQWZSMk4sV0FrQlp4SCxlQUFlO1VBQ1osRUFEWTtnQkFFTixDQUZNO2VBR1A7OztBQ3pFakI7Ozs7Ozs7Ozs7OztBQVlBLElBQU11SSxLQUFLLENBQUMsSUFBRCxFQUFPLElBQVAsQ0FBWDtBQUNBLElBQU1DLE9BQU8sQ0FBQyxJQUFELEVBQU8sSUFBUCxDQUFiO0FBQ0EsSUFBTUMsTUFBTSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQVo7QUFDQSxJQUFNQyxlQUFlLFNBQWZBLFlBQWUsQ0FBQ0MsWUFBRCxFQUE4QjtVQUN6Q0EsWUFBUjtTQUNPLENBQUw7YUFDUyxDQUFDLENBQUNGLEdBQUQsQ0FBRCxFQUFRLENBQUNGLEVBQUQsQ0FBUixFQUFjLENBQUNDLElBQUQsQ0FBZCxDQUFQO1NBQ0csQ0FBTDthQUNTLENBQUMsQ0FBQ0QsRUFBRCxFQUFLRSxHQUFMLENBQUQsRUFBWSxDQUFDRCxJQUFELEVBQU9DLEdBQVAsQ0FBWixFQUF5QixDQUFDQSxHQUFELEVBQU1GLEVBQU4sQ0FBekIsRUFBb0MsQ0FBQ0UsR0FBRCxFQUFNRCxJQUFOLENBQXBDLENBQVA7U0FDRyxDQUFMO2FBQ1MsQ0FDTCxDQUFDQyxHQUFELEVBQU1GLEVBQU4sRUFBVUUsR0FBVixFQUFlQSxHQUFmLENBREssRUFFTCxDQUFDQSxHQUFELEVBQU1ELElBQU4sRUFBWUMsR0FBWixFQUFpQkEsR0FBakIsQ0FGSyxFQUdMLENBQUNBLEdBQUQsRUFBTUEsR0FBTixFQUFXRixFQUFYLEVBQWVFLEdBQWYsQ0FISyxFQUlMLENBQUNBLEdBQUQsRUFBTUEsR0FBTixFQUFXRCxJQUFYLEVBQWlCQyxHQUFqQixDQUpLLEVBS0wsQ0FBQ0EsR0FBRCxFQUFNRixFQUFOLEVBQVVFLEdBQVYsRUFBZUQsSUFBZixDQUxLLEVBTUwsQ0FBQ0MsR0FBRCxFQUFNRCxJQUFOLEVBQVlDLEdBQVosRUFBaUJGLEVBQWpCLENBTkssQ0FBUDtTQVFHLENBQUw7O2FBRVMsQ0FDTCxDQUFDRSxHQUFELEVBQU1GLEVBQU4sRUFBVUUsR0FBVixDQURLLEVBRUwsQ0FBQ0EsR0FBRCxFQUFNRCxJQUFOLEVBQVlDLEdBQVosQ0FGSyxFQUdMLENBQUNBLEdBQUQsRUFBTUEsR0FBTixFQUFXRixFQUFYLENBSEssRUFJTCxDQUFDRSxHQUFELEVBQU1BLEdBQU4sRUFBV0QsSUFBWCxDQUpLLENBQVA7O0NBakJOOztBQTBCQSxJQUFNSSxhQUFhLFNBQWJBLFVBQWEsQ0FBQ0MsTUFBRCxFQUFTQyxTQUFUO1NBQ2pCQSxVQUFVcGMsR0FBVixDQUFjO1FBQUdzSixHQUFILFFBQUdBLEdBQUg7UUFBUUUsSUFBUixRQUFRQSxJQUFSO1FBQWMyQixLQUFkLFFBQWNBLEtBQWQ7UUFBcUJ4QyxNQUFyQixRQUFxQkEsTUFBckI7V0FBbUM7Y0FBQTtnQkFBQTthQUd4Q3dDLFFBQVFnUixNQUhnQztjQUl2Q3hULFNBQVN3VDtLQUpMO0dBQWQsQ0FEaUI7Q0FBbkI7O0FBUUEsSUFBTUUsU0FBUyxTQUFUQSxNQUFTO1NBQ2I3USxJQUFJbE0sTUFBSixDQUFXLFVBQUNnZCxRQUFELEVBQVduQixJQUFYLEVBQWlCb0IsQ0FBakI7V0FBd0JwQixPQUFPM1AsSUFBSThRLFFBQUosQ0FBUCxHQUF1QkMsQ0FBdkIsR0FBMkJELFFBQW5EO0dBQVgsRUFBeUUsQ0FBekUsQ0FEYTtDQUFmOztBQUdBLElBQU1FLDZCQUE2QixTQUE3QkEsMEJBQTZCLENBQUNQLFlBQUQ7U0FDakNBLGlCQUFpQixDQUFqQixHQUFxQixDQUFyQixHQUF5QixDQURRO0NBQW5DOztBQUdBLFNBQVNRLGdCQUFULFFBY0c7TUFiRE4sTUFhQyxTQWJEQSxNQWFDO01BWkRPLEtBWUMsU0FaREEsS0FZQztNQVhRQyxPQVdSLFNBWERDLE9BV0M7TUFWT0MsQ0FVUCxTQVZEbFUsTUFVQztNQVRNbVUsQ0FTTixTQVREM1IsS0FTQztNQVJENFIsU0FRQyxTQVJEQSxTQVFDOztNQUNHWCxZQUFZLEVBQWhCO01BQ01qUixRQUFRMlIsSUFBSVgsTUFBbEI7TUFDTXhULFNBQVNrVSxJQUFJVixNQUFuQjs7Ozs7O01BTU1hLFdBQVdOLFFBQVFGLDJCQUEyQkcsT0FBM0IsQ0FBUixHQUE4Q0EsT0FBL0Q7OztNQUdNQyxVQUFVWixhQUFhZ0IsUUFBYixDQUFoQjtNQUNNQyxZQUFZRixZQUFZSCxRQUFRcGMsTUFBdEM7TUFDTTRGLFNBQVN3VyxRQUFRSyxTQUFSLENBQWY7Ozs7OztNQU1NQyxhQUFhLElBQUlwZCxLQUFKLENBQVVrZCxRQUFWLEVBQW9CRyxJQUFwQixDQUF5QixDQUF6QixDQUFuQjtNQUNNQyxZQUFZLElBQUl0ZCxLQUFKLENBQVVrZCxRQUFWLEVBQW9CRyxJQUFwQixDQUF5QixDQUF6QixDQUFsQjs7OztPQUlLLElBQUlaLElBQUksQ0FBYixFQUFnQkEsSUFBSSxJQUFJUyxRQUF4QixFQUFrQ1QsS0FBSyxDQUF2QyxFQUEwQztRQUNsQ2MsTUFBTWhCLE9BQU9hLFVBQVAsQ0FBWjtRQUNNSSxTQUFTRixVQUFVQyxHQUFWLENBQWY7UUFDTUUsYUFBYW5YLE9BQU9pWCxHQUFQLEVBQVlDLE1BQVosSUFBc0IzVSxNQUF6Qzs7Y0FFVThTLElBQVYsQ0FBZTtXQUNSeUIsV0FBV0csR0FBWCxDQURRO1lBRVBBLE9BQU9sUyxRQUFRd1IsT0FBZixDQUZPO2FBR054UixRQUFRd1IsT0FIRjtjQUlMWTtLQUpWOztlQU9XRixHQUFYLEtBQW1CRSxVQUFuQjtjQUNVRixHQUFWLEtBQWtCLENBQWxCOzs7OztNQUtFWCxLQUFKLEVBQVc7UUFDSGMsa0JBQWtCcmMsS0FBS3NjLElBQUwsQ0FBVWQsVUFBVSxDQUFwQixLQUEwQnhSLFFBQVF3UixPQUFsQyxDQUF4QjtnQkFDWVAsVUFBVXBjLEdBQVYsQ0FBYzswQkFDckJ1YixRQURxQjtjQUVsQmlDLGtCQUFrQmpDLFNBQVMvUjs7S0FGdkIsQ0FBWjtjQUlVa1UsT0FBVixDQUFrQixFQUFFcFUsS0FBSyxDQUFQLEVBQVVFLE1BQU0sQ0FBaEIsRUFBbUIyQixPQUFPcVMsZUFBMUIsRUFBMkM3VSxjQUEzQyxFQUFsQjs7Ozs7O01BTUV3VCxNQUFKLEVBQVk7Z0JBQ0VELFdBQVdDLE1BQVgsRUFBbUJDLFNBQW5CLENBQVo7OztTQUdLQSxTQUFQOzs7QUFpQkYsQUFBZSxTQUFTdUIsT0FBVCxDQUFpQnpkLEtBQWpCLEVBQStCO01BRTFDMGMsT0FGMEMsR0FTeEMxYyxLQVR3QyxDQUUxQzBjLE9BRjBDO01BRzFDRixLQUgwQyxHQVN4Q3hjLEtBVHdDLENBRzFDd2MsS0FIMEM7TUFJMUNQLE1BSjBDLEdBU3hDamMsS0FUd0MsQ0FJMUNpYyxNQUowQztNQUsxQ3hULE1BTDBDLEdBU3hDekksS0FUd0MsQ0FLMUN5SSxNQUwwQztNQU0xQ29VLFNBTjBDLEdBU3hDN2MsS0FUd0MsQ0FNMUM2YyxTQU4wQztNQU8xQ2EsV0FQMEMsR0FTeEMxZCxLQVR3QyxDQU8xQzBkLFdBUDBDO01BUTFDelMsS0FSMEMsR0FTeENqTCxLQVR3QyxDQVExQ2lMLEtBUjBDOztNQVV0Q2lSLFlBQVlLLGlCQUFpQjtvQkFBQTtXQUUxQixDQUFDLENBQUNDLEtBRndCO2dCQUFBO2tCQUFBO1lBS3pCUCxVQUFVLENBTGU7ZUFNdEJZLGFBQWE7R0FOUixDQUFsQjtTQVNFelEsY0FBQyxVQUFEO1VBQ1E7VUFBUXVSLEtBQVIsU0FBR3JDLEdBQUg7YUFDSm9DLFlBQVk7b0JBQUE7ZUFFSHhCLFVBQVV5QixLQUFWLEVBQWlCMVMsS0FGZDtnQkFHRmlSLFVBQVV5QixLQUFWLEVBQWlCbFY7T0FIM0IsQ0FESTtLQURSO1lBUVV5VDtJQVRaOzs7QUFjRnVCLFFBQVE5USxTQUFSLEdBQW9CO1dBQ1RKLFVBQVVDLEtBQVYsQ0FBZ0IsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FBaEIsRUFBMkJxRixVQURsQjtTQUVYdEYsVUFBVVMsSUFGQztVQUdWVCxVQUFVVSxNQUhBO1VBSVZWLFVBQVVVLE1BQVYsQ0FBaUI0RSxVQUpQO2FBS1B0RixVQUFVVSxNQUxIO2VBTUxWLFVBQVU0RyxJQUFWLENBQWV0QixVQU5WO1NBT1h0RixVQUFVVSxNQUFWLENBQWlCNEU7Q0FQMUI7Ozs7QUMvSmUsU0FBUytMLE1BQVQsQ0FBZ0I1ZCxLQUFoQixFQUFvQztNQUN6QytMLFFBRHlDLEdBQzVCL0wsS0FENEIsQ0FDekMrTCxRQUR5Qzs7TUFFM0N1RixLQUFLQyxXQUNULENBQUN2UixNQUFNNmQsRUFBTixLQUFhbE0sU0FBYixJQUNDM1IsTUFBTStYLEVBQU4sS0FBYXBHLFNBRGQsSUFFQzNSLE1BQU1nWSxFQUFOLEtBQWFyRyxTQUZkLElBR0MzUixNQUFNaVksRUFBTixLQUFhdEcsU0FIZixLQUlFeFMsU0FBTzJlLGdCQUxBLEVBTVQ5ZCxNQUFNNmQsRUFBTixJQUFZMWUsbUJBQWVhLE1BQU02ZCxFQUFyQixDQU5ILEVBT1Q3ZCxNQUFNK1gsRUFBTixJQUFZNVksbUJBQWVhLE1BQU0rWCxFQUFyQixDQVBILEVBUVQvWCxNQUFNZ1ksRUFBTixJQUFZN1ksbUJBQWVhLE1BQU1nWSxFQUFyQixDQVJILEVBU1RoWSxNQUFNaVksRUFBTixJQUFZOVksbUJBQWVhLE1BQU1pWSxFQUFyQixDQVRILEVBVVRqWSxNQUFNK2QsSUFBTixJQUFjLElBQWQsSUFBc0I1ZSxtQkFBZWEsTUFBTStkLElBQXJCLENBVmIsRUFXVC9kLE1BQU1nZSxNQUFOLElBQWdCLElBQWhCLElBQXdCN2UsbUJBQWVhLE1BQU1nZSxNQUFyQixDQVhmLEVBWVRoZSxNQUFNaWUsTUFBTixJQUFnQixJQUFoQixJQUF3QjllLG1CQUFlYSxNQUFNaWUsTUFBckIsQ0FaZixFQWFUamUsTUFBTWtlLE1BQU4sSUFBZ0IsSUFBaEIsSUFBd0IvZSxtQkFBZWEsTUFBTWtlLE1BQXJCLENBYmYsQ0FBWDtTQWVPOVI7O01BQUssV0FBV2tGLEVBQWhCOztHQUFQOzs7QUFHRnNNLE9BQU9qUixTQUFQLEdBQW1CO1lBQ1BKLFVBQVVLLElBREg7TUFFYkwsVUFBVVUsTUFGRztNQUdiVixVQUFVVSxNQUhHO01BSWJWLFVBQVVVLE1BSkc7TUFLYlYsVUFBVVUsTUFMRztRQU1YVixVQUFVVSxNQU5DO1VBT1RWLFVBQVVVLE1BUEQ7VUFRVFYsVUFBVVUsTUFSRDtVQVNUVixVQUFVVTtDQVRwQjs7QUNwQ2UsU0FBU2tSLFNBQVQsQ0FBbUJuZSxLQUFuQixFQUFpQztNQUN0QytMLFFBRHNDLEdBQ3pCL0wsS0FEeUIsQ0FDdEMrTCxRQURzQzs7U0FHNUNLO09BQUE7TUFBSyxnQkFBZSxRQUFwQixFQUE2QixTQUFRLE1BQXJDOztTQUNFO1FBQUssVUFBVSxHQUFmLEVBQW9CLE9BQU0sTUFBMUI7OztHQUZKOzs7QUFTRitSLFVBQVV4UixTQUFWLEdBQXNCO1lBQ1ZKLFVBQVVLO0NBRHRCOzs7O0FDaEJlLFNBQVN3UixPQUFULEdBQW1CO1NBQ3pCaFMsc0JBQUksV0FBV2pOLFNBQU9rZixPQUF0QixHQUFQOzs7QUNHYSxTQUFTQyxLQUFULENBQWV0ZSxLQUFmLEVBQTZCO01BQ2xDdWUsU0FEa0MsR0FDcEJ2ZSxLQURvQixDQUNsQ3VlLFNBRGtDOztNQUV0QzlNLGFBQUo7VUFDUThNLFNBQVI7U0FDTyxJQUFMO2FBQ1MsbUJBQVA7O1NBRUcsT0FBTDthQUNTLHFCQUFQOztTQUVHLE1BQUw7YUFDUyxxQkFBUDs7U0FFRyxNQUFMO2FBQ1MsbUJBQVA7Ozs7O1NBTUZuUzs7TUFBSyxPQUFNLElBQVgsRUFBZ0IsUUFBTyxJQUF2Qjs0QkFDUSxHQUFHcUYsSUFBVDtHQUZKOzs7QUFPRjZNLE1BQU0zUixTQUFOLEdBQWtCO2FBQ0xKLFVBQVVDLEtBQVYsQ0FBZ0IsQ0FBQyxJQUFELEVBQU8sT0FBUCxFQUFnQixNQUFoQixFQUF3QixNQUF4QixDQUFoQjtDQURiOzs7O0FDMUJBOztBQUVBLElBQU1nUyxtQkFBbUI7T0FDbEIsSUFEa0I7T0FFbEIsT0FGa0I7T0FHbEIsTUFIa0I7T0FJbEI7Q0FKUDs7QUFPQSxJQUFNQyxnQkFBZ0I7TUFDaEIsQ0FEZ0I7U0FFYixDQUZhO1FBR2QsQ0FIYztRQUlkO0NBSlI7O0FBT0EsSUFBTUMsU0FBUyxFQUFmO0FBQ0EsQUFBTyxJQUFNQyxlQUFlLEVBQXJCO0FBQ1AsSUFBTUMseUJBQXlCLEVBQS9CO0FBQ0EsQUFBTyxJQUFNQyxnQkFBZ0IsQ0FBdEI7Ozs7O0FBNERQLEFBQU8sU0FBU0MsVUFBVCxDQUNMQyxVQURLLEVBRUxDLGNBRkssRUFHTEMsV0FISyxFQUlMQyxVQUpLLEVBS0w7OztNQUdJQyxLQUFLRixZQUFZN1YsR0FBWixHQUFrQjJWLFdBQVd0VyxNQUE3QixHQUFzQ2tXLFlBQS9DO01BQ0luVixRQUNGMFYsV0FBV2pVLEtBQVgsR0FBbUI4VCxXQUFXOVQsS0FBOUIsR0FBc0MwVCxZQUF0QyxHQUFxRE0sWUFBWXpWLEtBRG5FO01BRUk0VixPQUNGRixXQUFXelcsTUFBWCxHQUFvQnNXLFdBQVd0VyxNQUEvQixHQUF3Q2tXLFlBQXhDLEdBQXVETSxZQUFZNVYsTUFEckU7TUFFSUMsT0FBTzJWLFlBQVkzVixJQUFaLEdBQW1CeVYsV0FBVzlULEtBQTlCLEdBQXNDMFQsWUFBakQ7Ozs7TUFLRU0sWUFBWTdWLEdBQVosR0FBa0J5VixhQUFsQixJQUNBSyxXQUFXelcsTUFBWCxHQUFvQndXLFlBQVk1VixNQUFoQyxHQUF5Q3dWLGFBRjNDLEVBR0U7V0FDTyxDQUFQO1lBQ1EsQ0FBUjs7OztNQUtBSSxZQUFZM1YsSUFBWixHQUFtQnVWLGFBQW5CLElBQ0FLLFdBQVdqVSxLQUFYLEdBQW1CZ1UsWUFBWXpWLEtBQS9CLEdBQXVDcVYsYUFGekMsRUFHRTtTQUNLLENBQUw7V0FDTyxDQUFQOzs7TUFHSVEsU0FBUyxDQUFDRixFQUFELEVBQUszVixLQUFMLEVBQVk0VixJQUFaLEVBQWtCOVYsSUFBbEIsQ0FBZjs7O01BR00wUixNQUFNL1osS0FBSytaLEdBQUwsYUFBWXFFLE1BQVosQ0FBWjs7O01BR0lDLGdCQUFKO01BQ0lOLGtCQUFrQkssT0FBT1osY0FBY08sY0FBZCxDQUFQLElBQXdDLENBQTlELEVBQWlFOztjQUVyREEsY0FBVjtHQUZGLE1BR087O2NBRUtSLGlCQUFpQmEsT0FBTzlULE9BQVAsQ0FBZXlQLEdBQWYsQ0FBakIsQ0FBVjs7U0FFS3NFLE9BQVA7Ozs7OztBQU1GLEFBQU8sU0FBU0MsU0FBVCxDQUNMUixVQURLLEVBRUxPLE9BRkssRUFHTEwsV0FISyxFQUlMQyxVQUpLLEVBS0w7O01BRUlNLGVBQUo7TUFDSUMsbUJBQUo7TUFDSUMsNkJBQUo7O01BRUlKLFlBQVksT0FBWixJQUF1QkEsWUFBWSxNQUF2QyxFQUErQzthQUNwQ1AsV0FBV3RXLE1BQVgsR0FBb0IsQ0FBN0I7aUJBQ2F3VyxZQUFZN1YsR0FBWixHQUFrQixDQUFDNlYsWUFBWTVWLE1BQVosR0FBcUI0VixZQUFZN1YsR0FBbEMsSUFBeUMsQ0FBeEU7MkJBQ3VCOFYsV0FBV3pXLE1BQWxDO0dBSEYsTUFJTzs7YUFFSXNXLFdBQVc5VCxLQUFYLEdBQW1CLENBQTVCO2lCQUNhZ1UsWUFBWTNWLElBQVosR0FBbUIsQ0FBQzJWLFlBQVl6VixLQUFaLEdBQW9CeVYsWUFBWTNWLElBQWpDLElBQXlDLENBQXpFOzJCQUN1QjRWLFdBQVdqVSxLQUFsQzs7O01BR0kwVSxjQUFjRixhQUFhRCxNQUFiLEdBQXNCZCxNQUExQztNQUNNa0IsZUFBZUYsdUJBQXVCRCxVQUF2QixHQUFvQ0QsTUFBcEMsR0FBNkNkLE1BQWxFO01BQ0ltQixlQUFKO01BQ0lGLGNBQWMsQ0FBZCxJQUFtQkMsZUFBZSxDQUF0QyxFQUF5Qzs7YUFFOUIsUUFBVDtHQUZGLE1BR08sSUFBSUEsZUFBZSxDQUFuQixFQUFzQjs7YUFFbEJOLFlBQVksTUFBWixJQUFzQkEsWUFBWSxPQUFsQyxHQUE0QyxJQUE1QyxHQUFtRCxNQUE1RDtHQUZLLE1BR0E7O2FBRUlBLFlBQVksTUFBWixJQUFzQkEsWUFBWSxPQUFsQyxHQUE0QyxNQUE1QyxHQUFxRCxPQUE5RDs7U0FFS08sTUFBUDs7Ozs7O0FBTUYsQUFBTyxTQUFTQyxjQUFULENBQ0xELE1BREssRUFFTFosV0FGSyxFQUdMQyxVQUhLLEVBSUw7O01BRUlhLHNCQUNGbkIseUJBQXlCLENBQUNLLFlBQVl4VyxNQUFaLEdBQXFCa1csWUFBdEIsSUFBc0MsQ0FEakU7TUFFSXFCLHdCQUNGcEIseUJBQXlCLENBQUNLLFlBQVloVSxLQUFaLEdBQW9CMFQsWUFBckIsSUFBcUMsQ0FEaEU7TUFFSXNCLHFCQUFxQnRCLFlBQXpCO01BQ0l1Qix1QkFBdUJ2QixZQUEzQjs7OztNQUlNd0Isb0JBQ0psQixZQUFZN1YsR0FBWixHQUFrQjJXLG1CQUFsQixHQUF3QyxDQUF4QyxJQUNBZCxZQUFZNVYsTUFBWixHQUFxQjBXLG1CQUFyQixHQUEyQ2IsV0FBV3pXLE1BRnhEO01BR00yWCxzQkFDSm5CLFlBQVkzVixJQUFaLEdBQW1CMFcscUJBQW5CLEdBQTJDLENBQTNDLElBQ0FmLFlBQVl6VixLQUFaLEdBQW9Cd1cscUJBQXBCLEdBQTRDZCxXQUFXalUsS0FGekQ7TUFHSWtWLGlCQUFKLEVBQXVCOzBCQUVuQnRCLGdCQUFnQixDQUFDSSxZQUFZeFcsTUFBWixHQUFxQmtXLFlBQXRCLElBQXNDLENBRHhEO3lCQUVxQkUsYUFBckI7O01BRUV1QixtQkFBSixFQUF5Qjs0QkFFckJ2QixnQkFBZ0IsQ0FBQ0ksWUFBWWhVLEtBQVosR0FBb0IwVCxZQUFyQixJQUFxQyxDQUR2RDsyQkFFdUJFLGFBQXZCOzs7U0FHSztZQUNHO1NBQ0htQixxQkFERztTQUVIRDtLQUhBO1dBS0U7U0FDRkcsb0JBREU7U0FFRkQ7O0dBUFA7Ozs7OztBQWVGLEFBQU8sU0FBU0ksYUFBVCxDQUNMQyxJQURLLEVBRUxDLFNBRkssRUFHTHhCLFVBSEssRUFJTE8sT0FKSyxFQUtMTyxNQUxLLEVBTUxaLFdBTkssRUFPTDtNQUNJdUIsYUFBYUYsS0FBS2hYLElBQXRCO01BQ0ltWCxZQUFZSCxLQUFLbFgsR0FBckI7O01BRUlzWCxXQUFXcEIsWUFBWSxNQUFaLEdBQXFCLENBQUNYLFlBQXRCLEdBQXFDLElBQXBEO01BQ0lnQyxhQUFhckIsWUFBWSxNQUFaLEdBQXFCLENBQUNYLFlBQXRCLEdBQXFDLElBQXREO01BQ0lpQyxjQUFjLElBQWxCO01BQ0lDLFlBQVl2QixZQUFZLE9BQVosR0FBc0IsQ0FBQ1gsWUFBdkIsR0FBc0MsSUFBdEQ7O01BRUlrQixXQUFXLElBQWYsRUFBcUI7Z0JBQ1BTLEtBQUtsWCxHQUFMLEdBQVdtWCxVQUFVTyxNQUFWLENBQWlCM1csQ0FBeEM7ZUFDV29XLFVBQVVRLEtBQVYsQ0FBZ0I1VyxDQUEzQjtHQUZGLE1BR08sSUFBSTBWLFdBQVcsTUFBZixFQUF1QjtnQkFFMUJTLEtBQUtsWCxHQUFMLEdBQVcyVixXQUFXdFcsTUFBdEIsR0FBK0J3VyxZQUFZeFcsTUFBM0MsR0FBb0Q4WCxVQUFVTyxNQUFWLENBQWlCM1csQ0FEdkU7a0JBRWNvVyxVQUFVUSxLQUFWLENBQWdCNVcsQ0FBOUI7R0FISyxNQUlBLElBQUkwVixXQUFXLE1BQWYsRUFBdUI7aUJBQ2ZTLEtBQUtoWCxJQUFMLEdBQVlpWCxVQUFVTyxNQUFWLENBQWlCNWMsQ0FBMUM7Z0JBQ1lxYyxVQUFVUSxLQUFWLENBQWdCN2MsQ0FBNUI7R0FGSyxNQUdBLElBQUkyYixXQUFXLE9BQWYsRUFBd0I7aUJBRTNCUyxLQUFLaFgsSUFBTCxHQUFZeVYsV0FBVzlULEtBQXZCLEdBQStCZ1UsWUFBWWhVLEtBQTNDLEdBQW1Ec1YsVUFBVU8sTUFBVixDQUFpQjVjLENBRHRFO2lCQUVhcWMsVUFBVVEsS0FBVixDQUFnQjdjLENBQTdCO0dBSEssTUFJQSxJQUFJMmIsV0FBVyxRQUFmLEVBQXlCO1FBQzFCUCxZQUFZLE1BQVosSUFBc0JBLFlBQVksT0FBdEMsRUFBK0M7VUFDdkNHLGFBQWFnQixZQUFZeEIsWUFBWXhXLE1BQVosR0FBcUIsQ0FBcEQ7a0JBQ1lnWCxhQUFhVixXQUFXdFcsTUFBWCxHQUFvQixDQUE3QztpQkFDVyxDQUFDc1csV0FBV3RXLE1BQVgsR0FBb0JrVyxZQUFyQixJQUFxQyxDQUFoRDs7UUFFRVcsWUFBWSxJQUFaLElBQW9CQSxZQUFZLE1BQXBDLEVBQTRDO1VBQ3BDRyxjQUFhZSxhQUFhdkIsWUFBWWhVLEtBQVosR0FBb0IsQ0FBcEQ7bUJBQ2F3VSxjQUFhVixXQUFXOVQsS0FBWCxHQUFtQixDQUE3QztrQkFDWSxDQUFDOFQsV0FBVzlULEtBQVgsR0FBbUIwVCxZQUFwQixJQUFvQyxDQUFoRDs7OztTQUlHO2tCQUNTO1dBQ1A4QixTQURPO1lBRU5EO0tBSEg7aUJBS1E7V0FDTkUsUUFETTthQUVKQyxVQUZJO2NBR0hDLFdBSEc7WUFJTEM7O0dBVFY7Ozs7QUFlRixBQUFPLFNBQVNHLFdBQVQsQ0FDTEMsY0FESyxFQUVMbEMsVUFGSyxFQUdMTyxPQUhLLEVBSUxMLFdBSkssRUFLTEMsVUFMSyxFQU1MO01BQ01nQyxhQUFhdkMsZUFBZSxDQUFsQzs7TUFFSXZWLFlBQUo7TUFDSWtXLFlBQVksTUFBaEIsRUFBd0I7VUFDaEJKLFdBQVdpQyxPQUFYLEdBQXFCbEMsWUFBWTVWLE1BQWpDLEdBQTBDNlgsVUFBaEQ7R0FERixNQUVPLElBQUk1QixZQUFZLElBQWhCLEVBQXNCO1VBRXpCSixXQUFXaUMsT0FBWCxJQUFzQmxDLFlBQVk3VixHQUFaLEdBQWtCMlYsV0FBV3RXLE1BQTdCLEdBQXNDeVksVUFBNUQsQ0FERjtHQURLLE1BR0E7O1VBRUNoQyxXQUFXaUMsT0FBWCxHQUFxQmxDLFlBQVk3VixHQUF2Qzs7OztNQUlFRSxhQUFKO01BQ0lnVyxZQUFZLE1BQWhCLEVBQXdCO1dBRXBCSixXQUFXa0MsT0FBWCxJQUFzQm5DLFlBQVkzVixJQUFaLEdBQW1CeVYsV0FBVzlULEtBQTlCLEdBQXNDaVcsVUFBNUQsQ0FERjtHQURGLE1BR08sSUFBSTVCLFlBQVksT0FBaEIsRUFBeUI7V0FDdkJKLFdBQVdrQyxPQUFYLEdBQXFCbkMsWUFBWXpWLEtBQWpDLEdBQXlDMFgsVUFBaEQ7R0FESyxNQUVBOztXQUVFaEMsV0FBV2tDLE9BQVgsR0FBcUJuQyxZQUFZM1YsSUFBeEM7Ozs7U0FJSzJYLGVBQWU5VyxDQUF0QjtVQUNROFcsZUFBZS9jLENBQXZCO1NBQ08sRUFBRWtGLFFBQUYsRUFBT0UsVUFBUCxFQUFQOzs7SUFHbUIrWDs7Ozs7Ozs7Ozs7Ozs7eUxBQ25CbE4sUUFBZTtvQkFDQzthQUNQeEMsU0FETztlQUVMQSxTQUZLO2dCQUdKQSxTQUhJO2NBSU5BO09BTEs7bUJBT0E7YUFDTkEsU0FETTtlQUVKQSxTQUZJO2dCQUdIQSxTQUhHO2NBSUxBO09BWEs7ZUFhSjthQTJCWDJQLG9CQUFvQixVQUFDdGhCLEtBQUQsRUFBa0I7VUFFbENpaEIsY0FGa0MsR0FPaENqaEIsS0FQZ0MsQ0FFbENpaEIsY0FGa0M7VUFHbENqQyxjQUhrQyxHQU9oQ2hmLEtBUGdDLENBR2xDZ2YsY0FIa0M7VUFJbEN1Qyx3QkFKa0MsR0FPaEN2aEIsS0FQZ0MsQ0FJbEN1aEIsd0JBSmtDO1VBS2xDdEMsV0FMa0MsR0FPaENqZixLQVBnQyxDQUtsQ2lmLFdBTGtDO1VBTWxDaFUsS0FOa0MsR0FPaENqTCxLQVBnQyxDQU1sQ2lMLEtBTmtDOzs7OztVQVc5Qm1XLFVBQVVHLDJCQUNaLENBRFksR0FFWmhQLE9BQU9pUCxXQUFQLElBQ0NDLFNBQVNDLGVBQVQsSUFBNEJELFNBQVNDLGVBQVQsQ0FBeUJDLFVBRHRELElBRUEsQ0FKSjtVQUtNUixVQUFVSSwyQkFDWixDQURZLEdBRVpoUCxPQUFPcVAsV0FBUCxJQUNDSCxTQUFTQyxlQUFULElBQTRCRCxTQUFTQyxlQUFULENBQXlCRyxTQUR0RCxJQUVBLENBSko7O1VBTU0zQyxhQUFhO2dCQUNUM00sT0FBT3VQLFdBREU7ZUFFVnZQLE9BQU93UCxVQUZHO3dCQUFBOztPQUFuQjs7VUFPTWhELGFBQWE7Z0JBQ1QsTUFBSytCLE1BQUwsR0FBYyxNQUFLQSxNQUFMLENBQVlrQixZQUExQixHQUF5QyxDQURoQzs7T0FBbkI7OztVQU1NMUMsVUFBVVIsV0FDZEMsVUFEYyxFQUVkQyxjQUZjLEVBR2RDLFdBSGMsRUFJZEMsVUFKYyxDQUFoQjs7O1VBUU1XLFNBQVNOLFVBQVVSLFVBQVYsRUFBc0JPLE9BQXRCLEVBQStCTCxXQUEvQixFQUE0Q0MsVUFBNUMsQ0FBZjs7O1VBR01vQixPQUFPVSxZQUNYQyxjQURXLEVBRVhsQyxVQUZXLEVBR1hPLE9BSFcsRUFJWEwsV0FKVyxFQUtYQyxVQUxXLENBQWI7OztVQVNNK0MsYUFBYW5DLGVBQWVELE1BQWYsRUFBdUJaLFdBQXZCLEVBQW9DQyxVQUFwQyxDQUFuQjs7OzsyQkFHc0NtQixjQUNwQ0MsSUFEb0MsRUFFcEMyQixVQUZvQyxFQUdwQ2xELFVBSG9DLEVBSXBDTyxPQUpvQyxFQUtwQ08sTUFMb0MsRUFNcENaLFdBTm9DLENBMURGO1VBMEQ1QmlELFlBMUQ0QixrQkEwRDVCQSxZQTFENEI7VUEwRGRDLFdBMURjLGtCQTBEZEEsV0ExRGM7O1lBbUUvQjlOLFFBQUwsQ0FBYztnQ0FBQTtrQ0FBQTs7T0FBZDs7Ozs7O3dDQTNGa0I7OztXQUNiaU4saUJBQUwsQ0FBdUIsS0FBS3RoQixLQUE1QjtpQkFDVyxZQUFNO1lBQ1gsT0FBS0EsS0FBTCxDQUFXb2lCLFdBQVgsSUFBMEIsT0FBS3RCLE1BQW5DLEVBQTJDO2lCQUNwQ0EsTUFBTCxDQUFZdUIsS0FBWjs7T0FGSjthQUtPQyxnQkFBUCxDQUF3QixRQUF4QixFQUFrQyxLQUFLdGlCLEtBQUwsQ0FBV3VpQixRQUE3QzthQUNPRCxnQkFBUCxDQUF3QixTQUF4QixFQUFtQyxLQUFLdGlCLEtBQUwsQ0FBV3dpQixTQUE5Qzs7Ozs4Q0FHd0JDLFdBQWtCO1dBQ3JDbkIsaUJBQUwsQ0FBdUJtQixTQUF2Qjs7OzsyQ0FHcUI7YUFDZEMsbUJBQVAsQ0FBMkIsUUFBM0IsRUFBcUMsS0FBSzFpQixLQUFMLENBQVd1aUIsUUFBaEQ7YUFDT0csbUJBQVAsQ0FBMkIsU0FBM0IsRUFBc0MsS0FBSzFpQixLQUFMLENBQVd3aUIsU0FBakQ7Ozs7Ozs7Ozs7NkJBbUZPOzs7bUJBQzhCLEtBQUt4aUIsS0FEbkM7VUFDQzJpQixPQURELFVBQ0NBLE9BREQ7VUFDVTVXLFFBRFYsVUFDVUEsUUFEVjtVQUNvQmQsS0FEcEIsVUFDb0JBLEtBRHBCOzs7O1VBSUQyWCxhQUFhLEtBQUt6TyxLQUFMLENBQVdtTCxPQUFYLEtBQXVCLElBQXZCLEdBQThCLFFBQTlCLEdBQXlDLFNBQTVEO1VBQ011RCxhQUFnQkYsT0FBaEIsT0FBTjtVQUNNRyxTQUFTSCxZQUFZLE9BQVosR0FBc0IsU0FBdEIsR0FBa0MsSUFBakQ7VUFDTUksY0FBY0osWUFBWSxPQUFaLEdBQXNCLFdBQXRCLEdBQW9DQSxPQUF4RDs7YUFHRXZXOzs7cUJBQ2FqTixTQUFPNmpCLFNBRHBCOzRCQUVXRixjQUFULEVBQWlCRixzQkFBakIsSUFBZ0MsS0FBS3pPLEtBQUwsQ0FBVytOLFlBQTNDOzs7Ozt1QkFHYTNRLFdBQ1RySyxPQUFPMmIsVUFBUCxDQURTLEVBRVQzYixPQUFPNmIsV0FBUCxDQUZTLEVBR1Q1akIsU0FBTzhqQixVQUhFLEVBSVQ5akIsU0FBTytqQixRQUpFLENBRGI7aUJBT08sZ0JBQUs7cUJBQ0hwQyxNQUFMLEdBQWN6YyxDQUFkO2FBUko7c0JBVVksQ0FBQzs7Ozs7eUJBR0VrTixXQUFXcFMsU0FBTzhqQixVQUFsQixFQUE4QjlqQixTQUFPZ2tCLGFBQXJDLENBRGI7cUJBRVMsRUFBRWxZLFlBQUY7OztXQWRYOzs7O3lCQW1CZXNHLFdBQVdySyxPQUFPeWIsT0FBUCxDQUFYLEVBQTRCeGpCLFNBQU80aEIsS0FBbkMsQ0FEYjtrQ0FFYyxLQUFLNU0sS0FBTCxDQUFXZ08sV0FBdkI7OzBCQUVDLEtBQUQsSUFBTyxXQUFXLEtBQUtoTyxLQUFMLENBQVdtTCxPQUE3Qjs7O09BM0JSOzs7O0VBOUhrQ3pUO0FBa0t0Q3dWLFNBQVMxVSxTQUFULEdBQXFCO1dBQ1ZKLFVBQVVDLEtBQVYsQ0FBZ0IsQ0FBQyxNQUFELEVBQVMsVUFBVCxFQUFxQixRQUFyQixFQUErQixPQUEvQixDQUFoQixDQURVO1lBRVRELFVBQVVLLElBRkQ7a0JBR0hMLFVBQVVDLEtBQVYsQ0FBZ0IsQ0FBQyxJQUFELEVBQU8sT0FBUCxFQUFnQixNQUFoQixFQUF3QixNQUF4QixDQUFoQixDQUhHO2FBSVJELFVBQVU0RyxJQUFWLENBQWV0QixVQUpQO1lBS1R0RixVQUFVNEcsSUFBVixDQUFldEIsVUFMTjtrQkFNSHRGLFVBQVVNLEtBQVYsQ0FBZ0IsRUFBRTNJLEdBQUdxSSxVQUFVVSxNQUFmLEVBQXVCOUMsR0FBR29DLFVBQVVVLE1BQXBDLEVBQWhCLENBTkc7NEJBT09WLFVBQVVTLElBUGpCO2VBUU5ULFVBQVVTLElBUko7ZUFTTlQsVUFBVU0sS0FBVixDQUFnQjtZQUNuQk4sVUFBVVUsTUFEUztZQUVuQlYsVUFBVVUsTUFGUztVQUdyQlYsVUFBVVUsTUFIVztXQUlwQlYsVUFBVVUsTUFKVTtTQUt0QlYsVUFBVVUsTUFMWTtXQU1wQlYsVUFBVVU7R0FOTixDQVRNO1NBaUJaVixVQUFVVTtDQWpCbkI7O0lDOWRxQm1XOzs7Ozs7Ozs7Ozs7OztpTkFhbkJDLG1CQUFtQixVQUFDaEwsS0FBRCxFQUF1Qjs7VUFFbENpQyxLQUFLZ0osa0JBQVg7VUFFRSxDQUFDLE1BQUt0akIsS0FBTCxDQUFXeVgsT0FBWixJQUNBLENBQUM2QyxFQURELElBRUNqQyxNQUFNYSxNQUFOLFlBQXdCcUssSUFBeEIsSUFBZ0NqSixHQUFHbFAsUUFBSCxDQUFZaU4sTUFBTWEsTUFBbEIsQ0FIbkMsRUFJRTs7O1lBR0dsWixLQUFMLENBQVd5WCxPQUFYLENBQW1CWSxLQUFuQjs7Ozs7O3dDQXRCa0I7ZUFDVGlLLGdCQUFULENBQTBCLE9BQTFCLEVBQW1DLEtBQUtlLGdCQUF4QyxFQUEwRDtpQkFDL0M7T0FEWDs7OzsyQ0FLcUI7ZUFDWlgsbUJBQVQsQ0FBNkIsT0FBN0IsRUFBc0MsS0FBS1csZ0JBQTNDLEVBQTZEO2lCQUNsRDtPQURYOzs7OzZCQWtCTzthQUNBLEtBQUtyakIsS0FBTCxDQUFXK0wsUUFBbEI7Ozs7RUEzQjhDRjs7QUNRbEQsSUFBTTJYLGlCQUFpQjtNQUNqQixHQURpQjtNQUVqQixHQUZpQjtNQUdqQixHQUhpQjtNQUlqQixHQUppQjtNQUtqQjtDQUxOOztBQVFBLElBQU1DLGtCQUFrQixFQUF4Qjs7SUFtQnFCQzs7Ozs7Ozs7Ozs7Ozs7NkxBQ25CdlAsUUFBZTtzQkFDRztXQUNYLENBRFc7V0FFWDtPQUhROzJCQUtRO2dCQUNYLENBRFc7Z0JBRVgsQ0FGVztjQUdiLENBSGE7ZUFJWixDQUpZO2FBS2QsQ0FMYztlQU1aOzthQVlYd1AsZ0JBQWdCLFVBQUN0TCxLQUFELEVBQWdDO1VBQzFDQSxNQUFNdUwsT0FBTixLQUFrQkgsZUFBdEIsRUFBdUM7Y0FDaEN6akIsS0FBTCxDQUFXNmpCLFNBQVg7O2FBSUpDLGtCQUFrQixVQUFDekwsS0FBRCxFQUFrQjtVQUVoQ0EsTUFBTWEsTUFBTixZQUF3QnFLLElBQXhCLElBQ0EsTUFBS3ZqQixLQUFMLENBQVcrakIsTUFEWCxJQUVBLENBQUMsTUFBSy9qQixLQUFMLENBQVcrakIsTUFBWCxDQUFrQjNZLFFBQWxCLENBQTJCaU4sTUFBTWEsTUFBakMsQ0FISCxFQUlFO2NBQ0tsWixLQUFMLENBQVc2akIsU0FBWDs7YUFJSkcsZUFBZSxZQUFNO1lBQ2RDLGlCQUFMLENBQXVCLE1BQUtqa0IsS0FBNUI7YUFHRmlrQixvQkFBb0IsVUFBQ2prQixLQUFELEVBQWtCO1VBQzVCK2pCLE1BRDRCLEdBQ1MvakIsS0FEVCxDQUM1QitqQixNQUQ0QjtVQUNwQnhDLHdCQURvQixHQUNTdmhCLEtBRFQsQ0FDcEJ1aEIsd0JBRG9COztVQUVoQzJDLDRCQUFKO1VBQ0lqRCx1QkFBSjtVQUNJOEMsTUFBSixFQUFZOzhCQUNZQSxPQUFPSSxxQkFBUCxFQUF0Qjs7O3lCQUdpQjthQUNaNUMsMkJBQ0MyQyxvQkFBb0I1YSxJQUFwQixHQUEyQnlhLE9BQU9LLFVBRG5DLEdBRUMsQ0FIVzthQUlaN0MsMkJBQ0MyQyxvQkFBb0I5YSxHQUFwQixHQUEwQjJhLE9BQU9NLFNBRGxDLEdBRUM7U0FOTjs7O1lBVUdoUSxRQUFMLENBQWMsRUFBRTRNLDhCQUFGLEVBQWtCaUQsd0NBQWxCLEVBQWQ7Ozs7Ozt3Q0E5Q2tCO1dBQ2JELGlCQUFMLENBQXVCLEtBQUtqa0IsS0FBNUI7Ozs7OENBR3dCeWlCLFdBQWtCO1dBQ3JDd0IsaUJBQUwsQ0FBdUJ4QixTQUF2Qjs7Ozs2QkE0Q087bUJBUUgsS0FBS3ppQixLQVJGO1VBRUwrakIsTUFGSyxVQUVMQSxNQUZLO1VBR0xwQixPQUhLLFVBR0xBLE9BSEs7VUFJTDVXLFFBSkssVUFJTEEsUUFKSztVQUtMaVQsY0FMSyxVQUtMQSxjQUxLO1VBTUx1Qyx3QkFOSyxVQU1MQSx3QkFOSztVQU9MYSxXQVBLLFVBT0xBLFdBUEs7O1VBU0gsQ0FBQzJCLE1BQUwsRUFBYTtlQUNKLElBQVA7O1VBRUk5akIsT0FBTyxLQUFLRCxLQUFMLENBQVdDLElBQVgsR0FBa0IsS0FBS0QsS0FBTCxDQUFXQyxJQUE3QixHQUFvQyxJQUFqRDtVQUNNZ0wsUUFBUSxPQUFPaEwsSUFBUCxLQUFnQixRQUFoQixHQUEyQnVqQixlQUFldmpCLElBQWYsQ0FBM0IsR0FBa0RBLElBQWhFO2FBRUVtTTs0QkFBQTtVQUFzQixTQUFTLEtBQUswWCxlQUFwQzs7a0JBQ0U7O3FCQUNXbkIsT0FEWDs0QkFFa0IzRCxjQUZsQjt1QkFHYSxLQUFLMkUsYUFIbEI7c0JBSVksS0FBS0ssWUFKakI7c0NBSzRCekMsd0JBTDVCOzRCQU1rQixLQUFLcE4sS0FBTCxDQUFXOE0sY0FON0I7eUJBT2VtQixXQVBmO3lCQVFlLEtBQUtqTyxLQUFMLENBQVcrUCxtQkFSMUI7bUJBU1NqWjs7OztPQVhiOzs7O0VBL0VvQ1k7OztBQW1HeEM2WCxXQUFXL1csU0FBWCxHQUF1QjtVQUNiSixVQUFVVyxLQUFWLENBQWdCO2NBQ1pYLFVBQVU0RyxJQURFOzJCQUVDNUcsVUFBVTRHO0dBRjNCLENBRGE7V0FLWjVHLFVBQVVDLEtBQVYsQ0FBZ0IsQ0FBQyxNQUFELEVBQVMsVUFBVCxFQUFxQixRQUFyQixFQUErQixPQUEvQixDQUFoQixDQUxZO1lBTVhELFVBQVVLLElBTkM7a0JBT0xMLFVBQVVDLEtBQVYsQ0FBZ0IsQ0FBQyxJQUFELEVBQU8sT0FBUCxFQUFnQixNQUFoQixFQUF3QixNQUF4QixDQUFoQixDQVBLO2FBUVZELFVBQVU0RyxJQUFWLENBQWV0QixVQVJMOzRCQVNLdEYsVUFBVVMsSUFUZjtlQVVSVCxVQUFVUyxJQVZGO1FBV2ZULFVBQVVRLFNBQVYsQ0FBb0IsQ0FDeEJSLFVBQVVVLE1BRGMsRUFFeEJWLFVBQVVDLEtBQVYsQ0FBZ0IsQ0FBQyxJQUFELEVBQU8sSUFBUCxFQUFhLElBQWIsRUFBbUIsSUFBbkIsRUFBeUIsSUFBekIsQ0FBaEIsQ0FGd0IsQ0FBcEI7O0NBWFI7O0FDL0hlLFNBQVM4WCxNQUFULENBQWdCdGtCLEtBQWhCLEVBQThCO01BRXpDK2pCLE1BRnlDLEdBVXZDL2pCLEtBVnVDLENBRXpDK2pCLE1BRnlDO01BR3pDaFksUUFIeUMsR0FVdkMvTCxLQVZ1QyxDQUd6QytMLFFBSHlDO01BSXpDaVQsY0FKeUMsR0FVdkNoZixLQVZ1QyxDQUl6Q2dmLGNBSnlDO01BS3pDNkUsU0FMeUMsR0FVdkM3akIsS0FWdUMsQ0FLekM2akIsU0FMeUM7OEJBVXZDN2pCLEtBVnVDLENBTXpDdWhCLHdCQU55QztNQU16Q0Esd0JBTnlDLHlDQU1kLElBTmM7cUJBVXZDdmhCLEtBVnVDLENBT3pDa1IsS0FQeUM7TUFPekNBLEtBUHlDLGdDQU9qQyxPQVBpQzsyQkFVdkNsUixLQVZ1QyxDQVF6Q29pQixXQVJ5QztNQVF6Q0EsV0FSeUMsc0NBUTNCLElBUjJCO01BU3pDbmlCLElBVHlDLEdBVXZDRCxLQVZ1QyxDQVN6Q0MsSUFUeUM7OztNQVl2QyxDQUFDOGpCLE1BQUwsRUFBYTtXQUNKLElBQVA7OztTQUlBM1g7Y0FBQTs7Y0FDVTJYLE1BRFY7ZUFFVzdTLEtBRlg7c0JBR2tCOE4sY0FIbEI7aUJBSWE2RSxTQUpiO2dDQUs0QnRDLHdCQUw1QjttQkFNZWEsV0FOZjtZQU9RbmlCOzs7R0FSVjs7O0FBZUZxa0IsT0FBTzNYLFNBQVAsR0FBbUI7VUFDVEosVUFBVVcsS0FBVixDQUFnQjtjQUNaWCxVQUFVNEcsSUFERTsyQkFFQzVHLFVBQVU0RztHQUYzQixDQURTO1lBS1A1RyxVQUFVSyxJQUxIO2tCQU1ETCxVQUFVQyxLQUFWLENBQWdCLENBQUMsSUFBRCxFQUFPLE9BQVAsRUFBZ0IsTUFBaEIsRUFBd0IsTUFBeEIsQ0FBaEIsQ0FOQzthQU9ORCxVQUFVNEcsSUFBVixDQUFldEIsVUFQVDs0QkFRU3RGLFVBQVVTLElBUm5CO1NBU1ZULFVBQVVDLEtBQVYsQ0FBZ0IsQ0FBQyxNQUFELEVBQVMsUUFBVCxFQUFtQixPQUFuQixFQUE0QixVQUE1QixDQUFoQixDQVRVO1FBVVhELFVBQVVRLFNBQVYsQ0FBb0IsQ0FDeEJSLFVBQVVVLE1BRGMsRUFFeEJWLFVBQVVDLEtBQVYsQ0FBZ0IsQ0FBQyxJQUFELEVBQU8sSUFBUCxFQUFhLElBQWIsRUFBbUIsSUFBbkIsRUFBeUIsSUFBekIsQ0FBaEIsQ0FGd0IsQ0FBcEI7O0NBVlI7Ozs7QUN2Q0EsU0FBUytYLEdBQVQsQ0FBYUMsQ0FBYixFQUFnQkMsQ0FBaEIsRUFBbUI7U0FDVkQsRUFBRTFrQixHQUFGLENBQU0sVUFBQ21iLElBQUQsRUFBT0ssR0FBUDtXQUFlLENBQUNMLElBQUQsRUFBT3dKLEVBQUVuSixHQUFGLENBQVAsQ0FBZjtHQUFOLENBQVA7OztBQUdGLElBQU1vSixlQUFlLENBQXJCOztBQUVBLElBQU1DLGVBQWU7TUFDZixFQURlO01BRWYsRUFGZTtNQUdmO0NBSE47O0FBZUEsSUFBTUMsZUFBZSxTQUFmQSxZQUFlLENBQUM1akIsQ0FBRCxFQUFJZixJQUFKLEVBQWE7VUFDeEJlLENBQVI7U0FDTyxDQUFMO1NBQ0ssQ0FBTDthQUNTLENBQ0wsRUFBRW9JLEtBQUssQ0FBUCxFQUFVRSxNQUFNLENBQWhCLEVBQW1CMkIsT0FBT2hMLElBQTFCLEVBQWdDd0ksUUFBUXhJLElBQXhDLEVBQThDNGtCLFlBQVksUUFBMUQsRUFESyxDQUFQO1NBR0csQ0FBTDthQUNTLENBQ0w7YUFDTyxDQURQO2NBRVEsQ0FGUjsrQkFHdUJILGVBQWUsQ0FBcEMsUUFIRjtnQkFJVXprQixJQUpWO29CQUtjO09BTlQsRUFRTDthQUNPLENBRFA7OEJBRXNCeWtCLGVBQWUsQ0FBbkMsUUFGRjsrQkFHdUJBLGVBQWUsQ0FBcEMsUUFIRjtnQkFJVXprQixJQUpWO29CQUtjO09BYlQsQ0FBUDs7YUFpQk8sQ0FDTDthQUNPLENBRFA7Y0FFUSxDQUZSOytCQUd1QnlrQixlQUFlLENBQXBDLFFBSEY7Z0JBSVV6a0IsSUFKVjtvQkFLYztPQU5ULEVBUUw7YUFDTyxDQURQOzhCQUVzQnlrQixlQUFlLENBQW5DLFFBRkY7ZUFHUyxXQUhUO2dDQUl3QkEsZUFBZSxDQUFyQyxRQUpGO29CQUtjO09BYlQsRUFlTDs2QkFDcUJBLGVBQWUsQ0FBbEMsUUFERjs4QkFFc0JBLGVBQWUsQ0FBbkMsUUFGRjtlQUdTLFdBSFQ7Z0NBSXdCQSxlQUFlLENBQXJDLFFBSkY7b0JBS2M7T0FwQlQsQ0FBUDs7Q0F6Qk47O0FBbURBLElBQU1JLFdBQVcsU0FBWEEsUUFBVztTQUFPQyxPQUFPOWpCLEtBQUsrakIsRUFBTCxHQUFVLEdBQWpCLENBQVA7Q0FBakI7O0FBRUEsSUFBTXRSLGtCQUFnQixTQUFoQkEsYUFBZ0IsQ0FBQzFULEtBQUQsRUFJZjtNQUNHQyxJQURILEdBQzhCRCxLQUQ5QixDQUNHQyxJQURIO01BQ1NxQixJQURULEdBQzhCdEIsS0FEOUIsQ0FDU3NCLElBRFQ7TUFDZXVqQixVQURmLEdBQzhCN2tCLEtBRDlCLENBQ2U2a0IsVUFEZjs7O01BR0NJLDJCQUF5QmhrQixLQUFLaWtCLEdBQUwsQ0FBU0osU0FBUyxFQUFULENBQVQsQ0FBekIsWUFBc0Q3a0IsSUFBdEQsV0FBTjs7TUFFTWtsQixVQUNKL1k7OzthQUNRLE1BRFI7ZUFFVSxpQkFGVjtlQUdVLEtBSFY7MkJBSXNCLGVBSnRCO2FBS1E7Ozs7OztLQUxSOzs7O2tCQVNhLE1BRFg7Y0FFTyxNQUZQOzBCQUdtQixTQUhuQjtvQkFJYSxRQUpiO21CQUthLENBQ1R5SCxXQUFXQyxXQURGLEVBRVRELFdBQVdFLFNBRkYsRUFHVEYsV0FBV0csWUFIRixFQUlUSCxXQUFXSSxjQUpGLEVBS1Q5VCxJQUxTLENBS0osR0FMSTs7YUFPSCw0QkFBSW1CLElBQUosR0FBVSxDQUFWLEVBQWFzUyxXQUFiLEVBQVAsR0FBb0M7O0dBckIzQztVQXlCUWlSLFVBQVI7U0FDTyxZQUFMO2FBRUl6WTtXQUFBOzt3QkFDYzlLLElBRGQ7aUJBRVEsTUFGUjtrQkFHUyxNQUhUO21CQUlVLE1BSlY7c0JBS2EsS0FMYjtxQ0FNNkI7cUJBQ2hCOzZCQUNRMmpCLGNBRFI7NEJBRU9BOzs7OztPQVZ0QjtTQWlCRyxTQUFMO2FBRUk3WTtXQUFBOzt3QkFDYzlLLElBRGQ7aUJBRVEsTUFGUjtrQkFHUyxNQUhUO21CQUlVLE1BSlY7c0JBS2EsT0FMYjtxQ0FNNkI7cUJBQ2hCOzBCQUNLMmpCLGNBREw7NEJBRU9BOzs7OztPQVZ0Qjs7YUFtQkU3WTtXQUFBOzt3QkFDYzlLLElBRGQ7aUJBRVEsTUFGUjtrQkFHUyxNQUhUO21CQUlVLE1BSlY7c0JBS2EsUUFMYjswQkFNaUI7OztPQVBuQjs7Q0F4RU47O0FBdUZBLEFBQWUsU0FBUzhqQixXQUFULENBQXFCcGxCLEtBQXJCLEVBQW1DO01BQ3hDcWxCLGFBRHdDLEdBQ1BybEIsS0FETyxDQUN4Q3FsQixhQUR3QztNQUN6QjlRLE9BRHlCLEdBQ1B2VSxLQURPLENBQ3pCdVUsT0FEeUI7TUFDaEJ0VSxJQURnQixHQUNQRCxLQURPLENBQ2hCQyxJQURnQjs7TUFFMUNxbEIsY0FBY3JsQixPQUFPMGtCLGFBQWExa0IsSUFBYixDQUFQLEdBQTRCLE1BQWhEO01BQ01zbEIsZUFBZXRsQixPQUFPMGtCLGFBQWExa0IsSUFBYixDQUFQLEdBQTRCLEVBQWpEO01BQ01pYyxZQUFZMEksYUFBYVMsY0FBYy9rQixNQUEzQixFQUFtQ2dsQixXQUFuQyxDQUFsQjtTQUVFbFo7T0FBQTs7YUFDUSxPQURSO2dCQUVXLFFBRlg7YUFHUSxRQUhSO2FBSVNrWixXQUpUO2NBS1VDLFlBTFY7Z0JBTVcsVUFOWDtpQ0FPNkI7OEJBRW5CaFIsVUFBVSxFQUFFaVIsV0FBVyxnQkFBYixFQUFWLEdBQTRDLEVBRGxEOzs7c0JBSWM7Ozs7a0JBSWYsR0FBRCxJQUFLLDJCQUEyQixFQUFFcmEsU0FBUyxFQUFFc0ksZUFBZSxNQUFqQixFQUFYLEVBQWhDLEdBaEJGO1FBaUJPeUksU0FBSixFQUFlbUosYUFBZixFQUE4QnZsQixHQUE5QixDQUNDLGdCQUEwRHdiLEdBQTFELEVBQWtFOztVQUFoRUQsUUFBZ0U7O1VBQXREb0ssWUFBc0QsMEJBQXZDLEVBQUVua0IsTUFBTSxFQUFSLEVBQVlnUixLQUFLWCxTQUFqQixFQUF1Qzs7VUFDeEQxRyxLQUR3RCxHQUNmb1EsUUFEZSxDQUN4RHBRLEtBRHdEO1VBQ2pEeEMsTUFEaUQsR0FDZjRTLFFBRGUsQ0FDakQ1UyxNQURpRDtVQUN6Q1csR0FEeUMsR0FDZmlTLFFBRGUsQ0FDekNqUyxHQUR5QztVQUNwQ0UsSUFEb0MsR0FDZitSLFFBRGUsQ0FDcEMvUixJQURvQztVQUM5QnViLFVBRDhCLEdBQ2Z4SixRQURlLENBQzlCd0osVUFEOEI7VUFFeER2akIsSUFGd0QsR0FFMUNta0IsWUFGMEMsQ0FFeERua0IsSUFGd0Q7VUFFbERnUixHQUZrRCxHQUUxQ21ULFlBRjBDLENBRWxEblQsR0FGa0Q7O2FBSTlEbEc7V0FBQTs7ZUFDT2tQLEdBRFA7b0JBRVcsVUFGWDtpQkFHU3JRLEtBSFQ7a0JBSVV4QyxNQUpWO3FDQUs2QixFQUFFMEMsU0FBUyxFQUFFL0IsUUFBRixFQUFPRSxVQUFQLEVBQVg7O2NBR3pCOEMsY0FBQyxLQUFEO2VBQ085SyxJQURQO2lCQUVRLFNBRlI7ZUFHT2dSLEdBSFA7d0JBSWdCLENBSmhCO3lCQUtpQixDQUxqQjtlQU1NO1VBUFAsR0FVQ2xHLGNBQUNzSCxlQUFEO2dCQUNRcFMsSUFEUjtzQkFFY3VqQixVQUZkO2dCQUdRcGM7VUFwQlo7K0JBdUJPLFdBQVd0SixTQUFPbVUsSUFBdkI7T0F4Qko7S0FKSDtHQWxCTDs7O0FBdURGOFIsWUFBWXpZLFNBQVosR0FBd0I7aUJBQ1BKLFVBQVVtUCxPQUFWLENBQ2JuUCxVQUFVTSxLQUFWLENBQWdCO1VBQ1JOLFVBQVVZLE1BQVYsQ0FBaUIwRSxVQURUO1NBRVR0RixVQUFVWTtHQUZqQixDQURhLEVBS2IwRSxVQU5vQjtXQU9idEYsVUFBVVMsSUFQRztRQVFoQlQsVUFBVUMsS0FBVixDQUFnQixDQUFDLElBQUQsRUFBTyxJQUFQLEVBQWEsSUFBYixDQUFoQjtDQVJSOzs7O0FDL0xBLElBQU1rWix1QkFBdUI7TUFDdkIsQ0FEdUI7TUFFdkIsQ0FGdUI7TUFHdkIsQ0FIdUI7TUFJdkIsQ0FKdUI7TUFLdkI7Q0FMTjs7QUFRQSxJQUFNalIsZUFBMEM7TUFDMUMsQ0FEMEM7TUFFMUMsQ0FGMEM7TUFHMUMsQ0FIMEM7TUFJMUMsQ0FKMEM7TUFLMUM7Q0FMTjs7QUFRQSxBQUFlLFNBQVNrUixPQUFULENBQWlCM2xCLEtBQWpCLEVBQStCO01BRTFDNGxCLGtCQUYwQyxHQVl4QzVsQixLQVp3QyxDQUUxQzRsQixrQkFGMEM7TUFHMUM3WixRQUgwQyxHQVl4Qy9MLEtBWndDLENBRzFDK0wsUUFIMEM7cUJBWXhDL0wsS0Fad0MsQ0FJMUNrUixLQUowQztNQUkxQ0EsS0FKMEMsZ0NBSWxDLFVBSmtDO2tCQVl4Q2xSLEtBWndDLENBSzFDOFosRUFMMEM7TUFLMUNBLEVBTDBDLDZCQUtyQyxJQUxxQztNQU0xQzdFLE1BTjBDLEdBWXhDalYsS0Fad0MsQ0FNMUNpVixNQU4wQztNQU8xQ0QsTUFQMEMsR0FZeENoVixLQVp3QyxDQU8xQ2dWLE1BUDBDO3dCQVl4Q2hWLEtBWndDLENBUTFDOFUsUUFSMEM7TUFRMUNBLFFBUjBDLG1DQVEvQixXQVIrQjtvQkFZeEM5VSxLQVp3QyxDQVMxQ0MsSUFUMEM7TUFTMUNBLElBVDBDLCtCQVNuQyxJQVRtQztNQVUxQzhVLE1BVjBDLEdBWXhDL1UsS0Fad0MsQ0FVMUMrVSxNQVYwQzt3QkFZeEMvVSxLQVp3QyxDQVcxQ21WLFFBWDBDO01BVzFDQSxRQVgwQyxtQ0FXL0IsS0FYK0I7OztNQWN0QzdELEtBQUtpQyxXQUNUcFUsU0FBT3dtQixPQURFLEVBRVR4bUIsc0JBQWtCc1YsYUFBV3hVLElBQVgsQ0FBbEIsQ0FGUyxFQUdUOFUsVUFBVTVWLHdCQUFvQnNWLGFBQVdNLE1BQVgsQ0FBcEIsQ0FIRCxFQUlUQyxVQUFVN1Ysd0JBQW9Cc1YsYUFBV08sTUFBWCxDQUFwQixDQUpELEVBS1RDLFVBQVU5Vix3QkFBb0JzVixhQUFXUSxNQUFYLENBQXBCLENBTEQsRUFNVC9OLE9BQU9nSyxLQUFQLENBTlMsRUFPVDRELGFBQWEsV0FBYixJQUE0QmpCLFdBQVdrRCxTQVA5QixFQVFUNUIsWUFBWXRCLFdBQVdzQixRQVJkLENBQVg7O01BV00wUSxlQUFlRCxzQkFBc0JGLHFCQUFxQnpsQixJQUFyQixDQUEzQztTQUNPNEwsYUFBQSxPQUNEZ2EsWUFEQztlQUdRdlUsRUFIUjs7S0FLQzZELFlBQVksT0FBT3BKLFFBQVAsS0FBb0IsUUFBaEMsR0FDQSxFQUFFcUwsT0FBT3JMLFFBQVQsRUFEQSxHQUVBLElBUEQsR0FTTEEsUUFUSyxDQUFQOzs7QUFhRjRaLFFBQVFoWixTQUFSLEdBQW9CO3NCQUNFSixVQUFVQyxLQUFWLENBQWdCLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FBaEIsQ0FERjtZQUVSRCxVQUFVSyxJQUZGO1NBR1hMLFVBQVVDLEtBQVYsQ0FBZ0IsQ0FDckIsTUFEcUIsRUFFckIsVUFGcUIsRUFHckIsVUFIcUIsRUFJckIsTUFKcUIsRUFLckIsT0FMcUIsRUFNckIsV0FOcUIsRUFPckIsUUFQcUIsRUFRckIsVUFScUIsRUFTckIsTUFUcUIsRUFVckIsT0FWcUIsRUFXckIsUUFYcUIsRUFZckIsUUFacUIsRUFhckIsTUFicUIsRUFjckIsUUFkcUIsRUFlckIsS0FmcUIsRUFnQnJCLFlBaEJxQixFQWlCckIsT0FqQnFCLENBQWhCLENBSFc7TUFzQmRELFVBQVVZLE1BdEJJO1lBdUJSWixVQUFVQyxLQUFWLENBQWdCLENBQUMsUUFBRCxFQUFXLFdBQVgsQ0FBaEIsQ0F2QlE7UUF3QlpELFVBQVVDLEtBQVYsQ0FBZ0IsQ0FBQyxJQUFELEVBQU8sSUFBUCxFQUFhLElBQWIsRUFBbUIsSUFBbkIsRUFBeUIsSUFBekIsQ0FBaEIsQ0F4Qlk7VUF5QlZELFVBQVVDLEtBQVYsQ0FBZ0IsQ0FBQyxJQUFELEVBQU8sSUFBUCxFQUFhLElBQWIsRUFBbUIsSUFBbkIsRUFBeUIsSUFBekIsQ0FBaEIsQ0F6QlU7VUEwQlZELFVBQVVDLEtBQVYsQ0FBZ0IsQ0FBQyxJQUFELEVBQU8sSUFBUCxFQUFhLElBQWIsRUFBbUIsSUFBbkIsRUFBeUIsSUFBekIsQ0FBaEIsQ0ExQlU7VUEyQlZELFVBQVVDLEtBQVYsQ0FBZ0IsQ0FBQyxJQUFELEVBQU8sSUFBUCxFQUFhLElBQWIsRUFBbUIsSUFBbkIsRUFBeUIsSUFBekIsQ0FBaEIsQ0EzQlU7WUE0QlJELFVBQVVTO0NBNUJ0Qjs7Ozs7O0FDcEZBLElBQU04WSxxQkFBcUI7TUFDckIsRUFEcUI7TUFFckIsRUFGcUI7TUFHckIsRUFIcUI7TUFJckIsRUFKcUI7TUFLckI7Q0FMTjs7QUFrQkEsSUFBTUMsOEJBQThCO2VBQ3JCLE1BRHFCO1FBRTVCLE9BRjRCO2FBR3ZCLE1BSHVCO1NBSTNCO0NBSlQ7O0FBT0EsQUFBZSxTQUFTQyxHQUFULENBQWFobUIsS0FBYixFQUEyQjs7O3NCQVNwQ0EsS0FUb0MsQ0FFdEM0WSxNQUZzQztNQUV0Q0EsTUFGc0MsaUNBRTdCLEtBRjZCO3VCQVNwQzVZLEtBVG9DLENBR3RDMmlCLE9BSHNDO01BR3RDQSxPQUhzQyxrQ0FHNUIsYUFINEI7dUJBU3BDM2lCLEtBVG9DLENBSXRDdVosT0FKc0M7TUFJdENBLE9BSnNDLGtDQUk1QixLQUo0Qjt1QkFTcEN2WixLQVRvQyxDQUt0Q3lZLE9BTHNDO01BS3RDQSxPQUxzQyxrQ0FLNUIsS0FMNEI7eUJBU3BDelksS0FUb0MsQ0FNdENpbUIsU0FOc0M7TUFNdENBLFNBTnNDLG9DQU0xQkYsNEJBQTRCcEQsT0FBNUIsQ0FOMEI7TUFPdEN4UixJQVBzQyxHQVNwQ25SLEtBVG9DLENBT3RDbVIsSUFQc0M7b0JBU3BDblIsS0FUb0MsQ0FRdENDLElBUnNDO01BUXRDQSxJQVJzQywrQkFRL0IsSUFSK0I7OztNQVdsQ2ltQixXQUFXSixtQkFBbUI3bEIsSUFBbkIsSUFBMkIsQ0FBNUM7O01BRU1oQixjQUFjO1lBQ1Y2bUIsbUJBQW1CN2xCLElBQW5CLENBRFU7V0FFWDZsQixtQkFBbUI3bEIsSUFBbkI7R0FGVDs7TUFLTTRYLFVBQVV0RyxXQUFXcFMsU0FBT2duQixHQUFsQixFQUF1QmhuQixTQUFPd2pCLE9BQVAsQ0FBdkIsaURBQ2J4akIsU0FBT3laLE1BRE0sRUFDR0EsTUFESCwrQkFFYnpaLFNBQU9vYSxPQUZNLEVBRUlBLE9BRkosK0JBR2JwYSxTQUFPc1osT0FITSxFQUdJQSxXQUFXLENBQUNjLE9BQVosSUFBdUIsQ0FBQ1gsTUFINUIsZ0JBQWhCOztTQU9FeE07O01BQUssV0FBV3lMLE9BQWhCLEVBQXlCLE9BQU81WSxXQUFoQzs7U0FDRTtRQUFLLE9BQU0sUUFBWDtvQkFPRyxJQUFEO2VBQ1NnbkIsU0FEVDtjQUVROVUsSUFGUjtjQUdRK1UsUUFIUjs0QkFJcUI7OztHQWIzQjs7O0FBb0JGRixJQUFJclosU0FBSixHQUFnQjtVQUNOSixVQUFVUyxJQURKO1dBRUxULFVBQVVDLEtBQVYsQ0FBZ0IsQ0FBQyxhQUFELEVBQWdCLE1BQWhCLEVBQXdCLFdBQXhCLEVBQXFDLE9BQXJDLENBQWhCLENBRks7V0FHTEQsVUFBVVMsSUFITDtXQUlMVCxVQUFVUyxJQUpMO2FBS0hULFVBQVVDLEtBQVYsQ0FBZ0IsQ0FBQyxNQUFELEVBQVMsVUFBVCxFQUFxQixLQUFyQixFQUE0QixNQUE1QixFQUFvQyxPQUFwQyxDQUFoQixDQUxHO1FBTVJELFVBQVVDLEtBQVYsQ0FBZ0JwTSxPQUFPQyxJQUFQLENBQVkwUSxLQUFaLENBQWhCLEVBQW9DYyxVQU41QjtRQU9SdEYsVUFBVUMsS0FBVixDQUFnQnBNLE9BQU9DLElBQVAsQ0FBWXlsQixrQkFBWixDQUFoQjtDQVBSOztJQ3REcUJNOzs7Ozs7Ozs7Ozs7Ozs2TEFZbkJqUyxRQUFlO2NBQ0wsS0FESztlQUVKLEtBRkk7ZUFHSjthQUdYbUYsYUFBYTthQUFNLE1BQUtqRixRQUFMLENBQWMsRUFBRWtGLFNBQVMsS0FBWCxFQUFkLENBQU47YUFFYkMsY0FBYyxZQUFNO1lBQ2JuRixRQUFMLENBQWMsRUFBRWtGLFNBQVMsSUFBWCxFQUFkO2FBR0Y4TSxrQkFBa0IsWUFBTTtZQUNqQmhTLFFBQUwsQ0FBYyxFQUFFdUUsUUFBUSxJQUFWLEVBQWQ7YUFHRkwsbUJBQW1CLFlBQU07WUFDbEJsRSxRQUFMLENBQWMsRUFBRW9FLFNBQVMsSUFBWCxFQUFkO2FBR0ZDLG1CQUFtQixZQUFNO1lBQ2xCckUsUUFBTCxDQUFjO2dCQUNKLEtBREk7aUJBRUg7T0FGWDthQU1GaVMsZ0JBQWdCLFlBQU07WUFDZmpTLFFBQUwsQ0FBYyxFQUFFdUUsUUFBUSxLQUFWLEVBQWQ7Ozs7Ozs2QkFHTzttQkFVSCxLQUFLNVksS0FWRjtVQUVMc1gscUJBRkssVUFFTEEscUJBRks7VUFHTEMscUJBSEssVUFHTEEscUJBSEs7VUFJTHRHLGtCQUpLLFVBSUxBLGtCQUpLO1VBS0wwUixPQUxLLFVBS0xBLE9BTEs7VUFNTHNELFNBTkssVUFNTEEsU0FOSztVQU9MOVUsSUFQSyxVQU9MQSxJQVBLO1VBUUxsUixJQVJLLFVBUUxBLElBUks7VUFTTHdYLE9BVEssVUFTTEEsT0FUSzttQkFZOEIsS0FBS3RELEtBWm5DO1VBWUN5RSxNQVpELFVBWUNBLE1BWkQ7VUFZU1csT0FaVCxVQVlTQSxPQVpUO1VBWWtCZCxPQVpsQixVQVlrQkEsT0FabEI7OzthQWVMck07OzsyQkFDaUJrTCxxQkFEakI7MkJBRWlCQyxxQkFGakI7d0JBR2N0RyxrQkFIZDtxQkFJYTlSLFNBQU8yWSxNQUpwQjtrQkFLVSxLQUFLd0IsVUFMZjs7Ozs7Ozs7Ozs7WUFNVzttQkFBUzdCLFdBQVdBLFFBQVEsRUFBRVksWUFBRixFQUFSLENBQXBCO1dBQVQsQ0FORjttQkFPVyxLQUFLbUIsV0FQaEI7dUJBUWUsS0FBSzZNLGVBUnBCO3dCQVNnQixLQUFLOU4sZ0JBVHJCO3dCQVVnQixLQUFLRyxnQkFWckI7cUJBV2EsS0FBSzROLGFBWGxCO2lCQVlTclYsa0JBWlQ7Z0JBYU87O3NCQUVKLEdBQUQ7a0JBQ1UySCxNQURWO21CQUVXK0osT0FGWDttQkFHV3BKLE9BSFg7bUJBSVdkLE9BSlg7cUJBS2F3TixTQUxiO2dCQU1ROVUsSUFOUjtnQkFPUWxSOztPQXZCWjs7OztFQXpEb0M0TDs7QUFBbkJ1YSxXQUNaelosWUFBWTt5QkFDTUosVUFBVVMsSUFEaEI7eUJBRU1ULFVBQVVTLElBRmhCO3NCQUdHVCxVQUFVWSxNQUFWLENBQWlCMEUsVUFIcEI7V0FJUnRGLFVBQVVDLEtBQVYsQ0FBZ0IsQ0FBQyxhQUFELEVBQWdCLE1BQWhCLEVBQXdCLFdBQXhCLEVBQXFDLE9BQXJDLENBQWhCLENBSlE7UUFLWEQsVUFBVUMsS0FBVixDQUFnQnBNLE9BQU9DLElBQVAsQ0FBWTBRLEtBQVosQ0FBaEIsRUFBb0NjLFVBTHpCO2FBTU50RixVQUFVQyxLQUFWLENBQWdCLENBQUMsTUFBRCxFQUFTLFVBQVQsRUFBcUIsS0FBckIsRUFBNEIsTUFBNUIsRUFBb0MsT0FBcEMsQ0FBaEIsQ0FOTTtXQU9SRCxVQUFVNEcsSUFQRjtRQVFYNUcsVUFBVUMsS0FBVixDQUFnQixDQUFDLElBQUQsRUFBTyxJQUFQLEVBQWEsSUFBYixFQUFtQixJQUFuQixFQUF5QixJQUF6QixDQUFoQjs7Ozs7QUN2QkssU0FBUytaLEtBQVQsQ0FBZXZtQixLQUFmLEVBQTZCO01BQ2xDK0wsUUFEa0MsR0FDWi9MLEtBRFksQ0FDbEMrTCxRQURrQztNQUN4QnlhLE9BRHdCLEdBQ1p4bUIsS0FEWSxDQUN4QndtQixPQUR3Qjs7O1NBSXhDcGE7O01BQU8sV0FBV2pOLFNBQU9zbkIsS0FBekIsRUFBZ0MsU0FBU0QsT0FBekM7O0dBREY7OztBQU9GRCxNQUFNNVosU0FBTixHQUFrQjtZQUNOSixVQUFVSyxJQURKO1dBRVBMLFVBQVVZLE1BQVYsQ0FBaUIwRTtDQUY1Qjs7SUNUcUI2VTs7O2lCQUtQMW1CLEtBQVosRUFBMEI7Ozs2R0FDbEJBLEtBRGtCOztVQUoxQm1VLEtBSTBCLEdBSmxCO2VBQ0c7S0FHZTs7UUFFcEIsT0FBT3NOLFFBQVAsS0FBb0IsV0FBcEIsSUFBbUNBLFNBQVNrRixhQUFoRCxFQUErRDtZQUN4RHJNLEVBQUwsR0FBVW1ILFNBQVNrRixhQUFULENBQXVCLEtBQXZCLENBQVY7S0FERixNQUVPOztjQUVHQyxJQUFSLENBQ0Usc0VBREY7Ozs7Ozs7d0NBTWdCO1VBQ2QsT0FBT25GLFFBQVAsS0FBb0IsV0FBcEIsSUFBbUNBLFNBQVNvRixJQUFoRCxFQUFzRDtpQkFDM0NBLElBQVQsQ0FBY0MsV0FBZCxDQUEwQixLQUFLeE0sRUFBL0I7YUFDS2pHLFFBQUwsQ0FBYyxFQUFFMFMsU0FBUyxJQUFYLEVBQWQ7Ozs7OzJDQUltQjtVQUNqQnRGLFNBQVNvRixJQUFiLEVBQW1CO2lCQUNSQSxJQUFULENBQWNHLFdBQWQsQ0FBMEIsS0FBSzFNLEVBQS9COzs7Ozs2QkFNSztVQUNDdk8sUUFERCxHQUNjLEtBQUsvTCxLQURuQixDQUNDK0wsUUFERDs7YUFFQSxLQUFLb0ksS0FBTCxDQUFXNFMsT0FBWCxJQUFzQkUsYUFBYWxiLFFBQWIsRUFBdUIsS0FBS3VPLEVBQTVCLENBQTdCOzs7O0VBbEMrQnpPOztBQ05uQzs7Ozs7Ozs7O0FBU0EsSUFBTXFiLGNBQWMsU0FBZEEsV0FBYyxDQUFDamMsS0FBRCxFQUFReEMsTUFBUjtTQUFtQndDLFFBQVF4QyxNQUEzQjtDQUFwQjs7QUFTQSxBQUFlLFNBQVMwZSxTQUFULE9BS0w7TUFKUnBiLFFBSVEsUUFKUkEsUUFJUTtNQUhScWIsa0JBR1EsUUFIUkEsa0JBR1E7TUFGUjNlLE1BRVEsUUFGUkEsTUFFUTtNQURSd0MsS0FDUSxRQURSQSxLQUNROztNQUNGb2Msc0JBQXNCSCxZQUFZamMsS0FBWixFQUFtQnhDLE1BQW5CLENBQTVCOztNQUVJNmUsc0JBQUo7TUFDSUMscUJBQUo7O01BRUlILHFCQUFxQkMsbUJBQXpCLEVBQThDO21CQUM3QnBjLEtBQWY7b0JBQ2dCQSxRQUFRbWMsa0JBQXhCO0dBRkYsTUFHTzttQkFDVTNlLFNBQVMyZSxrQkFBeEI7b0JBQ2dCM2UsTUFBaEI7OztNQUdJNGIsWUFBWSxDQUFDaUQsZ0JBQWdCN2UsTUFBakIsSUFBMkIsQ0FBQyxDQUE5QztNQUNNMmIsYUFBYSxDQUFDbUQsZUFBZXRjLEtBQWhCLElBQXlCLENBQUMsQ0FBN0M7O1NBR0VtQjtRQUFBO01BQU0sT0FBT25CLEtBQWIsRUFBb0IsUUFBUXhDLE1BQTVCOzs7UUFDTyxPQUFPLEVBQUU3RyxXQUFXeWlCLFNBQWIsRUFBd0J0aUIsWUFBWXFpQixVQUFwQyxFQUFaOztZQUNFO1VBQU0sT0FBT21ELFlBQWIsRUFBMkIsUUFBUUQsYUFBbkM7Ozs7R0FITjs7O0FBV0ZILFVBQVV4YSxTQUFWLEdBQXNCO1lBQ1ZKLFVBQVVLLElBREE7c0JBRUFMLFVBQVVVLE1BQVYsQ0FBaUI0RSxVQUZqQjtVQUdadEYsVUFBVVUsTUFBVixDQUFpQjRFLFVBSEw7U0FJYnRGLFVBQVVVLE1BQVYsQ0FBaUI0RTtDQUoxQjs7OztBQ3RDQSxJQUFNMlYsZUFBZSxDQUFyQjs7SUFFcUJDOzs7Ozs7Ozs7Ozs7OztpTEFTbkJ0VCxRQUFlO3lCQUNNO2FBR3JCaUYsY0FBYyxVQUFDZixLQUFELEVBQWtDO3dCQUNwQixNQUFLclksS0FEZTtVQUN0QzBuQixJQURzQyxlQUN0Q0EsSUFEc0M7VUFDaENqUSxPQURnQyxlQUNoQ0EsT0FEZ0M7O1VBRTFDQSxXQUFXaVEsSUFBZixFQUFxQjtnQkFDWCxFQUFFclAsWUFBRixFQUFSOzthQUlKZ08sa0JBQWtCLFlBQU07eUJBQ0csTUFBS3JtQixLQURSO1VBQ2QwbkIsSUFEYyxnQkFDZEEsSUFEYztVQUNSeE8sTUFEUSxnQkFDUkEsTUFEUTs7VUFFbEJBLFdBQVcsT0FBWCxJQUFzQndPLElBQTFCLEVBQWdDO2NBQ3pCclQsUUFBTCxDQUFjLEVBQUVzVCxtQkFBbUIsS0FBckIsRUFBZDs7YUFJSkMsY0FBYyxVQUFDdlAsS0FBRCxFQUFxQzt5QkFDeEIsTUFBS3JZLEtBRG1CO1VBQ3pDMG5CLElBRHlDLGdCQUN6Q0EsSUFEeUM7VUFDbkN4TyxNQURtQyxnQkFDbkNBLE1BRG1DOztVQUU3Q0EsV0FBVyxPQUFYLElBQXNCYixNQUFNdUwsT0FBTixLQUFrQjRELFlBQXhDLElBQXdERSxJQUE1RCxFQUFrRTtjQUMzRHJULFFBQUwsQ0FBYyxFQUFFc1QsbUJBQW1CLElBQXJCLEVBQWQ7Ozs7Ozs7NkJBSUs7bUJBQ21ELEtBQUszbkIsS0FEeEQ7VUFDQytMLFFBREQsVUFDQ0EsUUFERDtpQ0FDV3FGLE1BRFg7VUFDV0EsTUFEWCxpQ0FDb0IsS0FEcEI7aUNBQzJCOEgsTUFEM0I7VUFDMkJBLE1BRDNCLGlDQUNvQyxJQURwQztVQUMwQ3dPLElBRDFDLFVBQzBDQSxJQUQxQzs7VUFFREcsTUFBTTNPLFdBQVcsT0FBWCxHQUFxQixxQkFBckIsR0FBNkMsSUFBekQ7VUFDTTRPLGFBQWE1TyxlQUFhQSxNQUFiLEdBQXdCLElBQTNDOzthQUdFOU07OztxQkFDYW1ILFdBQ1RwVSxTQUFPNG9CLElBREUsRUFFVCxLQUFLNVQsS0FBTCxDQUFXd1QsaUJBQVgsR0FBK0J4b0IsU0FBTzZvQixvQkFBdEMsR0FBNkQsRUFGcEQsRUFHVDVXLFNBQVMsRUFBVCxHQUFjalMsU0FBT2laLEtBSFosQ0FEYjtnQkFNUXNQLElBTlI7dUJBT2UsS0FBS3JCLGVBUHBCO21CQVFXLEtBQUt1QixXQVJoQjttQkFTVyxLQUFLeE8sV0FUaEI7ZUFVT3lPLEdBVlA7a0JBV1VDOzs7T0FaWjs7OztFQXZDOEJqYzs7QUFBYjRiLEtBQ1o5YSxZQUFZO1lBQ1BKLFVBQVVLLElBQVYsQ0FBZWlGLFVBRFI7UUFFWHRGLFVBQVVZLE1BQVYsQ0FBaUIwRSxVQUZOO1VBR1R0RixVQUFVUyxJQUhEO1dBSVJULFVBQVU0RyxJQUpGO1VBS1Q1RyxVQUFVQyxLQUFWLENBQWdCLENBQUMsSUFBRCxFQUFPLE1BQVAsRUFBZSxPQUFmLENBQWhCOzs7QUMxQlo7Ozs7OztBQU9BLEFBQWUsU0FBU3liLFFBQVQsQ0FDYnRvQixFQURhLEVBR2I7TUFEQXVvQixVQUNBLHVFQURxQixHQUNyQjs7TUFDSUMsYUFBK0IsSUFBbkM7O01BRU1DLFlBQVksU0FBWkEsU0FBWSxHQUFnQjtzQ0FBWkMsSUFBWTtVQUFBOzs7UUFDNUJGLFVBQUosRUFBZ0I7bUJBQ0RBLFVBQWI7OztpQkFHV0csV0FBVyxZQUFNO21CQUNmLElBQWI7NENBQ01ELElBQU47S0FGVyxFQUdWSCxVQUhVLENBQWI7R0FMRjs7WUFXVUssWUFBVixHQUF5QixZQUFNO1FBQ3pCSixVQUFKLEVBQWdCO21CQUNEQSxVQUFiOztHQUZKOztTQU1PQyxTQUFQOzs7QUM5QkY7Ozs7Ozs7Ozs7OztJQXlCcUJJOzs7Ozs7Ozs7Ozs7Ozs2TEFrQm5Cak8sUUFBUSxZQUFNO3dCQVFSLE1BQUt2YSxLQVJHO1VBRVZ5b0IsZUFGVSxlQUVWQSxlQUZVO1VBR1ZDLE9BSFUsZUFHVkEsT0FIVTtVQUlWQyxVQUpVLGVBSVZBLFVBSlU7VUFLVkMsU0FMVSxlQUtWQSxTQUxVO1VBTVZDLFlBTlUsZUFNVkEsWUFOVTtVQU9WaEgsU0FQVSxlQU9WQSxTQVBVOzs7VUFVUjZHLFdBQVdDLFVBQVgsSUFBeUIsQ0FBQ0MsU0FBOUIsRUFBeUM7OztVQUduQ0UsZUFBZUwsa0JBQWtCLENBQXZDOztVQUVJNUcsWUFBWWlILFlBQVosR0FBMkJELFlBQS9CLEVBQTZDOzs7Ozs7Ozt3Q0F2QjNCO2lCQUNQLEtBQUt0TyxLQUFoQjs7Ozt5Q0FHbUI7V0FDZEEsS0FBTDs7Ozs2QkF1Qk87YUFDQSxJQUFQOzs7O0VBdkNvQzFPOztBQUFuQjJjLFdBQ1o3YixZQUFZO21CQUNBSixVQUFVVSxNQUFWLENBQWlCNEUsVUFEakI7V0FFUnRGLFVBQVVTLElBRkY7Y0FHTFQsVUFBVVMsSUFBVixDQUFlNkUsVUFIVjthQUlOdEYsVUFBVTRHLElBSko7Z0JBS0g1RyxVQUFVVSxNQUFWLENBQWlCNEUsVUFMZDthQU1OdEYsVUFBVVUsTUFBVixDQUFpQjRFOzs7OztBQ2hDaEM7Ozs7Ozs7Ozs7Ozs7O0FBd0JBLFNBQVNrWCxrQkFBVCxDQUE0QkMsZUFBNUIsRUFBNkM7U0FDcEMsT0FBT0EsZUFBUCxLQUEyQixVQUEzQixHQUNIQSxpQkFERyxHQUVIQSxlQUZKOzs7SUFLbUJDOzs7Ozs7Ozs7Ozs7Ozt1TUE0Qm5CQyx3QkFBd0I7YUFBTSxNQUFLRixlQUFYO2FBRXhCRyxlQUFlLFVBQUM5USxLQUFELEVBQWtCO1lBQzFCclksS0FBTCxDQUFXb3BCLFFBQVgsQ0FBb0IvUSxLQUFwQjs7Ozs7O3dDQXZCa0I7VUFDWjJRLGtCQUFrQkQsbUJBQW1CLEtBQUsvb0IsS0FBTCxDQUFXZ3BCLGVBQTlCLENBQXhCO1VBQ0lBLGVBQUosRUFBcUI7YUFDZEsscUJBQUwsQ0FBMkJMLGVBQTNCOzs7Ozt5Q0FJaUI7VUFDYk0sc0JBQXNCUCxtQkFBbUIsS0FBSy9vQixLQUFMLENBQVdncEIsZUFBOUIsQ0FBNUI7VUFDSU0sdUJBQXVCQSx3QkFBd0IsS0FBS04sZUFBeEQsRUFBeUU7YUFDbEVLLHFCQUFMLENBQTJCQyxtQkFBM0I7Ozs7OzJDQUltQjtVQUNqQixLQUFLTixlQUFULEVBQTBCO2FBQ25CQSxlQUFMLENBQXFCdEcsbUJBQXJCLENBQXlDLFFBQXpDLEVBQW1ELEtBQUt5RyxZQUF4RDs7Ozs7MENBVWtCSCxpQkFBOEI7VUFDOUMsS0FBS0EsZUFBVCxFQUEwQjs7YUFFbkJBLGVBQUwsQ0FBcUJ0RyxtQkFBckIsQ0FBeUMsUUFBekMsRUFBbUQsS0FBS3lHLFlBQXhEOztXQUVHSCxlQUFMLEdBQXVCQSxlQUF2QjtXQUNLQSxlQUFMLENBQXFCMUcsZ0JBQXJCLENBQXNDLFFBQXRDLEVBQWdELEtBQUs2RyxZQUFyRDs7Ozs2QkFLTzthQUNBdGQsUUFBQSxDQUFlMGQsSUFBZixDQUFvQixLQUFLdnBCLEtBQUwsQ0FBVytMLFFBQS9CLENBQVA7Ozs7RUE5Q3lDRjs7QUFBeEJvZCxnQkFDWnRjLFlBQVk7WUFDUEosVUFBVUssSUFBVixDQUFlaUYsVUFEUjtZQUVQdEYsVUFBVTRHLElBQVYsQ0FBZXRCLFVBRlI7bUJBR0F0RixVQUFVUSxTQUFWLENBQW9CLENBQUNSLFVBQVVPLE1BQVgsRUFBbUJQLFVBQVU0RyxJQUE3QixDQUFwQixFQUNkdEI7OztBQ25DUDs7Ozs7O0FBT0EsQUFBZSxTQUFTMlgsUUFBVCxDQUNiN3BCLEVBRGEsRUFHYjtNQURBdW9CLFVBQ0EsdUVBRHFCLEdBQ3JCOztNQUNJdUIsYUFBSjtNQUNJdEIsbUJBQUo7TUFDTXVCLFlBQVksU0FBWkEsU0FBWSxHQUFnQjtzQ0FBWnJCLElBQVk7VUFBQTs7O1FBQzFCc0IsTUFBTUMsS0FBS0QsR0FBTCxFQUFaO1FBQ0lGLFNBQVM5WCxTQUFULElBQXNCZ1ksTUFBTUYsSUFBTixHQUFhdkIsVUFBdkMsRUFBbUQ7bUJBQ3BDQyxVQUFiO21CQUNhRyxXQUFXLFlBQU07ZUFDckJxQixHQUFQOzhDQUNNdEIsSUFBTjtPQUZXLEVBR1ZILGNBQWN5QixNQUFNRixJQUFwQixDQUhVLENBQWI7S0FGRixNQU1PO2FBQ0VFLEdBQVA7NENBQ010QixJQUFOOztHQVZKOztZQWNVRSxZQUFWLEdBQXlCLFlBQU07UUFDekJKLFVBQUosRUFBZ0I7bUJBQ0RBLFVBQWI7O0dBRko7O1NBTU91QixTQUFQOzs7SUM5Qm1CRzs7O1NBQ25CL3BCLE1BQXFCLElBQUlncUIsT0FBSjs7Ozs7MkJBRWpCemUsS0FBWTthQUNQLEtBQUt2TCxHQUFMLENBQVNpcUIsR0FBVCxDQUFhMWUsR0FBYixDQUFQOzs7O3dCQUdFQSxLQUFpQjthQUNaLEtBQUt2TCxHQUFMLENBQVNrcUIsR0FBVCxDQUFhM2UsR0FBYixDQUFQOzs7OzJCQUdFQSxLQUFRdEgsT0FBZ0I7V0FDckJqRSxHQUFMLENBQVNtcUIsR0FBVCxDQUFhNWUsR0FBYixFQUFrQnRILEtBQWxCOzs7OzRCQUdZO1dBQ1BqRSxHQUFMLEdBQVcsSUFBSWdxQixPQUFKLEVBQVg7Ozs7OztBQ25CSjs7Ozs7O0FBT0EsQUFBTyxTQUFTSSxnQkFBVCxDQUEwQkMsT0FBMUIsRUFBd0Q7U0FDdERBLFlBQVk1WCxNQUFaLEdBQXFCQSxPQUFPdVAsV0FBNUIsR0FBMENxSSxRQUFRbkksWUFBekQ7OztBQUdGLEFBQU8sU0FBU29JLGtCQUFULEdBQThCO01BQy9CN1gsT0FBTzRPLE9BQVAsS0FBbUJ4UCxTQUF2QixFQUFrQzs7V0FFekJZLE9BQU80TyxPQUFkOztNQUdBTSxTQUFTQyxlQUFULElBQ0FELFNBQVNDLGVBQVQsQ0FBeUJHLFNBQXpCLEtBQXVDbFEsU0FGekMsRUFHRTs7V0FFTzhQLFNBQVNDLGVBQVQsQ0FBeUJHLFNBQWhDOztTQUVLLENBQVA7OztBQUdGLEFBQU8sU0FBU3dJLG9CQUFULENBQThCRixPQUE5QixFQUE0RDtTQUMxREEsWUFBWTVYLE1BQVosR0FDSDZYLG9CQURHLEdBRUhELFFBQVF0SSxTQUFSLEdBQW9Cc0ksUUFBUWhHLHFCQUFSLEdBQWdDL2EsR0FGeEQ7OztBQUtGLEFBQU8sU0FBU2toQixlQUFULENBQXlCSCxPQUF6QixFQUF1RDtTQUNyREEsWUFBWTVYLE1BQVosSUFBc0JrUCxTQUFTQyxlQUEvQixHQUNIRCxTQUFTQyxlQUFULENBQXlCbUgsWUFEdEIsR0FFSHNCLFFBQVF0QixZQUZaOzs7QUFLRixBQUFPLFNBQVMwQixZQUFULENBQXNCSixPQUF0QixFQUFvRDtTQUNsREEsWUFBWTVYLE1BQVosR0FBcUI2WCxvQkFBckIsR0FBNENELFFBQVF0SSxTQUEzRDs7O0FDdENLLElBQU0ySSxzQkFBc0JDLE9BQU8sU0FBUCxDQUE1QjtBQUNQLEFBQU8sSUFBTUMseUJBQXlCRCxPQUFPLFlBQVAsQ0FBL0I7O0FDUVAsSUFBTXRPLFdBQVMsU0FBVEEsTUFBUyxNQUFPO01BQ2hCYixNQUFNLENBQVY7T0FDSyxJQUFJZSxJQUFJLENBQWIsRUFBZ0JBLElBQUkvUSxJQUFJaEwsTUFBeEIsRUFBZ0MrYixLQUFLLENBQXJDLEVBQXdDO1FBQ2xDL1EsSUFBSStRLENBQUosSUFBUy9RLElBQUlnUSxHQUFKLENBQWIsRUFBdUI7WUFDZmUsQ0FBTjs7O1NBR0dmLEdBQVA7Q0FQRjs7QUFVQSxJQUFNcVAsWUFBWSxTQUFaQSxTQUFZLENBQUMxZixLQUFEO01BQVF4QyxNQUFSLHVFQUFpQm1pQixRQUFqQjtTQUErQjtTQUMxQyxDQUFDLElBRHlDO1VBRXpDLENBQUMsSUFGd0M7Z0JBQUE7O0dBQS9CO0NBQWxCOztBQU9BLHFCQUFlO01BQ2JDLEtBRGEsUUFDYkEsS0FEYTs4QkFFYkMsV0FGYTtNQUViQSxXQUZhLG9DQUVDLEdBRkQ7eUJBR2I3TyxNQUhhO01BR2JBLE1BSGEsK0JBR0osRUFISTswQkFJYjhPLE9BSmE7TUFJYkEsT0FKYSxnQ0FJSCxDQUpHO01BS2I5ZixLQUxhLFFBS2JBLEtBTGE7U0FZUixVQUFDbVEsS0FBRCxFQUFzQztRQUN2Q25RLFNBQVMsSUFBYixFQUFtQjthQUNWbVEsTUFBTXRiLEdBQU4sQ0FBVTtlQUFNNnFCLFVBQVVHLFdBQVYsQ0FBTjtPQUFWLENBQVA7OztRQUdJRSx1QkFBdUJGLGNBQWM3TyxNQUEzQztRQUNNZ1AsY0FBY2hxQixLQUFLK1osR0FBTCxDQUNsQi9aLEtBQUtpcUIsS0FBTCxDQUFXLENBQUNqZ0IsUUFBUWdSLE1BQVQsSUFBbUIrTyxvQkFBOUIsQ0FEa0IsRUFFbEJELE9BRmtCLENBQXBCOztRQUtNSSxVQUFVLElBQUl2ckIsS0FBSixDQUFVcXJCLFdBQVYsRUFBdUJoTyxJQUF2QixDQUE0QixDQUE1QixDQUFoQjtRQUNNbU8sZUFBZW5xQixLQUFLK1osR0FBTCxDQUNuQi9aLEtBQUtpcUIsS0FBTCxDQUFXLENBQUNqZ0IsUUFBUStmLHVCQUF1QkMsV0FBL0IsR0FBNkNoUCxNQUE5QyxJQUF3RCxDQUFuRSxDQURtQixFQUVuQixDQUZtQixDQUFyQjs7V0FLT2IsTUFBTWhjLE1BQU4sQ0FBYSxVQUFDc00sR0FBRCxFQUFNdVAsSUFBTixFQUFlO1VBQzNCaUIsWUFBWXhRLEdBQWxCOztVQUVNakQsU0FBU29pQixNQUFNZCxHQUFOLENBQVU5TyxJQUFWLENBQWY7VUFDSUksaUJBQUo7O1VBRUk1UyxVQUFVLElBQWQsRUFBb0I7bUJBQ1BraUIsVUFBVUcsV0FBVixDQUFYO09BREYsTUFFTztZQUNDTyxrQkFBa0I1aUIsU0FBU3dULE1BQWpDO1lBQ01rQixNQUFNaEIsU0FBT2dQLE9BQVAsQ0FBWjtZQUNNL2hCLE9BQU0raEIsUUFBUWhPLEdBQVIsQ0FBWjtZQUNNN1QsUUFBTzZULE1BQU02TixvQkFBTixHQUE2QkksWUFBMUM7O2dCQUVRak8sR0FBUixLQUFnQmtPLGVBQWhCO21CQUNXLEVBQUVqaUIsU0FBRixFQUFPRSxXQUFQLEVBQWEyQixPQUFPNmYsV0FBcEIsRUFBaUNyaUIsY0FBakMsRUFBWDs7Z0JBRVE4UyxJQUFWLENBQWVGLFFBQWY7YUFDT2EsU0FBUDtLQWxCSyxFQW1CSixFQW5CSSxDQUFQO0dBN0JhO0NBQWY7O0FDdEJBLElBQU15TyxjQUFZLFNBQVpBLFNBQVksQ0FBQzFmLEtBQUQ7TUFBUXhDLE1BQVIsdUVBQWlCbWlCLFFBQWpCO1NBQStCO1NBQzFDLENBQUMsSUFEeUM7VUFFekMsQ0FBQyxJQUZ3QztnQkFBQTs7R0FBL0I7Q0FBbEI7O0FBT0Esd0JBQWU7TUFDYkMsS0FEYSxRQUNiQSxLQURhOzhCQUViQyxXQUZhO01BRWJBLFdBRmEsb0NBRUMsR0FGRDt5QkFHYjdPLE1BSGE7TUFHYkEsTUFIYSwrQkFHSixFQUhJO01BSWJoUixLQUphLFFBSWJBLEtBSmE7MEJBS2I4ZixPQUxhO01BS2JBLE9BTGEsZ0NBS0gsQ0FMRztTQVlSLFVBQUMzUCxLQUFELEVBQXNDO1FBQ3ZDblEsU0FBUyxJQUFiLEVBQW1CO2FBQ1ZtUSxNQUFNdGIsR0FBTixDQUFVO2VBQU02cUIsWUFBVUcsV0FBVixDQUFOO09BQVYsQ0FBUDs7O1FBR0lFLHVCQUF1QkYsY0FBYzdPLE1BQTNDO1FBQ01nUCxjQUFjaHFCLEtBQUsrWixHQUFMLENBQ2xCL1osS0FBS2lxQixLQUFMLENBQVcsQ0FBQ2pnQixRQUFRZ1IsTUFBVCxJQUFtQitPLG9CQUE5QixDQURrQixFQUVsQkQsT0FGa0IsQ0FBcEI7O1FBS003TyxZQUFZLEVBQWxCO1FBQ01pUCxVQUFVLEVBQWhCOztTQUVLLElBQUk5TyxJQUFJLENBQWIsRUFBZ0JBLElBQUlqQixNQUFNOWEsTUFBMUIsRUFBa0MrYixLQUFLLENBQXZDLEVBQTBDO1VBQ3BDaEIsaUJBQUo7VUFDTTVTLFVBQVNvaUIsTUFBTWQsR0FBTixDQUFVM08sTUFBTWlCLENBQU4sQ0FBVixDQUFmOztVQUVJNVQsV0FBVSxJQUFkLEVBQW9CO21CQUNQa2lCLFlBQVVHLFdBQVYsQ0FBWDtPQURGLE1BRU87WUFDQzltQixTQUFTcVksSUFBSTRPLFdBQW5CO1lBQ01LLE1BQU1ycUIsS0FBS2lxQixLQUFMLENBQVc3TyxJQUFJNE8sV0FBZixDQUFaOztZQUVJam5CLFdBQVcsQ0FBWCxJQUFnQnlFLFVBQVMwaUIsUUFBUUcsR0FBUixDQUE3QixFQUEyQztrQkFDakNBLEdBQVIsSUFBZTdpQixPQUFmOzs7WUFHSVcsT0FDSmtpQixNQUFNLENBQU4sR0FDSUgsUUFBUUksS0FBUixDQUFjLENBQWQsRUFBaUJELEdBQWpCLEVBQXNCbHNCLE1BQXRCLENBQTZCLFVBQUNvc0IsR0FBRCxFQUFNcmhCLENBQU47aUJBQVlxaEIsTUFBTXJoQixDQUFOLEdBQVU4UixNQUF0QjtTQUE3QixFQUEyRCxDQUEzRCxDQURKLEdBRUksQ0FITjs7bUJBS1c7bUJBQUE7Z0JBRUhqWSxTQUFTZ25CLG9CQUZOO2lCQUdGRixXQUhFOztTQUFYOztnQkFPUXZQLElBQVYsQ0FBZUYsUUFBZjs7V0FFS2EsU0FBUDtHQXREYTtDQUFmOztBQ1BBLElBQU1DLFdBQVMsU0FBVEEsTUFBUyxNQUFPO01BQ2hCYixNQUFNLENBQVY7T0FDSyxJQUFJZSxJQUFJLENBQWIsRUFBZ0JBLElBQUkvUSxJQUFJaEwsTUFBeEIsRUFBZ0MrYixLQUFLLENBQXJDLEVBQXdDO1FBQ2xDL1EsSUFBSStRLENBQUosSUFBUy9RLElBQUlnUSxHQUFKLENBQWIsRUFBdUI7WUFDZmUsQ0FBTjs7O1NBR0dmLEdBQVA7Q0FQRjs7QUFVQSx1QkFBZSxnQkFZUjt5QkFYTFcsTUFXSztNQVhMQSxNQVdLLCtCQVhJLENBV0o7TUFWTDRPLEtBVUssUUFWTEEsS0FVSzswQkFUTEUsT0FTSztNQVRMQSxPQVNLLGdDQVRLLENBU0w7bUNBUkxVLGdCQVFLO01BUkxBLGdCQVFLLHlDQVJjLEdBUWQ7TUFQTHhnQixLQU9LLFFBUExBLEtBT0s7O01BQ0RBLFNBQVMsSUFBYixFQUFtQjtXQUNWLFVBQUNtUSxLQUFEO2FBQ0xBLE1BQU10YixHQUFOLENBQVU7ZUFBTztlQUNWOHFCLFFBRFU7Z0JBRVRBLFFBRlM7aUJBR1JBLFFBSFE7a0JBSVBBO1NBSkE7T0FBVixDQURLO0tBQVA7Ozs7OztNQVlJYyxXQUFXenFCLEtBQUtpcUIsS0FBTCxDQUFXamdCLFFBQVF3Z0IsZ0JBQW5CLENBQWpCO01BQ01SLGNBQWNocUIsS0FBSytaLEdBQUwsQ0FDbEIvWixLQUFLaXFCLEtBQUwsQ0FBVyxDQUFDamdCLFFBQVF5Z0IsV0FBV3pQLE1BQXBCLElBQThCd1AsZ0JBQXpDLENBRGtCLEVBRWxCVixPQUZrQixDQUFwQjtNQUlNRCxjQUFjN3BCLEtBQUtpcUIsS0FBTCxDQUFXamdCLFFBQVFnZ0IsV0FBbkIsQ0FBcEI7O1NBRU8sVUFBQzdQLEtBQUQsRUFBcUI7O1FBRXBCK1AsVUFBVSxJQUFJdnJCLEtBQUosQ0FBVXFyQixXQUFWLEVBQXVCaE8sSUFBdkIsQ0FBNEIsQ0FBNUIsQ0FBaEI7O1dBRU83QixNQUFNaGMsTUFBTixDQUFhLFVBQUNzTSxHQUFELEVBQU11UCxJQUFOLEVBQWU7VUFDM0JpQixZQUFZeFEsR0FBbEI7VUFDTWpELFNBQVNvaUIsTUFBTWQsR0FBTixDQUFVOU8sSUFBVixDQUFmO1VBQ0lJLGlCQUFKOztVQUVJNVMsVUFBVSxJQUFkLEVBQW9CO21CQUNQO2VBQ0ptaUIsUUFESTtnQkFFSEEsUUFGRztpQkFHRkUsV0FIRTtrQkFJREY7U0FKVjtPQURGLE1BT087WUFDQ3pOLE1BQU1oQixTQUFPZ1AsT0FBUCxDQUFaO1lBQ00vaEIsT0FBTStoQixRQUFRaE8sR0FBUixDQUFaO1lBQ003VCxRQUFPNlQsTUFBTTJOLFdBQU4sR0FBb0I3TyxTQUFTLENBQTFDOztnQkFFUWtCLEdBQVIsS0FBZ0IxVSxNQUFoQjttQkFDVzttQkFBQTtxQkFBQTtpQkFHRnFpQixjQUFjN08sTUFIWjs7U0FBWDs7O2dCQVFRVixJQUFWLENBQWVGLFFBQWY7YUFDT2EsU0FBUDtLQTNCSyxFQTRCSixFQTVCSSxDQUFQO0dBSkY7Q0FqQ0Y7O0lDZHFCeVA7Ozs7SUNBQUM7Ozs7QUNrRXJCLElBQU1DLGtCQUFrQixHQUF4Qjs7O0FBR0EsSUFBTUMsd0JBQXdCLEdBQTlCOztBQUVBLElBQU1DLDZCQUE2QixTQUE3QkEsMEJBQTZCO1NBQU0vcUIsTUFBTTRwQixRQUFOLEdBQWlCNXBCLENBQWpCLEdBQXFCMlEsU0FBM0I7Q0FBbkM7Ozs7Ozs7O0lBT3FCcWE7Ozs7NkNBQ2E7YUFDdkIsSUFBSW5DLGdCQUFKLEVBQVA7Ozs7Ozs7OzttQkEyR1U3cEIsS0FBWixFQUE2Qjs7O2lIQUNyQkEsS0FEcUI7O1VBckc3QmdrQixZQXFHNkIsR0FyR2RpRSxTQUFTLFlBQU07VUFDeEIsTUFBS2dFLFdBQVQsRUFBc0I7Y0FDZjVYLFFBQUwsQ0FBYyxFQUFFcEosT0FBTyxNQUFLZ2hCLFdBQUwsQ0FBaUJDLFdBQTFCLEVBQWQ7O0tBRlcsRUFJWkwsZUFKWSxDQXFHYztVQS9GN0JNLG9CQStGNkIsR0EvRk4zQyxTQUFTLFlBQU07VUFDaEMsQ0FBQyxNQUFLUixlQUFWLEVBQTJCOzs7VUFHckJBLGtCQUFrQixNQUFLQSxlQUFMLENBQXFCRSxxQkFBckIsRUFBeEI7O1VBRUksQ0FBQ0YsZUFBTCxFQUFzQjs7OztZQUlqQjNVLFFBQUwsQ0FBYzttQkFDRGtXLGFBQWF2QixlQUFiO09BRGI7S0FWcUIsQ0ErRk07VUFoRjdCb0QscUJBZ0Y2QixHQWhGTG5FLFNBQVMsWUFBTTtZQUNoQ29FLGdCQUFMO0tBRHNCLEVBRXJCLENBRnFCLENBZ0ZLOztVQXdJN0JDLGlCQXhJNkIsR0F3SVQsVUFBQ3hnQixHQUFELEVBQXVCO1lBQ3BDbWdCLFdBQUwsR0FBbUJuZ0IsR0FBbkI7S0F6STJCOztVQTRJN0J5Z0IscUJBNUk2QixHQTRJTCxVQUFDemdCLEdBQUQsRUFBMkI7WUFDNUNrZCxlQUFMLEdBQXVCbGQsR0FBdkI7S0E3STJCOztVQWdKN0I4YyxTQWhKNkIsR0FnSmpCLFlBQU07VUFDUjRELFNBRFEsR0FDTSxNQUFLeHNCLEtBRFgsQ0FDUndzQixTQURROztVQUVaQSxhQUFhLE9BQU9BLFNBQVAsS0FBcUIsVUFBdEMsRUFBa0Q7Y0FDM0NuWSxRQUFMLENBQ0U7c0JBQ2M7U0FGaEIsRUFJRTtpQkFBTW1ZLFVBQVUsRUFBRTNzQixNQUFNLE1BQUtHLEtBQUwsQ0FBV29iLEtBQVgsQ0FBaUI5YSxNQUF6QixFQUFWLENBQU47U0FKRjs7S0FuSnlCOztVQW1NN0Jtc0Isc0JBbk02QixHQW1NSixVQUFDQyxRQUFELEVBQWNwUixHQUFkLEVBQTJCRCxRQUEzQixFQUEyQzt3QkFNOUQsTUFBS3JiLEtBTnlEO1VBRTFEMnNCLFlBRjBELGVBRWhFQyxJQUZnRTtVQUdoRUMsVUFIZ0UsZUFHaEVBLFVBSGdFO1VBSWhFQyxnQkFKZ0UsZUFJaEVBLGdCQUpnRTtVQUtoRUMsbUJBTGdFLGVBS2hFQSxtQkFMZ0U7VUFPMUQzakIsR0FQMEQsR0FPN0JpUyxRQVA2QixDQU8xRGpTLEdBUDBEO1VBT3JERSxJQVBxRCxHQU83QitSLFFBUDZCLENBT3JEL1IsSUFQcUQ7VUFPL0MyQixLQVArQyxHQU83Qm9RLFFBUDZCLENBTy9DcFEsS0FQK0M7VUFPeEN4QyxNQVB3QyxHQU83QjRTLFFBUDZCLENBT3hDNVMsTUFQd0M7OztVQVM5RHVrQixrQkFBSjtVQUNJLE1BQUtodEIsS0FBTCxDQUFXZ3BCLGVBQWYsRUFBZ0M7WUFDeEJpRSxnQkFBZ0IsTUFBS3hFLGVBQUwsR0FBdUJxRCxxQkFBN0M7WUFDTW9CLGtCQUFrQixNQUFLL1ksS0FBTCxDQUFXME4sU0FBWCxHQUF1QixNQUFLc0wsZUFBcEQ7WUFDTXJTLGNBQWNnUyxtQkFDaEJJLGtCQUFrQkosZ0JBREYsR0FFaEJJLGtCQUFrQkQsYUFGdEI7WUFHTUcsaUJBQWlCTCxzQkFDbkJHLGtCQUFrQixNQUFLekUsZUFBdkIsR0FBeUNzRSxtQkFEdEIsR0FFbkJHLGtCQUFrQixNQUFLekUsZUFBdkIsR0FBeUN3RSxhQUY3Qzs7b0JBSVksRUFDVjVSLFNBQVNqUyxHQUFULEdBQWVpUyxTQUFTNVMsTUFBeEIsR0FBaUNxUyxXQUFqQyxJQUNBTyxTQUFTalMsR0FBVCxHQUFlZ2tCLGNBRkwsQ0FBWjtPQVZGLE1BY087O29CQUVPLElBQVo7OztVQUdJQyxnQkFDSmpoQjs7O3lCQUNla1AsR0FEZjtxQkFFYSxDQUFDbmMsU0FBT211QixhQUFSLEVBQXVCbnVCLFNBQU9vdUIsc0JBQTlCLEVBQXNEcHRCLElBQXRELENBQ1QsR0FEUyxDQUZiO2dDQUFBO2lCQU1TO2lCQUNBLENBREE7a0JBRUMsQ0FGRDt1Q0FHb0JtSixJQUF6Qix1QkFBK0NGLEdBQS9DLFFBSEs7NkNBSTBCRSxJQUEvQix1QkFBcURGLEdBQXJELFFBSks7bUJBS0UyaUIsMkJBQTJCOWdCLEtBQTNCLENBTEY7b0JBTUc4Z0IsMkJBQTJCdGpCLE1BQTNCOzs7c0JBR1Rra0IsWUFBRCxJQUFXLE1BQU1ELFFBQWpCLEVBQTJCLFNBQVNwUixHQUFwQyxFQUF5QyxhQUFhLEtBQXREO09BaEJKOzthQW9CT3VSLGFBQWNHLGFBQWFLLGFBQWQsSUFBZ0MsSUFBN0MsR0FBb0RBLGFBQTNEO0tBcFAyQjs7VUFHdEI1RSxlQUFMLEdBQXVCLENBQXZCO1VBQ0swRSxlQUFMLEdBQXVCLENBQXZCOztVQUVLaFosS0FBTCxHQUFhOzhCQUNhblUsTUFBTW9iLEtBQU4sQ0FBWW9TLElBQVosQ0FDdEI7ZUFBUSxDQUFDLENBQUN2UyxJQUFGLElBQVUsQ0FBQ2piLE1BQU15dEIsZ0JBQU4sQ0FBdUJ6RCxHQUF2QixDQUEyQi9PLElBQTNCLENBQW5CO09BRHNCLENBRGI7a0JBSUMsS0FKRDs7YUFNSmpiLE1BQU1vYixLQU5GO2lCQU9BLENBUEE7YUFRSnpKO0tBUlQ7Ozs7Ozs7Ozs7O3dDQWVrQjs7O2FBQ1gyUSxnQkFBUCxDQUF3QixRQUF4QixFQUFrQyxLQUFLMEIsWUFBdkM7O1dBRUtxSSxnQkFBTDs7VUFFTXhLLFNBTFksR0FLRSxLQUFLMU4sS0FMUCxDQUtaME4sU0FMWTs7VUFNZCxLQUFLbUgsZUFBTCxJQUF3QixJQUE1QixFQUFrQztZQUMxQkEsbUJBQWtCLEtBQUtBLGVBQUwsQ0FBcUJFLHFCQUFyQixFQUF4QjtZQUNJRixnQkFBSixFQUFxQjtzQkFDUHVCLGFBQWF2QixnQkFBYixDQUFaOzs7O1dBSUMzVSxRQUFMLENBQWM7ZUFBYzs4QkFBQTtpQkFFbkIsT0FBSzRYLFdBQUwsR0FBbUIsT0FBS0EsV0FBTCxDQUFpQkMsV0FBcEMsR0FBa0R3QixVQUFVemlCO1NBRnZEO09BQWQ7Ozs7dUNBTWlCb0gsV0FBcUJxYixXQUFxQjs7O21CQUN2QixLQUFLMXRCLEtBRGtCO1VBQ25Eb2IsS0FEbUQsVUFDbkRBLEtBRG1EO1VBQzVDcVMsZ0JBRDRDLFVBQzVDQSxnQkFENEM7OztXQUd0RHJCLHFCQUFMOztVQUVJc0IsVUFBVXppQixLQUFWLElBQW1CLElBQW5CLElBQTJCLEtBQUtrSixLQUFMLENBQVdsSixLQUFYLEtBQXFCeWlCLFVBQVV6aUIsS0FBOUQsRUFBcUU7eUJBQ2xEMGlCLEtBQWpCOzs7VUFHSUMseUJBQXlCeFMsTUFBTW9TLElBQU4sQ0FDN0I7ZUFBUSxDQUFDLENBQUN2UyxJQUFGLElBQVUsQ0FBQ3dTLGlCQUFpQnpELEdBQWpCLENBQXFCL08sSUFBckIsQ0FBbkI7T0FENkIsQ0FBL0I7VUFJRTJTLDBCQUNBQSwyQkFBMkIsS0FBS3paLEtBQUwsQ0FBV3laLHNCQUR0QyxJQUVBRixVQUFVemlCLEtBQVYsSUFBbUIsSUFIckIsRUFJRTthQUNLNGlCLG9CQUFMLEdBQTRCQyxzQkFBc0IsWUFBTTtpQkFDakR6WixRQUFMLENBQWM7O1dBQWQ7U0FEMEIsQ0FBNUI7Ozs7Ozs7Ozs7MkNBV21CO1VBQ2pCLEtBQUt3WixvQkFBVCxFQUErQjs2QkFDUixLQUFLQSxvQkFBMUI7Ozs7V0FJR3pCLHFCQUFMLENBQTJCN0QsWUFBM0I7V0FDS3ZFLFlBQUwsQ0FBa0J1RSxZQUFsQjtXQUNLNEQsb0JBQUwsQ0FBMEI1RCxZQUExQjs7YUFFTzdGLG1CQUFQLENBQTJCLFFBQTNCLEVBQXFDLEtBQUtzQixZQUExQzs7Ozt1Q0EwRmlCO1VBQ2IsS0FBS2dGLGVBQUwsSUFBd0IsSUFBNUIsRUFBa0M7WUFDeEJBLGlCQUR3QixHQUNKLElBREksQ0FDeEJBLGVBRHdCOztZQUUxQitFLHFCQUFxQi9FLGtCQUFnQkUscUJBQWhCLEVBQTNCO1lBQ0k2RSxrQkFBSixFQUF3QjtlQUNqQnRGLGVBQUwsR0FBdUJ5QixpQkFBaUI2RCxrQkFBakIsQ0FBdkI7Y0FDTXpULEtBQUssS0FBSzJSLFdBQWhCO2NBQ0kzUixjQUFjMFQsV0FBbEIsRUFBK0I7Z0JBQ3ZCQyxvQkFBb0I1RCxxQkFBcUIwRCxrQkFBckIsQ0FBMUI7aUJBQ0taLGVBQUwsR0FDRTdTLEdBQUc2SixxQkFBSCxHQUEyQi9hLEdBQTNCLEdBQWlDNmtCLGlCQURuQzs7Ozs7Ozs7Ozs7Ozs7NkJBWUM7V0FDRmp1QixLQUFMLENBQVd5dEIsZ0JBQVgsQ0FBNEJFLEtBQTVCO1dBQ0t0QixnQkFBTDtXQUNLNkIsV0FBTDs7Ozs2QkF1RE87OztvQkFTSCxLQUFLbHVCLEtBVEY7VUFFTDhxQixXQUZLLFdBRUxBLFdBRks7VUFHQzZCLFlBSEQsV0FHTEMsSUFISztVQUlMdUIsUUFKSyxXQUlMQSxRQUpLO1VBS1FsUyxNQUxSLFdBS0xtUyxXQUxLO1VBTUxYLGdCQU5LLFdBTUxBLGdCQU5LO1VBT0xyUyxLQVBLLFdBT0xBLEtBUEs7VUFRTDJQLE9BUkssV0FRTEEsT0FSSzttQkFVbUMsS0FBSzVXLEtBVnhDO1VBVUN5WixzQkFWRCxVQVVDQSxzQkFWRDtVQVV5QjNpQixLQVZ6QixVQVV5QkEsS0FWekI7OztVQVlIL0UsZUFBSjtVQUNJaW9CLFlBQVlsakIsVUFBVSxJQUExQixFQUFnQztpQkFDckJvakIsZ0JBQWdCO3dCQUFBO2lCQUVoQlosZ0JBRmdCOzBCQUFBOzRCQUlMM0MsV0FKSzs7U0FBaEIsQ0FBVDtPQURGLE1BUU8sSUFDTCxLQUFLOXFCLEtBQUwsQ0FBV2tHLE1BQVgsS0FBc0J3a0Isc0JBQXRCLElBQ0EsS0FBSzFxQixLQUFMLENBQVdrRyxNQUFYLFlBQTZCb29CLGdCQUZ4QixFQUdMO2lCQUNTQyxpQkFBaUI7aUJBQ2pCZCxnQkFEaUI7a0NBQUE7d0JBQUE7MEJBQUE7O1NBQWpCLENBQVQ7T0FKSyxNQVdBO2lCQUNJZSxjQUFjO2lCQUNkZixnQkFEYztrQ0FBQTt3QkFBQTswQkFBQTs7U0FBZCxDQUFUOzs7VUFTRWdCLGlCQUFKO1VBQ0l4akIsU0FBUyxJQUFULElBQWlCMmlCLHNCQUFyQixFQUE2Qzs7O21CQUl6Q3hoQjs7O3VCQUNhak4sU0FBTzZzQixPQURwQjttQkFFUyxFQUFFdmpCLFFBQVEsQ0FBVixFQUFhd0MsT0FBTyxNQUFwQixFQUZUO2lCQUdPLEtBQUtxaEI7O2dCQUVIb0MsTUFBTixDQUFhO21CQUFRelQsSUFBUjtXQUFiLEVBQTJCbmIsR0FBM0IsQ0FBK0IsVUFBQ21iLElBQUQsRUFBT29CLENBQVA7bUJBQzlCalE7OzsyQkFDWSxRQURaO3NDQUFBO3FCQUdPaVEsQ0FIUDt1QkFJUzt1QkFDQSxDQURBO3dCQUVDLENBRkQ7NkJBR00saUNBSE47bUNBSVksaUNBSlo7eUJBS0U4UixXQUNIeGMsU0FERyxHQUVIb2EsMkJBQTJCakIsV0FBM0IsQ0FQQztpQkFKVDtxQkFhTyxpQkFBTTtzQkFDTHhRLE1BQU0sQ0FBQzZULFFBQVgsRUFBcUI7O3FDQUVGbEUsR0FBakIsQ0FBcUJoUCxJQUFyQixFQUEyQlgsR0FBRzBILFlBQTlCOzs7OzRCQUlIMkssWUFBRCxJQUFXLE1BQU0xUixJQUFqQixFQUF1QixTQUFTb0IsQ0FBaEMsRUFBbUMsYUFBYSxLQUFoRDthQXJCNEI7V0FBL0I7U0FOTDtPQUhGLE1BbUNPLElBQUlwUixTQUFTLElBQWIsRUFBbUI7OzttQkFHYm1CLHVCQUFLLE9BQU8sRUFBRW5CLE9BQU8sTUFBVCxFQUFaLEVBQStCLEtBQUssS0FBS3FoQixpQkFBekMsR0FBWDtPQUhLLE1BSUE7O1lBRUNxQyxnQkFBZ0J2VCxNQUFNc1QsTUFBTixDQUNwQjtpQkFBUXpULFFBQVF3UyxpQkFBaUJ6RCxHQUFqQixDQUFxQi9PLElBQXJCLENBQWhCO1NBRG9CLENBQXRCO1lBR00yVCxpQkFBaUJ4VCxNQUNwQnNULE1BRG9CLENBQ2I7aUJBQVF6VCxRQUFRLENBQUN3UyxpQkFBaUJ6RCxHQUFqQixDQUFxQi9PLElBQXJCLENBQWpCO1NBRGEsRUFFcEJzUSxLQUZvQixDQUVkLENBRmMsRUFFWFIsT0FGVyxDQUF2Qjs7WUFJTTdPLFlBQVloVyxPQUFPeW9CLGFBQVAsQ0FBbEI7WUFDTUUscUJBQXFCM29CLE9BQU8wb0IsY0FBUCxDQUEzQjs7WUFFTW5tQixTQUFTeVQsVUFBVTViLE1BQVYsR0FDWFcsS0FBSytaLEdBQUwsK0JBQVlrQixVQUFVcGMsR0FBVixDQUFjO2lCQUFPZ3ZCLElBQUkxbEIsR0FBSixHQUFVMGxCLElBQUlybUIsTUFBckI7U0FBZCxDQUFaLEVBRFcsR0FFWCxDQUZKO21CQUlFMkQ7O1lBQUssT0FBTyxFQUFFbkIsT0FBTyxNQUFULEVBQVosRUFBK0IsS0FBSyxLQUFLcWhCLGlCQUF6Qzs7O2NBQ08sV0FBV250QixTQUFPNnNCLE9BQXZCLEVBQWdDLE9BQU8sRUFBRXZqQixjQUFGLEVBQVV3QyxZQUFWLEVBQXZDOzBCQUNpQm5MLEdBQWQsQ0FBa0IsVUFBQ21iLElBQUQsRUFBT29CLENBQVA7cUJBQ2pCLE9BQUtvUSxzQkFBTCxDQUE0QnhSLElBQTVCLEVBQWtDb0IsQ0FBbEMsRUFBcUNILFVBQVVHLENBQVYsQ0FBckMsQ0FEaUI7YUFBbEI7V0FGTDs7O2NBTU8sV0FBV2xkLFNBQU82c0IsT0FBdkIsRUFBZ0MsT0FBTyxFQUFFL2dCLFlBQUYsRUFBdkM7MkJBQ2tCbkwsR0FBZixDQUFtQixVQUFDaXZCLElBQUQsRUFBTzFTLENBQVAsRUFBYTs7OztrQkFJekIyUyxtQkFBbUJMLGNBQWNydUIsTUFBZCxHQUF1QitiLENBQWhEO2tCQUNNaEIsV0FBV3dULG1CQUFtQnhTLENBQW5CLENBQWpCO3FCQUVFalE7OztzQ0FDb0I0aUIsZ0JBRHBCO3lCQUVTO2dDQUNPLFFBRFA7OEJBRUssVUFGTDt5QkFHQWpELDJCQUEyQjFRLFNBQVNqUyxHQUFwQyxDQUhBOzBCQUlDMmlCLDJCQUEyQjFRLFNBQVMvUixJQUFwQyxDQUpEOzJCQUtFeWlCLDJCQUEyQjFRLFNBQVNwUSxLQUFwQyxDQUxGOzRCQU1HOGdCLDJCQUEyQjFRLFNBQVM1UyxNQUFwQzttQkFSWjt1QkFVTyxpQkFBTTt3QkFDTDZSLEVBQUosRUFBUTt1Q0FDVzJQLEdBQWpCLENBQXFCOEUsSUFBckIsRUFBMkJ6VSxHQUFHMEgsWUFBOUI7Ozs7OEJBSUgySyxZQUFEO3dCQUNRb0MsSUFEUjsyQkFFV0MsZ0JBRlg7OztlQWpCSjthQU5EO1dBUEw7ZUF3Q1FoRyxlQUFMLElBQ0M1YyxjQUFDLFVBQUQ7NkJBQ21CLEtBQUtxYyxlQUR4Qjt1QkFFYSxLQUFLRyxTQUZsQjt3QkFJSSxLQUFLelUsS0FBTCxDQUFXd1UsVUFBWCxJQUF5QixLQUFLeFUsS0FBTCxDQUFXeVosc0JBSnhDOzBCQU1nQm5sQixNQU5oQjt1QkFPYSxLQUFLMEwsS0FBTCxDQUFXME47O1NBakQ5Qjs7O2FBd0RLLEtBQUs3aEIsS0FBTCxDQUFXZ3BCLGVBQVgsR0FDTDVjO3VCQUFBOztlQUNPLEtBQUttZ0IscUJBRFo7b0JBRVksS0FBS0osb0JBRmpCOzJCQUdtQixLQUFLbnNCLEtBQUwsQ0FBV2dwQjs7O09BSnpCLEdBU0x5RixRQVRGOzs7OzZDQS9UOEJ6dUIsT0FBaUJtVSxPQUFpQjtVQUN4RGlILEtBRHdELEdBQzVCcGIsS0FENEIsQ0FDeERvYixLQUR3RDtVQUNqRHFTLGdCQURpRCxHQUM1Qnp0QixLQUQ0QixDQUNqRHl0QixnQkFEaUQ7Ozs7VUFJMURHLHlCQUF5QnhTLE1BQU1vUyxJQUFOLENBQzdCO2VBQVEsQ0FBQ0MsaUJBQWlCekQsR0FBakIsQ0FBcUIvTyxJQUFyQixDQUFUO09BRDZCLENBQS9COzs7V0FLSyxJQUFJb0IsSUFBSSxDQUFiLEVBQWdCQSxJQUFJakIsTUFBTTlhLE1BQTFCLEVBQWtDK2IsS0FBSyxDQUF2QyxFQUEwQzs7O1lBR3BDbEksTUFBTWlILEtBQU4sQ0FBWWlCLENBQVosTUFBbUIxSyxTQUF2QixFQUFrQztpQkFDekI7MERBQUE7d0JBQUE7d0JBR087V0FIZDs7Ozs7O2NBVU0wSyxDQUFOLE1BQWFsSSxNQUFNaUgsS0FBTixDQUFZaUIsQ0FBWixDQUFiOztjQUVNL2IsTUFBTixHQUFlNlQsTUFBTWlILEtBQU4sQ0FBWTlhLE1BSjdCLEVBS0U7aUJBQ087MERBQUE7d0JBQUE7d0JBR087V0FIZDs7Ozs7VUFTQThhLE1BQU05YSxNQUFOLEtBQWlCLENBQWpCLElBQXNCNlQsTUFBTWlILEtBQU4sQ0FBWTlhLE1BQVosR0FBcUIsQ0FBL0MsRUFBa0Q7ZUFDekM7d0RBQUE7c0JBQUE7c0JBR087U0FIZDs7VUFNRXN0QiwyQkFBMkJ6WixNQUFNeVosc0JBQXJDLEVBQTZEOztlQUVwRDt3REFBQTs7U0FBUDs7OzthQU9LLElBQVA7Ozs7RUFsUG9DL2hCOztBQUFuQm1nQixRQWlDWnJmLFlBQVk7Ozs7O2VBS0pKLFVBQVVVLE1BTE47Ozs7OztRQVdYVixVQUFVNEcsSUFBVixDQUFldEIsVUFYSjs7Ozs7O1lBaUJQdEYsVUFBVVMsSUFqQkg7Ozs7O2VBc0JKVCxVQUFVVSxNQXRCTjs7Ozs7U0EyQlZWLFVBQVVtUCxPQUFWLENBQWtCblAsVUFBVVcsS0FBVixDQUFnQixFQUFoQixDQUFsQixFQUF1QzJFLFVBM0I3Qjs7Ozs7b0JBZ0NDdEYsVUFBVTBpQixVQUFWLENBQXFCcEYsZ0JBQXJCLENBaENEOzs7OztVQXFDVHRkLFVBQVVRLFNBQVYsQ0FBb0IsQ0FDMUJSLFVBQVUwaUIsVUFBVixDQUFxQkMsYUFBckIsQ0FEMEIsRUFFMUIzaUIsVUFBVTBpQixVQUFWLENBQXFCWCxnQkFBckIsQ0FGMEIsRUFHMUIvaEIsVUFBVTRpQixNQUhnQixDQUFwQixDQXJDUzs7Ozs7OzthQWdETjVpQixVQUFVNEcsSUFoREo7Ozs7O1dBcURSNUcsVUFBVVUsTUFyREY7Ozs7OzttQkEyREFWLFVBQVU0RyxJQTNEVjs7Ozs7Y0FnRUw1RyxVQUFVUzs7QUFqR0xnZixRQW9HWjVZLGVBQWU7ZUFDUCxHQURPO29CQUVGLElBQUl5VyxnQkFBSixFQUZFO1dBR1gsQ0FIVztVQUlaVyxtQkFKWTthQUtULHFCQUFNLEVBTEc7Y0FNUjs7O0FDM0doQixJQUFNcUIsb0JBQWtCLEdBQXhCOzs7QUFHQSxJQUFNQywwQkFBd0IsR0FBOUI7O0FBRUEsSUFBTUMsK0JBQTZCLFNBQTdCQSwwQkFBNkI7U0FBTS9xQixNQUFNNHBCLFFBQU4sR0FBaUI1cEIsQ0FBakIsR0FBcUIyUSxTQUEzQjtDQUFuQzs7QUFFQSxTQUFTeWQsV0FBVCxjQVVFO01BUkV0RSxXQVFGLFFBUkVBLFdBUUY7TUFQRXFELFFBT0YsUUFQRUEsUUFPRjtNQU5lbFMsTUFNZixRQU5FbVMsV0FNRjtNQUxFbG9CLE1BS0YsUUFMRUEsTUFLRjtNQUpFdW5CLGdCQUlGLFFBSkVBLGdCQUlGO01BSEUxQyxPQUdGLFFBSEVBLE9BR0Y7TUFERTlmLEtBQ0YsU0FERUEsS0FDRjs7TUFDSWtqQixZQUFZbGpCLFVBQVUsSUFBMUIsRUFBZ0M7V0FDdkJvakIsZ0JBQWdCO29CQUFBO2FBRWRaLGdCQUZjO3NCQUFBO3dCQUlIM0MsV0FKRzs7S0FBaEIsQ0FBUDs7TUFTQTVrQixXQUFXd2tCLHNCQUFYLElBQ0F4a0Isa0JBQWtCb29CLGdCQUZwQixFQUdFO1dBQ09DLGlCQUFpQjthQUNmZCxnQkFEZTs4QkFBQTtvQkFBQTtzQkFBQTs7S0FBakIsQ0FBUDs7U0FRS2UsY0FBYztXQUNaZixnQkFEWTs0QkFBQTtrQkFBQTtvQkFBQTs7R0FBZCxDQUFQOzs7QUFTRixTQUFTNEIsa0JBQVQsQ0FBK0JydkIsS0FBL0IsRUFBZ0RtVSxLQUFoRCxFQUFpRTtNQUN2RHNaLGdCQUR1RCxHQUN6Qnp0QixLQUR5QixDQUN2RHl0QixnQkFEdUQ7TUFDckMxQyxPQURxQyxHQUN6Qi9xQixLQUR5QixDQUNyQytxQixPQURxQztNQUV2RDNQLEtBRnVELEdBRTdDakgsS0FGNkMsQ0FFdkRpSCxLQUZ1RDs7Ozs7TUFNekR1VCxnQkFBZ0J2VCxNQUFNc1QsTUFBTixDQUNwQjtXQUFRelQsUUFBUXdTLGlCQUFpQnpELEdBQWpCLENBQXFCL08sSUFBckIsQ0FBaEI7R0FEb0IsQ0FBdEI7O01BSU0vVSxTQUFTa3BCLFlBQVlwdkIsS0FBWixFQUFtQm1VLEtBQW5CLENBQWY7TUFDTW1iLGtCQUFrQnBwQixPQUFPeW9CLGFBQVAsQ0FBeEI7O01BRU1sbUIsU0FBUzZtQixnQkFBZ0JodkIsTUFBaEIsR0FDWFcsS0FBSytaLEdBQUwsK0JBQVlzVSxnQkFBZ0J4dkIsR0FBaEIsQ0FBb0I7V0FBT2d2QixJQUFJMWxCLEdBQUosR0FBVTBsQixJQUFJcm1CLE1BQXJCO0dBQXBCLENBQVosRUFEVyxHQUVYLENBRko7OztNQUtNbW1CLGlCQUFpQnhULE1BQ3BCc1QsTUFEb0IsQ0FDYjtXQUFRelQsUUFBUSxDQUFDd1MsaUJBQWlCekQsR0FBakIsQ0FBcUIvTyxJQUFyQixDQUFqQjtHQURhLEVBRXBCc1EsS0FGb0IsQ0FFZCxDQUZjLEVBRVhSLE9BRlcsQ0FBdkI7TUFHTThELHFCQUFxQjNvQixPQUFPMG9CLGNBQVAsQ0FBM0I7O1NBRU87a0JBQUE7Z0NBQUE7a0NBQUE7MENBQUE7O0dBQVA7Ozs7Ozs7Ozs7O0lBZ0JtQlc7Ozt1QkE4R1B2dkIsS0FBWixFQUE2Qjs7O3lIQUNyQkEsS0FEcUI7O1VBdkc3QmdrQixZQXVHNkIsR0F2R2RpRSxTQUFTLFlBQU07VUFDeEIsTUFBS2dFLFdBQVQsRUFBc0I7Y0FDZjVYLFFBQUwsQ0FBYyxFQUFFcEosT0FBTyxNQUFLZ2hCLFdBQUwsQ0FBaUJDLFdBQTFCLEVBQWQ7O0tBRlcsRUFJWkwsaUJBSlksQ0F1R2M7VUFqRzdCTSxvQkFpRzZCLEdBakdOM0MsU0FBUyxZQUFNO1VBQ2hDLENBQUMsTUFBS1IsZUFBVixFQUEyQjs7O1VBR3JCQSxrQkFBa0IsTUFBS0EsZUFBTCxDQUFxQkUscUJBQXJCLEVBQXhCOztVQUVJLENBQUNGLGVBQUwsRUFBc0I7Ozs7WUFJakIzVSxRQUFMLENBQWM7bUJBQ0RrVyxhQUFhdkIsZUFBYjtPQURiOztZQUlLd0csZ0NBQUw7S0FkcUIsQ0FpR007VUFoRjdCcEQscUJBZ0Y2QixHQWhGTG5FLFNBQVMsWUFBTTtZQUNoQ29FLGdCQUFMO0tBRHNCLEVBRXJCLENBRnFCLENBZ0ZLOztVQThLN0JDLGlCQTlLNkIsR0E4S1QsVUFBQ3hnQixHQUFELEVBQXVCO1lBQ3BDbWdCLFdBQUwsR0FBbUJuZ0IsR0FBbkI7S0EvSzJCOztVQWtMN0J5Z0IscUJBbEw2QixHQWtMTCxVQUFDemdCLEdBQUQsRUFBMkI7WUFDNUNrZCxlQUFMLEdBQXVCbGQsR0FBdkI7S0FuTDJCOztVQXNMN0IwakIsZ0NBdEw2QixHQXNMTSxZQUFNO3dCQUNiLE1BQUtyYixLQURRO1VBQy9CMUwsTUFEK0IsZUFDL0JBLE1BRCtCO1VBQ3ZCd0MsS0FEdUIsZUFDdkJBLEtBRHVCOztVQUdyQyxPQUFPLE1BQUtqTCxLQUFMLENBQVd5dkIsNEJBQWxCLEtBQW1ELFVBQW5ELElBQ0EsTUFBS2hILGVBRlAsRUFHRTtZQUNNaUgsWUFBVztlQUNWLE1BQUt2YixLQUFMLENBQVcwTixTQUREO2dCQUVULENBRlM7a0JBR1AsTUFBSzRHLGVBSEU7aUJBSVJ4ZCxTQUFTO1NBSmxCO1lBTU0wa0IsV0FBVTtlQUNULE1BQUt4QyxlQURJO2dCQUVSLENBRlE7d0JBQUE7aUJBSVBsaUIsU0FBUztTQUpsQjs7Y0FPS2pMLEtBQUwsQ0FBV3l2Qiw0QkFBWCxDQUF3Q0UsUUFBeEMsRUFBaURELFNBQWpEOztLQXpNeUI7O1VBNk03QkUsMkJBN002QixHQTZNQyxVQUFDemIsS0FBRCxFQUE2QjtVQUNyRCxNQUFLblUsS0FBTCxDQUFXNnZCLHFCQUFmLEVBQXNDO2NBQy9CN3ZCLEtBQUwsQ0FBVzZ2QixxQkFBWCxDQUFpQzFiLEtBQWpDOztLQS9NeUI7O1VBMlA3QnNZLHNCQTNQNkIsR0EyUEosVUFBQ0MsUUFBRCxFQUFjcFIsR0FBZCxFQUEyQkQsUUFBM0IsRUFBMkM7d0JBTTlELE1BQUtyYixLQU55RDtVQUUxRDJzQixZQUYwRCxlQUVoRUMsSUFGZ0U7VUFHaEVDLFVBSGdFLGVBR2hFQSxVQUhnRTtVQUloRUMsZ0JBSmdFLGVBSWhFQSxnQkFKZ0U7VUFLaEVDLG1CQUxnRSxlQUtoRUEsbUJBTGdFO1VBTzFEM2pCLEdBUDBELEdBTzdCaVMsUUFQNkIsQ0FPMURqUyxHQVAwRDtVQU9yREUsSUFQcUQsR0FPN0IrUixRQVA2QixDQU9yRC9SLElBUHFEO1VBTy9DMkIsS0FQK0MsR0FPN0JvUSxRQVA2QixDQU8vQ3BRLEtBUCtDO1VBT3hDeEMsTUFQd0MsR0FPN0I0UyxRQVA2QixDQU94QzVTLE1BUHdDOzs7VUFTOUR1a0Isa0JBQUo7VUFDSSxNQUFLaHRCLEtBQUwsQ0FBV2dwQixlQUFmLEVBQWdDO1lBQ3hCaUUsZ0JBQWdCLE1BQUt4RSxlQUFMLEdBQXVCcUQsdUJBQTdDO1lBQ01vQixrQkFBa0IsTUFBSy9ZLEtBQUwsQ0FBVzBOLFNBQVgsR0FBdUIsTUFBS3NMLGVBQXBEO1lBQ01yUyxjQUFjZ1MsbUJBQ2hCSSxrQkFBa0JKLGdCQURGLEdBRWhCSSxrQkFBa0JELGFBRnRCO1lBR01HLGlCQUFpQkwsc0JBQ25CRyxrQkFBa0IsTUFBS3pFLGVBQXZCLEdBQXlDc0UsbUJBRHRCLEdBRW5CRyxrQkFBa0IsTUFBS3pFLGVBQXZCLEdBQXlDd0UsYUFGN0M7O29CQUlZLEVBQ1Y1UixTQUFTalMsR0FBVCxHQUFlaVMsU0FBUzVTLE1BQXhCLEdBQWlDcVMsV0FBakMsSUFDQU8sU0FBU2pTLEdBQVQsR0FBZWdrQixjQUZMLENBQVo7T0FWRixNQWNPOztvQkFFTyxJQUFaOzs7VUFHSUMsZ0JBQ0pqaEI7Ozt5QkFDZWtQLEdBRGY7cUJBRWEsQ0FBQ25jLFNBQU9tdUIsYUFBUixFQUF1Qm51QixTQUFPb3VCLHNCQUE5QixFQUFzRHB0QixJQUF0RCxDQUNULEdBRFMsQ0FGYjtnQ0FBQTtpQkFNUztpQkFDQSxDQURBO2tCQUVDLENBRkQ7dUNBR29CbUosSUFBekIsdUJBQStDRixHQUEvQyxRQUhLOzZDQUkwQkUsSUFBL0IsdUJBQXFERixHQUFyRCxRQUpLO21CQUtFMmlCLDZCQUEyQjlnQixLQUEzQixDQUxGO29CQU1HOGdCLDZCQUEyQnRqQixNQUEzQjs7O3NCQUdUa2tCLFlBQUQsSUFBVyxNQUFNRCxRQUFqQixFQUEyQixTQUFTcFIsR0FBcEMsRUFBeUMsYUFBYSxLQUF0RDtPQWhCSjs7YUFvQk91UixhQUFjRyxhQUFhSyxhQUFkLElBQWdDLElBQTdDLEdBQW9EQSxhQUEzRDtLQTVTMkI7O1VBR3RCNUUsZUFBTCxHQUF1QixDQUF2QjtVQUNLMEUsZUFBTCxHQUF1QixDQUF2Qjs7VUFFS2haLEtBQUwsR0FBYTs4QkFDYW5VLE1BQU1vYixLQUFOLENBQVlvUyxJQUFaLENBQ3RCO2VBQVEsQ0FBQyxDQUFDdlMsSUFBRixJQUFVLENBQUNqYixNQUFNeXRCLGdCQUFOLENBQXVCekQsR0FBdkIsQ0FBMkIvTyxJQUEzQixDQUFuQjtPQURzQixDQURiO2NBSUgsQ0FKRztxQkFLSSxFQUxKO3NCQU1LLEVBTkw7O2FBUUpqYixNQUFNb2IsS0FSRjswQkFTUyxFQVRUO3VCQVVNLEVBVk47aUJBV0EsQ0FYQTthQVlKeko7S0FaVDs7Ozs7Ozs7Ozs7Ozs7O3dDQW1Ca0I7OzthQUNYMlEsZ0JBQVAsQ0FBd0IsUUFBeEIsRUFBa0MsS0FBSzBCLFlBQXZDOztXQUVLcUksZ0JBQUw7O1VBRU14SyxTQUxZLEdBS0UsS0FBSzFOLEtBTFAsQ0FLWjBOLFNBTFk7O1VBTWQsS0FBS21ILGVBQUwsSUFBd0IsSUFBNUIsRUFBa0M7WUFDMUJBLG1CQUFrQixLQUFLQSxlQUFMLENBQXFCRSxxQkFBckIsRUFBeEI7WUFDSUYsZ0JBQUosRUFBcUI7c0JBQ1B1QixhQUFhdkIsZ0JBQWIsQ0FBWjs7OztXQUlDM1UsUUFBTCxDQUFjLHFCQUFhO1lBQ25CcEosUUFBUSxPQUFLZ2hCLFdBQUwsR0FDVixPQUFLQSxXQUFMLENBQWlCQyxXQURQLEdBRVZ3QixVQUFVemlCLEtBRmQ7WUFHTTZrQiw4QkFBc0IsT0FBSzNiLEtBQTNCLElBQWtDbEosWUFBbEMsR0FBTjs7OEJBQ0E7O1dBR0tva0IsbUJBQW1CLE9BQUtydkIsS0FBeEIsRUFBK0I4dkIsY0FBL0IsQ0FITDtPQUxGOzs7V0FhS0YsMkJBQUwsQ0FDRSxLQUFLemIsS0FBTCxDQUFXeVosc0JBQVgsR0FBb0MsV0FBcEMsR0FBa0QsTUFEcEQ7Ozs7dUNBS2lCdmIsV0FBcUJxYixXQUFxQjs7O21CQUN2QixLQUFLMXRCLEtBRGtCO1VBQ25Eb2IsS0FEbUQsVUFDbkRBLEtBRG1EO1VBQzVDcVMsZ0JBRDRDLFVBQzVDQSxnQkFENEM7OztXQUd0RHJCLHFCQUFMOztVQUVJc0IsVUFBVXppQixLQUFWLElBQW1CLElBQW5CLElBQTJCLEtBQUtrSixLQUFMLENBQVdsSixLQUFYLEtBQXFCeWlCLFVBQVV6aUIsS0FBOUQsRUFBcUU7eUJBQ2xEMGlCLEtBQWpCOzs7VUFHSUMseUJBQXlCeFMsTUFBTW9TLElBQU4sQ0FDN0I7ZUFBUSxDQUFDLENBQUN2UyxJQUFGLElBQVUsQ0FBQ3dTLGlCQUFpQnpELEdBQWpCLENBQXFCL08sSUFBckIsQ0FBbkI7T0FENkIsQ0FBL0I7O1VBSUkyUywwQkFBMEIsQ0FBQ0YsVUFBVUUsc0JBQXpDLEVBQWlFO2FBQzFEZ0MsMkJBQUwsQ0FBaUMsV0FBakM7T0FERixNQUVPLElBQUksQ0FBQ2hDLHNCQUFELElBQTJCRixVQUFVRSxzQkFBekMsRUFBaUU7YUFDakVnQywyQkFBTCxDQUFpQyxNQUFqQzs7V0FFR0osZ0NBQUw7O1VBR0U1QiwwQkFDQUEsMkJBQTJCLEtBQUt6WixLQUFMLENBQVd5WixzQkFEdEMsSUFFQUYsVUFBVXppQixLQUFWLElBQW1CLElBSHJCLEVBSUU7YUFDSzRpQixvQkFBTCxHQUE0QkMsc0JBQXNCLFlBQU07Y0FDaERpQyxrQkFBa0JWLG1CQUFtQixPQUFLcnZCLEtBQXhCLEVBQStCLE9BQUttVSxLQUFwQyxDQUF4QjtpQkFDS0UsUUFBTDs7YUFFSzBiLGVBRkw7U0FGMEIsQ0FBNUI7T0FMRixNQVlPLElBQUluQywwQkFBMEJGLFVBQVV0UyxLQUFWLEtBQW9CQSxLQUFsRCxFQUF5RDthQUN6RHlTLG9CQUFMLEdBQTRCQyxzQkFBc0IsWUFBTTtjQUNoRGlDLGtCQUFrQlYsbUJBQW1CLE9BQUtydkIsS0FBeEIsRUFBK0IsT0FBS21VLEtBQXBDLENBQXhCO2lCQUNLRSxRQUFMLGNBQW1CMGIsZUFBbkI7U0FGMEIsQ0FBNUI7Ozs7Ozs7Ozs7MkNBVW1CO1VBQ2pCLEtBQUtsQyxvQkFBVCxFQUErQjs2QkFDUixLQUFLQSxvQkFBMUI7Ozs7V0FJR3pCLHFCQUFMLENBQTJCN0QsWUFBM0I7V0FDS3ZFLFlBQUwsQ0FBa0J1RSxZQUFsQjtXQUNLNEQsb0JBQUwsQ0FBMEI1RCxZQUExQjs7YUFFTzdGLG1CQUFQLENBQTJCLFFBQTNCLEVBQXFDLEtBQUtzQixZQUExQzs7Ozt1Q0FrSGlCO1VBQ2IsS0FBS2dGLGVBQUwsSUFBd0IsSUFBNUIsRUFBa0M7WUFDeEJBLGlCQUR3QixHQUNKLElBREksQ0FDeEJBLGVBRHdCOztZQUUxQitFLHFCQUFxQi9FLGtCQUFnQkUscUJBQWhCLEVBQTNCO1lBQ0k2RSxrQkFBSixFQUF3QjtlQUNqQnRGLGVBQUwsR0FBdUJ5QixpQkFBaUI2RCxrQkFBakIsQ0FBdkI7Y0FDTXpULEtBQUssS0FBSzJSLFdBQWhCO2NBQ0kzUixjQUFjMFQsV0FBbEIsRUFBK0I7Z0JBQ3ZCQyxvQkFBb0I1RCxxQkFBcUIwRCxrQkFBckIsQ0FBMUI7aUJBQ0taLGVBQUwsR0FDRTdTLEdBQUc2SixxQkFBSCxHQUEyQi9hLEdBQTNCLEdBQWlDNmtCLGlCQURuQzs7Ozs7Ozs7Ozs7Ozs7NkJBWUM7V0FDRmp1QixLQUFMLENBQVd5dEIsZ0JBQVgsQ0FBNEJFLEtBQTVCO1dBQ0t0QixnQkFBTDtXQUNLbUQsZ0NBQUw7V0FDS3RCLFdBQUw7Ozs7NkJBdURPOzs7b0JBT0gsS0FBS2x1QixLQVBGO1VBRUw4cUIsV0FGSyxXQUVMQSxXQUZLO1VBR0M2QixZQUhELFdBR0xDLElBSEs7VUFJTHVCLFFBSkssV0FJTEEsUUFKSztVQUtMVixnQkFMSyxXQUtMQSxnQkFMSztVQU1MclMsS0FOSyxXQU1MQSxLQU5LO21CQWdCSCxLQUFLakgsS0FoQkY7VUFTTHlaLHNCQVRLLFVBU0xBLHNCQVRLO1VBVUxubEIsTUFWSyxVQVVMQSxNQVZLO1VBV0xtbUIsY0FYSyxVQVdMQSxjQVhLO1VBWUxELGFBWkssVUFZTEEsYUFaSztVQWFMRSxrQkFiSyxVQWFMQSxrQkFiSztVQWNMUyxlQWRLLFVBY0xBLGVBZEs7VUFlTHJrQixLQWZLLFVBZUxBLEtBZks7O1VBaUJId2pCLGlCQUFKO1VBQ0l4akIsU0FBUyxJQUFULElBQWlCMmlCLHNCQUFyQixFQUE2Qzs7O21CQUl6Q3hoQjs7O3VCQUNhak4sU0FBTzZzQixPQURwQjttQkFFUyxFQUFFdmpCLFFBQVEsQ0FBVixFQUFhd0MsT0FBTyxNQUFwQixFQUZUO2lCQUdPLEtBQUtxaEI7O2dCQUVIb0MsTUFBTixDQUFhO21CQUFRelQsSUFBUjtXQUFiLEVBQTJCbmIsR0FBM0IsQ0FBK0IsVUFBQ21iLElBQUQsRUFBT29CLENBQVA7bUJBQzlCalE7OzsyQkFDWSxRQURaO3NDQUFBO3FCQUdPaVEsQ0FIUDt1QkFJUzt1QkFDQSxDQURBO3dCQUVDLENBRkQ7NkJBR00saUNBSE47bUNBSVksaUNBSlo7eUJBS0U4UixXQUNIeGMsU0FERyxHQUVIb2EsNkJBQTJCakIsV0FBM0IsQ0FQQztpQkFKVDtxQkFhTyxpQkFBTTtzQkFDTHhRLE1BQU0sQ0FBQzZULFFBQVgsRUFBcUI7O3FDQUVGbEUsR0FBakIsQ0FBcUJoUCxJQUFyQixFQUEyQlgsR0FBRzBILFlBQTlCOzs7OzRCQUlIMkssWUFBRCxJQUFXLE1BQU0xUixJQUFqQixFQUF1QixTQUFTb0IsQ0FBaEMsRUFBbUMsYUFBYSxLQUFoRDthQXJCNEI7V0FBL0I7U0FOTDtPQUhGLE1BbUNPLElBQUlwUixTQUFTLElBQWIsRUFBbUI7OzttQkFHYm1CLHVCQUFLLE9BQU8sRUFBRW5CLE9BQU8sTUFBVCxFQUFaLEVBQStCLEtBQUssS0FBS3FoQixpQkFBekMsR0FBWDtPQUhLLE1BSUE7bUJBRUhsZ0I7O1lBQUssT0FBTyxFQUFFbkIsT0FBTyxNQUFULEVBQVosRUFBK0IsS0FBSyxLQUFLcWhCLGlCQUF6Qzs7O2NBQ08sV0FBV250QixTQUFPNnNCLE9BQXZCLEVBQWdDLE9BQU8sRUFBRXZqQixjQUFGLEVBQVV3QyxZQUFWLEVBQXZDOzBCQUNpQm5MLEdBQWQsQ0FBa0IsVUFBQ21iLElBQUQsRUFBT29CLENBQVA7Ozt1QkFFWm9RLHNCQUFMLENBQTRCeFIsSUFBNUIsRUFBa0NvQixDQUFsQyxFQUFxQ2lULGdCQUFnQmpULENBQWhCLENBQXJDOzthQUZEO1dBRkw7OztjQU9PLFdBQVdsZCxTQUFPNnNCLE9BQXZCLEVBQWdDLE9BQU8sRUFBRS9nQixZQUFGLEVBQXZDOzJCQUNrQm5MLEdBQWYsQ0FBbUIsVUFBQ2l2QixJQUFELEVBQU8xUyxDQUFQLEVBQWE7Ozs7a0JBSXpCMlMsbUJBQW1CTCxjQUFjcnVCLE1BQWQsR0FBdUIrYixDQUFoRDtrQkFDTWhCLFdBQVd3VCxtQkFBbUJ4UyxDQUFuQixDQUFqQjtxQkFFRWpROzs7c0NBQ29CNGlCLGdCQURwQjt5QkFFUztnQ0FDTyxRQURQOzhCQUVLLFVBRkw7eUJBR0FqRCw2QkFBMkIxUSxTQUFTalMsR0FBcEMsQ0FIQTswQkFJQzJpQiw2QkFBMkIxUSxTQUFTL1IsSUFBcEMsQ0FKRDsyQkFLRXlpQiw2QkFBMkIxUSxTQUFTcFEsS0FBcEMsQ0FMRjs0QkFNRzhnQiw2QkFBMkIxUSxTQUFTNVMsTUFBcEM7bUJBUlo7dUJBVU8saUJBQU07d0JBQ0w2UixFQUFKLEVBQVE7dUNBQ1cyUCxHQUFqQixDQUFxQjhFLElBQXJCLEVBQTJCelUsR0FBRzBILFlBQTlCOzs7OzhCQUlIMkssWUFBRDt3QkFDUW9DLElBRFI7MkJBRVdDLGdCQUZYOzs7ZUFqQko7YUFORDs7U0FUUDs7O2FBNkNLLEtBQUtodkIsS0FBTCxDQUFXZ3BCLGVBQVgsR0FDTDVjO3VCQUFBOztlQUNPLEtBQUttZ0IscUJBRFo7b0JBRVksS0FBS0osb0JBRmpCOzJCQUdtQixLQUFLbnNCLEtBQUwsQ0FBV2dwQjs7O09BSnpCLEdBU0x5RixRQVRGOzs7OzZDQXRTOEJ6dUIsT0FBaUJtVSxPQUFpQjtVQUN4RGlILEtBRHdELEdBQzVCcGIsS0FENEIsQ0FDeERvYixLQUR3RDtVQUNqRHFTLGdCQURpRCxHQUM1Qnp0QixLQUQ0QixDQUNqRHl0QixnQkFEaUQ7Ozs7VUFJMURHLHlCQUF5QnhTLE1BQU1vUyxJQUFOLENBQzdCO2VBQVF2UyxRQUFRLENBQUN3UyxpQkFBaUJ6RCxHQUFqQixDQUFxQi9PLElBQXJCLENBQWpCO09BRDZCLENBQS9COztVQUlNK1Usd0JBQ0Q3YixLQURDO3NEQUFBOztRQUFOOzs7V0FPSyxJQUFJa0ksSUFBSSxDQUFiLEVBQWdCQSxJQUFJakIsTUFBTTlhLE1BQTFCLEVBQWtDK2IsS0FBSyxDQUF2QyxFQUEwQzs7O1lBR3BDbEksTUFBTWlILEtBQU4sQ0FBWWlCLENBQVosTUFBbUIxSyxTQUF2QixFQUFrQzs7MERBQ2hDOzthQUdLMGQsbUJBQW1CcnZCLEtBQW5CLEVBQTBCZ3dCLFFBQTFCLENBSEw7Ozs7OztjQVVNM1QsQ0FBTixNQUFhbEksTUFBTWlILEtBQU4sQ0FBWWlCLENBQVosQ0FBYjs7Y0FFTS9iLE1BQU4sR0FBZTZULE1BQU1pSCxLQUFOLENBQVk5YSxNQUo3QixFQUtFOzswREFDQTs7YUFHSyt1QixtQkFBbUJydkIsS0FBbkIsRUFBMEJnd0IsUUFBMUIsQ0FITDs7Ozs7VUFTQTVVLE1BQU05YSxNQUFOLEtBQWlCLENBQWpCLElBQXNCNlQsTUFBTWlILEtBQU4sQ0FBWTlhLE1BQVosR0FBcUIsQ0FBL0MsRUFBa0Q7O3dEQUNoRDs7V0FHSyt1QixtQkFBbUJydkIsS0FBbkIsRUFBMEJnd0IsUUFBMUIsQ0FITDs7VUFNRXBDLDJCQUEyQnpaLE1BQU15WixzQkFBckMsRUFBNkQ7Ozt3REFFM0Q7O1dBR0t5QixtQkFBbUJydkIsS0FBbkIsRUFBMEJnd0IsUUFBMUIsQ0FITDs7OzthQVFLLElBQVA7Ozs7RUF6UndDbmtCOztBQUF2QjBqQixZQWtDWjVpQixZQUFZOzs7OztlQUtKSixVQUFVVSxNQUxOOzs7Ozs7UUFXWFYsVUFBVTRHLElBQVYsQ0FBZXRCLFVBWEo7Ozs7OztZQWlCUHRGLFVBQVVTLElBakJIOzs7OztlQXNCSlQsVUFBVVUsTUF0Qk47Ozs7O1NBMkJWVixVQUFVbVAsT0FBVixDQUFrQm5QLFVBQVVXLEtBQVYsQ0FBZ0IsRUFBaEIsQ0FBbEIsRUFBdUMyRSxVQTNCN0I7Ozs7O29CQWdDQ3RGLFVBQVUwaUIsVUFBVixDQUFxQnBGLGdCQUFyQixDQWhDRDs7Ozs7VUFxQ1R0ZCxVQUFVUSxTQUFWLENBQW9CLENBQzFCUixVQUFVMGlCLFVBQVYsQ0FBcUJDLGFBQXJCLENBRDBCLEVBRTFCM2lCLFVBQVUwaUIsVUFBVixDQUFxQlgsZ0JBQXJCLENBRjBCLEVBRzFCL2hCLFVBQVU0aUIsTUFIZ0IsQ0FBcEIsQ0FyQ1M7Ozs7Ozs7YUFnRE41aUIsVUFBVTRHLElBaERKOzs7OztXQXFEUjVHLFVBQVVVLE1BckRGOzs7Ozs7bUJBMkRBVixVQUFVNEcsSUEzRFY7Ozs7O2NBZ0VMNUcsVUFBVVM7O0FBbEdMdWlCLFlBcUdabmMsZUFBZTtlQUNQLEdBRE87b0JBRUYsSUFBSXlXLGdCQUFKLEVBRkU7V0FHWCxDQUhXO1VBSVpXLG1CQUpZO2FBS1QscUJBQU0sRUFMRztjQU1SOzs7QUNoUWhCOzs7Ozs7OztJQVFxQnlGOzs7OzZDQUlhO2FBQ3ZCLElBQUlwRyxnQkFBSixFQUFQOzs7OytCQUtVN3BCLEtBQVosRUFBNkI7Ozt5SUFDckJBLEtBRHFCOztVQWlCN0J5dkIsNEJBakI2QixHQWlCRSxVQUFDRSxPQUFELEVBQW9CRCxRQUFwQixFQUEyQzt3QkFDbkIsTUFBS3ZiLEtBRGM7VUFDaEVzVSxlQURnRSxlQUNoRUEsZUFEZ0U7VUFDL0M1RyxTQUQrQyxlQUMvQ0EsU0FEK0M7VUFDcENnSCxZQURvQyxlQUNwQ0EsWUFEb0M7O1VBR3RFNkcsU0FBU2puQixNQUFULEtBQW9CZ2dCLGVBQXBCLElBQ0FpSCxTQUFTdG1CLEdBQVQsS0FBaUJ5WSxTQURqQixJQUVBOE4sUUFBUWxuQixNQUFSLEtBQW1Cb2dCLFlBSHJCLEVBSUU7Y0FDS3hVLFFBQUwsQ0FBYzsyQkFDS3FiLFNBQVNqbkIsTUFEZDtxQkFFRGluQixTQUFTdG1CLEdBRlI7d0JBR0V1bUIsUUFBUWxuQjtTQUh4Qjs7S0F4QnlCOztVQStDN0J5bkIsTUEvQzZCLEdBK0NwQixVQUFDcGtCLEdBQUQsRUFBOEI7VUFDakNBLEdBQUosRUFBUztjQUNGcWtCLE9BQUwsR0FBZXJrQixHQUFmOztLQWpEeUI7O1VBcUQ3QjhjLFNBckQ2QixHQXFEakIsWUFBTTtVQUNSNEQsU0FEUSxHQUNNLE1BQUt4c0IsS0FEWCxDQUNSd3NCLFNBRFE7O1VBRVpBLGFBQWEsT0FBT0EsU0FBUCxLQUFxQixVQUF0QyxFQUFrRDtjQUMzQ25ZLFFBQUwsQ0FDRTtzQkFDYztTQUZoQixFQUlFO2lCQUFNbVksVUFBVSxFQUFFM3NCLE1BQU0sTUFBS0csS0FBTCxDQUFXb2IsS0FBWCxDQUFpQjlhLE1BQXpCLEVBQVYsQ0FBTjtTQUpGOztLQXhEeUI7O1VBaUU3QnN2QiwyQkFqRTZCLEdBaUVDLFVBQUN6YixLQUFELEVBQTZCO1VBQ25EeVoseUJBQXlCelosVUFBVSxXQUF6QztVQUNJLE1BQUtBLEtBQUwsQ0FBV3laLHNCQUFYLEtBQXNDQSxzQkFBMUMsRUFBa0U7Y0FDM0R2WixRQUFMLENBQWMsRUFBRXVaLDhDQUFGLEVBQWQ7OztVQUdFLE9BQU8sTUFBSzV0QixLQUFMLENBQVc2dkIscUJBQWxCLEtBQTRDLFVBQWhELEVBQTREO2NBQ3JEN3ZCLEtBQUwsQ0FBVzZ2QixxQkFBWCxDQUFpQzFiLEtBQWpDOztLQXhFeUI7O1VBNEU3QmljLE1BNUU2QixHQTRFcEIsWUFBTTtVQUNULE1BQUtELE9BQVQsRUFBa0I7Y0FDWEEsT0FBTCxDQUFhQyxNQUFiOztLQTlFeUI7O1VBa0Y3QnBNLFlBbEY2QixHQWtGZCxZQUFNO1VBQ2YsTUFBS21NLE9BQVQsRUFBa0I7Y0FDWEEsT0FBTCxDQUFhbk0sWUFBYjs7S0FwRnlCOztVQUd0QjdQLEtBQUwsR0FBYTt1QkFDTSxDQUROOzhCQUVhLEtBRmI7a0JBR0MsS0FIRDs7YUFLSm5VLE1BQU1vYixLQUxGO2lCQU1BLENBTkE7b0JBT0c7S0FQaEI7Ozs7Ozs7Ozs7OzZCQXVGTzthQUNBLEtBQUtwYixLQUFMLENBQVdncEIsZUFBWCxHQUNMNWM7Z0JBQUE7O3NCQUNHLFVBQUQ7MkJBQ21CLEtBQUsrSCxLQUFMLENBQVdzVSxlQUQ5QjtxQkFFYSxLQUFLRyxTQUZsQjtzQkFJSSxLQUFLelUsS0FBTCxDQUFXd1UsVUFBWCxJQUF5QixLQUFLeFUsS0FBTCxDQUFXeVosc0JBSnhDO3dCQU1nQixLQUFLelosS0FBTCxDQUFXMFUsWUFOM0I7cUJBT2EsS0FBSzFVLEtBQUwsQ0FBVzBOO1VBUjFCO3NCQVVHbUssV0FBRCxlQUNNLEtBQUtoc0IsS0FEWDt3Q0FFZ0MsS0FBS3l2Qiw0QkFGckM7aUNBR3lCLEtBQUtHLDJCQUg5QjtlQUlPLEtBQUtNOztPQWZULEdBbUJMOWpCLGNBQUM0ZixXQUFELGVBQWEsS0FBS2hzQixLQUFsQixJQUF5QixLQUFLLEtBQUtrd0IsTUFBbkMsSUFuQkY7Ozs7NkNBM0Q4Qmx3QixPQUFpQm1VLE9BQWlCO1VBQ3hEaUgsS0FEd0QsR0FDOUNwYixLQUQ4QyxDQUN4RG9iLEtBRHdEOzs7O1VBSTVEcGIsTUFBTW9iLEtBQU4sS0FBZ0JqSCxNQUFNaUgsS0FBMUIsRUFBaUM7ZUFDeEI7c0JBQUE7c0JBRU87U0FGZDs7OzthQU9LLElBQVA7Ozs7RUF0RGdEdlA7O0FBQS9Cb2tCLG9CQVFaN2MsZUFBZTRZLFlBQVE1WTs7SUN6QlhpZDs7OzRCQUNQcndCLEtBQVosRUFBMEI7OzttSUFDbEJBLEtBRGtCOztVQUVuQnN3QixZQUFMLEdBQW9CLElBQXBCOzs7Ozs7d0NBR2tCO1VBQ2QsT0FBTy9kLE1BQVAsS0FBa0IsV0FBdEIsRUFBbUM7YUFDNUIrZCxZQUFMLEdBQW9CL2QsT0FBT2tQLFFBQVAsQ0FBZ0JvRixJQUFoQixDQUFxQnRtQixLQUFyQixDQUEyQnVVLFFBQS9DO2VBQ08yTSxRQUFQLENBQWdCb0YsSUFBaEIsQ0FBcUJ0bUIsS0FBckIsQ0FBMkJ1VSxRQUEzQixHQUFzQyxRQUF0Qzs7Ozs7MkNBSW1CO1VBQ2pCLE9BQU92QyxNQUFQLEtBQWtCLFdBQXRCLEVBQW1DO2VBQzFCa1AsUUFBUCxDQUFnQm9GLElBQWhCLENBQXFCdG1CLEtBQXJCLENBQTJCdVUsUUFBM0IsR0FBc0MsS0FBS3diLFlBQTNDOzs7Ozs2QkFNSzthQUNBLEtBQUt0d0IsS0FBTCxDQUFXK0wsUUFBbEI7Ozs7RUF0QjBDRjs7QUNBOUMsU0FBUzBrQixpQkFBVCxDQUEyQmpXLEVBQTNCLEVBQStDO01BQ3ZDa1csV0FBVyxDQUNmLFNBRGUsRUFFZixZQUZlLEVBR2YsdUJBSGUsRUFJZix3QkFKZSxFQUtmLDBCQUxlLEVBTWYsd0JBTmUsRUFPZixRQVBlLEVBUWYsUUFSZSxFQVNmLE9BVGUsRUFVZixpQkFWZSxFQVdmLGdCQVhlLEVBWWYsbUJBWmUsRUFhZixpQkFiZSxFQWNmLGlCQWRlLEVBZWYsU0FmZSxFQWdCZnJ3QixJQWhCZSxDQWdCVixHQWhCVSxDQUFqQjtTQWlCT21hLEdBQUdtVyxnQkFBSCxDQUFvQkQsUUFBcEIsQ0FBUDs7O0FBR0YsSUFBTUUsZUFBZSxTQUFmQSxZQUFlLENBQUNwVyxFQUFELEVBQXFCO01BQ3BDLE9BQU9BLEdBQUcrSCxLQUFWLEtBQW9CLFVBQXhCLEVBQW9DO09BQy9CQSxLQUFIOztDQUZKOztJQU1xQnNPOzs7Ozs7Ozs7Ozs7OzsyTUFjbkJDLFdBQVcsVUFBQ3RXLEVBQUQsRUFBeUI7VUFDOUJBLEVBQUosRUFBUTtjQUNEQSxFQUFMLEdBQVVBLEVBQVY7O2FBSUpkLGNBQWMsVUFBQ25CLEtBQUQsRUFBdUI7VUFFakMsQ0FBQyxNQUFLaUMsRUFBTixJQUNDakMsTUFBTWEsTUFBTixZQUF3QnFLLElBQXhCLElBQWdDLE1BQUtqSixFQUFMLENBQVFsUCxRQUFSLENBQWlCaU4sTUFBTWEsTUFBdkIsQ0FGbkMsRUFHRTs7OztZQUlJMlgsZUFBTjtZQUNNQyxjQUFOO1lBQ0tDLGVBQUw7Ozs7Ozt3Q0E3QmtCO1dBQ2JDLG1CQUFMLEdBQTJCdlAsU0FBU3dQLGFBQXBDO1dBQ0tGLGVBQUw7ZUFDU3pPLGdCQUFULENBQTBCLE9BQTFCLEVBQW1DLEtBQUs5SSxXQUF4QyxFQUFxRCxJQUFyRDs7OzsyQ0FHcUI7ZUFDWmtKLG1CQUFULENBQTZCLE9BQTdCLEVBQXNDLEtBQUtsSixXQUEzQyxFQUF3RCxJQUF4RDtVQUNJLEtBQUt3WCxtQkFBVCxFQUE4QjtxQkFDZixLQUFLQSxtQkFBbEI7Ozs7O3NDQXVCYztVQUNSMVcsRUFEUSxHQUNELElBREMsQ0FDUkEsRUFEUTs7VUFFWkEsRUFBSixFQUFRO3FCQUNPaVcsa0JBQWtCalcsRUFBbEIsRUFBc0IsQ0FBdEIsQ0FBYjs7Ozs7NkJBUUs7YUFDQWxPOztVQUFLLEtBQUssS0FBS3drQixRQUFmO2FBQStCNXdCLEtBQUwsQ0FBVytMO09BQTVDOzs7O0VBN0MyQ0Y7Ozs7QUNYL0MsSUFBTTJYLG1CQUFpQjtNQUNqQixHQURpQjtNQUVqQixHQUZpQjtNQUdqQjtDQUhOOztBQU1BLElBQU1DLG9CQUFrQixFQUF4Qjs7QUFFQSxJQUFNeU4sV0FBVyxTQUFYQSxRQUFXO01BQUdubEIsUUFBSCxRQUFHQSxRQUFIO1NBQ2ZLO1lBQUE7OzJCQUNPLFdBQVdqTixTQUFPK3hCLFFBQXZCLEdBREY7O0dBRGU7Q0FBakI7O0lBT3FCQzs7Ozs7Ozs7Ozs7Ozs7cUxBb0JuQkMscUJBQXFCLFlBQU07WUFDcEJweEIsS0FBTCxDQUFXNmpCLFNBQVg7YUFHRndOLG1CQUFtQixZQUFNO1lBQ2xCcnhCLEtBQUwsQ0FBVzZqQixTQUFYO2FBR0YrRCxjQUFjLFVBQUN2UCxLQUFELEVBQWdDO1VBQ3hDQSxNQUFNdUwsT0FBTixLQUFrQkgsaUJBQXRCLEVBQXVDO2NBQ2hDempCLEtBQUwsQ0FBVzZqQixTQUFYOzs7Ozs7O3dDQWxCZ0I7YUFDWHZCLGdCQUFQLENBQXdCLE9BQXhCLEVBQWlDLEtBQUtzRixXQUF0Qzs7OzsyQ0FHcUI7YUFDZGxGLG1CQUFQLENBQTJCLE9BQTNCLEVBQW9DLEtBQUtrRixXQUF6Qzs7Ozs2QkFpQk87bUJBU0gsS0FBSzVuQixLQVRGO1VBRUxzeEIsdUJBRkssVUFFTEEsdUJBRks7VUFHTEMsdUJBSEssVUFHTEEsdUJBSEs7VUFJTHhsQixRQUpLLFVBSUxBLFFBSks7VUFLTHlsQixNQUxLLFVBS0xBLE1BTEs7VUFNTEMsT0FOSyxVQU1MQSxPQU5LOytCQU9MQyxJQVBLO1VBT0xBLElBUEssK0JBT0UsUUFQRjsrQkFRTHp4QixJQVJLO1VBUUxBLElBUkssK0JBUUUsSUFSRjs7VUFVRGdMLFFBQVF1WSxpQkFBZXZqQixJQUFmLENBQWQ7O2FBR0VtTTt3QkFBQTs7OzJCQUNFOzs7Ozs0QkFFZ0JtbEIsdUJBRGQ7eUJBRWFweUIsU0FBTzZqQixTQUZwQjtvQkFHUTBPOzs7c0JBRU47OztvQ0FDRTtrQkFBc0IsU0FBUyxLQUFLTixrQkFBcEM7OztvQkFDTyxXQUFXanlCLFNBQU93eUIsT0FBdkIsRUFBZ0MsVUFBVSxDQUFDLENBQTNDLEVBQThDLE9BQU8sRUFBRTFtQixZQUFGLEVBQXJEOzt1QkFDRTs7NEJBQ08sTUFEUDtnQ0FFVyxVQUZYOytCQUdVLE1BSFY7aUNBSVksUUFKWjs2QkFLUTs7O3lCQUVOO3dCQUFLLFNBQUw7K0JBQ1ksUUFBVCxHQUNDbUI7MkJBQUE7O3FEQUM2QjtxQ0FDaEIsRUFBRXdsQixhQUFhLEVBQWYsRUFBbUJDLGNBQWMsRUFBakM7MkJBRmI7bUNBSVUsTUFKVjswQ0FLaUIsUUFMakI7b0NBTVk7OztpQ0FFVjs0QkFBUyxNQUFLLElBQWQsRUFBbUIsb0JBQW9CLENBQXZDOzs7dUJBVEgsR0FjQ3psQjsyQkFBQTswQkFBSyxTQUFRLE1BQWIsRUFBb0IsU0FBUyxDQUE3Qjs7aUNBQ0U7NEJBQVMsTUFBSyxJQUFkLEVBQW1CLG9CQUFvQixDQUF2Qzs7O3VCQWhCTjsrQkFxQlksUUFBVCxJQUNDQTsyQkFBQTswQkFBSyxTQUFTLENBQWQsRUFBaUIsVUFBUyxVQUExQixFQUFxQyxTQUFyQyxFQUF5QyxXQUF6QztzQ0FDRyxVQUFEOzhDQUNzQmtsQix1QkFEdEI7Z0NBRU8sUUFGUDttQ0FHVyxLQUFLRDs7dUJBMUJ0QjsrQkE4QlksUUFBVCxJQUFxQmpsQixjQUFDLE9BQUQ7cUJBckMxQjs7eUJBdUNFO3dCQUFLLE1BQUssTUFBVixFQUFpQixVQUFTLE1BQTFCLEVBQWlDLFVBQVMsVUFBMUM7O3FCQXZDRjs7eUJBMENFO3dCQUFLLFNBQUw7Z0NBRUlBOzJCQUFBOztpQ0FDWSxRQUFULElBQXFCQSxjQUFDLE9BQUQsT0FEeEI7OzZCQUVFOzRCQUFLLFNBQVMsQ0FBZDs7Ozs7Ozs7Ozs7T0F6RHRCOzs7O0VBOUMrQlA7O0FBQWRzbEIsTUFDWnhrQixZQUFZO1lBQ1BKLFVBQVVLLElBREg7MkJBRVFMLFVBQVVZLE1BQVYsQ0FBaUIwRSxVQUZ6QjtVQUdUdEYsVUFBVUssSUFIRDtXQUlSTCxVQUFVWSxNQUFWLENBQWlCMEUsVUFKVDsyQkFLUXRGLFVBQVVZLE1BQVYsQ0FBaUIwRSxVQUx6QjthQU1OdEYsVUFBVTRHLElBTko7UUFPWDVHLFVBQVVDLEtBQVYsQ0FBZ0IsQ0FBQyxhQUFELEVBQWdCLFFBQWhCLENBQWhCLENBUFc7UUFRWEQsVUFBVUMsS0FBVixDQUFnQixDQUFDLElBQUQsRUFBTyxJQUFQLEVBQWEsSUFBYixDQUFoQjs7Ozs7QUNwQ0ssU0FBU3NsQixNQUFULENBQWdCOXhCLEtBQWhCLEVBQThCO01BQ25DK3hCLE1BRG1DLEdBQ1oveEIsS0FEWSxDQUNuQyt4QixNQURtQztvQkFDWi94QixLQURZLENBQzNCQyxJQUQyQjtNQUMzQkEsSUFEMkIsK0JBQ3BCLEdBRG9COzs7U0FJekNtTTtPQUFBOztpQ0FDNkI7aUJBQ2hCO21DQUNrQjJsQixTQUFTLENBQVQsR0FBYSxVQUQvQjttQkFFRSxNQUZGO3FCQUdJOztPQUxqQjtlQVFXQSxTQUFTLE1BQVQsR0FBa0IsT0FSN0I7Y0FTVTl4QixJQVRWO2dCQVVXLFVBVlg7YUFXU0E7Ozs7UUFFRixXQUFXZCxTQUFPNnlCLFdBQXZCOzZCQUNPLFdBQVc3eUIsU0FBTzh5QixXQUF2Qjs7R0FmTjs7O0FBcUJGSCxPQUFPbmxCLFNBQVAsR0FBbUI7VUFDVEosVUFBVVMsSUFERDtRQUVYVCxVQUFVVTtDQUZsQjs7OztJQ1pxQmlsQjs7Ozs7Ozs7Ozs7Ozs7K0xBaUJuQi9kLFFBQVE7ZUFDRzthQUdYNkUsZUFBZSxVQUFDWCxLQUFELEVBQWtDO1VBQ3ZDWSxPQUR1QyxHQUMzQlosTUFBTWEsTUFEcUIsQ0FDdkNELE9BRHVDOztZQUUxQ2paLEtBQUwsQ0FBV21aLFFBQVgsQ0FBb0IsRUFBRUYsZ0JBQUYsRUFBV1osWUFBWCxFQUFwQjthQUdGaUIsYUFBYTthQUFNLE1BQUtqRixRQUFMLENBQWMsRUFBRWtGLFNBQVMsS0FBWCxFQUFkLENBQU47YUFFYkMsY0FBYyxZQUFNO1lBQ2JuRixRQUFMLENBQWMsRUFBRWtGLFNBQVMsSUFBWCxFQUFkOzs7Ozs7NkJBR087OzttQkFDOEMsS0FBS3ZaLEtBRG5EO1VBQ0NpWixPQURELFVBQ0NBLE9BREQ7VUFDVXpCLFFBRFYsVUFDVUEsUUFEVjtVQUNvQnNDLEVBRHBCLFVBQ29CQSxFQURwQjtVQUN3QnhZLElBRHhCLFVBQ3dCQSxJQUR4QjtVQUM4QnJCLElBRDlCLFVBQzhCQSxJQUQ5QjtVQUNvQzhELEtBRHBDLFVBQ29DQSxLQURwQzs7YUFHTHFJOzs7cUJBQ2FtRixXQUFXcFMsU0FBTyt5QixXQUFsQixpREFDUi95QixTQUFPZ3pCLG9CQURDLEVBQ3NCLEtBQUtoZSxLQUFMLENBQVdvRixPQURqQywrQkFFUnBhLFNBQU9pekIsYUFGQyxFQUVlbnlCLFNBQVMsSUFGeEIsK0JBR1JkLFNBQU9rekIsYUFIQyxFQUdlcHlCLFNBQVMsSUFIeEIsK0JBSVJkLFNBQU9tekIsa0JBSkMsRUFJb0IsQ0FBQzlhLFFBQUQsSUFBYXlCLE9BSmpDLCtCQUtSOVosU0FBT296QixzQkFMQyxFQUt3Qi9hLFlBQVksQ0FBQ3lCLE9BTHJDOzs7bUJBU0FBLE9BRFg7cUJBRWExSCxXQUFXcFMsU0FBT3F6QixLQUFsQixtREFDUnJ6QixTQUFPc3pCLFlBREMsRUFDYyxDQUFDamIsUUFEZixnQ0FFUnJZLFNBQU91ekIsT0FGQyxFQUVTenlCLFNBQVMsSUFGbEIsZ0NBR1JkLFNBQU93ekIsT0FIQyxFQUdTMXlCLFNBQVMsSUFIbEIsaUJBRmI7b0JBT1l1WCxRQVBaO2NBUU1zQyxFQVJOO2dCQVNReFksSUFUUjtrQkFVVSxLQUFLZ1ksVUFWZjtvQkFXWSxLQUFLTixZQVhqQjttQkFZVyxLQUFLUSxXQVpoQjtnQkFhTyxPQWJQO2lCQWNTelY7VUF2Qlg7bUJBMEJJcUk7cUJBQ2FtRixXQUFXcFMsU0FBT3l6QixLQUFsQixtREFDUnp6QixTQUFPMHpCLE9BREMsRUFDUzV5QixTQUFTLElBRGxCLGdDQUVSZCxTQUFPMnpCLE9BRkMsRUFFUzd5QixTQUFTLElBRmxCLGdDQUdSZCxTQUFPNHpCLFlBSEMsRUFHYyxDQUFDdmIsUUFIZixnQ0FJUnJZLFNBQU82ekIsYUFKQyxFQUlleGIsUUFKZjs7T0E1Qm5COzs7O0VBbENxQzNMOztBQUFwQnFtQixZQUNadmxCLFlBQVk7V0FDUkosVUFBVVMsSUFERjtZQUVQVCxVQUFVUyxJQUZIO01BR2JULFVBQVVZLE1BQVYsQ0FBaUIwRSxVQUhKO1FBSVh0RixVQUFVWSxNQUpDO1lBS1BaLFVBQVU0RyxJQUFWLENBQWV0QixVQUxSO1NBTVZ0RixVQUFVWSxNQUFWLENBQWlCMEUsVUFOUDtRQU9YdEYsVUFBVUMsS0FBVixDQUFnQixDQUFDLElBQUQsRUFBTyxJQUFQLENBQWhCOztBQVJXMGxCLFlBV1o5ZSxlQUFlO1dBQ1gsS0FEVztZQUVWLEtBRlU7UUFHZDs7O0lDWFc2Zjs7Ozs7Ozs7Ozs7Ozs7K0xBSW5CQyxpQkFBaUIxSixTQUFTLFlBQU07WUFDekJuVixRQUFMLENBQWMsTUFBSzhlLGNBQUwsRUFBZDtLQURlLFNBTWpCaGYsUUFBUTt1QkFDVyxDQURYO29CQUVRLENBRlI7aUJBR0s7YUE4QmJtVyxrQkFBa0IsWUFBTTtVQUNkdEgsU0FEYyxHQUNBLE1BQUtoakIsS0FETCxDQUNkZ2pCLFNBRGM7O1VBRWxCLENBQUNBLFNBQUwsRUFBZ0I7ZUFDUCxDQUFQOzthQUVLc0gsZ0JBQWdCdEgsU0FBaEIsQ0FBUDs7Ozs7Ozs7Ozs7Ozs7O3dDQTdCa0I7OztVQUNWQSxTQURVLEdBQ0ksS0FBS2hqQixLQURULENBQ1ZnakIsU0FEVTs7VUFFZCxDQUFDQSxTQUFMLEVBQWdCOzs7aUJBR0wsWUFBTTtlQUNWM08sUUFBTDsyQkFDbUI2VixpQkFBaUJsSCxTQUFqQjtXQUNkLE9BQUttUSxjQUFMLEVBRkw7T0FERjs7Ozs7Ozs7O3lDQVdtQjs7V0FFZEQsY0FBTDs7Ozs7Ozs7O3FDQWNlO21CQUNxQixLQUFLbHpCLEtBRDFCO1VBQ1BnakIsU0FETyxVQUNQQSxTQURPO1VBQ0lvUSxZQURKLFVBQ0lBLFlBREo7O1VBRVgsQ0FBQ3BRLFNBQUwsRUFBZ0I7ZUFDUCxJQUFQOztVQUVJNkYsZUFBZXVLLGdCQUFnQixLQUFLOUksZUFBMUM7O2FBRU87c0JBQ1N6QixjQURUO21CQUVNMEIsYUFBYXZILFNBQWI7T0FGYjs7Ozs2QkFRTzttQkFDOEMsS0FBSzdPLEtBRG5EO1VBQ0NzVSxlQURELFVBQ0NBLGVBREQ7VUFDa0JJLFlBRGxCLFVBQ2tCQSxZQURsQjtVQUNnQ2hILFNBRGhDLFVBQ2dDQSxTQURoQztvQkFFK0MsS0FBSzdoQixLQUZwRDtVQUVDZ2pCLFNBRkQsV0FFQ0EsU0FGRDtVQUVZNEYsU0FGWixXQUVZQSxTQUZaO1VBRXVCRixPQUZ2QixXQUV1QkEsT0FGdkI7VUFFZ0NDLFVBRmhDLFdBRWdDQSxVQUZoQzs7O1VBSUQzb0IsUUFBUTt3Q0FBQTs0QkFBQTt3QkFBQTs4QkFBQTtrQ0FBQTs7T0FBZDs7VUFTSSxDQUFDZ2pCLFNBQUQsSUFBYzBGLE9BQWxCLEVBQTJCO2VBQ2xCLElBQVA7O2FBR0F0Yzt1QkFBQTs7b0JBQ1ksS0FBSzhtQixjQURqQjsyQkFFbUJsUTs7c0JBRWhCLFVBQUQsRUFBZ0JoakIsS0FBaEI7T0FMSjs7OztFQWxGcUM2TDs7O0FBNkZ6Q29uQixZQUFZdG1CLFNBQVosR0FBd0I7Ozs7YUFJWEosVUFBVVcsS0FBVixDQUFnQjtzQkFDUFgsVUFBVTRHLElBREg7eUJBRUo1RyxVQUFVNEc7R0FGdEIsQ0FKVztnQkFRUjVHLFVBQVU0RyxJQVJGO1dBU2I1RyxVQUFVUyxJQVRHO2NBVVZULFVBQVVTLElBVkE7YUFXWFQsVUFBVTRHO0NBWHZCOztBQWNBOGYsWUFBWTdmLFlBQVosR0FBMkI7YUFDZCxPQUFPYixNQUFQLEtBQWtCLFdBQWxCLEdBQWdDQSxNQUFoQyxHQUF5QztDQUR0RDs7OztJQ3ZHcUI4Z0I7Ozs7Ozs7Ozs7Ozs7OytMQVluQmxmLFFBQWU7ZUFDSixLQURJO2VBRUo7YUFHWDZFLGVBQWUsVUFBQ1gsS0FBRCxFQUE2QztZQUNyRHJZLEtBQUwsQ0FBV21aLFFBQVgsQ0FBb0I7ZUFDWGQsTUFBTWdCLGFBQU4sQ0FBb0J0VixLQURUO3dCQUVGc1U7T0FGbEI7YUFNRmliLGNBQWMsVUFBQ2piLEtBQUQsRUFBNkM7WUFDcERyWSxLQUFMLENBQVdtWixRQUFYLENBQW9CO2VBQ1gsRUFEVzt3QkFFRmQ7T0FGbEI7YUFNRkUsbUJBQW1CO2FBQU0sTUFBS2xFLFFBQUwsQ0FBYyxFQUFFb0UsU0FBUyxJQUFYLEVBQWQsQ0FBTjthQUVuQkMsbUJBQW1CO2FBQU0sTUFBS3JFLFFBQUwsQ0FBYyxFQUFFb0UsU0FBUyxLQUFYLEVBQWQsQ0FBTjthQUVuQmUsY0FBYyxVQUFDbkIsS0FBRCxFQUE2QztZQUNwRGhFLFFBQUwsQ0FBYyxFQUFFa0YsU0FBUyxJQUFYLEVBQWQ7O1VBRUksTUFBS3ZaLEtBQUwsQ0FBV3V6QixPQUFmLEVBQXdCO2NBQ2pCdnpCLEtBQUwsQ0FBV3V6QixPQUFYLENBQW1CO2lCQUNWbGIsTUFBTWdCLGFBQU4sQ0FBb0J0VixLQURWOzBCQUVEc1U7U0FGbEI7O2FBT0ppQixhQUFhLFVBQUNqQixLQUFELEVBQTZDO1lBQ25EaEUsUUFBTCxDQUFjLEVBQUVrRixTQUFTLEtBQVgsRUFBZDs7VUFFSSxNQUFLdlosS0FBTCxDQUFXd3pCLE1BQWYsRUFBdUI7Y0FDaEJ4ekIsS0FBTCxDQUFXd3pCLE1BQVgsQ0FBa0IsRUFBRW5iLFlBQUYsRUFBbEI7Ozs7Ozs7NkJBSUs7bUJBT0gsS0FBS3JZLEtBUEY7VUFFTGlSLGtCQUZLLFVBRUxBLGtCQUZLO1VBR0x3aUIsWUFISyxVQUdMQSxZQUhLO1VBSUwzWixFQUpLLFVBSUxBLEVBSks7VUFLTDRaLFdBTEssVUFLTEEsV0FMSztVQU1MM3ZCLEtBTkssVUFNTEEsS0FOSzs7Ozs7VUFXRDR2QixZQUNKLENBQUMsS0FBS3hmLEtBQUwsQ0FBV29GLE9BQVgsSUFBc0IsS0FBS3BGLEtBQUwsQ0FBV3NFLE9BQWxDLEtBQThDMVUsS0FBOUMsSUFBdURBLE1BQU16RCxNQUFOLEdBQWUsQ0FEeEU7O2FBSUU4TDtXQUFBOzttQkFDVSxNQURWO29CQUVXLFVBRlg7c0JBR2EsUUFIYjt3QkFJZ0IsS0FBS21NLGdCQUpyQjt3QkFLZ0IsS0FBS0csZ0JBTHJCO21CQU1XLEtBQUtjLFdBTmhCO2tCQU9VLEtBQUtGLFVBUGY7aUJBUVE7OzthQUVOOzt1Q0FDNkI7dUJBQ2hCOytCQUNRLE1BRFI7O3FCQUdGLEtBSEU7MkJBSUk7O2FBTmpCO3NCQVNXLFVBVFg7c0JBQUE7c0JBV1k7O3dCQUVULElBQUQsSUFBTSxNQUFLLFFBQVgsRUFBb0Isb0JBQW1CLEVBQXZDO1NBdkJKOzt3QkEwQmdCckksa0JBRGQ7d0JBRWdCd2lCLFlBRmhCO3FCQUdhdDBCLFNBQU95YSxLQUhwQjtjQUlNRSxFQUpOO29CQUtZLEtBQUtkLFlBTGpCO3VCQU1lMGEsV0FOZjtnQkFPTyxXQVBQO2dCQVFPLFFBUlA7aUJBU1MzdkI7VUFsQ1g7cUJBcUNJcUk7YUFBQTtZQUFLLFVBQVMsVUFBZCxFQUF5QixXQUF6QixFQUErQixTQUEvQjs7Ozt5QkFFZWpOLFNBQU95MEIsS0FEcEI7dUJBRVcsS0FBS04sV0FGaEI7d0JBR1ksQ0FBQyxDQUhiO29CQUlPOzswQkFFSixJQUFELElBQU0sTUFBSyxPQUFYLEVBQW1CLG9CQUFtQixFQUF0Qzs7O09BN0NWOzs7O0VBcEVxQ3puQjs7QUFBcEJ3bkIsWUFDWjFtQixZQUFZO3NCQUNHSixVQUFVWSxNQUFWLENBQWlCMEUsVUFEcEI7Z0JBRUh0RixVQUFVQyxLQUFWLENBQWdCLENBQUMsSUFBRCxFQUFPLEtBQVAsRUFBYyxVQUFkLEVBQTBCLE1BQTFCLENBQWhCLENBRkc7TUFHYkQsVUFBVVksTUFBVixDQUFpQjBFLFVBSEo7VUFJVHRGLFVBQVU0RyxJQUpEO1lBS1A1RyxVQUFVNEcsSUFBVixDQUFldEIsVUFMUjtXQU1SdEYsVUFBVTRHLElBTkY7ZUFPSjVHLFVBQVVZLE1BUE47U0FRVlosVUFBVVk7Ozs7O0FDeEJOLFNBQVMwbUIsZ0JBQVQsQ0FBMEI3ekIsS0FBMUIsRUFBd0M7OztNQUM3Q29iLEtBRDZDLEdBQ09wYixLQURQLENBQzdDb2IsS0FENkM7TUFDdENqQyxRQURzQyxHQUNPblosS0FEUCxDQUN0Q21aLFFBRHNDO01BQzVCMmEsaUJBRDRCLEdBQ085ekIsS0FEUCxDQUM1Qjh6QixpQkFENEI7b0JBQ085ekIsS0FEUCxDQUNUQyxJQURTO01BQ1RBLElBRFMsK0JBQ0YsSUFERTs7U0FHbkRtTTs7O2lCQUNhbUYsV0FBV3BTLFNBQU8wMEIsZ0JBQWxCLGlEQUNSMTBCLFNBQU82WSxFQURDLEVBQ0kvWCxTQUFTLElBRGIsK0JBRVJkLFNBQU84WSxFQUZDLEVBRUloWSxTQUFTLElBRmIsZ0JBRGI7WUFLTzs7VUFFRUgsR0FBTixDQUFVLFVBQUNtYixJQUFELEVBQU9vQixDQUFQLEVBQWE7OztVQUNoQjBYLGFBQWExWCxNQUFNeVgsaUJBQXpCO1VBQ014aUIsS0FBS0MsV0FBV3BTLFNBQU84YixJQUFsQixtREFDUjliLFNBQU82MEIsaUJBREMsRUFDbUIsQ0FBQ0QsVUFEcEIsZ0NBRVI1MEIsU0FBTzgwQixjQUZDLEVBRWdCRixVQUZoQixpQkFBWDthQUtFM25COzs7MkJBQ2lCMm5CLFVBRGpCO3FCQUVhemlCLEVBRmI7ZUFHTytLLENBSFA7bUJBSVc7bUJBQUtsRCxTQUFTLEVBQUVkLE9BQU82YixDQUFULEVBQVlDLGFBQWE5WCxDQUF6QixFQUFULENBQUw7V0FKWDtnQkFLTyxLQUxQO2dCQU1POztlQUVHcEIsSUFBUCxLQUFnQixRQUFoQixHQUNDN087Y0FBQTs7c0JBQUE7bUJBRVMybkIsYUFBYSxVQUFiLEdBQTBCLE1BRm5DO21CQUdRLFFBSFI7a0JBSVE5ekI7OztTQUxULEdBVUNtTTthQUFBO1lBQUssU0FBUSxNQUFiLEVBQW9CLGdCQUFlLFFBQW5DOzs7T0FuQk47S0FORDtHQVJMOzs7QUE0Q0Z5bkIsaUJBQWlCbG5CLFNBQWpCLEdBQTZCO1NBQ3BCSixVQUFVbVAsT0FBVixDQUFrQm5QLFVBQVVLLElBQTVCLEVBQWtDaUYsVUFEZDtZQUVqQnRGLFVBQVU0RyxJQUFWLENBQWV0QixVQUZFO3FCQUdSdEYsVUFBVVUsTUFBVixDQUFpQjRFO0NBSHRDOzs7O0lDOUJxQnVpQjs7Ozs7Ozs7Ozs7Ozs7NkxBd0JuQmpnQixRQUFRO2VBQ0csS0FESDttQkFFTzthQWNma2dCLGlCQUFpQixVQUFDaGMsS0FBRCxFQUFrQztVQUUvQ0EsTUFBTWEsTUFBTixZQUF3Qm9iLGlCQUF4QixJQUNBLE1BQUt0MEIsS0FBTCxDQUFXK0QsS0FBWCxLQUFxQnNVLE1BQU1hLE1BQU4sQ0FBYW5WLEtBRnBDLEVBR0U7Y0FDSy9ELEtBQUwsQ0FBV21aLFFBQVgsQ0FBb0IsRUFBRWQsWUFBRixFQUFTdFUsT0FBT3NVLE1BQU1hLE1BQU4sQ0FBYW5WLEtBQTdCLEVBQXBCOztZQUVJLE1BQUsvRCxLQUFMLENBQVd1MEIsWUFBZixFQUE2QjtnQkFDdEJsZ0IsUUFBTCxDQUFjLEVBQUVtZ0IsYUFBYSxLQUFmLEVBQWQ7OzthQUtObGIsYUFBYSxZQUFNO1VBQ2IsTUFBS3RaLEtBQUwsQ0FBV3UwQixZQUFmLEVBQTZCO2NBQ3RCbGdCLFFBQUwsQ0FBYyxFQUFFbWdCLGFBQWEsS0FBZixFQUFkOzthQUlKaGIsY0FBYyxZQUFNO1VBQ2QsTUFBS3haLEtBQUwsQ0FBV3UwQixZQUFmLEVBQTZCO2NBQ3RCbGdCLFFBQUwsQ0FBYyxFQUFFbWdCLGFBQWEsSUFBZixFQUFkOzs7Ozs7OzZCQU1LOzs7bUJBVUgsS0FBS3gwQixLQVZGO1VBRUx3WCxRQUZLLFVBRUxBLFFBRks7VUFHTCtjLFlBSEssVUFHTEEsWUFISztVQUlMemEsRUFKSyxVQUlMQSxFQUpLO1VBS0wyYSxtQkFMSyxVQUtMQSxtQkFMSztVQU1MbnpCLElBTkssVUFNTEEsSUFOSztVQU9Mb3pCLE9BUEssVUFPTEEsT0FQSztVQVFMaEIsV0FSSyxVQVFMQSxXQVJLO1VBU0wzdkIsS0FUSyxVQVNMQSxLQVRLOzs7VUFZRDhULFVBQVV0RyxXQUNkcFMsU0FBT3cxQixNQURPLEVBRWRuZCxXQUFXclksU0FBT3FZLFFBQWxCLEdBQTZCclksU0FBT2daLE9BRnRCLEVBR2RvYyxlQUFlcDFCLFNBQU95MUIsT0FBdEIsR0FBZ0N6MUIsU0FBTzAxQixNQUh6QixDQUFoQjs7YUFPRXpvQjtXQUFBOztpQkFDU29MLFdBQVcsV0FBWCxHQUF5QixPQURsQztxQ0FFNkIsRUFBRXJNLFNBQVMsRUFBRTJwQixjQUFjLENBQWhCLEVBQVgsRUFGN0I7bUJBR1UsTUFIVjtvQkFJVyxVQUpYO2lCQUtROzs7YUFFTjs7d0JBQ2EsUUFEYjt3QkFBQTt1Q0FHNkI7dUJBQ2hCLEVBQUVqRCxjQUFjLEVBQWhCLEVBQW9Ca0QsWUFBWSxDQUFoQzthQUpiO3FCQU1VLE1BTlY7c0JBT1csVUFQWDt1QkFBQTs7O3dCQVdHLElBQUQ7a0JBQ08sWUFEUDtrQkFFUSxFQUZSO21CQUdTdmQsV0FBVyxNQUFYLEdBQW9CLFVBSDdCO2dDQUlxQjs7U0F0QnpCOzs7O2dDQTJCTStjLGdCQUFnQixLQUFLcGdCLEtBQUwsQ0FBV29GLE9BQTNCLEdBQXdDTyxFQUF4QyxzQkFBNkQsSUFGakU7NEJBSWdCeWEsZUFBZSxNQUFmLEdBQXdCLE9BSnhDO3VCQUthMWMsT0FMYjtzQkFNWUwsUUFOWjtnQkFPTXNDLEVBUE47a0JBUVF4WSxJQVJSO29CQVNVLEtBQUtnWSxVQVRmO3FCQVVXLEtBQUtFLFdBVmhCO3NCQVdZLEtBQUs2YSxjQVhqQjtpQkFZTyxnQkFBSztxQkFDSE0sTUFBTCxHQUFjdHdCLENBQWQ7YUFiSjttQkFlU047O3lCQUdMLENBQUNBLEtBREYsSUFFR3FJOztjQUFRLGNBQVIsRUFBaUIsY0FBakIsRUFBMEIsV0FBMUIsRUFBZ0MsWUFBaEM7O1dBbkJOO2tCQXVCV3RNLEdBQVIsQ0FBWTttQkFDWHNNOztnQkFBUSxLQUFLNG9CLE9BQU9qeEIsS0FBcEIsRUFBMkIsT0FBT2l4QixPQUFPanhCLEtBQXpDO3FCQUNVMGlCO2FBRkM7V0FBWjtTQWhETDt3QkF1REksS0FBS3RTLEtBQUwsQ0FBV3FnQixXQURaLElBRUdwb0I7Z0JBQUE7O29CQUNVLEtBQUt1b0IsTUFEZjttQkFFUSxRQUZSOzRCQUdrQkYsbUJBSGxCO3VCQUlhO3FCQUFNLE9BQUtwZ0IsUUFBTCxDQUFjLEVBQUVtZ0IsYUFBYSxLQUFmLEVBQWQsQ0FBTjthQUpiO3lCQUtlLEtBTGY7a0JBTU87OztlQUVMO2NBQUssU0FBUyxDQUFkOztrQkFDRTtnQkFBTSxVQUFOLEVBQVcsT0FBTSxPQUFqQjs7O2tCQUNRLElBQU8xYSxFQUFQLG1CQUFOOzs7Ozs7T0FuRWQ7Ozs7NkNBeEQ4QjlaLE9BQWNtVSxPQUFjO1VBQ3REblUsTUFBTXUwQixZQUFOLEtBQXVCcGdCLE1BQU1vZ0IsWUFBakMsRUFBK0M7ZUFDdEM7dUJBQ1EsQ0FBQyxDQUFDdjBCLE1BQU11MEIsWUFEaEI7d0JBRVN2MEIsTUFBTXUwQjtTQUZ0Qjs7O2FBTUssSUFBUDs7OztFQXJDb0Mxb0I7O0FBQW5CdW9CLFdBQ1p6bkIsWUFBWTtZQUNQSixVQUFVUyxJQURIO2dCQUVIVCxVQUFVWSxNQUZQO01BR2JaLFVBQVVZLE1BQVYsQ0FBaUIwRSxVQUhKO3VCQUlJdEYsVUFBVVksTUFKZDtRQUtYWixVQUFVWSxNQUxDO1lBTVBaLFVBQVU0RyxJQUFWLENBQWV0QixVQU5SO1dBT1J0RixVQUFVbVAsT0FBVixDQUNQblAsVUFBVU0sS0FBVixDQUFnQjtXQUNQTixVQUFVWSxNQUFWLENBQWlCMEUsVUFEVjtXQUVQdEYsVUFBVVksTUFBVixDQUFpQjBFO0dBRjFCLENBRE8sQ0FQUTtlQWFKdEYsVUFBVVksTUFiTjtTQWNWWixVQUFVWTs7QUFmQWluQixXQWtCWmhoQixlQUFlO1lBQ1YsS0FEVTt1QkFFQyxPQUZEO1dBR1g7Ozs7O0FDN0NiLElBQU02aEIsT0FBTyxFQUFiOztBQU9BLEFBQWUsU0FBU0MsT0FBVCxPQUFzRDtNQUFuQ2prQixrQkFBbUMsUUFBbkNBLGtCQUFtQztNQUFma2tCLElBQWUsUUFBZkEsSUFBZTs7U0FDNURBLE9BQ0wvb0I7T0FBQTtNQUFLLElBQUksRUFBRXRJLFNBQVMsTUFBWCxFQUFULEVBQThCLGdCQUFlLFFBQTdDLEVBQXNELFVBQVMsUUFBL0Q7OztRQUNPLFdBQVczRSxTQUFPZ1MsSUFBdkI7b0JBQ0csSUFBRDtjQUNPLE9BRFA7NEJBRXNCRixrQkFGdEI7Y0FHUWdrQjs7O0dBTlAsR0FXTDdvQiwwQkFYRjs7O0FBZUY4b0IsUUFBUXZvQixTQUFSLEdBQW9CO1FBQ1pKLFVBQVVTLElBQVYsQ0FBZTZFLFVBREg7c0JBRUV0RixVQUFVWSxNQUFWLENBQWlCMEU7Q0FGdkM7O0FDSmUsU0FBU3VqQixNQUFULENBQWdCcDFCLEtBQWhCLEVBQThCOzhCQUNrQkEsS0FEbEIsQ0FDbkNxMUIsb0JBRG1DO01BQ25DQSxvQkFEbUMseUNBQ1osRUFBRUMsVUFBVSxDQUFaLEVBRFk7TUFDS3ZwQixRQURMLEdBQ2tCL0wsS0FEbEIsQ0FDSytMLFFBREw7O01BRXJDeEwsUUFBUTtTQUNQUCxNQUFNb0osR0FBTixJQUFhLElBQWIsR0FBb0JwSixNQUFNb0osR0FBMUIsR0FBZ0N1SSxTQUR6QjtVQUVOM1IsTUFBTXNKLElBQU4sSUFBYyxJQUFkLEdBQXFCdEosTUFBTXNKLElBQTNCLEdBQWtDcUksU0FGNUI7V0FHTDNSLE1BQU13SixLQUFOLElBQWUsSUFBZixHQUFzQnhKLE1BQU13SixLQUE1QixHQUFvQ21JLFNBSC9CO1lBSUozUixNQUFNcUosTUFBTixJQUFnQixJQUFoQixHQUF1QnJKLE1BQU1xSixNQUE3QixHQUFzQ3NJLFNBSmxDOztZQU1KMGpCLHFCQUFxQkM7R0FOL0I7U0FTRWxwQjs7TUFBSyxXQUFXbEcsT0FBT3F2QixNQUF2QixFQUErQixPQUFPaDFCLEtBQXRDOztHQURGOzs7QUFPRjYwQixPQUFPem9CLFNBQVAsR0FBbUI7WUFDUEosVUFBVUssSUFESDt3QkFFS0wsVUFBVU0sS0FBVixDQUFnQjtjQUMxQk4sVUFBVVU7R0FEQSxDQUZMO09BS1pWLFVBQVVRLFNBQVYsQ0FBb0IsQ0FBQ1IsVUFBVVUsTUFBWCxFQUFtQlYsVUFBVVksTUFBN0IsQ0FBcEIsQ0FMWTtRQU1YWixVQUFVUSxTQUFWLENBQW9CLENBQUNSLFVBQVVVLE1BQVgsRUFBbUJWLFVBQVVZLE1BQTdCLENBQXBCLENBTlc7VUFPVFosVUFBVVEsU0FBVixDQUFvQixDQUFDUixVQUFVVSxNQUFYLEVBQW1CVixVQUFVWSxNQUE3QixDQUFwQixDQVBTO1NBUVZaLFVBQVVRLFNBQVYsQ0FBb0IsQ0FBQ1IsVUFBVVUsTUFBWCxFQUFtQlYsVUFBVVksTUFBN0IsQ0FBcEI7Q0FSVDs7OztJQ3pCcUJxb0I7Ozs7Ozs7Ozs7Ozs7O3FMQWNuQnJoQixRQUFlO2VBQ0o7YUFHWG1GLGFBQWE7YUFBTSxNQUFLakYsUUFBTCxDQUFjLEVBQUVrRixTQUFTLEtBQVgsRUFBZCxDQUFOO2FBRWJQLGVBQWUsVUFBQ1gsS0FBRCxFQUFrQztVQUN2Q1ksT0FEdUMsR0FDM0JaLE1BQU1hLE1BRHFCLENBQ3ZDRCxPQUR1Qzs7WUFFMUNqWixLQUFMLENBQVdtWixRQUFYLENBQW9CO29CQUFBO2VBRVhGO09BRlQ7YUFNRk8sY0FBYyxZQUFNO1lBQ2JuRixRQUFMLENBQWMsRUFBRWtGLFNBQVMsSUFBWCxFQUFkOzs7Ozs7NkJBR087bUJBQ2tDLEtBQUt2WixLQUR2QztVQUNDd1gsUUFERCxVQUNDQSxRQUREO1VBQ1dzQyxFQURYLFVBQ1dBLEVBRFg7VUFDZXhZLElBRGYsVUFDZUEsSUFEZjtVQUNxQm0wQixRQURyQixVQUNxQkEsUUFEckI7OztVQUdEQyxlQUFlbmtCLFdBQ25CcFMsU0FBT3cyQixNQURZLHFCQUdoQngyQixTQUFPb2EsT0FIUyxFQUdDLEtBQUtwRixLQUFMLENBQVdvRixPQUhaOztpQkFPZmtjLFdBQ0V0MkIsU0FBT3kyQixVQURULEdBRUV6MkIsU0FBTzAyQixlQUhiLEdBSUlKLFdBQ0V0MkIsU0FBTzIyQixjQURULEdBRUUzMkIsU0FBTzQyQixXQVpNLENBQXJCOztVQWVNQyxlQUFlemtCLFdBQ25CcFMsU0FBTzgyQixNQURZLEVBRW5CUixXQUFXdDJCLFNBQU8rMkIsV0FBbEIsR0FBZ0MvMkIsU0FBT2czQixVQUZwQixFQUduQlYsWUFBWSxDQUFDamUsUUFBYixHQUF3QnJZLFNBQU9pM0IsVUFBL0IsR0FBNENqM0IsU0FBT2szQixXQUhoQyxDQUFyQjs7VUFNTUMsY0FBYy9rQixXQUFXcFMsU0FBT28zQixRQUFsQixxQkFDakJwM0IsU0FBT3EzQixlQURVLEVBQ1EsQ0FBQ2hmLFFBRFQsRUFBcEI7O2FBS0VwTDs7VUFBSyxXQUFXc3BCLFlBQWhCOzttQkFFYUQsUUFEWDtxQkFFYWEsV0FGYjtvQkFHWTllLFFBSFo7Y0FJTXNDLEVBSk47Z0JBS1F4WSxJQUxSO2tCQU1VLEtBQUtnWSxVQU5mO29CQU9ZLEtBQUtOLFlBUGpCO21CQVFXLEtBQUtRLFdBUmhCO2dCQVNPO1VBVlQ7K0JBWU8sV0FBV3djLFlBQWhCO09BYko7Ozs7RUE1RGdDbnFCOztBQUFmMnBCLE9BQ1o3b0IsWUFBWTtZQUNQSixVQUFVUyxJQURIO01BRWJULFVBQVVZLE1BQVYsQ0FBaUIwRSxVQUZKO1FBR1h0RixVQUFVWSxNQUhDO1lBSVBaLFVBQVU0RyxJQUFWLENBQWV0QixVQUpSO1lBS1B0RixVQUFVUzs7QUFOSHdvQixPQVNacGlCLGVBQWU7WUFDVixLQURVO1lBRVY7Ozs7O0lDSE9xakI7Ozs7Ozs7Ozs7Ozs7O2lMQWFuQnRpQixRQUFlO3VCQUNJeEMsU0FESjt1QkFFSUE7YUFHbkIra0IsaUJBQWlCLFVBQUNyYSxDQUFELEVBQVk2WCxDQUFaLEVBQXlDO1VBQ2hEL2EsUUFEZ0QsR0FDbkMsTUFBS25aLEtBRDhCLENBQ2hEbVosUUFEZ0Q7O2VBRS9DLEVBQUV3ZCxnQkFBZ0J0YSxDQUFsQixFQUFxQmhFLE9BQU82YixDQUE1QixFQUFUO2FBR0YwQyxpQkFBaUIsVUFBQ3ZhLENBQUQ7YUFBZSxNQUFLaEksUUFBTCxDQUFjLEVBQUV3aUIsaUJBQWlCeGEsQ0FBbkIsRUFBZCxDQUFmO2FBRWpCeWEsZ0JBQWdCO2FBQU0sTUFBS3ppQixRQUFMLENBQWMsRUFBRXdpQixpQkFBaUJsbEIsU0FBbkIsRUFBZCxDQUFOO2FBRWhCb2xCLHNCQUFzQixVQUFDMWEsQ0FBRDthQUFlLE1BQUtoSSxRQUFMLENBQWMsRUFBRTJpQixpQkFBaUIzYSxDQUFuQixFQUFkLENBQWY7YUFFdEI0YSxzQkFBc0I7YUFBTSxNQUFLNWlCLFFBQUwsQ0FBYyxFQUFFMmlCLGlCQUFpQnJsQixTQUFuQixFQUFkLENBQU47Ozs7Ozs2QkFFYjs7O21CQUNnQyxLQUFLM1IsS0FEckM7VUFDQ2szQixJQURELFVBQ0NBLElBREQ7VUFDT1AsY0FEUCxVQUNPQSxjQURQO1VBQ3VCUSxJQUR2QixVQUN1QkEsSUFEdkI7bUJBRXNDLEtBQUtoakIsS0FGM0M7VUFFQzBpQixlQUZELFVBRUNBLGVBRkQ7VUFFa0JHLGVBRmxCLFVBRWtCQSxlQUZsQjs7YUFJTDVxQjs7O3FCQUNhbUYsV0FBV3BTLFNBQU9zM0IsSUFBbEIsRUFBd0JVLFFBQVFqeEIsT0FBT2dGLFFBQXZDLENBRGI7Z0JBRU87O2FBRUNwTCxHQUFMLENBQVMsaUJBQWlCdWMsQ0FBakIsRUFBdUI7OztjQUFwQjNFLElBQW9CLFNBQXBCQSxJQUFvQjtjQUFkZ1EsSUFBYyxTQUFkQSxJQUFjOztjQUN6QjBQLFdBQVcvYSxNQUFNc2EsY0FBdkI7Y0FDTVUsWUFBWWhiLE1BQU0yYSxlQUF4QjtjQUNNTSxZQUFZamIsTUFBTXdhLGVBQXhCO2NBQ012bEIsS0FBS0MsV0FBV3BTLFNBQU9vNEIsR0FBbEIsaURBQ1JwNEIsU0FBT3E0QixjQURDLEVBQ2dCLENBQUNKLFFBRGpCLCtCQUVSajRCLFNBQU9zNEIsV0FGQyxFQUVhTCxRQUZiLGdCQUFYO2lCQUtFaHJCOzs7K0JBQ2lCZ3JCLFFBRGpCO3lCQUVhOWxCLEVBRmI7b0JBR1FvVyxJQUhSO3dCQUlVckwsQ0FBUixHQUFZcUwsSUFKZDt1QkFLVyxpQkFBQ3dNLENBQUQ7dUJBQThCLE9BQUt3QyxjQUFMLENBQW9CcmEsQ0FBcEIsRUFBdUI2WCxDQUF2QixDQUE5QjtlQUxYO3VCQU1XO3VCQUFNLE9BQUswQyxjQUFMLENBQW9CdmEsQ0FBcEIsQ0FBTjtlQU5YO3NCQU9VLE9BQUt5YSxhQVBmOzRCQVFnQjt1QkFBTSxPQUFLQyxtQkFBTCxDQUF5QjFhLENBQXpCLENBQU47ZUFSaEI7NEJBU2dCLE9BQUs0YSxtQkFUckI7b0JBVU87OztrQkFFTDs7MEJBQUE7dUJBRVNHLFlBQVlDLFNBQVosSUFBeUJDLFNBQXpCLEdBQXFDLFVBQXJDLEdBQWtELE1BRjNEO3NCQUdPOzs7O1dBaEJYO1NBUkQ7T0FMTDs7OztFQWxDOEJ6ckI7O0FBQWI0cUIsS0FDWjlwQixZQUFZO2tCQUNESixVQUFVVSxNQUFWLENBQWlCNEUsVUFEaEI7UUFFWHRGLFVBQVVtUCxPQUFWLENBQ0puUCxVQUFVTSxLQUFWLENBQWdCO1VBQ1JOLFVBQVVLLElBREY7VUFFUkwsVUFBVVk7R0FGbEIsQ0FESSxFQUtKMEUsVUFQZTtZQVFQdEYsVUFBVTRHLElBQVYsQ0FBZXRCLFVBUlI7UUFTWHRGLFVBQVVTOzs7OztJQ1FDMHFCOzs7Ozs7Ozs7Ozs7Ozt5TEF3Qm5CdmpCLFFBQVE7ZUFDRyxLQURIO21CQUVPO2FBY2Y2RSxlQUFlLFVBQUNYLEtBQUQsRUFBcUQ7WUFDN0RyWSxLQUFMLENBQVdtWixRQUFYLENBQW9CO29CQUFBO2VBRVhkLE1BQU1nQixhQUFOLENBQW9CdFY7T0FGN0I7O1VBS0ksTUFBSy9ELEtBQUwsQ0FBV3UwQixZQUFmLEVBQTZCO2NBQ3RCbGdCLFFBQUwsQ0FBYyxFQUFFbWdCLGFBQWEsSUFBZixFQUFkOzthQUlKbGIsYUFBYSxVQUFDakIsS0FBRCxFQUFxRDtVQUM1RCxNQUFLclksS0FBTCxDQUFXdTBCLFlBQWYsRUFBNkI7Y0FDdEJsZ0IsUUFBTCxDQUFjLEVBQUVtZ0IsYUFBYSxLQUFmLEVBQWQ7O1VBRUUsTUFBS3gwQixLQUFMLENBQVd3ekIsTUFBZixFQUF1QjtjQUNoQnh6QixLQUFMLENBQVd3ekIsTUFBWCxDQUFrQjtzQkFBQTtpQkFFVG5iLE1BQU1nQixhQUFOLENBQW9CdFY7U0FGN0I7O2FBT0p5VixjQUFjLFVBQUNuQixLQUFELEVBQXFEO1VBQzdELE1BQUtyWSxLQUFMLENBQVd1MEIsWUFBZixFQUE2QjtjQUN0QmxnQixRQUFMLENBQWMsRUFBRW1nQixhQUFhLElBQWYsRUFBZDs7VUFFRSxNQUFLeDBCLEtBQUwsQ0FBV3V6QixPQUFmLEVBQXdCO2NBQ2pCdnpCLEtBQUwsQ0FBV3V6QixPQUFYLENBQW1CO3NCQUFBO2lCQUVWbGIsTUFBTWdCLGFBQU4sQ0FBb0J0VjtTQUY3Qjs7YUFPSjRmLGdCQUFnQixVQUFDdEwsS0FBRCxFQUF3RDtVQUNsRSxNQUFLclksS0FBTCxDQUFXd2lCLFNBQWYsRUFBMEI7Y0FDbkJ4aUIsS0FBTCxDQUFXd2lCLFNBQVgsQ0FBcUI7c0JBQUE7aUJBRVpuSyxNQUFNZ0IsYUFBTixDQUFvQnRWO1NBRjdCOzs7Ozs7OzZCQVNLOzs7bUJBV0gsS0FBSy9ELEtBWEY7VUFFTHdYLFFBRkssVUFFTEEsUUFGSztVQUdMK2MsWUFISyxVQUdMQSxZQUhLO1VBSUwxYSxRQUpLLFVBSUxBLFFBSks7VUFLTEMsRUFMSyxVQUtMQSxFQUxLO1VBTUwyYSxtQkFOSyxVQU1MQSxtQkFOSztVQU9MbnpCLElBUEssVUFPTEEsSUFQSztVQVFMb3lCLFdBUkssVUFRTEEsV0FSSztVQVNMaUUsSUFUSyxVQVNMQSxJQVRLO1VBVUw1ekIsS0FWSyxVQVVMQSxLQVZLOzs7VUFhRDhULFVBQVV0RyxXQUNkcFMsU0FBT3k0QixRQURPLEVBRWRwZ0IsV0FBV3JZLFNBQU9xWSxRQUFsQixHQUE2QnJZLFNBQU9nWixPQUZ0QixFQUdkMEIsWUFBWTBhLFlBQVosR0FBMkJwMUIsU0FBT3kxQixPQUFsQyxHQUE0Q3oxQixTQUFPMDFCLE1BSHJDLENBQWhCOzthQU9Fem9COzs7OzhCQUdNbW9CLGdCQUFnQixLQUFLcGdCLEtBQUwsQ0FBV29GLE9BQTNCLEdBQXdDTyxFQUF4QyxzQkFBNkQsSUFGakU7MEJBSWdCeWEsZ0JBQWdCMWEsUUFBaEIsR0FBMkIsTUFBM0IsR0FBb0MsT0FKcEQ7cUJBS2FoQyxPQUxiO29CQU1ZTCxRQU5aO2NBT01zQyxFQVBOO2dCQVFReFksSUFSUjtrQkFTVSxLQUFLZ1ksVUFUZjtvQkFVWSxLQUFLTixZQVZqQjttQkFXVyxLQUFLUSxXQVhoQjtxQkFZYSxLQUFLbUssYUFabEI7dUJBYWUrUCxXQWJmO2VBY08sZ0JBQUs7bUJBQ0htRSxRQUFMLEdBQWdCeHpCLENBQWhCO1dBZko7Z0JBaUJRc3pCLElBakJSO2lCQWtCUzV6QjtVQW5CWDt3QkFxQm1CLEtBQUtvUSxLQUFMLENBQVdxZ0IsV0FBM0IsR0FDQ3BvQjtnQkFBQTs7b0JBQ1UsS0FBS3lyQixRQURmO21CQUVRLFFBRlI7NEJBR2tCcEQsbUJBSGxCO3VCQUlhO3FCQUFNLE9BQUtwZ0IsUUFBTCxDQUFjLEVBQUVtZ0IsYUFBYSxLQUFmLEVBQWQsQ0FBTjthQUpiO3lCQUtlLEtBTGY7a0JBTU87OztlQUVMO2NBQUssU0FBUyxDQUFkOztrQkFDRTtnQkFBTSxVQUFOLEVBQVcsT0FBTSxPQUFqQjs7O2tCQUNRLElBQU8xYSxFQUFQLG1CQUFOOzs7OztTQVhQLEdBZUc7T0FyQ1I7Ozs7NkNBNUU4QjlaLE9BQWNtVSxPQUFjO1VBQ3REblUsTUFBTXUwQixZQUFOLEtBQXVCcGdCLE1BQU1vZ0IsWUFBakMsRUFBK0M7ZUFDdEM7dUJBQ1EsQ0FBQyxDQUFDdjBCLE1BQU11MEIsWUFEaEI7d0JBRVN2MEIsTUFBTXUwQjtTQUZ0Qjs7O2FBTUssSUFBUDs7OztFQXJDa0Mxb0I7O0FBQWpCNnJCLFNBQ1ovcUIsWUFBWTtZQUNQSixVQUFVUyxJQURIO2dCQUVIVCxVQUFVWSxNQUZQO1lBR1BaLFVBQVVTLElBSEg7TUFJYlQsVUFBVVksTUFBVixDQUFpQjBFLFVBSko7dUJBS0l0RixVQUFVWSxNQUxkO1FBTVhaLFVBQVVZLE1BTkM7VUFPVFosVUFBVTRHLElBUEQ7WUFRUDVHLFVBQVU0RyxJQUFWLENBQWV0QixVQVJSO1dBU1J0RixVQUFVNEcsSUFURjthQVVONUcsVUFBVTRHLElBVko7ZUFXSjVHLFVBQVVZLE1BWE47UUFZWFosVUFBVVUsTUFaQztTQWFWVixVQUFVWTs7QUFkQXVxQixTQWlCWnRrQixlQUFlO1lBQ1YsS0FEVTtZQUVWLEtBRlU7dUJBR0MsT0FIRDtRQUlkOzs7OztJQ3BCVzBrQjs7Ozs7Ozs7Ozs7Ozs7MkxBcUNuQjNqQixRQUFRO2VBQ0csS0FESDttQkFFTzthQWNmNkUsZUFBZSxVQUFDWCxLQUFELEVBQWtEO1lBQzFEclksS0FBTCxDQUFXbVosUUFBWCxDQUFvQjtvQkFBQTtlQUVYZCxNQUFNZ0IsYUFBTixDQUFvQnRWO09BRjdCO2FBTUZ1VixhQUFhLFVBQUNqQixLQUFELEVBQWtEO1VBQ3pELE1BQUtyWSxLQUFMLENBQVd1MEIsWUFBZixFQUE2QjtjQUN0QmxnQixRQUFMLENBQWMsRUFBRW1nQixhQUFhLEtBQWYsRUFBZDs7VUFFRSxNQUFLeDBCLEtBQUwsQ0FBV3d6QixNQUFmLEVBQXVCO2NBQ2hCeHpCLEtBQUwsQ0FBV3d6QixNQUFYLENBQWtCO3NCQUFBO2lCQUVUbmIsTUFBTWdCLGFBQU4sQ0FBb0J0VjtTQUY3Qjs7YUFPSnlWLGNBQWMsVUFBQ25CLEtBQUQsRUFBa0Q7VUFDMUQsTUFBS3JZLEtBQUwsQ0FBV3UwQixZQUFmLEVBQTZCO2NBQ3RCbGdCLFFBQUwsQ0FBYyxFQUFFbWdCLGFBQWEsSUFBZixFQUFkOztVQUVFLE1BQUt4MEIsS0FBTCxDQUFXdXpCLE9BQWYsRUFBd0I7Y0FDakJ2ekIsS0FBTCxDQUFXdXpCLE9BQVgsQ0FBbUI7c0JBQUE7aUJBRVZsYixNQUFNZ0IsYUFBTixDQUFvQnRWO1NBRjdCOzthQU9KNGYsZ0JBQWdCLFVBQUN0TCxLQUFELEVBQXFEO1VBQy9ELE1BQUtyWSxLQUFMLENBQVd3aUIsU0FBZixFQUEwQjtjQUNuQnhpQixLQUFMLENBQVd3aUIsU0FBWCxDQUFxQjtzQkFBQTtpQkFFWm5LLE1BQU1nQixhQUFOLENBQW9CdFY7U0FGN0I7Ozs7Ozs7NkJBU0s7OzttQkFZSCxLQUFLL0QsS0FaRjtVQUVMeXpCLFlBRkssVUFFTEEsWUFGSztVQUdMamMsUUFISyxVQUdMQSxRQUhLO1VBSUwrYyxZQUpLLFVBSUxBLFlBSks7VUFLTDFhLFFBTEssVUFLTEEsUUFMSztVQU1MQyxFQU5LLFVBTUxBLEVBTks7VUFPTDJhLG1CQVBLLFVBT0xBLG1CQVBLO1VBUUxuekIsSUFSSyxVQVFMQSxJQVJLO1VBU0xveUIsV0FUSyxVQVNMQSxXQVRLO1VBVUwvYixJQVZLLFVBVUxBLElBVks7VUFXTDVULEtBWEssVUFXTEEsS0FYSzs7O1VBY0Q4VCxVQUFVdEcsV0FDZHBTLFNBQU80NEIsU0FETyxFQUVkdmdCLFdBQVdyWSxTQUFPcVksUUFBbEIsR0FBNkJyWSxTQUFPZ1osT0FGdEIsRUFHZDBCLFlBQVkwYSxZQUFaLEdBQTJCcDFCLFNBQU95MUIsT0FBbEMsR0FBNEN6MUIsU0FBTzAxQixNQUhyQyxDQUFoQjs7OztVQVFNbUQsVUFBVXJnQixTQUFTLFFBQVQsR0FBb0IsTUFBcEIsR0FBNkJoRyxTQUE3Qzs7YUFHRXZGOzs7OzhCQUdNbW9CLGdCQUFnQixLQUFLcGdCLEtBQUwsQ0FBV29GLE9BQTNCLEdBQXdDTyxFQUF4QyxzQkFBNkQsSUFGakU7MEJBSWdCeWEsZ0JBQWdCMWEsUUFBaEIsR0FBMkIsTUFBM0IsR0FBb0MsT0FKcEQ7d0JBS2dCNFosWUFMaEI7cUJBTWE1YixPQU5iO29CQU9ZTCxRQVBaO2NBUU1zQyxFQVJOO2dCQVNReFksSUFUUjtrQkFVVSxLQUFLZ1ksVUFWZjtvQkFXWSxLQUFLTixZQVhqQjttQkFZVyxLQUFLUSxXQVpoQjtxQkFhYSxLQUFLbUssYUFibEI7bUJBY1dxVSxPQWRYO3VCQWVldEUsV0FmZjtlQWdCTyxnQkFBSzttQkFDSHVFLFNBQUwsR0FBaUI1ekIsQ0FBakI7V0FqQko7Z0JBbUJRc1QsSUFuQlI7aUJBb0JTNVQ7VUFyQlg7d0JBd0JJLEtBQUtvUSxLQUFMLENBQVdxZ0IsV0FEWixJQUVHcG9CO2dCQUFBOztvQkFDVSxLQUFLNnJCLFNBRGY7bUJBRVEsUUFGUjs0QkFHa0J4RCxtQkFIbEI7dUJBSWE7cUJBQU0sT0FBS3BnQixRQUFMLENBQWMsRUFBRW1nQixhQUFhLEtBQWYsRUFBZCxDQUFOO2FBSmI7eUJBS2UsS0FMZjtrQkFNTzs7O2VBRUw7Y0FBSyxTQUFTLENBQWQ7O2tCQUNFO2dCQUFNLFVBQU4sRUFBVyxPQUFNLE9BQWpCOzs7a0JBQ1EsSUFBTzFhLEVBQVAsbUJBQU47Ozs7OztPQXBDZDs7Ozs2Q0E3RThCOVosT0FBY21VLE9BQWM7VUFDdERuVSxNQUFNdTBCLFlBQU4sS0FBdUJwZ0IsTUFBTW9nQixZQUFqQyxFQUErQztlQUN0Qzt1QkFDUSxDQUFDLENBQUN2MEIsTUFBTXUwQixZQURoQjt3QkFFU3YwQixNQUFNdTBCO1NBRnRCOzs7YUFNSyxJQUFQOzs7O0VBbERtQzFvQjs7QUFBbEJpc0IsVUFDWm5yQixZQUFZO2dCQUNISixVQUFVQyxLQUFWLENBQWdCLENBQzVCLGtCQUQ0QixFQUU1QixJQUY0QixFQUc1QixLQUg0QixFQUk1QixVQUo0QixDQUFoQixDQURHO1lBT1BELFVBQVVTLElBUEg7Z0JBUUhULFVBQVVZLE1BUlA7WUFTUFosVUFBVVMsSUFUSDtNQVViVCxVQUFVWSxNQUFWLENBQWlCMEUsVUFWSjt1QkFXSXRGLFVBQVVZLE1BWGQ7UUFZWFosVUFBVVksTUFaQztVQWFUWixVQUFVNEcsSUFiRDtZQWNQNUcsVUFBVTRHLElBQVYsQ0FBZXRCLFVBZFI7V0FlUnRGLFVBQVU0RyxJQWZGO2FBZ0JONUcsVUFBVTRHLElBaEJKO2VBaUJKNUcsVUFBVVksTUFqQk47UUFrQlhaLFVBQVVDLEtBQVYsQ0FBZ0IsQ0FDcEIsTUFEb0IsRUFFcEIsT0FGb0IsRUFHcEIsUUFIb0IsRUFJcEIsVUFKb0IsRUFLcEIsTUFMb0IsRUFNcEIsS0FOb0IsQ0FBaEIsQ0FsQlc7U0EwQlZELFVBQVVZOztBQTNCQTJxQixVQThCWjFrQixlQUFlO1lBQ1YsS0FEVTtZQUVWLEtBRlU7dUJBR0MsT0FIRDtRQUlkOzs7QUNoRUssU0FBUzhrQixLQUFULENBQWVsNEIsS0FBZixFQUE2QjtxQkFDWUEsS0FEWixDQUNsQ2tSLEtBRGtDO01BQ2xDQSxLQURrQyxnQ0FDMUIsVUFEMEI7TUFDZEMsSUFEYyxHQUNZblIsS0FEWixDQUNkbVIsSUFEYztNQUNSZ25CLFNBRFEsR0FDWW40QixLQURaLENBQ1JtNEIsU0FEUTtNQUNHemdCLElBREgsR0FDWTFYLEtBRFosQ0FDRzBYLElBREg7OztNQUd0Q3dMLGlCQUFKOztNQUVJeEwsZ0JBQWdCOVgsS0FBaEIsSUFBeUI4WCxLQUFLcFgsTUFBTCxHQUFjLENBQTNDLEVBQThDO2VBRTFDOEw7U0FBQTtRQUFLLElBQUksRUFBRXRJLFNBQVMsTUFBWCxFQUFUOztXQUNFO1VBQUssSUFBSSxFQUFFQSxTQUFTLFlBQVgsRUFBVCxFQUFvQyxNQUFLLE1BQXpDLEVBQWdELGdCQUFlLFFBQS9EO29CQUVJc0k7Y0FBQTtZQUFNLE9BQU0sU0FBWixFQUFzQixRQUFRLEVBQTlCLEVBQWtDLE9BQU8sRUFBekM7O1NBREQsR0FJRztPQU5SOztXQVFFOztjQUNNLEVBQUV0SSxTQUFTLFlBQVgsRUFETjswQkFFaUIsUUFGakI7cUNBRzZCLEVBQUVxSCxTQUFTLEVBQUV5bUIsYUFBYSxFQUFmLEVBQVg7OzthQUUzQjs7dUNBQzZCLEVBQUV6bUIsU0FBUyxFQUFFaXRCLFlBQVksUUFBZCxFQUFYOzs7Z0JBRTNCO2NBQU0sT0FBTSxPQUFaLEVBQW9CLE1BQUssSUFBekI7aUJBQ1EsQ0FBTDs7U0FUUDs7Y0FZRTtZQUFNLFVBQU4sRUFBVyxPQUFNLE9BQWpCLEVBQXlCLE1BQUssSUFBOUI7ZUFDUSxDQUFMOzs7S0F0QlQ7R0FERixNQTRCTzs7ZUFHSGhzQjtTQUFBOztZQUNNLEVBQUV0SSxTQUFTLE1BQVgsRUFETjt3QkFFaUIsU0FGakI7b0JBR2E7OztZQUVYO1VBQU0sVUFBTixFQUFXLE9BQU0sT0FBakIsRUFBeUIsTUFBSyxJQUE5Qjs7T0FMRjtjQVNJc0k7V0FBQTtVQUFLLDJCQUEyQixFQUFFakIsU0FBUyxFQUFFeW1CLGFBQWEsRUFBZixFQUFYLEVBQWhDO3NCQUNHLElBQUQsSUFBTSxvQkFBbUIsRUFBekIsRUFBNEIsT0FBTSxPQUFsQyxFQUEwQyxNQUFNemdCLElBQWhELEVBQXNELE1BQU0sRUFBNUQ7O0tBWFI7OztTQW1CQS9FO09BQUE7TUFBSyxjQUFjLENBQW5CLEVBQXNCLFVBQVUsQ0FBaEMsRUFBbUMsVUFBVSxHQUE3QyxFQUFrRCxPQUFNLE9BQXhEOztTQUNFO1FBQUssT0FBTzhFLEtBQVosRUFBbUIsU0FBbkIsRUFBdUIsVUFBVSxDQUFqQyxFQUFvQyxVQUFVLENBQTlDLEVBQWlELE9BQU0sTUFBdkQ7OztHQUZKOzs7QUFTRmduQixNQUFNdnJCLFNBQU4sR0FBa0I7U0FDVEosVUFBVUMsS0FBVixDQUFnQixDQUFDLFVBQUQsRUFBYSxRQUFiLENBQWhCLENBRFM7UUFFVkQsVUFBVUMsS0FBVixDQUFnQixDQUFDLHNCQUFELENBQWhCLENBRlU7UUFHVkQsVUFBVVEsU0FBVixDQUFvQixDQUN4QlIsVUFBVVksTUFEYyxFQUV4QlosVUFBVW1QLE9BQVYsQ0FBa0JuUCxVQUFVWSxNQUE1QixDQUZ3QixDQUFwQixFQUdIMEUsVUFOYTthQU9MdEYsVUFBVUs7Q0FQdkI7Ozs7QUNwQ0EsSUFBTXlyQixrQkFBa0IsRUFBeEI7QUFDQSxJQUFNQyxrQkFBa0IsRUFBeEI7O0lBRXFCQzs7Ozs7Ozs7Ozs7Ozs7MkxBQ25CQyxpQkFBaUIsVUFBQ25nQixLQUFELEVBQW1EO1VBQzFEb2dCLE9BRDBELEdBQzlDLE1BQUt6NEIsS0FEeUMsQ0FDMUR5NEIsT0FEMEQ7OztVQUloRUEsWUFDQ3BnQixNQUFNcWdCLFFBQU4sS0FBbUJMLGVBQW5CLElBQXNDaGdCLE1BQU1xZ0IsUUFBTixLQUFtQkosZUFEMUQsQ0FERixFQUdFOztjQUVNeEgsY0FBTjtnQkFDUSxFQUFFelksWUFBRixFQUFSOzs7Ozs7OzZCQUlLOzs7bUJBVUgsS0FBS3JZLEtBVkY7VUFFTCtMLFFBRkssVUFFTEEsUUFGSztvQ0FHTDRzQixTQUhLO1VBR0xBLFNBSEssb0NBR08sSUFIUDtVQUlMQyxVQUpLLFVBSUxBLFVBSks7c0NBS0xDLFdBTEs7VUFLTEEsV0FMSyxzQ0FLUyxTQUxUO1VBTUxyZ0IsWUFOSyxVQU1MQSxZQU5LO1VBT0xHLFlBUEssVUFPTEEsWUFQSztVQVFMOGYsT0FSSyxVQVFMQSxPQVJLO2dDQVNMdnJCLEtBVEs7VUFTTEEsS0FUSyxnQ0FTRyxRQVRIOzs7VUFZRDJLLFVBQVV0RyxXQUNkcFMsU0FBTzI1QixTQURPLEVBRWQzNUIsU0FBTzA1QixXQUFQLENBRmMsRUFHZDE1QixTQUFPK04sS0FBUCxDQUhjLGlEQUtYL04sU0FBT3k1QixVQUxJLEVBS1NBLFVBTFQsK0JBTVh6NUIsU0FBT3c1QixTQU5JLEVBTVFBLFNBTlIsZ0JBQWhCOzthQVdFdnNCOzs7cUJBQ2F5TCxPQURiO21CQUVXO21CQUFTNGdCLFdBQVdBLFFBQVEsRUFBRXBnQixZQUFGLEVBQVIsQ0FBcEI7V0FGWDs7Ozs7Ozs7Ozs7WUFHZ0I7bUJBQVNHLGdCQUFnQkEsYUFBYSxFQUFFSCxZQUFGLEVBQWIsQ0FBekI7V0FBZCxDQUhGOzs7Ozs7Ozs7OztZQUlnQjttQkFBU00sZ0JBQWdCQSxhQUFhLEVBQUVOLFlBQUYsRUFBYixDQUF6QjtXQUFkLENBSkY7c0JBS2MsS0FBS21nQixjQUxuQjtnQkFNTyxRQU5QO29CQU9XOzs7T0FSYjs7OztFQXBDbUMzc0I7OztBQW9EdkMwc0IsVUFBVTVyQixTQUFWLEdBQXNCO1lBQ1ZKLFVBQVVLLElBREE7Y0FFUkwsVUFBVVMsSUFGRjthQUdUVCxVQUFVUyxJQUhEO2VBSVBULFVBQVVDLEtBQVYsQ0FBZ0IsQ0FDM0IsTUFEMkIsRUFFM0IsTUFGMkIsRUFHM0IsVUFIMkIsRUFJM0IsTUFKMkIsRUFLM0IsUUFMMkIsRUFNM0IsU0FOMkIsRUFPM0IsUUFQMkIsRUFRM0IsU0FSMkIsQ0FBaEIsQ0FKTztXQWNYRCxVQUFVNEcsSUFkQztnQkFlTjVHLFVBQVU0RyxJQWZKO2dCQWdCTjVHLFVBQVU0RyxJQWhCSjtTQWlCYjVHLFVBQVVDLEtBQVYsQ0FBZ0IsQ0FDckIsUUFEcUIsRUFFckIsU0FGcUIsRUFHckIsTUFIcUIsRUFJckIsUUFKcUIsRUFLckIsWUFMcUIsRUFNckIsZUFOcUIsRUFPckIsYUFQcUIsRUFRckIsY0FScUIsQ0FBaEI7Q0FqQlQ7Ozs7SUMvRXFCdXNCOzs7Ozs7Ozs7Ozs7OzttTUFPbkI1a0IsUUFBUTtlQUNHO2FBR1g2a0IsaUJBQWlCLFVBQUNsdEIsR0FBRCxFQUEwQjtZQUNwQ210QixRQUFMLEdBQWdCbnRCLEdBQWhCO2FBR0ZvdEIsT0FBTyxVQUFDQyxPQUFELEVBQXFCO1VBQ3RCLE1BQUtGLFFBQVQsRUFBbUI7MEJBQ1UsTUFBS2o1QixLQURmO1lBQ1RvNUIsU0FEUyxlQUNUQSxRQURTO1lBQ0NGLEtBREQsZUFDQ0EsSUFERDs7b0NBRU8sTUFBS0QsUUFBTCxDQUFjOVUscUJBQWQsRUFGUDtZQUVUN2EsSUFGUyx5QkFFVEEsSUFGUztZQUVIMkIsS0FGRyx5QkFFSEEsS0FGRzs7WUFHWG91QixVQUFVcDRCLEtBQUsrWixHQUFMLENBQVMsQ0FBVCxFQUFZL1osS0FBS3E0QixHQUFMLENBQVMsQ0FBQ0gsVUFBVTd2QixJQUFYLElBQW1CMkIsS0FBNUIsRUFBbUMsQ0FBbkMsQ0FBWixDQUFoQjtZQUNNc3VCLFVBQVVGLFVBQVVELFNBQTFCO2NBQ0tHLE9BQUw7O2FBSUpDLFlBQVksVUFBQ25oQixLQUFEO2FBQ1ZBLE1BQU13WSxlQUFOLEVBRFU7YUFHWnhLLGtCQUFrQixVQUFDaE8sS0FBRCxFQUFnRDtZQUMzRGhFLFFBQUwsQ0FBYyxFQUFFb2xCLFNBQVMsSUFBWCxFQUFkO1lBQ0tQLElBQUwsQ0FBVTdnQixNQUFNOGdCLE9BQWhCO2FBR0ZPLGtCQUFrQixVQUFDcmhCLEtBQUQsRUFBZ0Q7VUFDeERvaEIsT0FEd0QsR0FDNUMsTUFBS3RsQixLQUR1QyxDQUN4RHNsQixPQUR3RDs7VUFFNURBLE9BQUosRUFBYTtjQUNOUCxJQUFMLENBQVU3Z0IsTUFBTThnQixPQUFoQjs7YUFJSjdTLGdCQUFnQixZQUFNO1lBQ2ZqUyxRQUFMLENBQWMsRUFBRW9sQixTQUFTLEtBQVgsRUFBZDs7Ozs7OzZCQUtPO21CQUMyQixLQUFLejVCLEtBRGhDO1VBQ0MyNUIsV0FERCxVQUNDQSxXQUREO1VBQ2NQLFFBRGQsVUFDY0EsUUFEZDs7VUFFRG51QixRQUFXaEssS0FBS2lxQixLQUFMLENBQVl5TyxjQUFjLEtBQWYsR0FBd0JQLFFBQW5DLElBQStDLEdBQTFELE1BQU47YUFFRWh0QjtXQUFBOztvQkFDVyxVQURYO21CQUVVLE1BRlY7Z0JBR08sTUFIUDtzQkFJYSxRQUpiO2tCQUtVOzs7Ozs2QkFHU2d0QixRQURqQjs2QkFFZ0IsR0FGaEI7NkJBR2lCTyxXQUhqQjt1QkFJYXg2QixTQUFPODVCLFFBSnBCO3FCQUtXLEtBQUtPLFNBTGhCO3dCQU1jLEtBQUtBLFNBTm5CO3lCQU9lLEtBQUtuVCxlQVBwQjt5QkFRZSxLQUFLcVQsZUFScEI7dUJBU2EsS0FBS3BULGFBVGxCO2lCQVVPLEtBQUswUyxjQVZaO2tCQVdPLGFBWFA7c0JBWVc7OztlQUVUOzt3QkFBQTt5QkFBQTt3QkFHVyxVQUhYO3FCQUlRLFdBSlI7cUJBS1EsU0FMUjtzQkFNVTs7MEJBRVAsR0FBRCxJQUFLLE9BQU0sT0FBWCxFQUFtQixPQUFNLFNBQXpCLEVBQW1DLFFBQU8sTUFBMUMsRUFBaUQsT0FBTy90QixLQUF4RDtXQXRCSjs7ZUF3QkU7O3dCQUNXLFVBRFg7cUJBRVEsU0FGUjtzQkFHVSxDQUhWO3lDQUk2QixFQUFFRSxTQUFTLEVBQUU3QixNQUFNMkIsS0FBUixFQUFYOzswQkFFMUIsR0FBRDtxQkFDUSxRQURSO3FCQUVTLEVBRlQ7c0JBR1UsRUFIVjtxQkFJUSxPQUpSOzBCQUtjLENBQUMsQ0FMZjt5Q0FNNkIsRUFBRUUsU0FBUyxFQUFFdkosV0FBVyxDQUFDLENBQWQsRUFBWDs7OztPQTVDckM7Ozs7RUFqRHVDaUs7O0FBQXRCa3RCLGNBQ1pwc0IsWUFBWTtlQUNKSixVQUFVVSxNQUFWLENBQWlCNEUsVUFEYjtZQUVQdEYsVUFBVVUsTUFBVixDQUFpQjRFLFVBRlY7UUFHWHRGLFVBQVU0RyxJQUFWLENBQWV0Qjs7O0FDU3pCLElBQU0rbkIsb0JBQW9CLFNBQXBCQSxpQkFBb0I7OzthQUVmQSxpQkFBVDs7YUFFU0MsdUJBRlQ7O2FBSVNDLG9CQUpUOzthQU1TQzs7Q0FSWDs7QUFVQSxJQUFNQyxlQUFlLFNBQWZBLFlBQWUsQ0FBQ0MsSUFBRCxFQUFtQjtNQUNoQ3R2QixVQUFVMUosS0FBS2lxQixLQUFMLENBQVcrTyxRQUFRLENBQW5CLENBQWhCO01BQ01DLFVBQVVqNUIsS0FBS2lxQixLQUFMLENBQVd2Z0IsVUFBVSxFQUFyQixDQUFoQjtNQUNNd3ZCLFVBQVV4dkIsVUFBVXV2QixVQUFVLEVBQXBDO01BQ01FLGFBQWFGLFVBQVUsRUFBVixTQUFtQkEsT0FBbkIsR0FBK0JBLE9BQWxEO01BQ01HLGFBQWFGLFVBQVUsRUFBVixTQUFtQkEsT0FBbkIsR0FBK0JBLE9BQWxEO1NBQ1VDLFVBQVYsU0FBd0JDLFVBQXhCO0NBTkY7O0lBU01DOzs7Ozs7Ozs7Ozs7OzttTUFvQkpDLHlCQUF5QixpQkFNbkI7VUFMSmxpQixLQUtJLFNBTEpBLEtBS0k7VUFDSW1pQixrQkFESixHQUMyQixNQUFLeDZCLEtBRGhDLENBQ0l3NkIsa0JBREo7O1lBRUUzSixlQUFOOzthQUlGNEosc0JBQXNCLGlCQU1oQjtVQUxKcGlCLEtBS0ksU0FMSkEsS0FLSTt3QkFDaUMsTUFBS3JZLEtBRHRDO1VBQ0kwNkIsT0FESixlQUNJQSxPQURKO1VBQ2FDLE9BRGIsZUFDYUEsT0FEYjtVQUNzQkMsTUFEdEIsZUFDc0JBLE1BRHRCOztVQUVBRixPQUFKLEVBQWE7Z0JBQ0hyaUIsS0FBUjtPQURGLE1BRU87ZUFDRUEsS0FBUDs7YUFJSndpQixxQkFBcUIsaUJBUWY7VUFQSnhpQixLQU9JLFNBUEpBLEtBT0k7VUFDSXlpQixjQURKLEdBQ3VCLE1BQUs5NkIsS0FENUIsQ0FDSTg2QixjQURKOztxQkFFV3ppQixLQUFmOzs7Ozs7NkJBR087bUJBY0gsS0FBS3JZLEtBZEY7VUFFTCs2QiwwQkFGSyxVQUVMQSwwQkFGSztVQUdMQywwQkFISyxVQUdMQSwwQkFISztVQUlMQyxzQkFKSyxVQUlMQSxzQkFKSztVQUtMQyx1QkFMSyxVQUtMQSx1QkFMSztVQU1MQyxzQkFOSyxVQU1MQSxzQkFOSztVQU9MQyx3QkFQSyxVQU9MQSx3QkFQSztVQVFMekIsV0FSSyxVQVFMQSxXQVJLO1VBU0xQLFFBVEssVUFTTEEsUUFUSztVQVVMaUMsVUFWSyxVQVVMQSxVQVZLO1VBV0xYLE9BWEssVUFXTEEsT0FYSztVQVlMeEIsSUFaSyxVQVlMQSxJQVpLO1VBYUxvQyxNQWJLLFVBYUxBLE1BYks7O1VBZURDLFFBQVFELFdBQVcsQ0FBekI7VUFDTUUsdUJBQ0osT0FBTy9aLFFBQVAsS0FBb0IsV0FBcEIsSUFBbUMsQ0FBQyxDQUFDbVksbUJBRHZDO2FBR0V4dEI7O1VBQUssV0FBV2pOLFNBQU9zOEIsUUFBdkI7O2FBQ0U7WUFBSyxTQUFTLENBQWQ7O3FCQUNFO2NBQVcsU0FBUyxLQUFLaEIsbUJBQXpCLEVBQThDLFdBQVcsS0FBekQ7MEJBQ0csSUFBRDtrQ0FFSUMsVUFBVVEsdUJBQVYsR0FBb0NDLHNCQUZ4QztxQkFJUSxPQUpSO29CQUtRVCxVQUFVLE9BQVYsR0FBb0IsTUFMNUI7b0JBTVE7OztTQVRkOzthQWFFO1lBQUssT0FBTyxFQUFaLEVBQWdCLFNBQVMsQ0FBekI7O2dCQUNFO2NBQU0sT0FBTSxPQUFaLEVBQW9CLE9BQU0sT0FBMUIsRUFBa0MsTUFBSyxJQUF2Qzt5QkFDZ0JmLFdBQWI7O1NBZlA7O2FBa0JFO1lBQUssU0FBUyxDQUFkLEVBQWlCLE1BQUssTUFBdEI7d0JBQ0csYUFBRDt5QkFDZUEsV0FEZjtzQkFFWVAsUUFGWjtrQkFHUUY7O1NBdEJaOzthQXlCRTtZQUFLLE9BQU8sRUFBWixFQUFnQixTQUFTLENBQXpCOztnQkFDRTtjQUFNLE9BQU0sT0FBWixFQUFvQixPQUFNLE9BQTFCLEVBQWtDLE1BQUssSUFBdkM7eUJBQ2dCRSxRQUFiOztTQTNCUDs7YUE4QkU7WUFBSyxTQUFTLENBQWQ7O3FCQUNFO2NBQVcsU0FBUyxLQUFLeUIsa0JBQXpCLEVBQTZDLFdBQVcsS0FBeEQ7MEJBQ0csSUFBRDtrQ0FFSVUsUUFBUUgsd0JBQVIsR0FBbUNILHNCQUZ2QztxQkFJUSxPQUpSO29CQUtRTSxRQUFRLE1BQVIsR0FBaUIsT0FMekI7b0JBTVE7OztTQXRDZDtnQ0EyQ0ludkI7YUFBQTtZQUFLLFNBQVMsQ0FBZDs7cUJBQ0U7Y0FBVyxTQUFTLEtBQUttdUIsc0JBQXpCLEVBQWlELFdBQVcsS0FBNUQ7MEJBQ0csSUFBRDtrQ0FFSWMsYUFDSUwsMEJBREosR0FFSUQsMEJBSlI7cUJBTVEsT0FOUjtvQkFPUU0sYUFBYSxVQUFiLEdBQTBCLFVBUGxDO29CQVFROzs7O09BdERsQjs7OztFQTlFd0J4dkI7O0FBQXRCeXVCLGNBQ0czdEIsWUFBWTs4QkFDV0osVUFBVVksTUFBVixDQUFpQjBFLFVBRDVCOzhCQUVXdEYsVUFBVVksTUFBVixDQUFpQjBFLFVBRjVCOzBCQUdPdEYsVUFBVVksTUFBVixDQUFpQjBFLFVBSHhCOzJCQUlRdEYsVUFBVVksTUFBVixDQUFpQjBFLFVBSnpCOzBCQUtPdEYsVUFBVVksTUFBVixDQUFpQjBFLFVBTHhCOzRCQU1TdEYsVUFBVVksTUFBVixDQUFpQjBFLFVBTjFCO2VBT0p0RixVQUFVVSxNQUFWLENBQWlCNEUsVUFQYjtZQVFQdEYsVUFBVVUsTUFBVixDQUFpQjRFLFVBUlY7Y0FTTHRGLFVBQVVTLElBQVYsQ0FBZTZFLFVBVFY7c0JBVUd0RixVQUFVNEcsSUFBVixDQUFldEIsVUFWbEI7V0FXUnRGLFVBQVU0RyxJQUFWLENBQWV0QixVQVhQO1VBWVR0RixVQUFVNEcsSUFBVixDQUFldEIsVUFaTjtrQkFhRHRGLFVBQVU0RyxJQUFWLENBQWV0QixVQWJkO1dBY1J0RixVQUFVUyxJQUFWLENBQWU2RSxVQWRQO1FBZVh0RixVQUFVNEcsSUFBVixDQUFldEIsVUFmSjtVQWdCVHRGLFVBQVVVLE1BQVYsQ0FBaUI0RTs7O0FDUDdCOzs7QUFHQSxJQUFNNnBCLG9CQUFvQixTQUFwQkEsaUJBQW9CLENBQUN2UixPQUFELEVBQTBCO01BQzlDQSxRQUFRdVIsaUJBQVosRUFBK0I7WUFDckJBLGlCQUFSOztHQURGLE1BR08sSUFBSXZSLFFBQVF3Uix1QkFBWixFQUFxQzs7WUFFbENBLHVCQUFSOztHQUZLLE1BSUEsSUFBSXhSLFFBQVF5UixvQkFBWixFQUFrQzs7WUFFL0JBLG9CQUFSOztHQUZLLE1BSUEsSUFBSXpSLFFBQVEwUixtQkFBWixFQUFpQzs7WUFFOUJBLG1CQUFSOztDQWRKOztBQWtCQSxJQUFNQyxpQkFBaUIsU0FBakJBLGNBQWlCLEdBQU07O01BRXZCcmEsU0FBU3FhLGNBQWIsRUFBNkI7O2FBRWxCQSxjQUFUOztHQUZGLE1BSU8sSUFBSXJhLFNBQVNzYSxvQkFBYixFQUFtQzs7YUFFL0JBLG9CQUFUOztHQUZLLE1BSUEsSUFBSXRhLFNBQVN1YSxtQkFBYixFQUFrQzs7YUFFOUJBLG1CQUFUOztHQUZLLE1BSUEsSUFBSXZhLFNBQVN3YSxnQkFBYixFQUErQjs7YUFFM0JBLGdCQUFUOztDQWhCSjs7OztBQXNCQSxJQUFNQyxlQUFlLFNBQWZBLFlBQWU7OzthQUVWQyxpQkFBVDs7YUFFU0MsdUJBRlQ7O2FBSVNDLG9CQUpUOzthQU1TQzs7Q0FSWDs7QUFVQSxJQUFNQyw2QkFBNkIsU0FBN0JBLDBCQUE2QixDQUFDQyxRQUFELEVBQTZCO1dBQ3JEbGEsZ0JBQVQsQ0FBMEIsa0JBQTFCLEVBQThDa2EsUUFBOUM7V0FDU2xhLGdCQUFULENBQTBCLHdCQUExQixFQUFvRGthLFFBQXBEO1dBQ1NsYSxnQkFBVCxDQUEwQixxQkFBMUIsRUFBaURrYSxRQUFqRDtXQUNTbGEsZ0JBQVQsQ0FBMEIsb0JBQTFCLEVBQWdEa2EsUUFBaEQ7Q0FKRjs7QUFPQSxJQUFNQyxnQ0FBZ0MsU0FBaENBLDZCQUFnQyxDQUFDRCxRQUFELEVBQTZCO1dBQ3hEOVosbUJBQVQsQ0FBNkIsa0JBQTdCLEVBQWlEOFosUUFBakQ7V0FDUzlaLG1CQUFULENBQTZCLHdCQUE3QixFQUF1RDhaLFFBQXZEO1dBQ1M5WixtQkFBVCxDQUE2QixxQkFBN0IsRUFBb0Q4WixRQUFwRDtXQUNTOVosbUJBQVQsQ0FBNkIsb0JBQTdCLEVBQW1EOFosUUFBbkQ7Q0FKRjs7QUFPQSxJQUFNRSxjQUFjLFNBQWRBLFdBQWMsQ0FBQ0MsU0FBRCxFQUFvQkMsU0FBcEIsRUFBbUQ7TUFDakUsUUFBT0QsU0FBUCx5Q0FBT0EsU0FBUCxlQUE0QkMsU0FBNUIseUNBQTRCQSxTQUE1QixFQUFKLEVBQTJDOzs7V0FHbEMsSUFBUDs7TUFFRWg5QixNQUFNaTlCLE9BQU4sQ0FBY0QsU0FBZCxDQUFKLEVBQThCO1FBQ3hCRCxVQUFVcjhCLE1BQVYsS0FBcUJzOEIsVUFBVXQ4QixNQUFuQyxFQUEyQzs7O2FBR2xDLElBQVA7Ozs7V0FJS3M4QixVQUFVcFAsSUFBVixDQUNMLFVBQUNzUCxNQUFELEVBQVNuZixLQUFUO2FBQ0UsQ0FBQy9kLE1BQU1pOUIsT0FBTixDQUFjRixTQUFkLENBQUQsSUFDQUcsT0FBT25sQixJQUFQLEtBQWdCZ2xCLFVBQVVoZixLQUFWLEVBQWlCaEcsSUFEakMsSUFFQW1sQixPQUFPeHFCLEdBQVAsS0FBZXFxQixVQUFVaGYsS0FBVixFQUFpQnJMLEdBSGxDO0tBREssQ0FBUDs7OztTQVNLc3FCLGNBQWNELFNBQXJCO0NBdkJGOztJQTBCcUJJOzs7Ozs7Ozs7Ozs7OzttTEErQ25CNW9CLFFBQVE7bUJBQ08sQ0FEUDtnQkFFSSxDQUZKO2tCQUdNO2FBMkRkNm9CLGVBQWUsVUFBQ2x4QixHQUFELEVBQTBCO1lBQ2xDbXhCLE1BQUwsR0FBY254QixHQUFkO2FBSUZveEIsY0FBYyxVQUFDcHhCLEdBQUQsRUFBNEI7WUFDbkNxeEIsS0FBTCxHQUFhcnhCLEdBQWI7YUFRRnN4QixrQkFBa0IsVUFBQ0MsWUFBRCxFQUEwQjtVQUN0QyxNQUFLRixLQUFULEVBQWdCO2NBQ1RBLEtBQUwsQ0FBV0UsWUFBWCxHQUEwQkEsWUFBMUI7O2FBS0pDLFlBQVksVUFBQ2hDLE1BQUQsRUFBb0I7VUFDMUIsTUFBSzZCLEtBQVQsRUFBZ0I7Y0FDVEEsS0FBTCxDQUFXN0IsTUFBWCxHQUFvQkEsTUFBcEI7O2FBS0ppQyxPQUFPLFlBQU07VUFDUCxNQUFLSixLQUFULEVBQWdCO2NBQ1RBLEtBQUwsQ0FBV0ksSUFBWDs7YUFLSkMsUUFBUSxZQUFNO1VBQ1IsTUFBS0wsS0FBVCxFQUFnQjtjQUNUQSxLQUFMLENBQVdLLEtBQVg7O2FBS0pDLE9BQU8sWUFBTTtVQUNQLE1BQUtOLEtBQVQsRUFBZ0I7Y0FDVEEsS0FBTCxDQUFXTSxJQUFYOzthQUtKdkUsT0FBTyxVQUFDZSxJQUFELEVBQWtCO1VBQ25CLE1BQUtrRCxLQUFULEVBQWdCO2NBQ1RBLEtBQUwsQ0FBV3hELFdBQVgsR0FBeUJNLElBQXpCOzthQUtKeUQsbUJBQW1CLFlBQU07VUFDbkJ4QixjQUFKLEVBQW9COztPQUFwQixNQUVPLElBQUksTUFBS2UsTUFBVCxFQUFpQjswQkFDSixNQUFLQSxNQUF2Qjs7YUFTSlUsZ0JBQWdCLFVBQUN0bEIsS0FBRCxFQUE2QztVQUNuRHVsQixPQURtRCxHQUN2QyxNQUFLNTlCLEtBRGtDLENBQ25ENDlCLE9BRG1EOzs7VUFHdkRBLE9BQUosRUFBYTtnQkFDSCxFQUFFdmxCLFlBQUYsRUFBUjs7YUFNSndsQix1QkFBdUIsVUFBQ3hsQixLQUFELEVBQTZDO1VBQzFEeWxCLGdCQUQwRCxHQUNyQyxNQUFLOTlCLEtBRGdDLENBQzFEODlCLGdCQUQwRDs7VUFFNUQxRSxXQUFZLE1BQUsrRCxLQUFMLElBQWMsTUFBS0EsS0FBTCxDQUFXL0QsUUFBMUIsSUFBdUMsQ0FBeEQ7WUFDSy9rQixRQUFMLENBQWMsRUFBRStrQixrQkFBRixFQUFkOztVQUVJMEUsZ0JBQUosRUFBc0I7eUJBQ0gsRUFBRXpsQixZQUFGLEVBQVMrZ0Isa0JBQVQsRUFBakI7O2FBS0oyRSxjQUFjLFVBQUMxbEIsS0FBRCxFQUE2QztVQUNqRDJsQixPQURpRCxHQUNyQyxNQUFLaCtCLEtBRGdDLENBQ2pEZytCLE9BRGlEOzs7VUFHckRBLE9BQUosRUFBYTtnQkFDSCxFQUFFM2xCLFlBQUYsRUFBUjs7YUFLSmtpQix5QkFBeUIsVUFBQ2xpQixLQUFELEVBQWtCO1VBQ2pDbWlCLGtCQURpQyxHQUNWLE1BQUt4NkIsS0FESyxDQUNqQ3c2QixrQkFEaUM7O1VBRW5DYSxhQUFhLENBQUMsQ0FBQ2EsY0FBckI7WUFDSzduQixRQUFMLENBQWMsRUFBRWduQixzQkFBRixFQUFkOztVQUVJYixrQkFBSixFQUF3QjsyQkFDSCxFQUFFbmlCLFlBQUYsRUFBU2dqQixzQkFBVCxFQUFuQjs7YUFLSjRDLGFBQWEsVUFBQzVsQixLQUFELEVBQTJDO1VBQzlDdWlCLE1BRDhDLEdBQ25DLE1BQUs1NkIsS0FEOEIsQ0FDOUM0NkIsTUFEOEM7OztVQUdsREEsTUFBSixFQUFZO2VBQ0gsRUFBRXZpQixZQUFGLEVBQVA7O2FBS0o2bEIsY0FBYyxVQUFDN2xCLEtBQUQsRUFBMkM7VUFDL0NzaUIsT0FEK0MsR0FDbkMsTUFBSzM2QixLQUQ4QixDQUMvQzI2QixPQUQrQzs7O1VBR25EQSxPQUFKLEVBQWE7Z0JBQ0gsRUFBRXRpQixZQUFGLEVBQVI7O2FBS0o4bEIsaUJBQWlCLFVBQUM5bEIsS0FBRCxFQUE2QztVQUNwRCtsQixjQURvRCxHQUNqQyxNQUFLcCtCLEtBRDRCLENBQ3BEbytCLGNBRG9EOztrQkFFdkMsTUFBS2pCLEtBQUwsSUFBYyxFQUZ5QjtVQUVwRGtCLFFBRm9ELFNBRXBEQSxRQUZvRDs7VUFHdERDLFNBQ0pELFlBQVlBLFNBQVMvOUIsTUFBVCxHQUFrQixDQUE5QixHQUFrQys5QixTQUFTRSxHQUFULENBQWFGLFNBQVMvOUIsTUFBVCxHQUFrQixDQUEvQixDQUFsQyxHQUFzRSxDQUR4RTs7VUFHSTg5QixjQUFKLEVBQW9CO3VCQUNILEVBQUUvbEIsWUFBRixFQUFTaW1CLGNBQVQsRUFBZjs7YUFLSkUsYUFBYSxVQUFDbm1CLEtBQUQsRUFBNkM7VUFDaERvbUIsTUFEZ0QsR0FDckMsTUFBS3orQixLQURnQyxDQUNoRHkrQixNQURnRDs7O1VBR3BEQSxNQUFKLEVBQVk7ZUFDSCxFQUFFcG1CLFlBQUYsRUFBUDs7YUFLSnFtQixtQkFBbUIsVUFBQ3JtQixLQUFELEVBQTZDO1VBQ3REc21CLFlBRHNELEdBQ3JDLE1BQUszK0IsS0FEZ0MsQ0FDdEQyK0IsWUFEc0Q7O1VBRXhEaEYsY0FBZSxNQUFLd0QsS0FBTCxJQUFjLE1BQUtBLEtBQUwsQ0FBV3hELFdBQTFCLElBQTBDLENBQTlEO1lBQ0t0bEIsUUFBTCxDQUFjLEVBQUVzbEIsd0JBQUYsRUFBZDs7VUFFSWdGLFlBQUosRUFBa0I7cUJBQ0gsRUFBRXRtQixZQUFGLEVBQVM0aEIsTUFBTU4sV0FBZixFQUFiOzthQUtKa0IscUJBQXFCLFVBQUN4aUIsS0FBRCxFQUEyQztVQUN0RHlpQixjQURzRCxHQUNuQyxNQUFLOTZCLEtBRDhCLENBQ3REODZCLGNBRHNEOztVQUV4RFMsUUFBUyxNQUFLNEIsS0FBTCxJQUFjLE1BQUtBLEtBQUwsQ0FBVzVCLEtBQTFCLElBQW9DLEtBQWxEOztVQUVJVCxjQUFKLEVBQW9CO3VCQUNILEVBQUV6aUIsWUFBRixFQUFTaWpCLFFBQVFDLFFBQVEsQ0FBUixHQUFZLENBQTdCLEVBQWY7Ozs7Ozs7Ozs7Ozs7d0NBek5nQjttQkFDd0IsS0FBS3Y3QixLQUQ3QjtVQUNWcTlCLFlBRFUsVUFDVkEsWUFEVTtVQUNJM0MsT0FESixVQUNJQSxPQURKO1VBQ2FZLE1BRGIsVUFDYUEsTUFEYjs7OztVQUlkLE9BQU83WixRQUFQLEtBQW9CLFdBQXhCLEVBQXFDO21DQUNSLEtBQUs4WSxzQkFBaEM7OztXQUdHZ0QsSUFBTDs7V0FFS0QsU0FBTCxDQUFlaEMsTUFBZjs7V0FFSzhCLGVBQUwsQ0FBcUJDLFlBQXJCOztVQUVJM0MsT0FBSixFQUFhO2FBQ04rQyxJQUFMOzs7Ozt1Q0FJZXByQixXQUFrQjs7VUFFL0JxcUIsWUFBWXJxQixVQUFVQyxHQUF0QixFQUEyQixLQUFLdFMsS0FBTCxDQUFXc1MsR0FBdEMsQ0FBSixFQUFnRDthQUN6Q2lyQixJQUFMOzs7VUFHRWxyQixVQUFVaXBCLE1BQVYsS0FBcUIsS0FBS3Q3QixLQUFMLENBQVdzN0IsTUFBcEMsRUFBNEM7YUFDckNnQyxTQUFMLENBQWUsS0FBS3Q5QixLQUFMLENBQVdzN0IsTUFBMUI7OztVQUdFanBCLFVBQVVnckIsWUFBVixLQUEyQixLQUFLcjlCLEtBQUwsQ0FBV3E5QixZQUExQyxFQUF3RDthQUNqREQsZUFBTCxDQUFxQixLQUFLcDlCLEtBQUwsQ0FBV3E5QixZQUFoQzs7O1VBR0VockIsVUFBVXFvQixPQUFWLEtBQXNCLEtBQUsxNkIsS0FBTCxDQUFXMDZCLE9BQXJDLEVBQThDO1lBQ3hDLEtBQUsxNkIsS0FBTCxDQUFXMDZCLE9BQWYsRUFBd0I7ZUFDakIrQyxJQUFMO1NBREYsTUFFTztlQUNBRCxLQUFMOzs7Ozs7MkNBS2lCO29DQUNTLEtBQUtqRCxzQkFBbkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs2QkFzTE87b0JBV0gsS0FBS3Y2QixLQVhGO1VBRUxrbkIsV0FGSyxXQUVMQSxXQUZLO1VBR0wwWCxRQUhLLFdBR0xBLFFBSEs7VUFJTEMsSUFKSyxXQUlMQSxJQUpLO1VBS0xuRSxPQUxLLFdBS0xBLE9BTEs7VUFNTG9FLFdBTkssV0FNTEEsV0FOSztVQU9MQyxNQVBLLFdBT0xBLE1BUEs7VUFRTEMsT0FSSyxXQVFMQSxPQVJLO1VBU0wxc0IsR0FUSyxXQVNMQSxHQVRLO1VBVUxncEIsTUFWSyxXQVVMQSxNQVZLO21CQVl1QyxLQUFLbm5CLEtBWjVDO1VBWUN3bEIsV0FaRCxVQVlDQSxXQVpEO1VBWWNQLFFBWmQsVUFZY0EsUUFaZDtVQVl3QmlDLFVBWnhCLFVBWXdCQSxVQVp4Qjs7O1VBY0Q1bkIsZ0JBQWlCNG5CLGNBQWMsR0FBZixJQUEyQixJQUFJblUsV0FBTCxHQUFvQixHQUE5QyxNQUF0Qjs7YUFHRTlhOzs7ZUFDTyxLQUFLNHdCLFlBRFo7cUJBRWE3OUIsU0FBTzg5QixNQUZwQjtpQkFHUyxFQUFFeHBCLDRCQUFGLEVBQWlCaEwsUUFBUTR5QixhQUFhLE1BQWIsR0FBc0IsQ0FBL0M7Ozs7O3NCQUdLWCxPQURaO2tCQUVRbUUsSUFGUjttQkFHU3ZELFdBQVcsQ0FIcEI7eUJBSWV3RCxXQUpmO29CQUtVQyxNQUxWO3FCQU1XQyxPQU5YO2lCQU9PLE9BQU8xc0IsR0FBUCxLQUFlLFFBQWYsR0FBMEJBLEdBQTFCLEdBQWdDWCxTQVB2QztpQkFRTyxLQUFLdXJCLFdBUlo7dUJBU2EvOUIsU0FBT2crQixLQVRwQjt1QkFVYSxLQUFLUSxhQVZsQjs4QkFXb0IsS0FBS0Usb0JBWHpCO3FCQVlXLEtBQUtFLFdBWmhCO3NCQWFZLEtBQUtTLFVBYmpCOzBCQWNnQixLQUFLRSxnQkFkckI7d0JBZWMsS0FBS1A7O2dCQUVWdEIsT0FBTixDQUFjdnFCLEdBQWQsS0FDQ0EsSUFBSXhTLEdBQUosQ0FBUTttQkFDTnNNLDBCQUFRLEtBQUswd0IsT0FBT3hxQixHQUFwQixFQUF5QixLQUFLd3FCLE9BQU94cUIsR0FBckMsRUFBMEMsTUFBTXdxQixPQUFPbmxCLElBQXZELEdBRE07V0FBUixDQWxCSjttQ0FxQlMsTUFBSyxVQUFaLEVBQXVCLEtBQUtpbkIsUUFBNUI7U0ExQko7YUE2QlE1K0IsS0FBTCxDQUFXeTdCLFFBQVgsSUFDQ3J2QixjQUFDLGFBQUQ7c0NBQzhCLEtBQUtwTSxLQUFMLENBQVcrNkIsMEJBRHpDO3NDQUU4QixLQUFLLzZCLEtBQUwsQ0FBV2c3QiwwQkFGekM7a0NBRzBCLEtBQUtoN0IsS0FBTCxDQUFXaTdCLHNCQUhyQzttQ0FJMkIsS0FBS2o3QixLQUFMLENBQVdrN0IsdUJBSnRDO2tDQUswQixLQUFLbDdCLEtBQUwsQ0FBV203QixzQkFMckM7b0NBTTRCLEtBQUtuN0IsS0FBTCxDQUFXbzdCLHdCQU52Qzt1QkFPZXpCLFdBUGY7b0JBUVlQLFFBUlo7c0JBU2NpQyxVQVRkO2tCQVVVLEtBQUs0QyxVQVZmO21CQVdXLEtBQUtDLFdBWGhCOzhCQVlzQixLQUFLUixnQkFaM0I7MEJBYWtCLEtBQUs3QyxrQkFidkI7bUJBY1dILE9BZFg7Z0JBZVEsS0FBS3hCLElBZmI7a0JBZ0JVb0M7O09BL0NoQjs7OztFQTFTK0J6dkI7O0FBQWRreEIsTUFDWnB3QixZQUFZOzhCQUNXSixVQUFVWSxNQURyQjs4QkFFV1osVUFBVVksTUFGckI7MEJBR09aLFVBQVVZLE1BSGpCOzJCQUlRWixVQUFVWSxNQUpsQjswQkFLT1osVUFBVVksTUFMakI7NEJBTVNaLFVBQVVZLE1BTm5CO2VBT0paLFVBQVVVLE1BQVYsQ0FBaUI0RSxVQVBiO1lBUVB0RixVQUFVWSxNQUFWLENBQWlCMEUsVUFSVjtZQVNQdEYsVUFBVVMsSUFUSDtRQVVYVCxVQUFVUyxJQVZDO29CQVdDVCxVQUFVNEcsSUFYWDtXQVlSNUcsVUFBVTRHLElBWkY7c0JBYUc1RyxVQUFVNEcsSUFiYjtrQkFjRDVHLFVBQVU0RyxJQWRUO1VBZVQ1RyxVQUFVNEcsSUFmRDtXQWdCUjVHLFVBQVU0RyxJQWhCRjtXQWlCUjVHLFVBQVU0RyxJQWpCRjtVQWtCVDVHLFVBQVU0RyxJQWxCRDtnQkFtQkg1RyxVQUFVNEcsSUFuQlA7a0JBb0JENUcsVUFBVTRHLElBcEJUO2dCQXFCSDVHLFVBQVVVLE1BckJQO1dBc0JSVixVQUFVUyxJQXRCRjtlQXVCSlQsVUFBVVMsSUF2Qk47VUF3QlRULFVBQVVZLE1BeEJEO1dBeUJSWixVQUFVQyxLQUFWLENBQWdCLENBQUMsTUFBRCxFQUFTLFVBQVQsRUFBcUIsTUFBckIsQ0FBaEIsQ0F6QlE7T0EwQlpELFVBQVVRLFNBQVYsQ0FBb0IsQ0FDdkJSLFVBQVVZLE1BRGEsRUFFdkJaLFVBQVVtUCxPQUFWLENBQ0VuUCxVQUFVVyxLQUFWLENBQWdCO1VBQ1JYLFVBQVVDLEtBQVYsQ0FBZ0IsQ0FBQyxZQUFELEVBQWUsV0FBZixFQUE0QixXQUE1QixDQUFoQixFQUNIcUYsVUFGVztTQUdUdEYsVUFBVVksTUFBVixDQUFpQjBFO0dBSHhCLENBREYsQ0FGdUIsQ0FBcEIsRUFTRkEsVUFuQ2M7VUFvQ1R0RixVQUFVVTs7QUFyQ0Q4dkIsTUF3Q1ozcEIsZUFBZTtnQkFDTixDQURNO1dBRVgsS0FGVztXQUdYLE1BSFc7VUFJWjs7Ozs7In0=
